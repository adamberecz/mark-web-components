var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-646db95b.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity)
          fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy)
          fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    /**
    * @vue/shared v3.4.37
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function makeMap(str, expectsLowerCase) {
      const set2 = new Set(str.split(","));
      return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO = () => false;
    const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend$3 = Object.assign;
    const remove = (arr, el) => {
      const i2 = arr.indexOf(el);
      if (i2 > -1) {
        arr.splice(i2, 1);
      }
    };
    const hasOwnProperty$h = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$h.call(val, key);
    const isArray$n = Array.isArray;
    const isMap$2 = (val) => toTypeString(val) === "[object Map]";
    const isSet$3 = (val) => toTypeString(val) === "[object Set]";
    const isDate$2 = (val) => toTypeString(val) === "[object Date]";
    const isFunction$7 = (val) => typeof val === "function";
    const isString$4 = (val) => typeof val === "string";
    const isSymbol$6 = (val) => typeof val === "symbol";
    const isObject$f = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return (isObject$f(val) || isFunction$7(val)) && isFunction$7(val.then) && isFunction$7(val.catch);
    };
    const objectToString$2 = Object.prototype.toString;
    const toTypeString = (value) => objectToString$2.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$4 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString$4(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn2) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn2(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize$2 = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction((str) => {
      const s2 = str ? `on${capitalize$2(str)}` : ``;
      return s2;
    });
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, ...arg) => {
      for (let i2 = 0; i2 < fns.length; i2++) {
        fns[i2](...arg);
      }
    };
    const def = (obj, key, value, writable = false) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        writable,
        value
      });
    };
    const looseToNumber = (val) => {
      const n2 = parseFloat(val);
      return isNaN(n2) ? val : n2;
    };
    const toNumber$2 = (val) => {
      const n2 = isString$4(val) ? Number(val) : NaN;
      return isNaN(n2) ? val : n2;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$n(value)) {
        const res = {};
        for (let i2 = 0; i2 < value.length; i2++) {
          const item = value[i2];
          const normalized = isString$4(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString$4(value) || isObject$f(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$4(value)) {
        res = value;
      } else if (isArray$n(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          const normalized = normalizeClass(value[i2]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$f(value)) {
        for (const name2 in value) {
          if (value[name2]) {
            res += name2 + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style } = props;
      if (klass && !isString$4(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style) {
        props.style = normalizeStyle(style);
      }
      return props;
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function looseCompareArrays(a2, b2) {
      if (a2.length !== b2.length)
        return false;
      let equal = true;
      for (let i2 = 0; equal && i2 < a2.length; i2++) {
        equal = looseEqual(a2[i2], b2[i2]);
      }
      return equal;
    }
    function looseEqual(a2, b2) {
      if (a2 === b2)
        return true;
      let aValidType = isDate$2(a2);
      let bValidType = isDate$2(b2);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
      }
      aValidType = isSymbol$6(a2);
      bValidType = isSymbol$6(b2);
      if (aValidType || bValidType) {
        return a2 === b2;
      }
      aValidType = isArray$n(a2);
      bValidType = isArray$n(b2);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
      }
      aValidType = isObject$f(a2);
      bValidType = isObject$f(b2);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a2).length;
        const bKeysCount = Object.keys(b2).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a2) {
          const aHasKey = a2.hasOwnProperty(key);
          const bHasKey = b2.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
            return false;
          }
        }
      }
      return String(a2) === String(b2);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    const isRef$1 = (val) => {
      return !!(val && val.__v_isRef === true);
    };
    const toDisplayString = (val) => {
      return isString$4(val) ? val : val == null ? "" : isArray$n(val) || isObject$f(val) && (val.toString === objectToString$2 || !isFunction$7(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (isRef$1(val)) {
        return replacer(_key, val.value);
      } else if (isMap$2(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i2) => {
              entries[stringifySymbol(key, i2) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet$3(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
        };
      } else if (isSymbol$6(val)) {
        return stringifySymbol(val);
      } else if (isObject$f(val) && !isArray$n(val) && !isPlainObject$4(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v2, i2 = "") => {
      var _a;
      return (
        // Symbol.description in es2019+ so we need to cast here to pass
        // the lib: es2016 check
        isSymbol$6(v2) ? `Symbol(${(_a = v2.description) != null ? _a : i2})` : v2
      );
    };
    /**
    * @vue/reactivity v3.4.37
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      run(fn2) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn2();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          let i2, l2;
          for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
            this.effects[i2].stop();
          }
          for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
            this.cleanups[i2]();
          }
          if (this.scopes) {
            for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
              this.scopes[i2].stop(true);
            }
          }
          if (!this.detached && this.parent && !fromParent) {
            const last2 = this.parent.scopes.pop();
            if (last2 && last2 !== this) {
              this.parent.scopes[this.index] = last2;
              last2.index = this.index;
            }
          }
          this.parent = void 0;
          this._active = false;
        }
      }
    }
    function recordEffectScope(effect2, scope2 = activeEffectScope) {
      if (scope2 && scope2.active) {
        scope2.effects.push(effect2);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    let activeEffect;
    class ReactiveEffect {
      constructor(fn2, trigger2, scheduler, scope2) {
        this.fn = fn2;
        this.trigger = trigger2;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this._dirtyLevel = 4;
        this._trackId = 0;
        this._runnings = 0;
        this._shouldSchedule = false;
        this._depsLength = 0;
        recordEffectScope(this, scope2);
      }
      get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
          this._dirtyLevel = 1;
          pauseTracking();
          for (let i2 = 0; i2 < this._depsLength; i2++) {
            const dep = this.deps[i2];
            if (dep.computed) {
              triggerComputed(dep.computed);
              if (this._dirtyLevel >= 4) {
                break;
              }
            }
          }
          if (this._dirtyLevel === 1) {
            this._dirtyLevel = 0;
          }
          resetTracking();
        }
        return this._dirtyLevel >= 4;
      }
      set dirty(v2) {
        this._dirtyLevel = v2 ? 4 : 0;
      }
      run() {
        this._dirtyLevel = 0;
        if (!this.active) {
          return this.fn();
        }
        let lastShouldTrack = shouldTrack;
        let lastEffect = activeEffect;
        try {
          shouldTrack = true;
          activeEffect = this;
          this._runnings++;
          preCleanupEffect(this);
          return this.fn();
        } finally {
          postCleanupEffect(this);
          this._runnings--;
          activeEffect = lastEffect;
          shouldTrack = lastShouldTrack;
        }
      }
      stop() {
        if (this.active) {
          preCleanupEffect(this);
          postCleanupEffect(this);
          this.onStop && this.onStop();
          this.active = false;
        }
      }
    }
    function triggerComputed(computed2) {
      return computed2.value;
    }
    function preCleanupEffect(effect2) {
      effect2._trackId++;
      effect2._depsLength = 0;
    }
    function postCleanupEffect(effect2) {
      if (effect2.deps.length > effect2._depsLength) {
        for (let i2 = effect2._depsLength; i2 < effect2.deps.length; i2++) {
          cleanupDepEffect(effect2.deps[i2], effect2);
        }
        effect2.deps.length = effect2._depsLength;
      }
    }
    function cleanupDepEffect(dep, effect2) {
      const trackId = dep.get(effect2);
      if (trackId !== void 0 && effect2._trackId !== trackId) {
        dep.delete(effect2);
        if (dep.size === 0) {
          dep.cleanup();
        }
      }
    }
    let shouldTrack = true;
    let pauseScheduleStack = 0;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last2 = trackStack.pop();
      shouldTrack = last2 === void 0 ? true : last2;
    }
    function pauseScheduling() {
      pauseScheduleStack++;
    }
    function resetScheduling() {
      pauseScheduleStack--;
      while (!pauseScheduleStack && queueEffectSchedulers.length) {
        queueEffectSchedulers.shift()();
      }
    }
    function trackEffect(effect2, dep, debuggerEventExtraInfo) {
      if (dep.get(effect2) !== effect2._trackId) {
        dep.set(effect2, effect2._trackId);
        const oldDep = effect2.deps[effect2._depsLength];
        if (oldDep !== dep) {
          if (oldDep) {
            cleanupDepEffect(oldDep, effect2);
          }
          effect2.deps[effect2._depsLength++] = dep;
        } else {
          effect2._depsLength++;
        }
      }
    }
    const queueEffectSchedulers = [];
    function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
      pauseScheduling();
      for (const effect2 of dep.keys()) {
        let tracking;
        if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
          effect2._dirtyLevel = dirtyLevel;
        }
        if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          effect2.trigger();
          if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
            effect2._shouldSchedule = false;
            if (effect2.scheduler) {
              queueEffectSchedulers.push(effect2.scheduler);
            }
          }
        }
      }
      resetScheduling();
    }
    const createDep = (cleanup, computed2) => {
      const dep = /* @__PURE__ */ new Map();
      dep.cleanup = cleanup;
      dep.computed = computed2;
      return dep;
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol("");
    const MAP_KEY_ITERATE_KEY = Symbol("");
    function track(target, type, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
        }
        trackEffect(
          activeEffect,
          dep
        );
      }
    }
    function trigger(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && isArray$n(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || !isSymbol$6(key2) && key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type) {
          case "add":
            if (!isArray$n(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$2(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$n(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$2(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap$2(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      pauseScheduling();
      for (const dep of deps) {
        if (dep) {
          triggerEffects(
            dep,
            4
          );
        }
      }
      resetScheduling();
    }
    function getDepFromReactive(object2, key) {
      const depsMap = targetMap.get(object2);
      return depsMap && depsMap.get(key);
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$6)
    );
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
            track(arr, "get", i2 + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          pauseScheduling();
          const res = toRaw(this)[key].apply(this, args);
          resetScheduling();
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function hasOwnProperty$g(key) {
      if (!isSymbol$6(key))
        key = String(key);
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _isShallow = false) {
        this._isReadonly = _isReadonly;
        this._isShallow = _isShallow;
      }
      get(target, key, receiver) {
        const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return isShallow2;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the receiver is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
            return target;
          }
          return;
        }
        const targetIsArray = isArray$n(target);
        if (!isReadonly2) {
          if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty$g;
          }
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol$6(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (isShallow2) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$f(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(false, isShallow2);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._isShallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$n(target) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray$n(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol$6(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray$n(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(true, isShallow2);
      }
      set(target, key) {
        return true;
      }
      deleteProperty(target, key) {
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
      true
    );
    const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
    const toShallow = (value) => value;
    const getProto = (v2) => Reflect.getPrototypeOf(v2);
    function get$3(target, key, isReadonly2 = false, isShallow2 = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has(key, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size$1(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add$2(value, _isShallow = false) {
      if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
        value = toRaw(value);
      }
      const target = toRaw(this);
      const proto2 = getProto(target);
      const hadKey = proto2.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
      }
      return this;
    }
    function set$2(key, value, _isShallow = false) {
      if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
        value = toRaw(value);
      }
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      const oldValue = get2.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      get2 ? get2.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const result = target.clear();
      if (hadItems) {
        trigger(target, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach2(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap$2(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        return type === "delete" ? false : type === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get$3(this, key);
        },
        get size() {
          return size$1(this);
        },
        has,
        add: add$2,
        set: set$2,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get$3(this, key, false, true);
        },
        get size() {
          return size$1(this);
        },
        has,
        add(value) {
          return add$2.call(this, value, true);
        },
        set(key, value) {
          return set$2.call(this, key, value, true);
        },
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get$3(this, key, true);
        },
        get size() {
          return size$1(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get$3(this, key, true, true);
        },
        get size() {
          return size$1(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
      ];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
        shallowInstrumentations2[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          true
        );
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [
      mutableInstrumentations,
      readonlyInstrumentations,
      shallowInstrumentations,
      shallowReadonlyInstrumentations
    ] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const shallowReadonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, true)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function shallowReadonly(target) {
      return createReactiveObject(
        target,
        true,
        shallowReadonlyHandlers,
        shallowReadonlyCollectionHandlers,
        shallowReadonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$f(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return value ? !!value["__v_raw"] : false;
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      if (Object.isExtensible(value)) {
        def(value, "__v_skip", true);
      }
      return value;
    }
    const toReactive = (value) => isObject$f(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$f(value) ? readonly(value) : value;
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this.getter = getter;
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this.effect = new ReactiveEffect(
          () => getter(this._value),
          () => triggerRefValue(
            this,
            this.effect._dirtyLevel === 2 ? 2 : 3
          )
        );
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
          triggerRefValue(self2, 4);
        }
        trackRefValue(self2);
        if (self2.effect._dirtyLevel >= 2) {
          triggerRefValue(self2, 2);
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
      // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
      get _dirty() {
        return this.effect.dirty;
      }
      set _dirty(v2) {
        this.effect.dirty = v2;
      }
      // #endregion
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$7(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    function trackRefValue(ref2) {
      var _a;
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffect(
          activeEffect,
          (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
            () => ref2.dep = void 0,
            ref2 instanceof ComputedRefImpl ? ref2 : void 0
          )
        );
      }
    }
    function triggerRefValue(ref2, dirtyLevel = 4, newVal, oldVal) {
      ref2 = toRaw(ref2);
      const dep = ref2.dep;
      if (dep) {
        triggerEffects(
          dep,
          dirtyLevel
        );
      }
    }
    function isRef(r2) {
      return !!(r2 && r2.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
          this._rawValue;
          this._rawValue = newVal;
          this._value = useDirectValue ? newVal : toReactive(newVal);
          triggerRefValue(this, 4);
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    class CustomRefImpl {
      constructor(factory) {
        this.dep = void 0;
        this.__v_isRef = true;
        const { get: get2, set: set2 } = factory(
          () => trackRefValue(this),
          () => triggerRefValue(this)
        );
        this._get = get2;
        this._set = set2;
      }
      get value() {
        return this._get();
      }
      set value(newVal) {
        this._set(newVal);
      }
    }
    function customRef(factory) {
      return new CustomRefImpl(factory);
    }
    function toRefs(object2) {
      const ret = isArray$n(object2) ? new Array(object2.length) : {};
      for (const key in object2) {
        ret[key] = propertyToRef(object2, key);
      }
      return ret;
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    function propertyToRef(source, key, defaultValue) {
      const val = source[key];
      return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
    }
    /**
    * @vue/runtime-core v3.4.37
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack = [];
    let isWarning = false;
    function warn$1(msg, ...args) {
      if (isWarning)
        return;
      isWarning = true;
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            // eslint-disable-next-line no-restricted-syntax
            msg + args.map((a2) => {
              var _a, _b;
              return (_b = (_a = a2.toString) == null ? void 0 : _a.call(a2)) != null ? _b : JSON.stringify(a2);
            }).join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
      isWarning = false;
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last2 = normalizedStack[0];
        if (last2 && last2.vnode === currentVNode) {
          last2.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i2) => {
        logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys2 = Object.keys(props);
      keys2.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys2.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString$4(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$7(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function callWithErrorHandling(fn2, instance, type, args) {
      try {
        return args ? fn2(...args) : fn2();
      } catch (err) {
        handleError(err, instance, type);
      }
    }
    function callWithAsyncErrorHandling(fn2, instance, type, args) {
      if (isFunction$7(fn2)) {
        const res = callWithErrorHandling(fn2, instance, type, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      if (isArray$n(fn2)) {
        const values2 = [];
        for (let i2 = 0; i2 < fn2.length; i2++) {
          values2.push(callWithAsyncErrorHandling(fn2[i2], instance, type, args));
        }
        return values2;
      }
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
              if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          pauseTracking();
          callWithErrorHandling(
            appErrorHandler,
            null,
            10,
            [err, exposedInstance, errorInfo]
          );
          resetTracking();
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev);
    }
    function logError(err, type, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn2) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
    }
    function findInsertionIndex(id) {
      let start2 = flushIndex + 1;
      let end2 = queue.length;
      while (start2 < end2) {
        const middle = start2 + end2 >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id || middleJobId === id && middleJob.pre) {
          start2 = middle + 1;
        } else {
          end2 = middle;
        }
      }
      return start2;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i2 = queue.indexOf(job);
      if (i2 > flushIndex) {
        queue.splice(i2, 1);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$n(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(
          cb,
          cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
        )) {
          pendingPostFlushCbs.push(cb);
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i2 = isFlushing ? flushIndex + 1 : 0) {
      for (; i2 < queue.length; i2++) {
        const cb = queue[i2];
        if (cb && cb.pre) {
          if (instance && cb.id !== instance.uid) {
            continue;
          }
          queue.splice(i2, 1);
          i2--;
          cb();
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a2, b2) => getId(a2) - getId(b2)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          const cb = activePostFlushCbs[postFlushIndex];
          if (cb.active !== false)
            cb();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    const comparator = (a2, b2) => {
      const diff2 = getId(a2) - getId(b2);
      if (diff2 === 0) {
        if (a2.pre && !b2.pre)
          return -1;
        if (b2.pre && !a2.pre)
          return 1;
      }
      return diff2;
    };
    function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      queue.sort(comparator);
      const check2 = NOOP;
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (false)
              ;
            callWithErrorHandling(
              job,
              job.i,
              job.i ? 15 : 14
            );
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx)
        return fn2;
      if (fn2._n) {
        return fn2;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn2(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        return vnode;
      }
      const instance = getComponentPublicInstance(currentRenderingInstance);
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i2 = 0; i2 < directives.length; i2++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
        if (dir) {
          if (isFunction$7(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name2) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i2 = 0; i2 < bindings.length; i2++) {
        const binding = bindings[i2];
        if (oldBindings) {
          binding.oldValue = oldBindings[i2].value;
        }
        let hook = binding.dir[name2];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    function setTransitionHooks(vnode, hooks2) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks2);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks2.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks2.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks2;
      }
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineComponent(options, extraOptions) {
      return isFunction$7(options) ? (
        // #8326: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend$3({ name: options.name }, extraOptions, { setup: options }))()
      ) : options;
    }
    const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
      }, target);
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks2 = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          pauseTracking();
          const reset = setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks2.unshift(wrappedHook);
        } else {
          hooks2.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => {
      if (!isInSSRComponentSetup || lifecycle === "sp") {
        injectHook(lifecycle, (...args) => hook(...args), target);
      }
    };
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook("bu");
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook("bum");
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook("sp");
    const onRenderTriggered = createHook(
      "rtg"
    );
    const onRenderTracked = createHook(
      "rtc"
    );
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    const COMPONENTS = "components";
    function resolveComponent(name2, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString$4(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveAsset(type, name2, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name2 || selfName === camelize(name2) || selfName === capitalize$2(camelize(name2)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name2) || // global registration
          resolve(instance.appContext[type], name2)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name2) {
      return registry && (registry[name2] || registry[camelize(name2)] || registry[capitalize$2(camelize(name2))]);
    }
    function renderList(source, renderItem, cache, index2) {
      let ret;
      const cached = cache && cache[index2];
      if (isArray$n(source) || isString$4(source)) {
        ret = new Array(source.length);
        for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
          ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i2 = 0; i2 < source; i2++) {
          ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
        }
      } else if (isObject$f(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
          );
        } else {
          const keys2 = Object.keys(source);
          ret = new Array(keys2.length);
          for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
            const key = keys2[i2];
            ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
          }
        }
      } else {
        ret = [];
      }
      if (cache) {
        cache[index2] = ret;
      }
      return ret;
    }
    function createSlots(slots, dynamicSlots) {
      for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
        const slot = dynamicSlots[i2];
        if (isArray$n(slot)) {
          for (let j2 = 0; j2 < slot.length; j2++) {
            slots[slot[j2].name] = slot[j2].fn;
          }
        } else if (slot) {
          slots[slot.name] = slot.key ? (...args) => {
            const res = slot.fn(...args);
            if (res)
              res.key = slot.key;
            return res;
          } : slot.fn;
        }
      }
      return slots;
    }
    function renderSlot(slots, name2, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name2 !== "default")
          props.name = name2;
        return createVNode("slot", props, fallback && fallback());
      }
      let slot = slots[name2];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const rendered = createBlock(
        Fragment,
        {
          key: (props.key || // slot content array of a dynamic conditional slot may have a branch
          // key attached in the `createSlots` helper, respect that
          validSlotContent && validSlotContent.key || `_${name2}`) + // #7256 force differentiate fallback content from actual content
          (!validSlotContent && fallback ? "_fb" : "")
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    const getPublicInstance = (i2) => {
      if (!i2)
        return null;
      if (isStatefulComponent(i2))
        return getComponentPublicInstance(i2);
      return getPublicInstance(i2.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend$3(/* @__PURE__ */ Object.create(null), {
        $: (i2) => i2,
        $el: (i2) => i2.vnode.el,
        $data: (i2) => i2.data,
        $props: (i2) => i2.props,
        $attrs: (i2) => i2.attrs,
        $slots: (i2) => i2.slots,
        $refs: (i2) => i2.refs,
        $parent: (i2) => getPublicInstance(i2.parent),
        $root: (i2) => getPublicInstance(i2.root),
        $emit: (i2) => i2.emit,
        $options: (i2) => resolveMergedOptions(i2),
        $forceUpdate: (i2) => i2.f || (i2.f = () => {
          i2.effect.dirty = true;
          queueJob(i2.update);
        }),
        $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
        $watch: (i2) => instanceWatch.bind(i2)
      })
    );
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        if (key === "__v_skip") {
          return true;
        }
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n2 = accessCache[key];
          if (n2 !== void 0) {
            switch (n2) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance.attrs, "get", "");
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else
          ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    function normalizePropsOrEmits(props) {
      return isArray$n(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render: render2,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components: components2,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$7(methodHandler)) {
            {
              ctx[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$f(data))
          ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$7(opt) ? opt.bind(publicThis, publicThis) : isFunction$7(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set2 = !isFunction$7(opt) && isFunction$7(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c2 = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c2.value,
            set: (v2) => c2.value = v2
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$7(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$n(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$n(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render2 && instance.render === NOOP) {
        instance.render = render2;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components2)
        instance.components = components2;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
      if (isArray$n(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$f(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v2) => injected.value = v2
          });
        } else {
          ctx[key] = injected;
        }
      }
    }
    function callHook(hook, instance, type) {
      callWithAsyncErrorHandling(
        isArray$n(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString$4(raw)) {
        const handler = ctx[raw];
        if (isFunction$7(handler)) {
          watch(getter, handler);
        }
      } else if (isFunction$7(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (isObject$f(raw)) {
        if (isArray$n(raw)) {
          raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
        } else {
          const handler = isFunction$7(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$7(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else
        ;
    }
    function resolveMergedOptions(instance) {
      const base2 = instance.type;
      const { mixins, extends: extendsOptions } = base2;
      const {
        mixins: globalMixins,
        optionsCache: cache,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache.get(base2);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base2;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
          );
        }
        mergeOptions(resolved, base2, optionMergeStrategies);
      }
      if (isObject$f(base2)) {
        cache.set(base2, resolved);
      }
      return resolved;
    }
    function mergeOptions(to2, from2, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from2;
      if (extendsOptions) {
        mergeOptions(to2, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m2) => mergeOptions(to2, m2, strats, true)
        );
      }
      for (const key in from2) {
        if (asMixin && key === "expose")
          ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to2[key] = strat ? strat(to2[key], from2[key]) : from2[key];
        }
      }
      return to2;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to2, from2) {
      if (!from2) {
        return to2;
      }
      if (!to2) {
        return from2;
      }
      return function mergedDataFn() {
        return extend$3(
          isFunction$7(to2) ? to2.call(this, this) : to2,
          isFunction$7(from2) ? from2.call(this, this) : from2
        );
      };
    }
    function mergeInject(to2, from2) {
      return mergeObjectOptions(normalizeInject(to2), normalizeInject(from2));
    }
    function normalizeInject(raw) {
      if (isArray$n(raw)) {
        const res = {};
        for (let i2 = 0; i2 < raw.length; i2++) {
          res[raw[i2]] = raw[i2];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to2, from2) {
      return to2 ? [...new Set([].concat(to2, from2))] : from2;
    }
    function mergeObjectOptions(to2, from2) {
      return to2 ? extend$3(/* @__PURE__ */ Object.create(null), to2, from2) : from2;
    }
    function mergeEmitsOrPropsOptions(to2, from2) {
      if (to2) {
        if (isArray$n(to2) && isArray$n(from2)) {
          return [.../* @__PURE__ */ new Set([...to2, ...from2])];
        }
        return extend$3(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to2),
          normalizePropsOrEmits(from2 != null ? from2 : {})
        );
      } else {
        return from2;
      }
    }
    function mergeWatchOptions(to2, from2) {
      if (!to2)
        return from2;
      if (!from2)
        return to2;
      const merged = extend$3(/* @__PURE__ */ Object.create(null), to2);
      for (const key in from2) {
        merged[key] = mergeAsArray(to2[key], from2[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render2, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$7(rootComponent)) {
          rootComponent = extend$3({}, rootComponent);
        }
        if (rootProps != null && !isObject$f(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        let isMounted = false;
        const app = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version: version$2,
          get config() {
            return context.config;
          },
          set config(v2) {
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin))
              ;
            else if (plugin && isFunction$7(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app, ...options);
            } else if (isFunction$7(plugin)) {
              installedPlugins.add(plugin);
              plugin(app, ...options);
            } else
              ;
            return app;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app;
          },
          component(name2, component) {
            if (!component) {
              return context.components[name2];
            }
            context.components[name2] = component;
            return app;
          },
          directive(name2, directive) {
            if (!directive) {
              return context.directives[name2];
            }
            context.directives[name2] = directive;
            return app;
          },
          mount(rootContainer, isHydrate, namespace) {
            if (!isMounted) {
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace === true) {
                namespace = "svg";
              } else if (namespace === false) {
                namespace = void 0;
              }
              if (isHydrate && hydrate) {
                hydrate(vnode, rootContainer);
              } else {
                render2(vnode, rootContainer, namespace);
              }
              isMounted = true;
              app._container = rootContainer;
              rootContainer.__vue_app__ = app;
              return getComponentPublicInstance(vnode.component);
            }
          },
          unmount() {
            if (isMounted) {
              render2(null, app._container);
              delete app._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app;
          },
          runWithContext(fn2) {
            const lastApp = currentApp;
            currentApp = app;
            try {
              return fn2();
            } finally {
              currentApp = lastApp;
            }
          }
        };
        return app;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance)
        ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$7(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else
          ;
      }
    }
    const internalObjectProto = {};
    const createInternalObject = () => Object.create(internalObjectProto);
    const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = createInternalObject();
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            let key = propsToUpdate[i2];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance.attrs, "set", "");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i2 = 0; i2 < needCastKeys.length; i2++) {
          const key = needCastKeys[i2];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$7(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    const mixinPropsCache = /* @__PURE__ */ new WeakMap();
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache = asMixin ? mixinPropsCache : appContext.propsCache;
      const cached = cache.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$7(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend$3(normalized, props);
          if (keys2)
            needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$f(comp)) {
          cache.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$n(raw)) {
        for (let i2 = 0; i2 < raw.length; i2++) {
          const normalizedKey = camelize(raw[i2]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$n(opt) || isFunction$7(opt) ? { type: opt } : extend$3({}, opt);
            const propType = prop.type;
            let shouldCast = false;
            let shouldCastTrue = true;
            if (isArray$n(propType)) {
              for (let index2 = 0; index2 < propType.length; ++index2) {
                const type = propType[index2];
                const typeName = isFunction$7(type) && type.name;
                if (typeName === "Boolean") {
                  shouldCast = true;
                  break;
                } else if (typeName === "String") {
                  shouldCastTrue = false;
                }
              }
            } else {
              shouldCast = isFunction$7(propType) && propType.name === "Boolean";
            }
            prop[
              0
              /* shouldCast */
            ] = shouldCast;
            prop[
              1
              /* shouldCastTrue */
            ] = shouldCastTrue;
            if (shouldCast || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$f(comp)) {
        cache.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$" && !isReservedProp(key)) {
        return true;
      }
      return false;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$n(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false)
          ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (isFunction$7(value)) {
          slots[key] = normalizeSlot(key, value, ctx);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const assignSlots = (slots, children, optimized) => {
      for (const key in children) {
        if (optimized || key !== "_") {
          slots[key] = children[key];
        }
      }
    };
    const initSlots = (instance, children, optimized) => {
      const slots = instance.slots = createInternalObject();
      if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          assignSlots(slots, children, optimized);
          if (optimized) {
            def(slots, "_", type, true);
          }
        } else {
          normalizeObjectSlots(children, slots);
        }
      } else if (children) {
        normalizeVNodeSlots(instance, children);
      }
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            assignSlots(slots, children, optimized);
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$n(rawRef)) {
        rawRef.forEach(
          (r2, i2) => setRef(
            r2,
            oldRawRef && (isArray$n(oldRawRef) ? oldRawRef[i2] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref2 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref2) {
        if (isString$4(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$7(ref2)) {
        callWithErrorHandling(ref2, owner, 12, [value, refs]);
      } else {
        const _isString = isString$4(ref2);
        const _isRef = isRef(ref2);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
              if (isUnmount) {
                isArray$n(existing) && remove(existing, refValue);
              } else {
                if (!isArray$n(existing)) {
                  if (_isString) {
                    refs[ref2] = [refValue];
                    if (hasOwn(setupState, ref2)) {
                      setupState[ref2] = refs[ref2];
                    }
                  } else {
                    ref2.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref2.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref2] = value;
              if (hasOwn(setupState, ref2)) {
                setupState[ref2] = value;
              }
            } else if (_isRef) {
              ref2.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else
              ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    const TeleportEndKey = Symbol("_vte");
    const isTeleport = (type) => type.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
    const resolveTarget = (props, select2) => {
      const targetSelector = props && props.to;
      if (isString$4(targetSelector)) {
        if (!select2) {
          return null;
        } else {
          const target = select2(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      name: "Teleport",
      __isTeleport: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n1 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = prepareAnchor(target, n2, createText, insert);
          if (target) {
            if (namespace === "svg" || isTargetSVG(target)) {
              namespace = "svg";
            } else if (namespace === "mathml" || isTargetMathML(target)) {
              namespace = "mathml";
            }
          }
          const mount = (container2, anchor2) => {
            if (shapeFlag & 16) {
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          };
          if (disabled) {
            mount(container, mainAnchor);
          } else if (target) {
            mount(target, targetAnchor);
          }
        } else {
          n2.el = n1.el;
          n2.targetStart = n1.targetStart;
          const mainAnchor = n2.anchor = n1.anchor;
          const target = n2.target = n1.target;
          const targetAnchor = n2.targetAnchor = n1.targetAnchor;
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          if (namespace === "svg" || isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                n2.props.to = n1.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
              );
            }
          }
        }
        updateCssVars(n2);
      },
      remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const {
          shapeFlag,
          children,
          anchor,
          targetStart,
          targetAnchor,
          target,
          props
        } = vnode;
        if (target) {
          hostRemove(targetStart);
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            unmount(
              child,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i2 = 0; i2 < children.length; i2++) {
            move(
              children[i2],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector, insert, createText }
    }, hydrateChildren) {
      const target = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (isTeleportDisabled(vnode.props)) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetStart = targetNode;
            vnode.targetAnchor = targetNode && nextSibling(targetNode);
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              if (targetAnchor && targetAnchor.nodeType === 8) {
                if (targetAnchor.data === "teleport start anchor") {
                  vnode.targetStart = targetAnchor;
                } else if (targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              targetAnchor = nextSibling(targetAnchor);
            }
            if (!vnode.targetAnchor) {
              prepareAnchor(target, vnode, createText, insert);
            }
            hydrateChildren(
              targetNode && nextSibling(targetNode),
              vnode,
              target,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode) {
      const ctx = vnode.ctx;
      if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while (node && node !== vnode.targetAnchor) {
          if (node.nodeType === 1)
            node.setAttribute("data-v-owner", ctx.uid);
          node = node.nextSibling;
        }
        ctx.ut();
      }
    }
    function prepareAnchor(target, vnode, createText, insert) {
      const targetStart = vnode.targetStart = createText("");
      const targetAnchor = vnode.targetAnchor = createText("");
      targetStart[TeleportEndKey] = targetAnchor;
      if (target) {
        insert(targetStart, target);
        insert(targetAnchor, target);
      }
      return targetAnchor;
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref: ref2, shapeFlag } = n2;
        switch (type) {
          case Text:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, namespace);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else
              ;
        }
        if (ref2 != null && parentComponent) {
          setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace = "svg";
        } else if (n2.type === "math") {
          namespace = "mathml";
        }
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(
          vnode.type,
          namespace,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(el, key, null, props[key], namespace, parentComponent);
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value, namespace);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
            hostSetScopeId(el, slotScopeIds[i2]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start2 = 0) => {
        for (let i2 = start2; i2 < children.length; i2++) {
          const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
          hostSetElementText(el, "");
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(el, oldProps, newProps, parentComponent, namespace);
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, namespace);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
                const key = propsToUpdate[i2];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(el, key, prev, next, namespace, parentComponent);
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
        for (let i2 = 0; i2 < newChildren.length; i2++) {
          const oldVNode = oldChildren[i2];
          const newVNode = newChildren[i2];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el,
                  key,
                  oldProps[key],
                  null,
                  namespace,
                  parentComponent
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key))
              continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n1,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance, false, optimized);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace,
            optimized
          );
        }
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.effect.dirty = true;
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m: m2, parent: parent2 } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent2, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                instance.subTree = renderComponentRoot(instance);
                hydrateNode(
                  el,
                  instance.subTree,
                  instance,
                  parentSuspense,
                  null
                );
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(
                  // note: we are moving the render call into an async callback,
                  // which means it won't track dependencies - but it's ok because
                  // a server-rendered async wrapper is already in resolved state
                  // and it will never need to change.
                  () => !instance.isUnmounted && hydrateSubTree()
                );
              } else {
                hydrateSubTree();
              }
            } else {
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace
              );
              initialVNode.el = subTree.el;
            }
            if (m2) {
              queuePostRenderEffect(m2, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent2, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent2 && isAsyncWrapper(parent2.vnode) && parent2.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u: u2, parent: parent2, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent2, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u2) {
              queuePostRenderEffect(u2, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent2, next, vnode),
                parentSuspense
              );
            }
          }
        };
        const effect2 = instance.effect = new ReactiveEffect(
          componentUpdateFn,
          NOOP,
          () => queueJob(update),
          instance.scope
          // track it in component's effect scope
        );
        const update = instance.update = () => {
          if (effect2.dirty) {
            effect2.run();
          }
        };
        update.i = instance;
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i2;
        for (i2 = 0; i2 < commonLength; i2++) {
          const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          patch(
            c1[i2],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let i2 = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i2 <= e1 && i2 <= e2) {
          const n1 = c1[i2];
          const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i2++;
        }
        while (i2 <= e1 && i2 <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i2 > e1) {
          if (i2 <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i2 <= e2) {
              patch(
                null,
                c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              i2++;
            }
          }
        } else if (i2 > e2) {
          while (i2 <= e1) {
            unmount(c1[i2], parentComponent, parentSuspense, true);
            i2++;
          }
        } else {
          const s1 = i2;
          const s2 = i2;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i2 = s2; i2 <= e2; i2++) {
            const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i2);
            }
          }
          let j2;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved2 = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i2 = 0; i2 < toBePatched; i2++)
            newIndexToOldIndexMap[i2] = 0;
          for (i2 = s1; i2 <= e1; i2++) {
            const prevChild = c1[i2];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex2;
            if (prevChild.key != null) {
              newIndex2 = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j2 = s2; j2 <= e2; j2++) {
                if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
                  newIndex2 = j2;
                  break;
                }
              }
            }
            if (newIndex2 === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex2 - s2] = i2 + 1;
              if (newIndex2 >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex2;
              } else {
                moved2 = true;
              }
              patch(
                prevChild,
                c2[newIndex2],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved2 ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j2 = increasingNewIndexSequence.length - 1;
          for (i2 = toBePatched - 1; i2 >= 0; i2--) {
            const nextIndex = s2 + i2;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i2] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (moved2) {
              if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
                move(nextChild, container, anchor, 2);
              } else {
                j2--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor, internals);
          return;
        }
        if (type === Fragment) {
          hostInsert(el, container, anchor);
          for (let i2 = 0; i2 < children.length; i2++) {
            move(children[i2], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref: ref2,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs,
          cacheIndex
        } = vnode;
        if (patchFlag === -2) {
          optimized = false;
        }
        if (ref2 != null) {
          setRef(ref2, null, parentSuspense, vnode, true);
        }
        if (cacheIndex != null) {
          parentComponent.renderCache[cacheIndex] = void 0;
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #5154
          // when v-once is used inside a block, setBlockTracking(-1) marks the
          // parent block with hasOnce: true
          // so that it doesn't take the fast path during unmount - otherwise
          // components nested in v-once are never unmounted.
          !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
          {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end2) => {
        let next;
        while (cur !== end2) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end2);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope: scope2, update, subTree, um, m: m2, a: a2 } = instance;
        invalidateMount(m2);
        invalidateMount(a2);
        if (bum) {
          invokeArrayFns(bum);
        }
        scope2.stop();
        if (update) {
          update.active = false;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
        for (let i2 = start2; i2 < children.length; i2++) {
          unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        const el = hostNextSibling(vnode.anchor || vnode.el);
        const teleportEnd = el && el[TeleportEndKey];
        return teleportEnd ? hostNextSibling(teleportEnd) : el;
      };
      let isFlushing2 = false;
      const render2 = (vnode, container, namespace) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace
          );
        }
        container._vnode = vnode;
        if (!isFlushing2) {
          isFlushing2 = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing2 = false;
        }
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(
          internals
        );
      }
      return {
        render: render2,
        hydrate,
        createApp: createAppAPI(render2, hydrate)
      };
    }
    function resolveChildrenNamespace({ type, props }, currentNamespace) {
      return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, update }, allowed) {
      effect2.allowRecurse = update.allowRecurse = allowed;
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$n(ch1) && isArray$n(ch2)) {
        for (let i2 = 0; i2 < ch1.length; i2++) {
          const c1 = ch1[i2];
          let c2 = ch2[i2];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
              c2.el = c1.el;
            }
            if (!shallow && c2.patchFlag !== -2)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i2, j2, u2, v2, c2;
      const len = arr.length;
      for (i2 = 0; i2 < len; i2++) {
        const arrI = arr[i2];
        if (arrI !== 0) {
          j2 = result[result.length - 1];
          if (arr[j2] < arrI) {
            p2[i2] = j2;
            result.push(i2);
            continue;
          }
          u2 = 0;
          v2 = result.length - 1;
          while (u2 < v2) {
            c2 = u2 + v2 >> 1;
            if (arr[result[c2]] < arrI) {
              u2 = c2 + 1;
            } else {
              v2 = c2;
            }
          }
          if (arrI < arr[result[u2]]) {
            if (u2 > 0) {
              p2[i2] = result[u2 - 1];
            }
            result[u2] = i2;
          }
        }
      }
      u2 = result.length;
      v2 = result[u2 - 1];
      while (u2-- > 0) {
        result[u2] = v2;
        v2 = p2[v2];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    function invalidateMount(hooks2) {
      if (hooks2) {
        for (let i2 = 0; i2 < hooks2.length; i2++)
          hooks2[i2].active = false;
      }
    }
    const ssrContextKey = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        return ctx;
      }
    };
    const INITIAL_WATCHER_VALUE = {};
    function watch(source, cb, options) {
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, {
      immediate,
      deep,
      flush,
      once,
      onTrack,
      onTrigger
    } = EMPTY_OBJ) {
      if (cb && once) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          unwatch();
        };
      }
      const instance = currentInstance;
      const reactiveGetter = (source2) => deep === true ? source2 : (
        // for deep: false, only traverse root-level properties
        traverse(source2, deep === false ? 1 : void 0)
      );
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (isArray$n(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
        getter = () => source.map((s2) => {
          if (isRef(s2)) {
            return s2.value;
          } else if (isReactive(s2)) {
            return reactiveGetter(s2);
          } else if (isFunction$7(s2)) {
            return callWithErrorHandling(s2, instance, 2);
          } else
            ;
        });
      } else if (isFunction$7(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(source, instance, 2);
        } else {
          getter = () => {
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(
              source,
              instance,
              3,
              [onCleanup]
            );
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn2) => {
        cleanup = effect2.onStop = () => {
          callWithErrorHandling(fn2, instance, 4);
          cleanup = effect2.onStop = void 0;
        };
      };
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else {
          return NOOP;
        }
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect2.active || !effect2.dirty) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect2.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler = () => queueJob(job);
      }
      const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
      const scope2 = getCurrentScope();
      const unwatch = () => {
        effect2.stop();
        if (scope2) {
          remove(scope2.effects, effect2);
        }
      };
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect2.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(
          effect2.run.bind(effect2),
          instance && instance.suspense
        );
      } else {
        effect2.run();
      }
      if (ssrCleanup)
        ssrCleanup.push(unwatch);
      return unwatch;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$4(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$7(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i2 = 0; i2 < segments.length && cur; i2++) {
          cur = cur[segments[i2]];
        }
        return cur;
      };
    }
    function traverse(value, depth = Infinity, seen) {
      if (depth <= 0 || !isObject$f(value) || value["__v_skip"]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      depth--;
      if (isRef(value)) {
        traverse(value.value, depth, seen);
      } else if (isArray$n(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          traverse(value[i2], depth, seen);
        }
      } else if (isSet$3(value) || isMap$2(value)) {
        value.forEach((v2) => {
          traverse(v2, depth, seen);
        });
      } else if (isPlainObject$4(value)) {
        for (const key in value) {
          traverse(value[key], depth, seen);
        }
        for (const key of Object.getOwnPropertySymbols(value)) {
          if (Object.prototype.propertyIsEnumerable.call(value, key)) {
            traverse(value[key], depth, seen);
          }
        }
      }
      return value;
    }
    const getModelModifiers = (props, modelName) => {
      return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
    };
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
      if (modifiers) {
        if (modifiers.trim) {
          args = rawArgs.map((a2) => isString$4(a2) ? a2.trim() : a2);
        }
        if (modifiers.number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$7(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend$3(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$f(comp)) {
          cache.set(comp, null);
        }
        return null;
      }
      if (isArray$n(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend$3(normalized, raw);
      }
      if (isObject$f(comp)) {
        cache.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render: render2,
        renderCache,
        props,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      const prev = setCurrentRenderingInstance(instance);
      let result;
      let fallthroughAttrs;
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = false ? new Proxy(proxyToUse, {
            get(target, key, receiver) {
              warn$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render2.call(
              thisProxy,
              proxyToUse,
              renderCache,
              false ? shallowReadonly(props) : props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render22 = Component;
          if (false)
            ;
          result = normalizeVNode(
            render22.length > 1 ? render22(
              false ? shallowReadonly(props) : props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return shallowReadonly(attrs);
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render22(
              false ? shallowReadonly(props) : props,
              null
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root2 = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root2 = cloneVNode(root2, fallthroughAttrs, false, true);
          }
        }
      }
      if (vnode.dirs) {
        root2 = cloneVNode(root2, null, false, true);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        root2.transition = vnode.transition;
      }
      {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i2 = 0; i2 < dynamicProps.length; i2++) {
            const key = dynamicProps[i2];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i2 = 0; i2 < nextKeys.length; i2++) {
        const key = nextKeys[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent: parent2 }, el) {
      while (parent2) {
        const root2 = parent2.subTree;
        if (root2.suspense && root2.suspense.activeBranch === vnode) {
          root2.el = vnode.el;
        }
        if (root2 === vnode) {
          (vnode = parent2.vnode).el = el;
          parent2 = parent2.parent;
        } else {
          break;
        }
      }
    }
    const isSuspense = (type) => type.__isSuspense;
    function queueEffectWithSuspense(fn2, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$n(fn2)) {
          suspense.effects.push(...fn2);
        } else {
          suspense.effects.push(fn2);
        }
      } else {
        queuePostFlushCb(fn2);
      }
    }
    const Fragment = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
      if (value < 0 && currentBlock) {
        currentBlock.hasOnce = true;
      }
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      return n1.type === n2.type && n1.key === n2.key;
    }
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref2,
      ref_key,
      ref_for
    }) => {
      if (typeof ref2 === "number") {
        ref2 = "" + ref2;
      }
      return ref2 != null ? isString$4(ref2) || isRef(ref2) || isFunction$7(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
    };
    function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString$4(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        type = Comment;
      }
      if (isVNode(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag = -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString$4(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$f(style)) {
          if (isProxy(style) && !isArray$n(style)) {
            style = extend$3({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      const shapeFlag = isString$4(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$f(type) ? 4 : isFunction$7(type) ? 2 : 0;
      return createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || isInternalObject(props) ? extend$3({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
      const { props, ref: ref2, patchFlag, children, transition } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref2 ? isArray$n(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref2,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetStart: vnode.targetStart,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      if (transition && cloneTransition) {
        setTransitionHooks(
          cloned,
          transition.clone(cloned)
        );
      }
      return cloned;
    }
    function createTextVNode(text2 = " ", flag = 0) {
      return createVNode(Text, null, text2, flag);
    }
    function createCommentVNode(text2 = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text2)) : createVNode(Comment, null, text2);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$n(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$n(children)) {
        type = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children._;
          if (!slotFlag && !isInternalObject(children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$7(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type = 16;
          children = [createTextVNode(children)];
        } else {
          type = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i2 = 0; i2 < args.length; i2++) {
        const toMerge = args[i2];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$n(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent2, suspense) {
      const type = vnode.type;
      const appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent: parent2,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent2 ? parent2.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent2 ? parent2.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g2 = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g2[key]))
          setters = g2[key] = [];
        setters.push(setter);
        return (v2) => {
          if (setters.length > 1)
            setters.forEach((set2) => set2(v2));
          else
            setters[0](v2);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v2) => currentInstance = v2
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v2) => isInSSRComponentSetup = v2
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false, optimized = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children, optimized);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
      const { setup } = Component;
      if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(
          setup,
          instance,
          0,
          [
            instance.props,
            setupContext
          ]
        );
        resetTracking();
        reset();
        if (isPromise(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e2) => {
              handleError(e2, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$7(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$f(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else
        ;
      finishComponentSetup(instance, isSSR);
    }
    let compile;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend$3(
              extend$3(
                {
                  isCustomElement,
                  delimiters
                },
                compilerOptions
              ),
              componentCompilerOptions
            );
            Component.render = compile(template, finalCompilerOptions);
          }
        }
        instance.render = Component.render || NOOP;
      }
      {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
    }
    const attrsProxyHandlers = {
      get(target, key) {
        track(target, "get", "");
        return target[key];
      }
    };
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          attrs: new Proxy(instance.attrs, attrsProxyHandlers),
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getComponentPublicInstance(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      } else {
        return instance.proxy;
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$7(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name2 = getComponentName(Component);
      if (!name2 && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name2 = match[1];
        }
      }
      if (!name2 && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name2 = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name2 ? classify(name2) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$7(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
      return c2;
    };
    function h$1(type, propsOrChildren, children) {
      const l2 = arguments.length;
      if (l2 === 2) {
        if (isObject$f(propsOrChildren) && !isArray$n(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l2 > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l2 === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    }
    const version$2 = "3.4.37";
    /**
    * @vue/runtime-dom v3.4.37
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent2, anchor) => {
        parent2.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent2 = child.parentNode;
        if (parent2) {
          parent2.removeChild(child);
        }
      },
      createElement: (tag, namespace, is, props) => {
        const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text2) => doc.createTextNode(text2),
      createComment: (text2) => doc.createComment(text2),
      setText: (node, text2) => {
        node.nodeValue = text2;
      },
      setElementText: (el, text2) => {
        el.textContent = text2;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id) {
        el.setAttribute(id, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent2, anchor, namespace, start2, end2) {
        const before2 = anchor ? anchor.previousSibling : parent2.lastChild;
        if (start2 && (start2 === end2 || start2.nextSibling)) {
          while (true) {
            parent2.insertBefore(start2.cloneNode(true), anchor);
            if (start2 === end2 || !(start2 = start2.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
          const template = templateContainer.content;
          if (namespace === "svg" || namespace === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent2.insertBefore(template, anchor);
        }
        return [
          // first
          before2 ? before2.nextSibling : parent2.firstChild,
          // last
          anchor ? anchor.previousSibling : parent2.lastChild
        ];
      }
    };
    const vtcKey = Symbol("_vtc");
    function patchClass(el, value, isSVG) {
      const transitionClasses = el[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    const vShowOriginalDisplay = Symbol("_vod");
    const vShowHidden = Symbol("_vsh");
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    function setDisplay(el, value) {
      el.style.display = value ? el[vShowOriginalDisplay] : "none";
      el[vShowHidden] = !value;
    }
    const CSS_VAR_TEXT = Symbol("");
    const displayRE = /(^|;)\s*display\s*:/;
    function patchStyle(el, prev, next) {
      const style = el.style;
      const isCssString = isString$4(next);
      let hasControlledDisplay = false;
      if (next && !isCssString) {
        if (prev) {
          if (!isString$4(prev)) {
            for (const key in prev) {
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          } else {
            for (const prevStyle of prev.split(";")) {
              const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          }
        }
        for (const key in next) {
          if (key === "display") {
            hasControlledDisplay = true;
          }
          setStyle(style, key, next[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next) {
            const cssVarText = style[CSS_VAR_TEXT];
            if (cssVarText) {
              next += ";" + cssVarText;
            }
            style.cssText = next;
            hasControlledDisplay = displayRE.test(next);
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
      }
      if (vShowOriginalDisplay in el) {
        el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
        if (el[vShowHidden]) {
          style.display = "none";
        }
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style, name2, val) {
      if (isArray$n(val)) {
        val.forEach((v2) => setStyle(style, name2, v2));
      } else {
        if (val == null)
          val = "";
        if (name2.startsWith("--")) {
          style.setProperty(name2, val);
        } else {
          const prefixed = autoPrefix(style, name2);
          if (importantRE.test(val)) {
            style.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name2 = camelize(rawName);
      if (name2 !== "filter" && name2 in style) {
        return prefixCache[rawName] = name2;
      }
      name2 = capitalize$2(name2);
      for (let i2 = 0; i2 < prefixes.length; i2++) {
        const prefixed = prefixes[i2] + name2;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(
            key,
            isBoolean2 ? "" : isSymbol$6(value) ? String(value) : value
          );
        }
      }
    }
    function patchDOMProp(el, key, value, parentComponent) {
      if (key === "innerHTML" || key === "textContent") {
        if (value == null)
          return;
        el[key] = value;
        return;
      }
      const tag = el.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
        const newValue = value == null ? "" : String(value);
        if (oldValue !== newValue || !("_value" in el)) {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        el._value = value;
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e2) {
      }
      needRemove && el.removeAttribute(key);
    }
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el[veiKey] || (el[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name2, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(
            nextValue,
            instance
          );
          addEventListener(el, name2, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name2, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name2) {
      let options;
      if (optionsModifierRE.test(name2)) {
        options = {};
        let m2;
        while (m2 = name2.match(optionsModifierRE)) {
          name2 = name2.slice(0, name2.length - m2[0].length);
          options[m2[0].toLowerCase()] = true;
        }
      }
      const event = name2[2] === ":" ? name2.slice(3) : hyphenate(name2.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p$1 = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e2) => {
        if (!e2._vts) {
          e2._vts = Date.now();
        } else if (e2._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e2, invoker.value),
          instance,
          5,
          [e2]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e2, value) {
      if (isArray$n(value)) {
        const originalStop = e2.stopImmediatePropagation;
        e2.stopImmediatePropagation = () => {
          originalStop.call(e2);
          e2._stopped = true;
        };
        return value.map(
          (fn2) => (e22) => !e22._stopped && fn2 && fn2(e22)
        );
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
      const isSVG = namespace === "svg";
      if (key === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue);
        if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
          patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
        }
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && isNativeOn(key) && isFunction$7(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && isString$4(value)) {
        return false;
      }
      return key in el;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineCustomElement(options, extraOptions, hydrate2) {
      const Comp = /* @__PURE__ */ defineComponent(options, extraOptions);
      class VueCustomElement extends VueElement {
        constructor(initialProps) {
          super(Comp, initialProps, hydrate2);
        }
      }
      VueCustomElement.def = Comp;
      return VueCustomElement;
    }
    const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
    };
    class VueElement extends BaseClass {
      constructor(_def, _props = {}, hydrate2) {
        super();
        this._def = _def;
        this._props = _props;
        this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        this._ob = null;
        if (this.shadowRoot && hydrate2) {
          hydrate2(this._createVNode(), this.shadowRoot);
        } else {
          this.attachShadow({ mode: "open" });
          if (!this._def.__asyncLoader) {
            this._resolveProps(this._def);
          }
        }
      }
      connectedCallback() {
        this._connected = true;
        if (!this._instance) {
          if (this._resolved) {
            this._update();
          } else {
            this._resolveDef();
          }
        }
      }
      disconnectedCallback() {
        this._connected = false;
        nextTick(() => {
          if (!this._connected) {
            if (this._ob) {
              this._ob.disconnect();
              this._ob = null;
            }
            render$10(null, this.shadowRoot);
            this._instance = null;
          }
        });
      }
      /**
       * resolve inner component definition (handle possible async component)
       */
      _resolveDef() {
        this._resolved = true;
        for (let i2 = 0; i2 < this.attributes.length; i2++) {
          this._setAttr(this.attributes[i2].name);
        }
        this._ob = new MutationObserver((mutations) => {
          for (const m2 of mutations) {
            this._setAttr(m2.attributeName);
          }
        });
        this._ob.observe(this, { attributes: true });
        const resolve2 = (def2, isAsync = false) => {
          const { props, styles: styles2 } = def2;
          let numberProps;
          if (props && !isArray$n(props)) {
            for (const key in props) {
              const opt = props[key];
              if (opt === Number || opt && opt.type === Number) {
                if (key in this._props) {
                  this._props[key] = toNumber$2(this._props[key]);
                }
                (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
              }
            }
          }
          this._numberProps = numberProps;
          if (isAsync) {
            this._resolveProps(def2);
          }
          this._applyStyles(styles2);
          this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) {
          asyncDef().then((def2) => resolve2(def2, true));
        } else {
          resolve2(this._def);
        }
      }
      _resolveProps(def2) {
        const { props } = def2;
        const declaredPropKeys = isArray$n(props) ? props : Object.keys(props || {});
        for (const key of Object.keys(this)) {
          if (key[0] !== "_" && declaredPropKeys.includes(key)) {
            this._setProp(key, this[key], true, false);
          }
        }
        for (const key of declaredPropKeys.map(camelize)) {
          Object.defineProperty(this, key, {
            get() {
              return this._getProp(key);
            },
            set(val) {
              this._setProp(key, val);
            }
          });
        }
      }
      _setAttr(key) {
        let value = this.hasAttribute(key) ? this.getAttribute(key) : void 0;
        const camelKey = camelize(key);
        if (this._numberProps && this._numberProps[camelKey]) {
          value = toNumber$2(value);
        }
        this._setProp(camelKey, value, false);
      }
      /**
       * @internal
       */
      _getProp(key) {
        return this._props[key];
      }
      /**
       * @internal
       */
      _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
          this._props[key] = val;
          if (shouldUpdate && this._instance) {
            this._update();
          }
          if (shouldReflect) {
            if (val === true) {
              this.setAttribute(hyphenate(key), "");
            } else if (typeof val === "string" || typeof val === "number") {
              this.setAttribute(hyphenate(key), val + "");
            } else if (!val) {
              this.removeAttribute(hyphenate(key));
            }
          }
        }
      }
      _update() {
        render$10(this._createVNode(), this.shadowRoot);
      }
      _createVNode() {
        const vnode = createVNode(this._def, extend$3({}, this._props));
        if (!this._instance) {
          vnode.ce = (instance) => {
            this._instance = instance;
            instance.isCE = true;
            const dispatch = (event, args) => {
              this.dispatchEvent(
                new CustomEvent(event, {
                  detail: args
                })
              );
            };
            instance.emit = (event, ...args) => {
              dispatch(event, args);
              if (hyphenate(event) !== event) {
                dispatch(hyphenate(event), args);
              }
            };
            let parent2 = this;
            while (parent2 = parent2 && (parent2.parentNode || parent2.host)) {
              if (parent2 instanceof VueElement) {
                instance.parent = parent2._instance;
                instance.provides = parent2._instance.provides;
                break;
              }
            }
          };
        }
        return vnode;
      }
      _applyStyles(styles2) {
        if (styles2) {
          styles2.forEach((css2) => {
            const s2 = document.createElement("style");
            s2.textContent = css2;
            this.shadowRoot.appendChild(s2);
          });
        }
      }
    }
    const getModelAssigner = (vnode) => {
      const fn2 = vnode.props["onUpdate:modelValue"] || false;
      return isArray$n(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
    };
    function onCompositionStart(e2) {
      e2.target.composing = true;
    }
    function onCompositionEnd(e2) {
      const target = e2.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el, { modifiers: { lazy, trim: trim2, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e2) => {
          if (e2.target.composing)
            return;
          let domValue = el.value;
          if (trim2) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el[assignKey](domValue);
        });
        if (trim2) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim: trim2, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (el.composing)
          return;
        const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el && el.type !== "range") {
          if (lazy && value === oldValue) {
            return;
          }
          if (trim2 && el.value.trim() === newValue) {
            return;
          }
        }
        el.value = newValue;
      }
    };
    const vModelCheckbox = {
      // #4096 array checkboxes need to be deep traversed
      deep: true,
      created(el, _2, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          const modelValue = el._modelValue;
          const elementValue = getValue$2(el);
          const checked = el.checked;
          const assign = el[assignKey];
          if (isArray$n(modelValue)) {
            const index2 = looseIndexOf(modelValue, elementValue);
            const found = index2 !== -1;
            if (checked && !found) {
              assign(modelValue.concat(elementValue));
            } else if (!checked && found) {
              const filtered = [...modelValue];
              filtered.splice(index2, 1);
              assign(filtered);
            }
          } else if (isSet$3(modelValue)) {
            const cloned = new Set(modelValue);
            if (checked) {
              cloned.add(elementValue);
            } else {
              cloned.delete(elementValue);
            }
            assign(cloned);
          } else {
            assign(getCheckboxValue(el, checked));
          }
        });
      },
      // set initial checked on mount to wait for true-value/false-value
      mounted: setChecked,
      beforeUpdate(el, binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
      }
    };
    function setChecked(el, { value, oldValue }, vnode) {
      el._modelValue = value;
      if (isArray$n(value)) {
        el.checked = looseIndexOf(value, vnode.props.value) > -1;
      } else if (isSet$3(value)) {
        el.checked = value.has(vnode.props.value);
      } else if (value !== oldValue) {
        el.checked = looseEqual(value, getCheckboxValue(el, true));
      }
    }
    const vModelRadio = {
      created(el, { value }, vnode) {
        el.checked = looseEqual(value, vnode.props.value);
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          el[assignKey](getValue$2(el));
        });
      },
      beforeUpdate(el, { value, oldValue }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (value !== oldValue) {
          el.checked = looseEqual(value, vnode.props.value);
        }
      }
    };
    const vModelSelect = {
      // <select multiple> value need to be deep traversed
      deep: true,
      created(el, { value, modifiers: { number } }, vnode) {
        const isSetModel = isSet$3(value);
        addEventListener(el, "change", () => {
          const selectedVal = Array.prototype.filter.call(el.options, (o2) => o2.selected).map(
            (o2) => number ? looseToNumber(getValue$2(o2)) : getValue$2(o2)
          );
          el[assignKey](
            el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
          );
          el._assigning = true;
          nextTick(() => {
            el._assigning = false;
          });
        });
        el[assignKey] = getModelAssigner(vnode);
      },
      // set value in mounted & updated because <select> relies on its children
      // <option>s.
      mounted(el, { value, modifiers: { number } }) {
        setSelected(el, value);
      },
      beforeUpdate(el, _binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
      },
      updated(el, { value, modifiers: { number } }) {
        if (!el._assigning) {
          setSelected(el, value);
        }
      }
    };
    function setSelected(el, value, number) {
      const isMultiple = el.multiple;
      const isArrayValue = isArray$n(value);
      if (isMultiple && !isArrayValue && !isSet$3(value)) {
        return;
      }
      for (let i2 = 0, l2 = el.options.length; i2 < l2; i2++) {
        const option = el.options[i2];
        const optionValue = getValue$2(option);
        if (isMultiple) {
          if (isArrayValue) {
            const optionType = typeof optionValue;
            if (optionType === "string" || optionType === "number") {
              option.selected = value.some((v2) => String(v2) === String(optionValue));
            } else {
              option.selected = looseIndexOf(value, optionValue) > -1;
            }
          } else {
            option.selected = value.has(optionValue);
          }
        } else if (looseEqual(getValue$2(option), value)) {
          if (el.selectedIndex !== i2)
            el.selectedIndex = i2;
          return;
        }
      }
      if (!isMultiple && el.selectedIndex !== -1) {
        el.selectedIndex = -1;
      }
    }
    function getValue$2(el) {
      return "_value" in el ? el._value : el.value;
    }
    function getCheckboxValue(el, checked) {
      const key = checked ? "_trueValue" : "_falseValue";
      return key in el ? el[key] : checked;
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e2) => e2.stopPropagation(),
      prevent: (e2) => e2.preventDefault(),
      self: (e2) => e2.target !== e2.currentTarget,
      ctrl: (e2) => !e2.ctrlKey,
      shift: (e2) => !e2.shiftKey,
      alt: (e2) => !e2.altKey,
      meta: (e2) => !e2.metaKey,
      left: (e2) => "button" in e2 && e2.button !== 0,
      middle: (e2) => "button" in e2 && e2.button !== 1,
      right: (e2) => "button" in e2 && e2.button !== 2,
      exact: (e2, modifiers) => systemModifiers.some((m2) => e2[`${m2}Key`] && !modifiers.includes(m2))
    };
    const withModifiers = (fn2, modifiers) => {
      const cache = fn2._withMods || (fn2._withMods = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
        for (let i2 = 0; i2 < modifiers.length; i2++) {
          const guard = modifierGuards[modifiers[i2]];
          if (guard && guard(event, modifiers))
            return;
        }
        return fn2(event, ...args);
      });
    };
    const keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    const withKeys = (fn2, modifiers) => {
      const cache = fn2._withKeys || (fn2._withKeys = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
          return fn2(event);
        }
      });
    };
    const rendererOptions = /* @__PURE__ */ extend$3({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const render$10 = (...args) => {
      ensureRenderer().render(...args);
    };
    const createApp = (...args) => {
      const app = ensureRenderer().createApp(...args);
      const { mount } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app._component;
        if (!isFunction$7(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function normalizeContainer(container) {
      if (isString$4(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    var T$1 = Object.defineProperty;
    var D$1 = (e2, i2, t2) => i2 in e2 ? T$1(e2, i2, { enumerable: true, configurable: true, writable: true, value: t2 }) : e2[i2] = t2;
    var u$1 = (e2, i2, t2) => (D$1(e2, typeof i2 != "symbol" ? i2 + "" : i2, t2), t2);
    const K$1 = Object.assign, P$1 = Array.isArray, U$1 = (e2) => typeof e2 == "string", A$1 = (e2) => {
      const i2 = /* @__PURE__ */ Object.create(null);
      return (t2) => i2[t2] || (i2[t2] = e2(t2));
    }, z$1 = /-(\w)/g, w$1 = A$1((e2) => e2.replace(z$1, (i2, t2) => t2 ? t2.toUpperCase() : "")), M$1 = /\B([A-Z])/g, m$1 = A$1(
      (e2) => e2.replace(M$1, "-$1").toLowerCase()
    ), S$1 = (e2) => {
      const i2 = U$1(e2) ? Number(e2) : NaN;
      return isNaN(i2) ? e2 : i2;
    };
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function k$1(e2, i2, t2) {
      const s2 = /* @__PURE__ */ defineComponent(e2);
      class o2 extends O$1 {
        constructor(r2) {
          super(s2, r2, i2, t2);
        }
      }
      return u$1(o2, "def", s2), o2;
    }
    const F$1 = typeof HTMLElement < "u" ? HTMLElement : class {
    };
    let O$1 = class O2 extends F$1 {
      constructor(t2, s2 = {}, o2 = { shadowRoot: true }, n2) {
        super();
        u$1(this, "_instance", null);
        u$1(this, "_connected", false);
        u$1(this, "_resolved", false);
        u$1(this, "_numberProps", null);
        u$1(this, "_styles");
        u$1(this, "_slots", {});
        u$1(this, "_ob", null);
        this._def = t2, this._props = s2, this._config = o2, this._root && n2 ? n2(this._createVNode(), this._root) : (this._config.shadowRoot !== false && this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def));
      }
      get _root() {
        return this._config.shadowRoot ? this.shadowRoot : this;
      }
      connectedCallback() {
        this._connected = true, this._instance || (this._resolved ? this._update() : this._resolveDef());
      }
      disconnectedCallback() {
        this._connected = false, nextTick(() => {
          this._connected || (this._ob && (this._ob.disconnect(), this._ob = null), render$10(null, this._root), this._instance = null);
        });
      }
      /**
       * resolve inner component definition (handle possible async component)
       */
      _resolveDef() {
        this._resolved = true;
        for (let o2 = 0; o2 < this.attributes.length; o2++)
          this._setAttr(this.attributes[o2].name);
        this._ob = new MutationObserver((o2) => {
          for (const n2 of o2)
            this._setAttr(n2.attributeName);
        }), this._ob.observe(this, { attributes: true });
        const t2 = (o2, n2 = false) => {
          const { props: r2 } = o2, p2 = this._collectNestedStyles(o2);
          let d2;
          if (r2 && !P$1(r2))
            for (const a2 in r2) {
              const _2 = r2[a2];
              (_2 === Number || _2 && _2.type === Number) && (a2 in this._props && (this._props[a2] = S$1(this._props[a2])), (d2 || (d2 = /* @__PURE__ */ Object.create(null)))[w$1(a2)] = true);
            }
          if (this._numberProps = d2, n2 && this._resolveProps(o2), !this._config.shadowRoot) {
            this._slots = {};
            for (const a2 of Array.from(this.children)) {
              const _2 = a2.getAttribute("slot") || "default";
              this._slots[_2] || (this._slots[_2] = []), this._slots[_2].push(
                h$1(a2.tagName.toLowerCase(), {}, a2.innerHTML)
              );
            }
            this.replaceChildren();
          }
          this._applyStyles(p2), this._update();
        }, s2 = this._def.__asyncLoader;
        s2 ? s2().then((o2) => t2(o2, true)) : t2(this._def);
      }
      _resolveProps(t2) {
        const { props: s2 } = t2, o2 = P$1(s2) ? s2 : Object.keys(s2 || {});
        for (const n2 of Object.keys(this))
          n2[0] !== "_" && o2.includes(n2) && this._setProp(n2, this[n2], true, false);
        for (const n2 of o2.map(w$1))
          Object.defineProperty(this, n2, {
            get() {
              return this._getProp(n2);
            },
            set(r2) {
              this._setProp(n2, r2);
            }
          });
      }
      _setAttr(t2) {
        let s2 = this.hasAttribute(t2) ? this.getAttribute(t2) : void 0;
        const o2 = w$1(t2);
        this._numberProps && this._numberProps[o2] && (s2 = S$1(s2)), this._setProp(o2, s2, false);
      }
      /**
       * @internal
       */
      _getProp(t2) {
        return this._props[t2];
      }
      /**
       * @internal
       */
      _setProp(t2, s2, o2 = true, n2 = true) {
        s2 !== this._props[t2] && (this._props[t2] = s2, n2 && this._instance && this._update(), o2 && (s2 === true ? this.setAttribute(m$1(t2), "") : typeof s2 == "string" || typeof s2 == "number" ? this.setAttribute(m$1(t2), s2 + "") : s2 || this.removeAttribute(m$1(t2))));
      }
      _update() {
        render$10(this._createVNode(), this._root);
      }
      _createVNode() {
        const t2 = createVNode(this._def, K$1({}, this._props), this._slots);
        return this._instance || (t2.ce = (s2) => {
          this._instance = s2, s2.isCE = true;
          const o2 = (r2, p2) => {
            this.dispatchEvent(
              new CustomEvent(r2, {
                detail: p2
              })
            );
          };
          s2.emit = (r2, ...p2) => {
            o2(r2, p2), m$1(r2) !== r2 && o2(m$1(r2), p2);
          };
          let n2 = this;
          for (; n2 = n2 && (n2.parentNode || n2.host); )
            if (n2 instanceof O2) {
              s2.parent = n2._instance, s2.provides = n2._instance.provides;
              break;
            }
        }), t2;
      }
      _applyStyles(t2) {
        t2 && t2.forEach((s2) => {
          const o2 = document.createElement("style");
          o2.textContent = s2, this._root.prepend(o2);
        });
      }
      _collectNestedStyles(t2) {
        let s2 = t2.styles ?? [];
        return t2.components && Object.values(t2.components).forEach((o2) => {
          s2 = s2.concat(this._collectNestedStyles(o2));
        }), s2;
      }
    };
    const G$1 = (e2) => {
      for (; (e2 == null ? void 0 : e2.nodeType) !== 1; ) {
        if (!e2.parentElement)
          throw new Error(
            "No parent element found, the rootComponent must be wrapped in a HTML element (e.g. <template><div> app content </div></template>)"
          );
        e2 = e2.parentElement;
      }
      return e2;
    };
    function C$1(e2) {
      return "on" + e2.charAt(0).toUpperCase() + e2.slice(1);
    }
    const q$1 = ({
      rootComponent: e2,
      plugins: i2,
      cssFrameworkStyles: t2,
      VueDefineCustomElement: s2,
      h: o2,
      createApp: n2,
      getCurrentInstance: r2,
      elementName: p2,
      disableRemoveStylesOnUnmount: d2,
      disableShadowDOM: a2
    }) => (a2 ? k$1 : s2)({
      name: "vue-custom-element-root-component",
      styles: [t2],
      props: {
        ...e2.props,
        modelValue: { type: [String, Number, Boolean, Array, Object] }
        // v-model support
      },
      emits: e2 == null ? void 0 : e2.emits,
      setup(L2, { slots: V2 }) {
        var N2;
        const E2 = [...(e2 == null ? void 0 : e2.emits) || [], "update:modelValue"], h2 = n2();
        if (h2.component("app-root", e2), e2.provide) {
          const c2 = typeof e2.provide == "function" ? e2.provide() : e2.provide;
          Object.keys(c2).forEach((l2) => {
            h2.provide(l2, c2[l2]);
          });
        }
        h2.mixin({
          mounted() {
            var l2, v2, y2;
            if (((v2 = (l2 = this.$) == null ? void 0 : l2.type) == null ? void 0 : v2.name) === "vue-custom-element-root-component")
              return;
            const c2 = (f2) => {
              f2 != null && f2.length && (this.__style = document.createElement("style"), this.__style.innerText = f2.join().replace(/\n/g, ""), G$1(this.$el).append(this.__style));
            };
            if (c2((y2 = this.$) == null ? void 0 : y2.type.styles), this.$options.components)
              for (const f2 of Object.values(this.$options.components))
                c2(f2.styles);
          },
          unmounted() {
            var c2;
            d2 || (c2 = this.__style) == null || c2.remove();
          }
        }), h2.use(i2);
        const b2 = r2();
        if (Object.assign(b2.appContext, h2._context), Object.assign(b2.provides, h2._context.provides), false)
          ;
        const j2 = E2 == null ? void 0 : E2.reduce((c2, l2) => {
          const v2 = C$1(l2);
          return c2[v2] = (y2) => {
            b2.emit(l2, y2);
          }, c2;
        }, {}), x2 = (N2 = e2 == null ? void 0 : e2.namedSlots) == null ? void 0 : N2.reduce((c2, l2) => (c2[l2] = () => o2("slot", { name: l2 }), c2), {});
        return () => o2(
          e2,
          {
            ...L2,
            ...j2
          },
          {
            default: () => o2("slot"),
            ...x2,
            ...V2
          }
        );
      }
    }, a2 && { shadowRoot: false }), Z$1 = ({
      elementName: e2,
      rootComponent: i2,
      plugins: t2,
      cssFrameworkStyles: s2,
      VueDefineCustomElement: o2,
      h: n2,
      createApp: r2,
      getCurrentInstance: p2,
      disableRemoveStylesOnUnmount: d2 = false,
      disableShadowDOM: a2 = false
    }) => {
      if (!i2) {
        console.warn("No root component provided. Please provide a root component to create a web component.");
        return;
      }
      if (!e2) {
        console.warn("No element name provided. Please provide an element name to create a web component.");
        return;
      }
      if (!o2) {
        console.warn(
          "No VueDefineCustomElement provided. Please provide a VueDefineCustomElement to create a web component."
        );
        return;
      }
      if (!n2) {
        console.warn("No h provided. Please provide an h to create a web component.");
        return;
      }
      if (!r2) {
        console.warn("No createApp provided. Please provide a createApp to create a web component.");
        return;
      }
      if (!p2) {
        console.warn("No getCurrentInstance provided. Please provide a getCurrentInstance to create a web component.");
        return;
      }
      const _2 = q$1({
        rootComponent: i2,
        plugins: t2,
        cssFrameworkStyles: s2,
        VueDefineCustomElement: o2,
        h: n2,
        createApp: r2,
        getCurrentInstance: p2,
        elementName: e2,
        disableRemoveStylesOnUnmount: d2,
        disableShadowDOM: a2
      });
      customElements.define(
        e2,
        _2
      );
    };
    const styles = `*,:after,:before,:root{--vf-primary:#07bf9b;--vf-primary-darker:#06ac8b;--vf-danger:#ef4444;--vf-danger-lighter:#fee2e2;--vf-success:#10b981;--vf-success-lighter:#d1fae5;--vf-gray-50:#f9fafb;--vf-gray-100:#f3f4f6;--vf-gray-200:#e5e7eb;--vf-gray-300:#d1d5db;--vf-gray-400:#9ca3af;--vf-gray-500:#6b7280;--vf-gray-600:#4b5563;--vf-gray-700:#374151;--vf-gray-800:#1f2937;--vf-gray-900:#111827;--vf-dark-50:#efefef;--vf-dark-100:#dcdcdc;--vf-dark-200:#bdbdbd;--vf-dark-300:#a0a0a0;--vf-dark-400:#848484;--vf-dark-500:#737373;--vf-dark-600:#393939;--vf-dark-700:#323232;--vf-dark-800:#262626;--vf-dark-900:#191919;--vf-ring-color:#07bf9b66;--vf-ring-width:2px;--vf-link-color:var(--vf-primary);--vf-link-decoration:inherit;--vf-font-size:1rem;--vf-font-size-sm:0.875rem;--vf-font-size-lg:1rem;--vf-font-size-small:0.875rem;--vf-font-size-small-sm:0.8125rem;--vf-font-size-small-lg:0.875rem;--vf-font-size-h1:2.125rem;--vf-font-size-h1-sm:2.125rem;--vf-font-size-h1-lg:2.125rem;--vf-font-size-h2:1.875rem;--vf-font-size-h2-sm:1.875rem;--vf-font-size-h2-lg:1.875rem;--vf-font-size-h3:1.5rem;--vf-font-size-h3-sm:1.5rem;--vf-font-size-h3-lg:1.5rem;--vf-font-size-h4:1.25rem;--vf-font-size-h4-sm:1.25rem;--vf-font-size-h4-lg:1.25rem;--vf-font-size-h1-mobile:1.5rem;--vf-font-size-h1-mobile-sm:1.5rem;--vf-font-size-h1-mobile-lg:1.5rem;--vf-font-size-h2-mobile:1.25rem;--vf-font-size-h2-mobile-sm:1.25rem;--vf-font-size-h2-mobile-lg:1.25rem;--vf-font-size-h3-mobile:1.125rem;--vf-font-size-h3-mobile-sm:1.125rem;--vf-font-size-h3-mobile-lg:1.125rem;--vf-font-size-h4-mobile:1rem;--vf-font-size-h4-mobile-sm:1rem;--vf-font-size-h4-mobile-lg:1rem;--vf-font-size-blockquote:1rem;--vf-font-size-blockquote-sm:0.875rem;--vf-font-size-blockquote-lg:1rem;--vf-line-height:1.5rem;--vf-line-height-sm:1.25rem;--vf-line-height-lg:1.5rem;--vf-line-height-small:1.25rem;--vf-line-height-small-sm:1.125rem;--vf-line-height-small-lg:1.25rem;--vf-line-height-headings:1.2;--vf-line-height-headings-sm:1.2;--vf-line-height-headings-lg:1.2;--vf-line-height-blockquote:1.5rem;--vf-line-height-blockquote-sm:1.25rem;--vf-line-height-blockquote-lg:1.5rem;--vf-letter-spacing:0;--vf-letter-spacing-sm:0;--vf-letter-spacing-lg:0;--vf-letter-spacing-small:0;--vf-letter-spacing-small-sm:0;--vf-letter-spacing-small-lg:0;--vf-letter-spacing-headings:0;--vf-letter-spacing-headings-sm:0;--vf-letter-spacing-headings-lg:0;--vf-letter-spacing-blockquote:0;--vf-letter-spacing-blockquote-sm:0;--vf-letter-spacing-blockquote-lg:0;--vf-gutter:1rem;--vf-gutter-sm:0.5rem;--vf-gutter-lg:1rem;--vf-min-height-input:2.375rem;--vf-min-height-input-sm:2.125rem;--vf-min-height-input-lg:2.875rem;--vf-py-input:0.375rem;--vf-py-input-sm:0.375rem;--vf-py-input-lg:0.625rem;--vf-px-input:0.75rem;--vf-px-input-sm:0.5rem;--vf-px-input-lg:0.875rem;--vf-py-btn:0.375rem;--vf-py-btn-sm:0.375rem;--vf-py-btn-lg:0.625rem;--vf-px-btn:0.875rem;--vf-px-btn-sm:0.75rem;--vf-px-btn-lg:1.25rem;--vf-py-btn-small:0.25rem;--vf-py-btn-small-sm:0.25rem;--vf-py-btn-small-lg:0.375rem;--vf-px-btn-small:0.625rem;--vf-px-btn-small-sm:0.625rem;--vf-px-btn-small-lg:0.75rem;--vf-py-group-tabs:var(--vf-py-input);--vf-py-group-tabs-sm:var(--vf-py-input-sm);--vf-py-group-tabs-lg:var(--vf-py-input-lg);--vf-px-group-tabs:var(--vf-px-input);--vf-px-group-tabs-sm:var(--vf-px-input-sm);--vf-px-group-tabs-lg:var(--vf-px-input-lg);--vf-py-group-blocks:0.75rem;--vf-py-group-blocks-sm:0.625rem;--vf-py-group-blocks-lg:0.875rem;--vf-px-group-blocks:1rem;--vf-px-group-blocks-sm:1rem;--vf-px-group-blocks-lg:1rem;--vf-py-tag:0;--vf-py-tag-sm:var(--vf-py-tag);--vf-py-tag-lg:var(--vf-py-tag);--vf-px-tag:0.4375rem;--vf-px-tag-sm:var(--vf-px-tag);--vf-px-tag-lg:var(--vf-px-tag);--vf-py-slider-tooltip:0.125rem;--vf-py-slider-tooltip-sm:0.0625rem;--vf-py-slider-tooltip-lg:0.1875rem;--vf-px-slider-tooltip:0.375rem;--vf-px-slider-tooltip-sm:0.3125rem;--vf-px-slider-tooltip-lg:0.5rem;--vf-py-blockquote:0.25rem;--vf-py-blockquote-sm:0.25rem;--vf-py-blockquote-lg:0.25rem;--vf-px-blockquote:0.75rem;--vf-px-blockquote-sm:0.75rem;--vf-px-blockquote-lg:0.75rem;--vf-py-hr:0.25rem;--vf-space-addon:0;--vf-space-addon-sm:var(--vf-space-addon);--vf-space-addon-lg:var(--vf-space-addon);--vf-space-checkbox:0.375rem;--vf-space-checkbox-sm:var(--vf-space-checkbox);--vf-space-checkbox-lg:var(--vf-space-checkbox);--vf-space-tags:0.1875rem;--vf-space-tags-sm:var(--vf-space-tags);--vf-space-tags-lg:var(--vf-space-tags);--vf-space-static-tag-1:1rem;--vf-space-static-tag-2:2rem;--vf-space-static-tag-3:3rem;--vf-floating-top:0rem;--vf-floating-top-sm:0rem;--vf-floating-top-lg:0.6875rem;--vf-bg-input:#fff;--vf-bg-input-hover:var(--vf-bg-input);--vf-bg-input-focus:var(--vf-bg-input);--vf-bg-input-danger:var(--vf-bg-input);--vf-bg-input-success:var(--vf-bg-input);--vf-bg-checkbox:var(--vf-bg-input);--vf-bg-checkbox-hover:var(--vf-bg-checkbox);--vf-bg-checkbox-focus:var(--vf-bg-checkbox);--vf-bg-checkbox-danger:var(--vf-bg-checkbox);--vf-bg-checkbox-success:var(--vf-bg-checkbox);--vf-bg-disabled:var(--vf-gray-200);--vf-bg-selected:var(--vf-gray-100);--vf-bg-passive:var(--vf-gray-300);--vf-bg-icon:var(--vf-gray-500);--vf-bg-danger:var(--vf-danger-lighter);--vf-bg-success:var(--vf-success-lighter);--vf-bg-addon:transparent;--vf-bg-tag:var(--vf-primary);--vf-bg-slider-handle:var(--vf-primary);--vf-bg-toggle-handle:#fff;--vf-bg-date-head:var(--vf-gray-100);--vf-bg-btn:var(--vf-primary);--vf-bg-btn-danger:var(--vf-danger);--vf-bg-btn-secondary:var(--vf-gray-200);--vf-color-on-primary:#fff;--vf-color-input:var(--vf-gray-800);--vf-color-input-hover:var(--vf-color-input);--vf-color-input-focus:var(--vf-color-input);--vf-color-input-danger:var(--vf-color-input);--vf-color-input-success:var(--vf-color-input);--vf-color-placeholder:var(--vf-gray-300);--vf-color-disabled:var(--vf-gray-400);--vf-color-passive:var(--vf-gray-700);--vf-color-muted:var(--vf-gray-500);--vf-color-floating:var(--vf-color-muted);--vf-color-floating-focus:var(--vf-color-floating);--vf-color-floating-success:var(--vf-color-floating);--vf-color-floating-danger:var(--vf-color-floating);--vf-color-danger:var(--vf-danger);--vf-color-success:var(--vf-success);--vf-color-addon:var(--vf-color-input);--vf-color-tag:var(--vf-color-on-primary);--vf-color-date-head:var(--vf-gray-700);--vf-color-btn:var(--vf-color-on-primary);--vf-color-btn-danger:#fff;--vf-color-btn-secondary:var(--vf-gray-700);--vf-border-color-input:var(--vf-gray-300);--vf-border-color-input-focus:var(--vf-primary);--vf-border-color-input-hover:var(--vf-border-color-input);--vf-border-color-input-danger:var(--vf-border-color-input);--vf-border-color-input-success:var(--vf-border-color-input);--vf-border-color-checkbox:var(--vf-border-color-input);--vf-border-color-checkbox-focus:var(--vf-primary);--vf-border-color-checkbox-hover:var(--vf-border-color-checkbox);--vf-border-color-checkbox-danger:var(--vf-border-color-checkbox);--vf-border-color-checkbox-success:var(--vf-border-color-checkbox);--vf-border-color-checked:var(--vf-primary);--vf-border-color-btn:var(--vf-primary);--vf-border-color-tag:var(--vf-primary);--vf-border-color-slider-tooltip:var(--vf-primary);--vf-border-color-passive:var(--vf-gray-300);--vf-border-color-btn-danger:var(--vf-danger);--vf-border-color-btn-secondary:var(--vf-gray-200);--vf-border-color-blockquote:var(--vf-gray-300);--vf-border-color-hr:var(--vf-gray-300);--vf-border-color-signature-hr:var(--vf-gray-300);--vf-border-width-input-t:1px;--vf-border-width-input-r:1px;--vf-border-width-input-b:1px;--vf-border-width-input-l:1px;--vf-border-width-radio-t:var(--vf-border-width-input-t);--vf-border-width-radio-r:var(--vf-border-width-input-r);--vf-border-width-radio-b:var(--vf-border-width-input-b);--vf-border-width-radio-l:var(--vf-border-width-input-l);--vf-border-width-checkbox-t:var(--vf-border-width-input-t);--vf-border-width-checkbox-r:var(--vf-border-width-input-r);--vf-border-width-checkbox-b:var(--vf-border-width-input-b);--vf-border-width-checkbox-l:var(--vf-border-width-input-l);--vf-border-width-dropdown:1px;--vf-border-width-btn:1px;--vf-border-width-toggle:0.125rem;--vf-border-width-tag:1px;--vf-border-width-blockquote:3px;--vf-shadow-input:0px 0px 0px 0px transparent;--vf-shadow-input-hover:0px 0px 0px 0px transparent;--vf-shadow-input-focus:0px 0px 0px 0px transparent;--vf-shadow-handles:0px 0px 0px 0px transparent;--vf-shadow-handles-hover:0px 0px 0px 0px transparent;--vf-shadow-handles-focus:0px 0px 0px 0px transparent;--vf-shadow-btn:0px 0px 0px 0px transparent;--vf-shadow-dropdown:0px 0px 0px 0px transparent;--vf-radius-input:0.25rem;--vf-radius-input-sm:var(--vf-radius-input);--vf-radius-input-lg:var(--vf-radius-input);--vf-radius-btn:var(--vf-radius-input);--vf-radius-btn-sm:var(--vf-radius-input-sm);--vf-radius-btn-lg:var(--vf-radius-input);--vf-radius-small:var(--vf-radius-input);--vf-radius-small-sm:var(--vf-radius-input-sm);--vf-radius-small-lg:var(--vf-radius-input);--vf-radius-large:var(--vf-radius-input);--vf-radius-large-sm:var(--vf-radius-input-sm);--vf-radius-large-lg:var(--vf-radius-input);--vf-radius-tag:var(--vf-radius-input);--vf-radius-tag-sm:var(--vf-radius-input-sm);--vf-radius-tag-lg:var(--vf-radius-input);--vf-radius-checkbox:var(--vf-radius-input);--vf-radius-checkbox-sm:var(--vf-radius-input-sm);--vf-radius-checkbox-lg:var(--vf-radius-input);--vf-radius-slider:var(--vf-radius-input);--vf-radius-slider-sm:var(--vf-radius-input-sm);--vf-radius-slider-lg:var(--vf-radius-input);--vf-radius-image:var(--vf-radius-input);--vf-radius-image-sm:var(--vf-radius-input-sm);--vf-radius-image-lg:var(--vf-radius-input);--vf-radius-gallery:var(--vf-radius-input);--vf-radius-gallery-sm:var(--vf-radius-input-sm);--vf-radius-gallery-lg:var(--vf-radius-input);--vf-checkbox-size:1rem;--vf-checkbox-size-sm:0.875rem;--vf-checkbox-size-lg:1rem;--vf-gallery-size:6rem;--vf-gallery-size-sm:5rem;--vf-gallery-size-lg:7rem;--vf-toggle-width:3rem;--vf-toggle-width-sm:2.75rem;--vf-toggle-width-lg:3rem;--vf-toggle-height:1.25rem;--vf-toggle-height-sm:1rem;--vf-toggle-height-lg:1.25rem;--vf-slider-height:0.375rem;--vf-slider-height-sm:0.3125rem;--vf-slider-height-lg:0.5rem;--vf-slider-height-vertical:20rem;--vf-slider-height-vertical-sm:var(--vf-slider-height-vertical);--vf-slider-height-vertical-lg:var(--vf-slider-height-vertical);--vf-slider-handle-size:1rem;--vf-slider-handle-size-sm:0.875rem;--vf-slider-handle-size-lg:1.25rem;--vf-slider-tooltip-distance:0.5rem;--vf-slider-tooltip-distance-sm:0.375rem;--vf-slider-tooltip-distance-lg:0.5rem;--vf-slider-tooltip-arrow-size:0.3125rem;--vf-slider-tooltip-arrow-size-sm:var(--vf-slider-tooltip-arrow-size);--vf-slider-tooltip-arrow-size-lg:var(--vf-slider-tooltip-arrow-size)}.dark,.dark *,.dark :after,.dark :before{--vf-bg-input:var(--vf-dark-800);--vf-bg-input-hover:var(--vf-bg-input);--vf-bg-input-focus:var(--vf-bg-input);--vf-bg-input-danger:var(--vf-bg-input);--vf-bg-input-success:var(--vf-bg-input);--vf-bg-checkbox:var(--vf-dark-700);--vf-bg-checkbox-hover:var(--vf-bg-checkbox);--vf-bg-checkbox-focus:var(--vf-bg-checkbox);--vf-bg-checkbox-danger:var(--vf-bg-checkbox);--vf-bg-checkbox-success:var(--vf-bg-checkbox);--vf-bg-disabled:var(--vf-dark-700);--vf-bg-selected:var(--vf-dark-700);--vf-bg-passive:var(--vf-dark-700);--vf-bg-icon:var(--vf-dark-400);--vf-bg-danger:var(--vf-danger-lighter);--vf-bg-success:var(--vf-success-lighter);--vf-bg-addon:transparent;--vf-bg-tag:var(--vf-primary);--vf-bg-slider-handle:var(--vf-primary);--vf-bg-toggle-handle:#fff;--vf-bg-date-head:var(--vf-dark-700);--vf-bg-btn:var(--vf-primary);--vf-bg-btn-danger:var(--vf-danger);--vf-bg-btn-secondary:var(--vf-dark-700);--vf-color-on-primary:#fff;--vf-color-input:var(--vf-dark-100);--vf-color-input-hover:var(--vf-color-input);--vf-color-input-focus:var(--vf-color-input);--vf-color-input-danger:var(--vf-color-input);--vf-color-input-success:var(--vf-color-input);--vf-color-placeholder:var(--vf-dark-500);--vf-color-disabled:var(--vf-dark-500);--vf-color-passive:var(--vf-dark-900);--vf-color-muted:var(--vf-dark-500);--vf-color-floating:var(--vf-color-muted);--vf-color-floating-focus:var(--vf-color-floating);--vf-color-floating-success:var(--vf-color-floating);--vf-color-floating-danger:var(--vf-color-floating);--vf-color-danger:var(--vf-danger);--vf-color-success:var(--vf-success);--vf-color-addon:initial;--vf-color-tag:var(--vf-color-on-primary);--vf-color-date-head:var(--vf-dark-200);--vf-color-btn:var(--vf-color-on-primary);--vf-color-btn-danger:#fff;--vf-color-btn-secondary:var(--vf-dark-300);--vf-border-color-input:var(--vf-dark-800);--vf-border-color-input-focus:var(--vf-primary);--vf-border-color-input-hover:var(--vf-border-color-input);--vf-border-color-input-danger:var(--vf-border-color-input);--vf-border-color-input-success:var(--vf-border-color-input);--vf-border-color-checkbox:var(--vf-border-color-input);--vf-border-color-checkbox-focus:var(--vf-primary);--vf-border-color-checkbox-hover:var(--vf-border-color-checkbox);--vf-border-color-checkbox-danger:var(--vf-border-color-checkbox);--vf-border-color-checkbox-success:var(--vf-border-color-checkbox);--vf-border-color-checked:var(--vf-primary);--vf-border-color-btn:var(--vf-primary);--vf-border-color-tag:var(--vf-primary);--vf-border-color-slider-tooltip:var(--vf-primary);--vf-border-color-passive:var(--vf-dark-700);--vf-border-color-btn-danger:var(--vf-danger);--vf-border-color-btn-secondary:var(--vf-dark-700);--vf-border-color-blockquote:var(--vf-dark-700);--vf-border-color-hr:var(--vf-dark-700);--vf-border-color-signature-hr:var(--vf-dark-500)}form *{box-sizing:border-box}form label{margin:0}form [multiple],form [type=checkbox],form [type=date],form [type=datetime-local],form [type=email],form [type=month],form [type=number],form [type=password],form [type=radio],form [type=search],form [type=tel],form [type=text],form [type=time],form [type=url],form [type=week],form select,form textarea{-webkit-appearance:none;-moz-appearance:none;appearance:none;font-size:var(--vf-font-size);letter-spacing:var(--vf-letter-spacing);line-height:var(--vf-line-height)}form [multiple]:focus,form [type=checkbox]:focus,form [type=date]:focus,form [type=datetime-local]:focus,form [type=email]:focus,form [type=month]:focus,form [type=number]:focus,form [type=password]:focus,form [type=radio]:focus,form [type=search]:focus,form [type=tel]:focus,form [type=text]:focus,form [type=time]:focus,form [type=url]:focus,form [type=week]:focus,form select:focus,form textarea:focus{outline:none}form [multiple]::-webkit-search-cancel-button,form [multiple]::-webkit-search-decoration,form [multiple]::-webkit-search-results-button,form [multiple]::-webkit-search-results-decoration,form [type=checkbox]::-webkit-search-cancel-button,form [type=checkbox]::-webkit-search-decoration,form [type=checkbox]::-webkit-search-results-button,form [type=checkbox]::-webkit-search-results-decoration,form [type=date]::-webkit-search-cancel-button,form [type=date]::-webkit-search-decoration,form [type=date]::-webkit-search-results-button,form [type=date]::-webkit-search-results-decoration,form [type=datetime-local]::-webkit-search-cancel-button,form [type=datetime-local]::-webkit-search-decoration,form [type=datetime-local]::-webkit-search-results-button,form [type=datetime-local]::-webkit-search-results-decoration,form [type=email]::-webkit-search-cancel-button,form [type=email]::-webkit-search-decoration,form [type=email]::-webkit-search-results-button,form [type=email]::-webkit-search-results-decoration,form [type=month]::-webkit-search-cancel-button,form [type=month]::-webkit-search-decoration,form [type=month]::-webkit-search-results-button,form [type=month]::-webkit-search-results-decoration,form [type=number]::-webkit-search-cancel-button,form [type=number]::-webkit-search-decoration,form [type=number]::-webkit-search-results-button,form [type=number]::-webkit-search-results-decoration,form [type=password]::-webkit-search-cancel-button,form [type=password]::-webkit-search-decoration,form [type=password]::-webkit-search-results-button,form [type=password]::-webkit-search-results-decoration,form [type=radio]::-webkit-search-cancel-button,form [type=radio]::-webkit-search-decoration,form [type=radio]::-webkit-search-results-button,form [type=radio]::-webkit-search-results-decoration,form [type=search]::-webkit-search-cancel-button,form [type=search]::-webkit-search-decoration,form [type=search]::-webkit-search-results-button,form [type=search]::-webkit-search-results-decoration,form [type=tel]::-webkit-search-cancel-button,form [type=tel]::-webkit-search-decoration,form [type=tel]::-webkit-search-results-button,form [type=tel]::-webkit-search-results-decoration,form [type=text]::-webkit-search-cancel-button,form [type=text]::-webkit-search-decoration,form [type=text]::-webkit-search-results-button,form [type=text]::-webkit-search-results-decoration,form [type=time]::-webkit-search-cancel-button,form [type=time]::-webkit-search-decoration,form [type=time]::-webkit-search-results-button,form [type=time]::-webkit-search-results-decoration,form [type=url]::-webkit-search-cancel-button,form [type=url]::-webkit-search-decoration,form [type=url]::-webkit-search-results-button,form [type=url]::-webkit-search-results-decoration,form [type=week]::-webkit-search-cancel-button,form [type=week]::-webkit-search-decoration,form [type=week]::-webkit-search-results-button,form [type=week]::-webkit-search-results-decoration,form select::-webkit-search-cancel-button,form select::-webkit-search-decoration,form select::-webkit-search-results-button,form select::-webkit-search-results-decoration,form textarea::-webkit-search-cancel-button,form textarea::-webkit-search-decoration,form textarea::-webkit-search-results-button,form textarea::-webkit-search-results-decoration{-webkit-appearance:none}form ::-moz-placeholder{color:var(--vf-color-placeholder)}form ::placeholder{color:var(--vf-color-placeholder)}.vf-row{display:grid;gap:var(--vf-gutter);grid-template-columns:repeat(12,minmax(0,1fr))}.vf-row.vf-row-sm{gap:var(--vf-gutter-sm)}.vf-row.vf-row-lg{gap:var(--vf-gutter-lg)}.vf-row.vf-row-embed{display:block}.vf-rowset{display:grid;row-gap:var(--vf-gutter)}.vf-rowset.vf-rowset-sm{row-gap:var(--vf-gutter-sm)}.vf-rowset.vf-rowset-lg{row-gap:var(--vf-gutter-lg)}.vf-col{grid-column:span 12/span 12}.vf-col-1{grid-column:span 1/span 12}.vf-col-2{grid-column:span 2/span 12}.vf-col-3{grid-column:span 3/span 12}.vf-col-4{grid-column:span 4/span 12}.vf-col-5{grid-column:span 5/span 12}.vf-col-6{grid-column:span 6/span 12}.vf-col-7{grid-column:span 7/span 12}.vf-col-8{grid-column:span 8/span 12}.vf-col-9{grid-column:span 9/span 12}.vf-col-10{grid-column:span 10/span 12}.vf-col-11{grid-column:span 11/span 12}.vf-col-12{grid-column:span 12/span 12}@media (min-width:640px){.vf-col-sm{grid-column:span 12/span 12}.vf-col-sm-1{grid-column:span 1/span 12}.vf-col-sm-2{grid-column:span 2/span 12}.vf-col-sm-3{grid-column:span 3/span 12}.vf-col-sm-4{grid-column:span 4/span 12}.vf-col-sm-5{grid-column:span 5/span 12}.vf-col-sm-6{grid-column:span 6/span 12}.vf-col-sm-7{grid-column:span 7/span 12}.vf-col-sm-8{grid-column:span 8/span 12}.vf-col-sm-9{grid-column:span 9/span 12}.vf-col-sm-10{grid-column:span 10/span 12}.vf-col-sm-11{grid-column:span 11/span 12}.vf-col-sm-12{grid-column:span 12/span 12}}@media (min-width:768px){.vf-col-md{grid-column:span 12/span 12}.vf-col-md-1{grid-column:span 1/span 12}.vf-col-md-2{grid-column:span 2/span 12}.vf-col-md-3{grid-column:span 3/span 12}.vf-col-md-4{grid-column:span 4/span 12}.vf-col-md-5{grid-column:span 5/span 12}.vf-col-md-6{grid-column:span 6/span 12}.vf-col-md-7{grid-column:span 7/span 12}.vf-col-md-8{grid-column:span 8/span 12}.vf-col-md-9{grid-column:span 9/span 12}.vf-col-md-10{grid-column:span 10/span 12}.vf-col-md-11{grid-column:span 11/span 12}.vf-col-md-12{grid-column:span 12/span 12}}@media (min-width:1024px){.vf-col-lg{grid-column:span 12/span 12}.vf-col-lg-1{grid-column:span 1/span 12}.vf-col-lg-2{grid-column:span 2/span 12}.vf-col-lg-3{grid-column:span 3/span 12}.vf-col-lg-4{grid-column:span 4/span 12}.vf-col-lg-5{grid-column:span 5/span 12}.vf-col-lg-6{grid-column:span 6/span 12}.vf-col-lg-7{grid-column:span 7/span 12}.vf-col-lg-8{grid-column:span 8/span 12}.vf-col-lg-9{grid-column:span 9/span 12}.vf-col-lg-10{grid-column:span 10/span 12}.vf-col-lg-11{grid-column:span 11/span 12}.vf-col-lg-12{grid-column:span 12/span 12}}@media (min-width:1280px){.vf-col-xl{grid-column:span 12/span 12}.vf-col-xl-1{grid-column:span 1/span 12}.vf-col-xl-2{grid-column:span 2/span 12}.vf-col-xl-3{grid-column:span 3/span 12}.vf-col-xl-4{grid-column:span 4/span 12}.vf-col-xl-5{grid-column:span 5/span 12}.vf-col-xl-6{grid-column:span 6/span 12}.vf-col-xl-7{grid-column:span 7/span 12}.vf-col-xl-8{grid-column:span 8/span 12}.vf-col-xl-9{grid-column:span 9/span 12}.vf-col-xl-10{grid-column:span 10/span 12}.vf-col-xl-11{grid-column:span 11/span 12}.vf-col-xl-12{grid-column:span 12/span 12}}@media (min-width:1536px){.vf-col-2xl{grid-column:span 12/span 12}.vf-col-2xl-1{grid-column:span 1/span 12}.vf-col-2xl-2{grid-column:span 2/span 12}.vf-col-2xl-3{grid-column:span 3/span 12}.vf-col-2xl-4{grid-column:span 4/span 12}.vf-col-2xl-5{grid-column:span 5/span 12}.vf-col-2xl-6{grid-column:span 6/span 12}.vf-col-2xl-7{grid-column:span 7/span 12}.vf-col-2xl-8{grid-column:span 8/span 12}.vf-col-2xl-9{grid-column:span 9/span 12}.vf-col-2xl-10{grid-column:span 10/span 12}.vf-col-2xl-11{grid-column:span 11/span 12}.vf-col-2xl-12{grid-column:span 12/span 12}}.vf-contains-link a{color:var(--vf-link-color);-webkit-text-decoration:var(--vf-link-decoration);text-decoration:var(--vf-link-decoration)}.vf-static-tag{font-size:var(--vf-font-size);letter-spacing:var(--vf-letter-spacing);line-height:var(--vf-line-height)}.vf-static-tag.vf-static-tag-sm{font-size:var(--vf-font-size-sm);letter-spacing:var(--vf-letter-spacing-sm);line-height:var(--vf-line-height-sm)}.vf-static-tag.vf-static-tag-lg{font-size:var(--vf-font-size-lg);letter-spacing:var(--vf-letter-spacing-lg);line-height:var(--vf-line-height-lg)}.vf-static-tag-left{text-align:left}.vf-static-tag-center{text-align:center}.vf-static-tag-right{text-align:right}.vf-static-tag-blockquote blockquote{border-left:var(--vf-border-width-blockquote) var(--vf-border-color-blockquote) solid;font-size:var(--vf-font-size-blockquote);letter-spacing:var(--vf-letter-spacing-blockquote);line-height:var(--vf-line-height-blockquote);margin:0;padding:var(--vf-py-blockquote) 0 var(--vf-py-blockquote) var(--vf-px-blockquote)}.vf-static-tag-blockquote.vf-static-tag-sm blockquote{font-size:var(--vf-font-size-blockquote-sm);letter-spacing:var(--vf-letter-spacing-blockquote-sm);line-height:var(--vf-line-height-blockquote-sm);padding:var(--vf-py-blockquote-sm) 0 var(--vf-py-blockquote-sm) var(--vf-px-blockquote-sm)}.vf-static-tag-blockquote.vf-static-tag-lg blockquote{font-size:var(--vf-font-size-blockquote-lg);letter-spacing:var(--vf-letter-spacing-blockquote-lg);line-height:var(--vf-line-height-blockquote-lg);padding:var(--vf-py-blockquote-lg) 0 var(--vf-py-blockquote-lg) var(--vf-px-blockquote-lg)}.vf-static-tag-a a{color:var(--vf-link-color);-webkit-text-decoration:var(--vf-link-decoration);text-decoration:var(--vf-link-decoration)}.vf-static-tag-hr{padding:var(--vf-py-hr) 0}.vf-static-tag-hr hr{border-color:var(--vf-border-color-hr)}.vf-static-tag-img img{display:inline-block}.vf-static-tag-top-1{margin-top:var(--vf-space-static-tag-1)}.vf-static-tag-top-2{margin-top:var(--vf-space-static-tag-2)}.vf-static-tag-top-3{margin-top:var(--vf-space-static-tag-3)}.vf-static-tag-bottom-1{margin-bottom:var(--vf-space-static-tag-1)}.vf-static-tag-bottom-2{margin-bottom:var(--vf-space-static-tag-2)}.vf-static-tag-bottom-3{margin-bottom:var(--vf-space-static-tag-3)}.vf-static-tag-h1 h1{font-weight:700;letter-spacing:var(--vf-letter-spacing-headings);line-height:var(--vf-line-height-headings);margin:0}.vf-static-tag-h1.vf-static-tag-sm h1{letter-spacing:var(--vf-letter-spacing-headings-sm);line-height:var(--vf-line-height-headings-sm);margin:0}.vf-static-tag-h1.vf-static-tag-lg h1{letter-spacing:var(--vf-letter-spacing-headings-lg);line-height:var(--vf-line-height-headings-lg);margin:0}.vf-static-tag-h2 h2{font-weight:700;letter-spacing:var(--vf-letter-spacing-headings);line-height:var(--vf-line-height-headings);margin:0}.vf-static-tag-h2.vf-static-tag-sm h2{letter-spacing:var(--vf-letter-spacing-headings-sm);line-height:var(--vf-line-height-headings-sm);margin:0}.vf-static-tag-h2.vf-static-tag-lg h2{letter-spacing:var(--vf-letter-spacing-headings-lg);line-height:var(--vf-line-height-headings-lg);margin:0}.vf-static-tag-h3 h3{font-weight:700;letter-spacing:var(--vf-letter-spacing-headings);line-height:var(--vf-line-height-headings);margin:0}.vf-static-tag-h3.vf-static-tag-sm h3{letter-spacing:var(--vf-letter-spacing-headings-sm);line-height:var(--vf-line-height-headings-sm);margin:0}.vf-static-tag-h3.vf-static-tag-lg h3{letter-spacing:var(--vf-letter-spacing-headings-lg);line-height:var(--vf-line-height-headings-lg);margin:0}.vf-static-tag-h4 h4{font-weight:700;letter-spacing:var(--vf-letter-spacing-headings);line-height:var(--vf-line-height-headings);margin:0}.vf-static-tag-h4.vf-static-tag-sm h4{letter-spacing:var(--vf-letter-spacing-headings-sm);line-height:var(--vf-line-height-headings-sm);margin:0}.vf-static-tag-h4.vf-static-tag-lg h4{letter-spacing:var(--vf-letter-spacing-headings-lg);line-height:var(--vf-line-height-headings-lg);margin:0}.vf-static-tag-h1 h1{font-size:var(--vf-font-size-h1-mobile)}.vf-static-tag-h1.vf-static-tag-sm h1{font-size:var(--vf-font-size-h1-mobile-sm)}.vf-static-tag-h1.vf-static-tag-lg h1{font-size:var(--vf-font-size-h1-mobile-lg)}.vf-static-tag-h2 h2{font-size:var(--vf-font-size-h2-mobile)}.vf-static-tag-h2.vf-static-tag-sm h2{font-size:var(--vf-font-size-h2-mobile-sm)}.vf-static-tag-h2.vf-static-tag-lg h2{font-size:var(--vf-font-size-h2-mobile-lg)}.vf-static-tag-h3 h3{font-size:var(--vf-font-size-h3-mobile)}.vf-static-tag-h3.vf-static-tag-sm h3{font-size:var(--vf-font-size-h3-mobile-sm)}.vf-static-tag-h3.vf-static-tag-lg h3{font-size:var(--vf-font-size-h3-mobile-lg)}.vf-static-tag-h4 h4{font-size:var(--vf-font-size-h4-mobile)}.vf-static-tag-h4.vf-static-tag-sm h4{font-size:var(--vf-font-size-h4-mobile-sm)}.vf-static-tag-h4.vf-static-tag-lg h4{font-size:var(--vf-font-size-h4-mobile-lg)}@media (min-width:768px){.vf-static-tag-h1 h1{font-size:var(--vf-font-size-h1)}.vf-static-tag-h1.vf-static-tag-sm h1{font-size:var(--vf-font-size-h1-sm)}.vf-static-tag-h1.vf-static-tag-lg h1{font-size:var(--vf-font-size-h1-lg)}.vf-static-tag-h2 h2{font-size:var(--vf-font-size-h2)}.vf-static-tag-h2.vf-static-tag-sm h2{font-size:var(--vf-font-size-h2-sm)}.vf-static-tag-h2.vf-static-tag-lg h2{font-size:var(--vf-font-size-h2-lg)}.vf-static-tag-h3 h3{font-size:var(--vf-font-size-h3)}.vf-static-tag-h3.vf-static-tag-sm h3{font-size:var(--vf-font-size-h3-sm)}.vf-static-tag-h3.vf-static-tag-lg h3{font-size:var(--vf-font-size-h3-lg)}.vf-static-tag-h4 h4{font-size:var(--vf-font-size-h4)}.vf-static-tag-h4.vf-static-tag-sm h4{font-size:var(--vf-font-size-h4-sm)}.vf-static-tag-h4.vf-static-tag-lg h4{font-size:var(--vf-font-size-h4-lg)}}.vf-input-group{align-items:stretch;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--vf-bg-input);border-color:var(--vf-border-color-input);border-radius:var(--vf-radius-input);border-style:solid;border-width:var(--vf-border-width-input-t) var(--vf-border-width-input-r) var(--vf-border-width-input-b) var(--vf-border-width-input-l);box-shadow:var(--vf-shadow-input);color:var(--vf-color-input);cursor:text;display:flex;font-family:inherit;margin:0;min-height:var(--vf-min-height-input);outline:0 solid var(--vf-ring-color);outline-offset:0;transition-duration:.2s;transition-property:box-shadow,color,background-color,border-color;transition-timing-function:cubic-bezier(.4,0,.2,1);width:100%}.vf-input-group .vf-input-field{background:transparent;border:0;border-radius:var(--vf-radius-input);color:var(--vf-color-input);flex:1 1 0%;font-family:inherit;font-size:var(--vf-font-size);letter-spacing:var(--vf-letter-spacing);line-height:var(--vf-line-height);min-height:100%;outline:0 solid transparent;outline-offset:0;padding:var(--vf-py-input) var(--vf-px-input);transition:color .2s ease-in-out}.vf-input-group .vf-input-field:-webkit-autofill,.vf-input-group .vf-input-field:-webkit-autofill:active,.vf-input-group .vf-input-field:-webkit-autofill:focus,.vf-input-group .vf-input-field:-webkit-autofill:hover{-webkit-box-shadow:0 0 0 99px var(--vf-bg-input) inset!important}.vf-input-group .vf-input-field:-webkit-autofill{-webkit-text-fill-color:var(--vf-color-input)!important}.vf-input-group textarea.vf-input-field{border-radius:var(--vf-radius-large)}.vf-input-group.vf-input-group-disabled{background-color:var(--vf-bg-disabled);color:var(--vf-color-disabled);pointer-events:none}.vf-input-group.vf-input-group-disabled .vf-input-field{color:var(--vf-color-disabled)}.vf-input-group.vf-input-group-success{background-color:var(--vf-bg-input-success);border-color:var(--vf-border-color-input-success);color:var(--vf-color-input-success)}.vf-input-group.vf-input-group-success .vf-input-field{color:var(--vf-color-input-success)}.vf-input-group.vf-input-group-success .vf-input-field:-webkit-autofill,.vf-input-group.vf-input-group-success .vf-input-field:-webkit-autofill:active,.vf-input-group.vf-input-group-success .vf-input-field:-webkit-autofill:focus,.vf-input-group.vf-input-group-success .vf-input-field:-webkit-autofill:hover{-webkit-box-shadow:0 0 0 99px var(--vf-bg-input-success) inset!important}.vf-input-group.vf-input-group-success .vf-input-field:-webkit-autofill{-webkit-text-fill-color:var(--vf-color-input-success)!important}.vf-input-group.vf-input-group-danger{background-color:var(--vf-bg-input-danger);border-color:var(--vf-border-color-input-danger);color:var(--vf-color-input-danger)}.vf-input-group.vf-input-group-danger .vf-input-field{color:var(--vf-color-input-danger)}.vf-input-group.vf-input-group-danger .vf-input-field:-webkit-autofill,.vf-input-group.vf-input-group-danger .vf-input-field:-webkit-autofill:active,.vf-input-group.vf-input-group-danger .vf-input-field:-webkit-autofill:focus,.vf-input-group.vf-input-group-danger .vf-input-field:-webkit-autofill:hover{-webkit-box-shadow:0 0 0 99px var(--vf-bg-input-danger) inset!important}.vf-input-group.vf-input-group-danger .vf-input-field:-webkit-autofill{-webkit-text-fill-color:var(--vf-color-input-danger)!important}.vf-input-group.vf-input-group-focused{box-shadow:var(--vf-shadow-input-focus);outline:var(--vf-ring-width) solid var(--vf-ring-color)}.vf-input-group.vf-input-group-focused:not(.vf-input-group-success):not(.vf-input-group-danger){background-color:var(--vf-bg-input-focus);border-color:var(--vf-border-color-input-focus);color:var(--vf-color-input-focus)}.vf-input-group.vf-input-group-focused:not(.vf-input-group-success):not(.vf-input-group-danger) .vf-input-field{color:var(--vf-color-input-focus)}.vf-input-group.vf-input-group-focused:not(.vf-input-group-success):not(.vf-input-group-danger) .vf-input-field:-webkit-autofill,.vf-input-group.vf-input-group-focused:not(.vf-input-group-success):not(.vf-input-group-danger) .vf-input-field:-webkit-autofill:active,.vf-input-group.vf-input-group-focused:not(.vf-input-group-success):not(.vf-input-group-danger) .vf-input-field:-webkit-autofill:focus,.vf-input-group.vf-input-group-focused:not(.vf-input-group-success):not(.vf-input-group-danger) .vf-input-field:-webkit-autofill:hover{-webkit-box-shadow:0 0 0 99px var(--vf-bg-input-focus) inset!important}.vf-input-group.vf-input-group-focused:not(.vf-input-group-success):not(.vf-input-group-danger) .vf-input-field:-webkit-autofill{-webkit-text-fill-color:var(--vf-color-input-focus)!important}.vf-input-group:hover{box-shadow:var(--vf-shadow-input-hover)}.vf-input-group:hover:not(.vf-input-group-success):not(.vf-input-group-danger):not(.vf-input-group-focused){background-color:var(--vf-bg-input-hover);border-color:var(--vf-border-color-input-hover);color:var(--vf-color-input-hover)}.vf-input-group:hover:not(.vf-input-group-success):not(.vf-input-group-danger):not(.vf-input-group-focused) .vf-input-field{color:var(--vf-color-input-hover)}.vf-input-group.vf-input-group-sm{border-radius:var(--vf-radius-input-sm);min-height:var(--vf-min-height-input-sm)}.vf-input-group.vf-input-group-sm .vf-input-field{border-radius:var(--vf-radius-input-sm);font-size:var(--vf-font-size-sm);letter-spacing:var(--vf-letter-spacing-sm);line-height:var(--vf-line-height-sm);padding:var(--vf-py-input-sm) var(--vf-px-input-sm)}.vf-input-group.vf-input-group-sm.vf-input-group-textarea{border-radius:var(--vf-radius-large-sm)}.vf-input-group.vf-input-group-lg{border-radius:var(--vf-radius-input-lg);min-height:var(--vf-min-height-input-lg)}.vf-input-group.vf-input-group-lg .vf-input-field{border-radius:var(--vf-radius-input-lg);font-size:var(--vf-font-size-lg);letter-spacing:var(--vf-letter-spacing-lg);line-height:var(--vf-line-height-lg);padding:var(--vf-py-input-lg) var(--vf-px-input-lg)}.vf-input-group.vf-input-group-lg.vf-input-group-textarea{border-radius:var(--vf-radius-large-lg)}.vf-input-group .vf-floating-label{left:calc(var(--vf-px-input) - var(--vf-border-width-input-l))}.vf-input-group .vf-floating-label.vf-floating-label-lg{left:calc(var(--vf-px-input-lg) - var(--vf-border-width-input-l))}.vf-input-group .vf-floating-label.vf-floating-label-sm{left:calc(var(--vf-px-input-sm) - var(--vf-border-width-input-l))}.vf-input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--vf-bg-input);border-color:var(--vf-border-color-input);border-radius:var(--vf-radius-input);border-style:solid;border-width:var(--vf-border-width-input-t) var(--vf-border-width-input-r) var(--vf-border-width-input-b) var(--vf-border-width-input-l);box-shadow:var(--vf-shadow-input);color:var(--vf-color-input);font-family:inherit;font-size:var(--vf-font-size);letter-spacing:var(--vf-letter-spacing);line-height:var(--vf-line-height);margin:0;min-height:var(--vf-min-height-input);outline:0 solid var(--vf-ring-color);outline-offset:0;padding:var(--vf-py-input) var(--vf-px-input);transition-duration:.2s;transition-property:box-shadow,color,background-color,border-color;transition-timing-function:cubic-bezier(.4,0,.2,1);width:100%}.vf-input[disabled]{background-color:var(--vf-bg-disabled);color:var(--vf-color-disabled);pointer-events:none}.vf-input.vf-input-success{background-color:var(--vf-bg-input-success);border-color:var(--vf-border-color-input-success);color:var(--vf-color-input-success)}.vf-input.vf-input-danger{background-color:var(--vf-bg-input-danger);border-color:var(--vf-border-color-input-danger);color:var(--vf-color-input-danger)}.vf-input:hover{box-shadow:var(--vf-shadow-input-hover)}.vf-input:hover:not(.vf-input-success):not(.vf-input-danger){background-color:var(--vf-bg-input-hover);border-color:var(--vf-border-color-input-hover);color:var(--vf-color-input-hover)}.vf-input:focus{box-shadow:var(--vf-shadow-input-focus);outline:var(--vf-ring-width) solid var(--vf-ring-color)}.vf-input:focus:not(.vf-input-success):not(.vf-input-danger){background-color:var(--vf-bg-input-focus);border-color:var(--vf-border-color-input-focus);color:var(--vf-color-input-focus)}.vf-input.vf-input-sm{border-radius:var(--vf-radius-input-sm);font-size:var(--vf-font-size-sm);letter-spacing:var(--vf-letter-spacing-sm);line-height:var(--vf-line-height-sm);min-height:var(--vf-min-height-input-sm);padding:var(--vf-py-input-sm) var(--vf-px-input-sm)}.vf-input.vf-input-lg{border-radius:var(--vf-radius-input-lg);font-size:var(--vf-font-size-lg);letter-spacing:var(--vf-letter-spacing-lg);line-height:var(--vf-line-height-lg);min-height:var(--vf-min-height-input-lg);padding:var(--vf-py-input-lg) var(--vf-px-input-lg)}.vf-floating-wrapper~.vf-input,.vf-floating-wrapper~div .vf-input,.vf-input-group.vf-input-group .vf-floating-wrapper~.vf-input-field,.vf-input-group.vf-input-group .vf-floating-wrapper~div .vf-input-field{padding-bottom:calc(var(--vf-py-input) - var(--vf-floating-top)/2);padding-top:calc(var(--vf-py-input) + var(--vf-floating-top)/2)}.vf-floating-wrapper~.vf-input-sm,.vf-floating-wrapper~div .vf-input-sm,.vf-input-group.vf-input-group-sm .vf-floating-wrapper~.vf-input-field,.vf-input-group.vf-input-group-sm .vf-floating-wrapper~div .vf-input-field{padding-bottom:calc(var(--vf-py-input-sm) - var(--vf-floating-top-sm)/2);padding-top:calc(var(--vf-py-input-sm) + var(--vf-floating-top-sm)/2)}.vf-floating-wrapper~.vf-input-lg,.vf-floating-wrapper~div .vf-input-lg,.vf-input-group.vf-input-group-lg .vf-floating-wrapper~.vf-input-field,.vf-input-group.vf-input-group-lg .vf-floating-wrapper~div .vf-input-field{padding-bottom:calc(var(--vf-py-input-lg) - var(--vf-floating-top-lg)/2);padding-top:calc(var(--vf-py-input-lg) + var(--vf-floating-top-lg)/2)}.vf-checkbox-container,.vf-checkbox-wrapper{align-items:flex-start;display:flex;width:100%}.vf-checkbox{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--vf-bg-checkbox);border-color:var(--vf-border-color-checkbox);border-radius:var(--vf-radius-checkbox);border-style:solid;border-width:var(--vf-border-width-checkbox-t) var(--vf-border-width-checkbox-r) var(--vf-border-width-checkbox-b) var(--vf-border-width-checkbox-l);box-shadow:var(--vf-shadow-handles);cursor:pointer;flex-shrink:0;height:var(--vf-checkbox-size);margin:0;margin-right:var(--vf-space-checkbox);margin-top:calc((var(--vf-line-height) - var(--vf-checkbox-size))/2);outline:0 solid var(--vf-ring-color);outline-offset:0;transition-duration:.2s;transition-property:box-shadow,color,background-color,border-color;transition-timing-function:cubic-bezier(.4,0,.2,1);width:var(--vf-checkbox-size)}.vf-checkbox[disabled]{opacity:.5;pointer-events:none}.vf-checkbox.vf-checkbox-danger:not(:checked){background-color:var(--vf-bg-checkbox-danger);border-color:var(--vf-border-color-checkbox-danger)}.vf-checkbox:hover:not([disabled]){box-shadow:var(--vf-shadow-handles-hover)}.vf-checkbox:hover:not([disabled]):not(.vf-checkbox-danger):not(:checked):not(:focus){background-color:var(--vf-bg-checkbox-hover);border-color:var(--vf-border-color-checkbox-hover)}.vf-checkbox:focus{box-shadow:var(--vf-shadow-handles-focus);outline:var(--vf-ring-width) solid var(--vf-ring-color)}.vf-checkbox:focus:not(.vf-checkbox-danger):not(:checked){background-color:var(--vf-bg-checkbox-focus);border-color:var(--vf-border-color-checkbox-focus)}.vf-checkbox:checked{background-color:var(--vf-primary);border-color:var(--vf-border-color-checked)}.vf-checkbox:checked:after{background-color:var(--vf-color-on-primary);content:" ";display:block;height:calc(100% + var(--vf-border-width-checkbox-t) + var(--vf-border-width-checkbox-b));left:calc(var(--vf-border-width-checkbox-l)*-1);-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 16 16' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M12.207 4.793a1 1 0 0 1 0 1.414l-5 5a1 1 0 0 1-1.414 0l-2-2a1 1 0 0 1 1.414-1.414L6.5 9.086l4.293-4.293a1 1 0 0 1 1.414 0z'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 16 16' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M12.207 4.793a1 1 0 0 1 0 1.414l-5 5a1 1 0 0 1-1.414 0l-2-2a1 1 0 0 1 1.414-1.414L6.5 9.086l4.293-4.293a1 1 0 0 1 1.414 0z'/%3E%3C/svg%3E");-webkit-mask-position:center center;mask-position:center center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:contain;mask-size:contain;position:relative;top:calc(var(--vf-border-width-checkbox-t)*-1);width:calc(100% + var(--vf-border-width-checkbox-l) + var(--vf-border-width-checkbox-r))}.vf-checkbox.vf-checkbox-sm{border-radius:var(--vf-radius-checkbox-sm);height:var(--vf-checkbox-size-sm);margin-right:var(--vf-space-checkbox-sm);margin-top:calc((var(--vf-line-height-sm) - var(--vf-checkbox-size-sm))/2);width:var(--vf-checkbox-size-sm)}.vf-checkbox.vf-checkbox-lg{border-radius:var(--vf-radius-checkbox-lg);height:var(--vf-checkbox-size-lg);margin-right:var(--vf-space-checkbox-lg);margin-top:calc((var(--vf-line-height-lg) - var(--vf-checkbox-size-lg))/2);width:var(--vf-checkbox-size-lg)}.vf-checkbox-text{cursor:pointer}.vf-radio-container,.vf-radio-wrapper{align-items:flex-start;display:flex;width:100%}.vf-radio{align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--vf-bg-checkbox);border-color:var(--vf-border-color-checkbox);border-radius:999px;border-style:solid;border-width:var(--vf-border-width-radio-t) var(--vf-border-width-radio-r) var(--vf-border-width-radio-b) var(--vf-border-width-radio-l);box-shadow:var(--vf-shadow-handles);cursor:pointer;display:flex;flex-shrink:0;height:var(--vf-checkbox-size);justify-content:center;margin:0;margin-right:var(--vf-space-checkbox);margin-top:calc((var(--vf-line-height) - var(--vf-checkbox-size))/2);outline:0 solid var(--vf-ring-color);outline-offset:0;transition-duration:.2s;transition-property:box-shadow,color,background-color,border-color;transition-timing-function:cubic-bezier(.4,0,.2,1);width:var(--vf-checkbox-size)}.vf-radio[disabled]{opacity:.5;pointer-events:none}.vf-radio.vf-radio-danger:not(:checked){background-color:var(--vf-bg-checkbox-danger);border-color:var(--vf-border-color-checkbox-danger)}.vf-radio:hover:not([disabled]){box-shadow:var(--vf-shadow-handles-hover)}.vf-radio:hover:not([disabled]):not(.vf-radio-danger):not(:checked):not(:focus){background-color:var(--vf-bg-checkbox-hover);border-color:var(--vf-border-color-checkbox-hover)}.vf-radio:focus{box-shadow:var(--vf-shadow-handles-focus);outline:var(--vf-ring-width) solid var(--vf-ring-color)}.vf-radio:focus:not(.vf-radio-danger):not(:checked){background-color:var(--vf-bg-checkbox-focus);border-color:var(--vf-border-color-checkbox-focus)}.vf-radio:checked{background-color:var(--vf-primary);border-color:var(--vf-border-color-checked)}.vf-radio:checked:after{background-color:var(--vf-color-on-primary);content:"";display:block;height:100%;-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 16 16' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='8' cy='8' r='3.5'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 16 16' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='8' cy='8' r='3.5'/%3E%3C/svg%3E");-webkit-mask-position:center center;mask-position:center center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:contain;mask-size:contain;width:100%}.vf-radio.vf-radio-sm{height:var(--vf-checkbox-size-sm);margin-right:var(--vf-space-checkbox-sm);margin-top:calc((var(--vf-line-height-sm) - var(--vf-checkbox-size-sm))/2);width:var(--vf-checkbox-size-sm)}.vf-radio.vf-radio-lg{height:var(--vf-checkbox-size-lg);margin-right:var(--vf-space-checkbox-lg);margin-top:calc((var(--vf-line-height-lg) - var(--vf-checkbox-size-lg))/2);width:var(--vf-checkbox-size-lg)}.vf-btn,.vf-radio-text{cursor:pointer}.vf-btn{align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:0;border-radius:var(--vf-radius-btn);border-style:solid;border-width:var(--vf-border-width-btn);box-shadow:var(--vf-shadow-btn);color:inherit;display:inline-flex;font-size:inherit;font-size:var(--vf-font-size);justify-content:center;letter-spacing:var(--vf-letter-spacing);line-height:inherit;line-height:var(--vf-line-height);outline:0 solid var(--vf-ring-color);outline-offset:0;padding:var(--vf-py-btn) var(--vf-px-btn);text-decoration:none;transition:.15s}.vf-btn:focus{box-shadow:0 0 0 var(--vf-ring-width) var(--vf-ring-color)}.vf-btn:hover:not(:disabled):not(.vf-btn-loading){text-decoration:none;transform:scale(1.05)}.vf-btn.vf-btn-sm{border-radius:var(--vf-radius-btn-sm);font-size:var(--vf-font-size-sm);letter-spacing:var(--vf-letter-spacing-sm);line-height:var(--vf-line-height-sm);padding:var(--vf-py-btn-sm) var(--vf-px-btn-sm)}.vf-btn.vf-btn-lg{border-radius:var(--vf-radius-btn-lg);font-size:var(--vf-font-size-lg);letter-spacing:var(--vf-letter-spacing-lg);line-height:var(--vf-line-height-lg);padding:var(--vf-py-btn-lg) var(--vf-px-btn-lg)}.vf-btn.vf-btn-small{border-radius:var(--vf-radius-small);font-size:var(--vf-font-size-small);letter-spacing:var(--vf-letter-spacing-small);line-height:var(--vf-line-height-small);padding:var(--vf-py-btn-small) var(--vf-px-btn-small)}.vf-btn.vf-btn-small.vf-btn-small-sm{border-radius:var(--vf-radius-small-sm);padding:var(--vf-py-btn-small-sm) var(--vf-px-btn-small-sm)}.vf-btn.vf-btn-small.vf-btn-small-lg{border-radius:var(--vf-radius-small-lg);padding:var(--vf-py-btn-small-lg) var(--vf-px-btn-small-lg)}.vf-btn.vf-btn-full{width:100%}.vf-btn.vf-btn-center{align-items:center;display:flex;justify-content:center;margin-left:auto;margin-right:auto}.vf-btn.vf-btn-disabled,.vf-btn[disabled]{cursor:not-allowed;opacity:.6}.vf-btn.vf-btn-primary{background-color:var(--vf-primary);border-color:var(--vf-border-color-btn);color:var(--vf-color-on-primary)}.vf-btn.vf-btn-secondary{background-color:var(--vf-bg-btn-secondary);border-color:var(--vf-border-color-btn-secondary);color:var(--vf-color-btn-secondary)}.vf-btn.vf-btn-danger{background-color:var(--vf-bg-btn-danger);border-color:var(--vf-border-color-btn-danger);color:var(--vf-color-btn-danger)}.vf-btn.vf-btn-loading{color:transparent!important;cursor:not-allowed;opacity:.6;pointer-events:none;position:relative}.vf-btn.vf-btn-loading:after{animation:button-spinner 1s linear infinite;content:"";display:inline-block;height:1rem;left:50%;margin-left:-.5rem;margin-top:-.5rem;-webkit-mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 512 512' fill='%23fff' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m456.433 371.72-27.79-16.045c-7.192-4.152-10.052-13.136-6.487-20.636 25.82-54.328 23.566-118.602-6.768-171.03-30.265-52.529-84.802-86.621-144.76-91.424C262.35 71.922 256 64.953 256 56.649V24.56c0-9.31 7.916-16.609 17.204-15.96 81.795 5.717 156.412 51.902 197.611 123.408 41.301 71.385 43.99 159.096 8.042 232.792-4.082 8.369-14.361 11.575-22.424 6.92z'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 512 512' fill='%23fff' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m456.433 371.72-27.79-16.045c-7.192-4.152-10.052-13.136-6.487-20.636 25.82-54.328 23.566-118.602-6.768-171.03-30.265-52.529-84.802-86.621-144.76-91.424C262.35 71.922 256 64.953 256 56.649V24.56c0-9.31 7.916-16.609 17.204-15.96 81.795 5.717 156.412 51.902 197.611 123.408 41.301 71.385 43.99 159.096 8.042 232.792-4.082 8.369-14.361 11.575-22.424 6.92z'/%3E%3C/svg%3E");-webkit-mask-position:center center;mask-position:center center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:contain;mask-size:contain;position:absolute;top:50%;width:1rem}.vf-btn.vf-btn-loading.vf-btn-loading-primary:after{background-color:var(--vf-color-on-primary)}.vf-btn.vf-btn-loading.vf-btn-loading-secondary:after{background-color:var(--vf-color-btn-secondary)}.vf-btn.vf-btn-loading.vf-btn-loading-danger:after{background-color:var(--vf-color-btn-danger)}body:not([dir=rtl]) .vf-btn.vf-btn-right{float:right}body:not([dir=rtl]) .vf-checkbox-wrapper-right,body:not([dir=rtl]) .vf-radio-wrapper-right{justify-content:flex-end}body:not([dir=rtl]) .vf-checkbox-right{margin-left:var(--vf-space-checkbox);margin-right:0}body:not([dir=rtl]) .vf-checkbox-right.vf-checkbox-sm{margin-left:var(--vf-space-checkbox-sm);margin-right:0}body:not([dir=rtl]) .vf-checkbox-right.vf-checkbox-lg{margin-left:var(--vf-space-checkbox-lg);margin-right:0}body:not([dir=rtl]) .vf-checkbox-right:checked:after{left:0;right:calc(var(--vf-border-width-checkbox-l)*-1)}body:not([dir=rtl]) .vf-radio-right{margin-left:var(--vf-space-checkbox);margin-right:0}body:not([dir=rtl]) .vf-radio-right.vf-radio-sm{margin-left:var(--vf-space-checkbox-sm);margin-right:0}body:not([dir=rtl]) .vf-radio-right.vf-radio-lg{margin-left:var(--vf-space-checkbox-lg);margin-right:0}body:not([dir=rtl]) .vf-checkbox-text-right,body:not([dir=rtl]) .vf-radio-text-right{order:-1}body[dir=rtl] .vf-btn.vf-btn-left{float:left}body[dir=rtl] .vf-checkbox-wrapper-left,body[dir=rtl] .vf-radio-wrapper-left{justify-content:flex-end}body[dir=rtl] .vf-checkbox{margin-left:var(--vf-space-checkbox);margin-right:0}body[dir=rtl] .vf-checkbox.vf-checkbox-sm{margin-left:var(--vf-space-checkbox-sm);margin-right:0}body[dir=rtl] .vf-checkbox.vf-checkbox-lg{margin-left:var(--vf-space-checkbox-lg);margin-right:0}body[dir=rtl] .vf-checkbox:checked:after{left:0;right:calc(var(--vf-border-width-checkbox-l)*-1)}body[dir=rtl] .vf-checkbox-left{margin-left:0;margin-right:var(--vf-space-checkbox)}body[dir=rtl] .vf-checkbox-left.vf-checkbox-sm{margin-left:0;margin-right:var(--vf-space-checkbox-sm)}body[dir=rtl] .vf-checkbox-left.vf-checkbox-lg{margin-left:0;margin-right:var(--vf-space-checkbox-lg)}body[dir=rtl] .vf-checkbox-left:checked:after{left:0;right:calc(var(--vf-border-width-checkbox-l)*-1)}body[dir=rtl] .vf-radio{margin-left:var(--vf-space-checkbox);margin-right:0}body[dir=rtl] .vf-radio.vf-radio-sm{margin-left:var(--vf-space-checkbox-sm);margin-right:0}body[dir=rtl] .vf-radio.vf-radio-lg{margin-left:var(--vf-space-checkbox-lg);margin-right:0}body[dir=rtl] .vf-radio-left{margin-left:0;margin-right:var(--vf-space-checkbox)}body[dir=rtl] .vf-radio-left.vf-radio-sm{margin-left:0;margin-right:var(--vf-space-checkbox-sm)}body[dir=rtl] .vf-radio-left.vf-radio-lg{margin-left:0;margin-right:var(--vf-space-checkbox-lg)}body[dir=rtl] .vf-checkbox-text-left,body[dir=rtl] .vf-radio-text-left{order:-1}@keyframes button-spinner{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.vf-assistive-text{clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;position:absolute;width:1px}.vf-label{align-items:flex-start;display:flex;font-size:var(--vf-font-size);letter-spacing:var(--vf-letter-spacing);line-height:var(--vf-line-height);margin-bottom:0}.vf-label-sm{font-size:var(--vf-font-size-sm);letter-spacing:var(--vf-letter-spacing-sm);line-height:var(--vf-line-height-sm)}.vf-label-lg{font-size:var(--vf-font-size-lg);letter-spacing:var(--vf-letter-spacing-lg);line-height:var(--vf-line-height-lg)}.vf-vertical-label{padding-bottom:calc(var(--vf-gutter)/3);padding-right:0;padding-top:0}.vf-vertical-label-sm{padding-bottom:calc(var(--vf-gutter-sm)/3);padding-right:0;padding-top:0}.vf-vertical-label-lg{padding-bottom:calc(var(--vf-gutter-lg)/3);padding-right:0;padding-top:0}.vf-text-type .vf-horizontal-label{padding-bottom:0;padding-right:var(--vf-gutter);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input))}.vf-text-type .vf-horizontal-label-sm{padding-bottom:0;padding-right:var(--vf-gutter-sm);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-sm))}.vf-text-type .vf-horizontal-label-lg{padding-bottom:0;padding-right:var(--vf-gutter-lg);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-lg))}.vf-text-type .vf-xs\\:vf-vertical-label,:not(.vf-text-type) .vf-xs\\:vf-vertical-label{padding-bottom:calc(var(--vf-gutter)/3);padding-right:0;padding-top:0}.vf-text-type .vf-xs\\:vf-vertical-label-sm,:not(.vf-text-type) .vf-xs\\:vf-vertical-label-sm{padding-bottom:calc(var(--vf-gutter-sm)/3);padding-right:0;padding-top:0}.vf-text-type .vf-xs\\:vf-vertical-label-lg,:not(.vf-text-type) .vf-xs\\:vf-vertical-label-lg{padding-bottom:calc(var(--vf-gutter-lg)/3);padding-right:0;padding-top:0}.vf-xs\\:vf-horizontal-label,.vf-xs\\:vf-horizontal-label-lg,.vf-xs\\:vf-horizontal-label-sm{padding-bottom:0}.vf-text-type .vf-xs\\:vf-horizontal-label{padding-right:var(--vf-gutter);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input))}.vf-text-type .vf-xs\\:vf-horizontal-label-sm{padding-right:var(--vf-gutter-sm);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-sm))}.vf-text-type .vf-xs\\:vf-horizontal-label-lg{padding-right:var(--vf-gutter-lg);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-lg))}@media (min-width:640px){.vf-text-type .vf-sm\\:vf-vertical-label,:not(.vf-text-type) .vf-sm\\:vf-vertical-label{padding-bottom:calc(var(--vf-gutter)/3);padding-right:0;padding-top:0}.vf-text-type .vf-sm\\:vf-vertical-label-sm,:not(.vf-text-type) .vf-sm\\:vf-vertical-label-sm{padding-bottom:calc(var(--vf-gutter-sm)/3);padding-right:0;padding-top:0}.vf-text-type .vf-sm\\:vf-vertical-label-lg,:not(.vf-text-type) .vf-sm\\:vf-vertical-label-lg{padding-bottom:calc(var(--vf-gutter-lg)/3);padding-right:0;padding-top:0}.vf-sm\\:vf-horizontal-label,.vf-sm\\:vf-horizontal-label-lg,.vf-sm\\:vf-horizontal-label-sm{padding-bottom:0}.vf-text-type .vf-sm\\:vf-horizontal-label{padding-right:var(--vf-gutter);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input))}.vf-text-type .vf-sm\\:vf-horizontal-label-sm{padding-right:var(--vf-gutter-sm);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-sm))}.vf-text-type .vf-sm\\:vf-horizontal-label-lg{padding-right:var(--vf-gutter-lg);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-lg))}}@media (min-width:768px){.vf-text-type .vf-md\\:vf-vertical-label,:not(.vf-text-type) .vf-md\\:vf-vertical-label{padding-bottom:calc(var(--vf-gutter)/3);padding-right:0;padding-top:0}.vf-text-type .vf-md\\:vf-vertical-label-sm,:not(.vf-text-type) .vf-md\\:vf-vertical-label-sm{padding-bottom:calc(var(--vf-gutter-sm)/3);padding-right:0;padding-top:0}.vf-text-type .vf-md\\:vf-vertical-label-lg,:not(.vf-text-type) .vf-md\\:vf-vertical-label-lg{padding-bottom:calc(var(--vf-gutter-lg)/3);padding-right:0;padding-top:0}.vf-md\\:vf-horizontal-label,.vf-md\\:vf-horizontal-label-lg,.vf-md\\:vf-horizontal-label-sm{padding-bottom:0}.vf-text-type .vf-md\\:vf-horizontal-label{padding-right:var(--vf-gutter);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input))}.vf-text-type .vf-md\\:vf-horizontal-label-sm{padding-right:var(--vf-gutter-sm);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-sm))}.vf-text-type .vf-md\\:vf-horizontal-label-lg{padding-right:var(--vf-gutter-lg);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-lg))}}@media (min-width:1024px){.vf-text-type .vf-lg\\:vf-vertical-label,:not(.vf-text-type) .vf-lg\\:vf-vertical-label{padding-bottom:calc(var(--vf-gutter)/3);padding-right:0;padding-top:0}.vf-text-type .vf-lg\\:vf-vertical-label-sm,:not(.vf-text-type) .vf-lg\\:vf-vertical-label-sm{padding-bottom:calc(var(--vf-gutter-sm)/3);padding-right:0;padding-top:0}.vf-text-type .vf-lg\\:vf-vertical-label-lg,:not(.vf-text-type) .vf-lg\\:vf-vertical-label-lg{padding-bottom:calc(var(--vf-gutter-lg)/3);padding-right:0;padding-top:0}.vf-lg\\:vf-horizontal-label,.vf-lg\\:vf-horizontal-label-lg,.vf-lg\\:vf-horizontal-label-sm{padding-bottom:0}.vf-text-type .vf-lg\\:vf-horizontal-label{padding-right:var(--vf-gutter);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input))}.vf-text-type .vf-lg\\:vf-horizontal-label-sm{padding-right:var(--vf-gutter-sm);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-sm))}.vf-text-type .vf-lg\\:vf-horizontal-label-lg{padding-right:var(--vf-gutter-lg);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-lg))}}@media (min-width:1280px){.vf-text-type .vf-xl\\:vf-vertical-label,:not(.vf-text-type) .vf-xl\\:vf-vertical-label{padding-bottom:calc(var(--vf-gutter)/3);padding-right:0;padding-top:0}.vf-text-type .vf-xl\\:vf-vertical-label-sm,:not(.vf-text-type) .vf-xl\\:vf-vertical-label-sm{padding-bottom:calc(var(--vf-gutter-sm)/3);padding-right:0;padding-top:0}.vf-text-type .vf-xl\\:vf-vertical-label-lg,:not(.vf-text-type) .vf-xl\\:vf-vertical-label-lg{padding-bottom:calc(var(--vf-gutter-lg)/3);padding-right:0;padding-top:0}.vf-xl\\:vf-horizontal-label,.vf-xl\\:vf-horizontal-label-lg,.vf-xl\\:vf-horizontal-label-sm{padding-bottom:0}.vf-text-type .vf-xl\\:vf-horizontal-label{padding-right:var(--vf-gutter);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input))}.vf-text-type .vf-xl\\:vf-horizontal-label-sm{padding-right:var(--vf-gutter-sm);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-sm))}.vf-text-type .vf-xl\\:vf-horizontal-label-lg{padding-right:var(--vf-gutter-lg);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-lg))}}@media (min-width:1536px){.vf-text-type .vf-2xl\\:vf-vertical-label,:not(.vf-text-type) .vf-2xl\\:vf-vertical-label{padding-bottom:calc(var(--vf-gutter)/3);padding-right:0;padding-top:0}.vf-text-type .vf-2xl\\:vf-vertical-label-sm,:not(.vf-text-type) .vf-2xl\\:vf-vertical-label-sm{padding-bottom:calc(var(--vf-gutter-sm)/3);padding-right:0;padding-top:0}.vf-text-type .vf-2xl\\:vf-vertical-label-lg,:not(.vf-text-type) .vf-2xl\\:vf-vertical-label-lg{padding-bottom:calc(var(--vf-gutter-lg)/3);padding-right:0;padding-top:0}.vf-2xl\\:vf-horizontal-label,.vf-2xl\\:vf-horizontal-label-lg,.vf-2xl\\:vf-horizontal-label-sm{padding-bottom:0}.vf-text-type .vf-2xl\\:vf-horizontal-label{padding-right:var(--vf-gutter);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input))}.vf-text-type .vf-2xl\\:vf-horizontal-label-sm{padding-right:var(--vf-gutter-sm);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-sm))}.vf-text-type .vf-2xl\\:vf-horizontal-label-lg{padding-right:var(--vf-gutter-lg);padding-top:calc(var(--vf-border-width-input-t) + var(--vf-py-input-lg))}}`;
    function bind(fn2, thisArg) {
      return function wrap() {
        return fn2.apply(thisArg, arguments);
      };
    }
    const { toString: toString$b } = Object.prototype;
    const { getPrototypeOf } = Object;
    const kindOf = ((cache) => (thing) => {
      const str = toString$b.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    const kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    const typeOfTest = (type) => (thing) => typeof thing === type;
    const { isArray: isArray$m } = Array;
    const isUndefined$1 = typeOfTest("undefined");
    function isBuffer$7(val) {
      return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && isFunction$6(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    const isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    const isString$3 = typeOfTest("string");
    const isFunction$6 = typeOfTest("function");
    const isNumber$1 = typeOfTest("number");
    const isObject$e = (thing) => thing !== null && typeof thing === "object";
    const isBoolean = (thing) => thing === true || thing === false;
    const isPlainObject$3 = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    const isDate$1 = kindOfTest("Date");
    const isFile = kindOfTest("File");
    const isBlob = kindOfTest("Blob");
    const isFileList = kindOfTest("FileList");
    const isStream = (val) => isObject$e(val) && isFunction$6(val.pipe);
    const isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$6(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction$6(thing.toString) && thing.toString() === "[object FormData]"));
    };
    const isURLSearchParams = kindOfTest("URLSearchParams");
    const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    const trim$1 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach$1(obj, fn2, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i2;
      let l2;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray$m(obj)) {
        for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          fn2.call(null, obj[i2], i2, obj);
        }
      } else {
        const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys2.length;
        let key;
        for (i2 = 0; i2 < len; i2++) {
          key = keys2[i2];
          fn2.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys2 = Object.keys(obj);
      let i2 = keys2.length;
      let _key;
      while (i2-- > 0) {
        _key = keys2[i2];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    const _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    const isContextDefined = (context) => !isUndefined$1(context) && context !== _global;
    function merge$1() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue2 = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject$3(result[targetKey]) && isPlainObject$3(val)) {
          result[targetKey] = merge$1(result[targetKey], val);
        } else if (isPlainObject$3(val)) {
          result[targetKey] = merge$1({}, val);
        } else if (isArray$m(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
        arguments[i2] && forEach$1(arguments[i2], assignValue2);
      }
      return result;
    }
    const extend$2 = (a2, b2, thisArg, { allOwnKeys } = {}) => {
      forEach$1(b2, (val, key) => {
        if (thisArg && isFunction$6(val)) {
          a2[key] = bind(val, thisArg);
        } else {
          a2[key] = val;
        }
      }, { allOwnKeys });
      return a2;
    };
    const stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    const inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
      let props;
      let i2;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i2 = props.length;
        while (i2-- > 0) {
          prop = props[i2];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    const endsWith$1 = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    const toArray$1 = (thing) => {
      if (!thing)
        return null;
      if (isArray$m(thing))
        return thing;
      let i2 = thing.length;
      if (!isNumber$1(i2))
        return null;
      const arr = new Array(i2);
      while (i2-- > 0) {
        arr[i2] = thing[i2];
      }
      return arr;
    };
    const isTypedArray$5 = ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    const forEachEntry = (obj, fn2) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn2.call(obj, pair[0], pair[1]);
      }
    };
    const matchAll = (regExp, str) => {
      let matches2;
      const arr = [];
      while ((matches2 = regExp.exec(str)) !== null) {
        arr.push(matches2);
      }
      return arr;
    };
    const isHTMLForm = kindOfTest("HTMLFormElement");
    const toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer2(m2, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    const hasOwnProperty$f = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    const isRegExp = kindOfTest("RegExp");
    const reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach$1(descriptors2, (descriptor, name2) => {
        let ret;
        if ((ret = reducer(descriptor, name2, obj)) !== false) {
          reducedDescriptors[name2] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    const freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name2) => {
        if (isFunction$6(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
          return false;
        }
        const value = obj[name2];
        if (!isFunction$6(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name2 + "'");
          };
        }
      });
    };
    const toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray$m(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    const noop$2 = () => {
    };
    const toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    const ALPHA = "abcdefghijklmnopqrstuvwxyz";
    const DIGIT = "0123456789";
    const ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size2--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$6(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    const toJSONObject = (obj) => {
      const stack2 = new Array(10);
      const visit = (source, i2) => {
        if (isObject$e(source)) {
          if (stack2.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack2[i2] = source;
            const target = isArray$m(source) ? [] : {};
            forEach$1(source, (value, key) => {
              const reducedValue = visit(value, i2 + 1);
              !isUndefined$1(reducedValue) && (target[key] = reducedValue);
            });
            stack2[i2] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    const isAsyncFn = kindOfTest("AsyncFunction");
    const isThenable = (thing) => thing && (isObject$e(thing) || isFunction$6(thing)) && isFunction$6(thing.then) && isFunction$6(thing.catch);
    const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token2, callbacks) => {
        _global.addEventListener("message", ({ source, data }) => {
          if (source === _global && data === token2) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token2, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction$6(_global.postMessage)
    );
    const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    const utils$1 = {
      isArray: isArray$m,
      isArrayBuffer,
      isBuffer: isBuffer$7,
      isFormData,
      isArrayBufferView,
      isString: isString$3,
      isNumber: isNumber$1,
      isBoolean,
      isObject: isObject$e,
      isPlainObject: isPlainObject$3,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined: isUndefined$1,
      isDate: isDate$1,
      isFile,
      isBlob,
      isRegExp,
      isFunction: isFunction$6,
      isStream,
      isURLSearchParams,
      isTypedArray: isTypedArray$5,
      isFileList,
      forEach: forEach$1,
      merge: merge$1,
      extend: extend$2,
      trim: trim$1,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith: endsWith$1,
      toArray: toArray$1,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty: hasOwnProperty$f,
      hasOwnProp: hasOwnProperty$f,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop: noop$2,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap
    };
    function AxiosError(message, code, config2, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config2 && (this.config = config2);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON2() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    const prototype$1 = AxiosError.prototype;
    const descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config2, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter2(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config2, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    const httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each2(token2, i2) {
        token2 = removeBrackets(token2);
        return !dots && i2 ? "[" + token2 + "]" : token2;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter2(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each2(el, index2) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack2 = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack2.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack2.push(value);
        utils$1.forEach(value, function each2(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack2.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    const prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name2, value) {
      this._pairs.push([name2, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each2(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url2, params, options) {
      if (!params) {
        return url2;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url2.indexOf("#");
        if (hashmarkIndex !== -1) {
          url2 = url2.slice(0, hashmarkIndex);
        }
        url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url2;
    }
    class InterceptorManager {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn2) {
        utils$1.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn2(h2);
          }
        });
      }
    }
    const InterceptorManager$1 = InterceptorManager;
    const transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    const platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    const hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    const hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    const origin = hasBrowserEnv && window.location.href || "http://localhost";
    const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      origin
    }, Symbol.toStringTag, { value: "Module" }));
    const platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name2) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys2 = Object.keys(arr);
      let i2;
      const len = keys2.length;
      let key;
      for (i2 = 0; i2 < len; i2++) {
        key = keys2[i2];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index2) {
        let name2 = path[index2++];
        if (name2 === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name2);
        const isLast = index2 >= path.length;
        name2 = !name2 && utils$1.isArray(target) ? target.length : name2;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name2)) {
            target[name2] = [target[name2], value];
          } else {
            target[name2] = value;
          }
          return !isNumericKey;
        }
        if (!target[name2] || !utils$1.isObject(target[name2])) {
          target[name2] = [];
        }
        const result = buildPath(path, value, target[name2], index2);
        if (result && utils$1.isArray(target[name2])) {
          target[name2] = arrayToObject(target[name2]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name2, value) => {
          buildPath(parsePropPath(name2), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e2) {
          if (e2.name !== "SyntaxError") {
            throw e2;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    const defaults$3 = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults$3.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e2) {
            if (strictJSONParsing) {
              if (e2.name === "SyntaxError") {
                throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e2;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults$3.headers[method] = {};
    });
    const defaults$4 = defaults$3;
    const ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    const parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i2;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i2 = line.indexOf(":");
        key = line.substring(0, i2).trim().toLowerCase();
        val = line.substring(i2 + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    const $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens2 = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens2[match[1]] = match[2];
      }
      return tokens2;
    }
    const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
      if (utils$1.isFunction(filter2)) {
        return filter2.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter2)) {
        return value.indexOf(filter2) !== -1;
      }
      if (utils$1.isRegExp(filter2)) {
        return filter2.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1.isHeaders(header)) {
          for (const [key, value] of header.entries()) {
            setHeader(value, key, rewrite);
          }
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys2 = Object.keys(this);
        let i2 = keys2.length;
        let deleted = false;
        while (i2--) {
          const key = keys2[i2];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format2) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format2 ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed2 = new this(first);
        targets.forEach((target) => computed2.set(target));
        return computed2;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    }
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    const AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config2 = this || defaults$4;
      const context = response || config2;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn2) {
        data = fn2.call(config2, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config2, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve2, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function parseProtocol(url2) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min2) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head2 = 0;
      let tail = 0;
      let firstSampleTS;
      min2 = min2 !== void 0 ? min2 : 1e3;
      return function push(chunkLength) {
        const now2 = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now2;
        }
        bytes[head2] = chunkLength;
        timestamps[head2] = now2;
        let i2 = tail;
        let bytesCount = 0;
        while (i2 !== head2) {
          bytesCount += bytes[i2++];
          i2 = i2 % samplesCount;
        }
        head2 = (head2 + 1) % samplesCount;
        if (head2 === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now2 - firstSampleTS < min2) {
          return;
        }
        const passed = startedAt && now2 - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle$2(fn2, freq) {
      let timestamp = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now2 = Date.now()) => {
        timestamp = now2;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn2.apply(null, args);
      };
      const throttled = (...args) => {
        const now2 = Date.now();
        const passed = now2 - timestamp;
        if (passed >= threshold) {
          invoke(args, now2);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush = () => lastArgs && invoke(lastArgs);
      return [throttled, flush];
    }
    const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle$2((e2) => {
        const loaded = e2.loaded;
        const total = e2.lengthComputable ? e2.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e2,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    const progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    const asyncDecorator = (fn2) => (...args) => utils$1.asap(() => fn2(...args));
    const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url2) {
          let href = url2;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    const cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name2, value, expires, path, domain, secure) {
          const cookie = [name2 + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name2) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name2) {
          this.write(name2, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url2) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config3 = {};
      function getMergedValue(target, source, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a2, b2, caseless) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(a2, b2, caseless);
        } else if (!utils$1.isUndefined(a2)) {
          return getMergedValue(void 0, a2, caseless);
        }
      }
      function valueFromConfig2(a2, b2) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        }
      }
      function defaultToConfig2(a2, b2) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        } else if (!utils$1.isUndefined(a2)) {
          return getMergedValue(void 0, a2);
        }
      }
      function mergeDirectKeys(a2, b2, prop) {
        if (prop in config2) {
          return getMergedValue(a2, b2);
        } else if (prop in config1) {
          return getMergedValue(void 0, a2);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
      });
      return config3;
    }
    const resolveConfig = (config2) => {
      const newConfig = mergeConfig({}, config2);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config2.params, config2.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      let contentType;
      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if ((contentType = headers.getContentType()) !== false) {
          const [type, ...tokens2] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
          headers.setContentType([type || "multipart/form-data", ...tokens2].join("; "));
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    const xhrAdapter = isXHRAdapterSupported && function(config2) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        const _config = resolveConfig(config2);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config2,
            request
          };
          settle(function _resolve(value) {
            resolve2(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
          request = null;
        };
        request.onerror = function handleError2() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config2,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
          return;
        }
        request.send(requestData || null);
      });
    };
    const composeSignals = (signals, timeout) => {
      let controller = new AbortController();
      let aborted;
      const onabort = function(cancel) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = cancel instanceof Error ? cancel : this.reason;
          controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
        }
      };
      let timer = timeout && setTimeout(() => {
        onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = unsubscribe;
      return [signal, () => {
        timer && clearTimeout(timer);
        timer = null;
      }];
    };
    const composeSignals$1 = composeSignals;
    const streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end2;
      while (pos < len) {
        end2 = pos + chunkSize;
        yield chunk.slice(pos, end2);
        pos = end2;
      }
    };
    const readBytes = async function* (iterable, chunkSize, encode2) {
      for await (const chunk of iterable) {
        yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode2(String(chunk)), chunkSize);
      }
    };
    const trackStream = (stream, chunkSize, onProgress, onFinish, encode2) => {
      const iterator = readBytes(stream, chunkSize, encode2);
      let bytes = 0;
      let done;
      let _onFinish = (e2) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e2);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
    const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
    const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
    const test = (fn2, ...args) => {
      try {
        return !!fn2(...args);
      } catch (e2) {
        return false;
      }
    };
    const supportsRequestStream = isReadableStreamSupported && test(() => {
      let duplexAccessed = false;
      const hasContentType = new Request(platform.origin, {
        body: new ReadableStream(),
        method: "POST",
        get duplex() {
          duplexAccessed = true;
          return "half";
        }
      }).headers.has("Content-Type");
      return duplexAccessed && !hasContentType;
    });
    const DEFAULT_CHUNK_SIZE = 64 * 1024;
    const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
    const resolvers = {
      stream: supportsResponseStream && ((res) => res.body)
    };
    isFetchSupported && ((res) => {
      ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
        !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config2) => {
          throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config2);
        });
      });
    })(new Response());
    const getBodyLength = async (body) => {
      if (body == null) {
        return 0;
      }
      if (utils$1.isBlob(body)) {
        return body.size;
      }
      if (utils$1.isSpecCompliantForm(body)) {
        return (await new Request(body).arrayBuffer()).byteLength;
      }
      if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
        return body.byteLength;
      }
      if (utils$1.isURLSearchParams(body)) {
        body = body + "";
      }
      if (utils$1.isString(body)) {
        return (await encodeText(body)).byteLength;
      }
    };
    const resolveBodyLength = async (headers, body) => {
      const length = utils$1.toFiniteNumber(headers.getContentLength());
      return length == null ? getBodyLength(body) : length;
    };
    const fetchAdapter = isFetchSupported && (async (config2) => {
      let {
        url: url2,
        method,
        data,
        signal,
        cancelToken,
        timeout,
        onDownloadProgress,
        onUploadProgress,
        responseType,
        headers,
        withCredentials = "same-origin",
        fetchOptions
      } = resolveConfig(config2);
      responseType = responseType ? (responseType + "").toLowerCase() : "text";
      let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals$1([signal, cancelToken], timeout) : [];
      let finished, request;
      const onFinish = () => {
        !finished && setTimeout(() => {
          composedSignal && composedSignal.unsubscribe();
        });
        finished = true;
      };
      let requestContentLength;
      try {
        if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
          let _request = new Request(url2, {
            method: "POST",
            body: data,
            duplex: "half"
          });
          let contentTypeHeader;
          if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
            headers.setContentType(contentTypeHeader);
          }
          if (_request.body) {
            const [onProgress, flush] = progressEventDecorator(
              requestContentLength,
              progressEventReducer(asyncDecorator(onUploadProgress))
            );
            data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush, encodeText);
          }
        }
        if (!utils$1.isString(withCredentials)) {
          withCredentials = withCredentials ? "include" : "omit";
        }
        request = new Request(url2, {
          ...fetchOptions,
          signal: composedSignal,
          method: method.toUpperCase(),
          headers: headers.normalize().toJSON(),
          body: data,
          duplex: "half",
          credentials: withCredentials
        });
        let response = await fetch(request);
        const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
        if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
          const options = {};
          ["status", "statusText", "headers"].forEach((prop) => {
            options[prop] = response[prop];
          });
          const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
          const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
            responseContentLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true)
          ) || [];
          response = new Response(
            trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
              flush && flush();
              isStreamResponse && onFinish();
            }, encodeText),
            options
          );
        }
        responseType = responseType || "text";
        let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
        !isStreamResponse && onFinish();
        stopTimeout && stopTimeout();
        return await new Promise((resolve2, reject) => {
          settle(resolve2, reject, {
            data: responseData,
            headers: AxiosHeaders$1.from(response.headers),
            status: response.status,
            statusText: response.statusText,
            config: config2,
            request
          });
        });
      } catch (err) {
        onFinish();
        if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
          throw Object.assign(
            new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request),
            {
              cause: err.cause || err
            }
          );
        }
        throw AxiosError.from(err, err && err.code, config2, request);
      }
    });
    const knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: fetchAdapter
    };
    utils$1.forEach(knownAdapters, (fn2, value) => {
      if (fn2) {
        try {
          Object.defineProperty(fn2, "name", { value });
        } catch (e2) {
        }
        Object.defineProperty(fn2, "adapterName", { value });
      }
    });
    const renderReason = (reason) => `- ${reason}`;
    const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    const adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i2 = 0; i2 < length; i2++) {
          nameOrAdapter = adapters2[i2];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i2] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s2,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config2) {
      if (config2.cancelToken) {
        config2.cancelToken.throwIfRequested();
      }
      if (config2.signal && config2.signal.aborted) {
        throw new CanceledError(null, config2);
      }
    }
    function dispatchRequest(config2) {
      throwIfCancellationRequested(config2);
      config2.headers = AxiosHeaders$1.from(config2.headers);
      config2.data = transformData.call(
        config2,
        config2.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
        config2.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config2.adapter || defaults$4.adapter);
      return adapter(config2).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config2);
        response.data = transformData.call(
          config2,
          config2.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config2);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config2,
              config2.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    const VERSION = "1.7.4";
    const validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
      };
    });
    const deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys2 = Object.keys(options);
      let i2 = keys2.length;
      while (i2-- > 0) {
        const opt = keys2[i2];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    const validator = {
      assertOptions,
      validators: validators$1
    };
    const validators = validator.validators;
    class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config2) {
        try {
          return await this._request(configOrUrl, config2);
        } catch (err) {
          if (err instanceof Error) {
            let dummy;
            Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
            const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack2;
              } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack2;
              }
            } catch (e2) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config2) {
        if (typeof configOrUrl === "string") {
          config2 = config2 || {};
          config2.url = configOrUrl;
        } else {
          config2 = configOrUrl || {};
        }
        config2 = mergeConfig(this.defaults, config2);
        const { transitional, paramsSerializer, headers } = config2;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config2.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config2.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i2 = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config2);
          while (i2 < len) {
            promise = promise.then(chain[i2++], chain[i2++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config2;
        i2 = 0;
        while (i2 < len) {
          const onFulfilled = requestInterceptorChain[i2++];
          const onRejected = requestInterceptorChain[i2++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i2 = 0;
        len = responseInterceptorChain.length;
        while (i2 < len) {
          promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
        }
        return promise;
      }
      getUri(config2) {
        config2 = mergeConfig(this.defaults, config2);
        const fullPath = buildFullPath(config2.baseURL, config2.url);
        return buildURL(fullPath, config2.params, config2.paramsSerializer);
      }
    }
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url2, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          url: url2,
          data: (config2 || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config2) {
          return this.request(mergeConfig(config2 || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url2,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    const Axios$1 = Axios;
    class CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve2) {
          resolvePromise = resolve2;
        });
        const token2 = this;
        this.promise.then((cancel) => {
          if (!token2._listeners)
            return;
          let i2 = token2._listeners.length;
          while (i2-- > 0) {
            token2._listeners[i2](cancel);
          }
          token2._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve2) => {
            token2.subscribe(resolve2);
            _resolve = resolve2;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token2.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config2, request) {
          if (token2.reason) {
            return;
          }
          token2.reason = new CanceledError(message, config2, request);
          resolvePromise(token2.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token2 = new CancelToken(function executor(c2) {
          cancel = c2;
        });
        return {
          token: token2,
          cancel
        };
      }
    }
    const CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    const HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    const HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    const axios = createInstance(defaults$4);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    const axios$1 = axios;
    //! moment.js
    //! version : 2.30.1
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    var hookCallback;
    function hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray$l(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject$d(input) {
      return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a2, b2) {
      return Object.prototype.hasOwnProperty.call(a2, b2);
    }
    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k2;
        for (k2 in obj) {
          if (hasOwnProp(obj, k2)) {
            return false;
          }
        }
        return true;
      }
    }
    function isUndefined(input) {
      return input === void 0;
    }
    function isNumber(input) {
      return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map$1(arr, fn2) {
      var res = [], i2, arrLen = arr.length;
      for (i2 = 0; i2 < arrLen; ++i2) {
        res.push(fn2(arr[i2], i2));
      }
      return res;
    }
    function extend$1(a2, b2) {
      for (var i2 in b2) {
        if (hasOwnProp(b2, i2)) {
          a2[i2] = b2[i2];
        }
      }
      if (hasOwnProp(b2, "toString")) {
        a2.toString = b2.toString;
      }
      if (hasOwnProp(b2, "valueOf")) {
        a2.valueOf = b2.valueOf;
      }
      return a2;
    }
    function createUTC(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }
    function getParsingFlags(m2) {
      if (m2._pf == null) {
        m2._pf = defaultParsingFlags();
      }
      return m2._pf;
    }
    var some$1;
    if (Array.prototype.some) {
      some$1 = Array.prototype.some;
    } else {
      some$1 = function(fun) {
        var t2 = Object(this), len = t2.length >>> 0, i2;
        for (i2 = 0; i2 < len; i2++) {
          if (i2 in t2 && fun.call(this, t2[i2], i2, t2)) {
            return true;
          }
        }
        return false;
      };
    }
    function isValid(m2) {
      var flags = null, parsedParts = false, isNowValid = m2._d && !isNaN(m2._d.getTime());
      if (isNowValid) {
        flags = getParsingFlags(m2);
        parsedParts = some$1.call(flags.parsedDateParts, function(i2) {
          return i2 != null;
        });
        isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
        if (m2._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
        }
      }
      if (Object.isFrozen == null || !Object.isFrozen(m2)) {
        m2._isValid = isNowValid;
      } else {
        return isNowValid;
      }
      return m2._isValid;
    }
    function createInvalid(flags) {
      var m2 = createUTC(NaN);
      if (flags != null) {
        extend$1(getParsingFlags(m2), flags);
      } else {
        getParsingFlags(m2).userInvalidated = true;
      }
      return m2;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to2, from2) {
      var i2, prop, val, momentPropertiesLen = momentProperties.length;
      if (!isUndefined(from2._isAMomentObject)) {
        to2._isAMomentObject = from2._isAMomentObject;
      }
      if (!isUndefined(from2._i)) {
        to2._i = from2._i;
      }
      if (!isUndefined(from2._f)) {
        to2._f = from2._f;
      }
      if (!isUndefined(from2._l)) {
        to2._l = from2._l;
      }
      if (!isUndefined(from2._strict)) {
        to2._strict = from2._strict;
      }
      if (!isUndefined(from2._tzm)) {
        to2._tzm = from2._tzm;
      }
      if (!isUndefined(from2._isUTC)) {
        to2._isUTC = from2._isUTC;
      }
      if (!isUndefined(from2._offset)) {
        to2._offset = from2._offset;
      }
      if (!isUndefined(from2._pf)) {
        to2._pf = getParsingFlags(from2);
      }
      if (!isUndefined(from2._locale)) {
        to2._locale = from2._locale;
      }
      if (momentPropertiesLen > 0) {
        for (i2 = 0; i2 < momentPropertiesLen; i2++) {
          prop = momentProperties[i2];
          val = from2[prop];
          if (!isUndefined(val)) {
            to2[prop] = val;
          }
        }
      }
      return to2;
    }
    function Moment(config2) {
      copyConfig(this, config2);
      this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
      if (!this.isValid()) {
        this._d = /* @__PURE__ */ new Date(NaN);
      }
      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
        console.warn("Deprecation warning: " + msg);
      }
    }
    function deprecate(msg, fn2) {
      var firstTime = true;
      return extend$1(function() {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
          var args = [], arg, i2, key, argLen = arguments.length;
          for (i2 = 0; i2 < argLen; i2++) {
            arg = "";
            if (typeof arguments[i2] === "object") {
              arg += "\n[" + i2 + "] ";
              for (key in arguments[0]) {
                if (hasOwnProp(arguments[0], key)) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
              }
              arg = arg.slice(0, -2);
            } else {
              arg = arguments[i2];
            }
            args.push(arg);
          }
          warn(
            msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
          );
          firstTime = false;
        }
        return fn2.apply(this, arguments);
      }, fn2);
    }
    var deprecations = {};
    function deprecateSimple(name2, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name2, msg);
      }
      if (!deprecations[name2]) {
        warn(msg);
        deprecations[name2] = true;
      }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction$5(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set$1(config2) {
      var prop, i2;
      for (i2 in config2) {
        if (hasOwnProp(config2, i2)) {
          prop = config2[i2];
          if (isFunction$5(prop)) {
            this[i2] = prop;
          } else {
            this["_" + i2] = prop;
          }
        }
      }
      this._config = config2;
      this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
      );
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res = extend$1({}, parentConfig), prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject$d(parentConfig[prop]) && isObject$d(childConfig[prop])) {
            res[prop] = {};
            extend$1(res[prop], parentConfig[prop]);
            extend$1(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject$d(parentConfig[prop])) {
          res[prop] = extend$1({}, res[prop]);
        }
      }
      return res;
    }
    function Locale(config2) {
      if (config2 != null) {
        this.set(config2);
      }
    }
    var keys$8;
    if (Object.keys) {
      keys$8 = Object.keys;
    } else {
      keys$8 = function(obj) {
        var i2, res = [];
        for (i2 in obj) {
          if (hasOwnProp(obj, i2)) {
            res.push(i2);
          }
        }
        return res;
      };
    }
    var defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    function calendar(key, mom, now2) {
      var output = this._calendar[key] || this._calendar["sameElse"];
      return isFunction$5(output) ? output.call(mom, now2) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
      return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token2, padded, ordinal2, callback) {
      var func = callback;
      if (typeof callback === "string") {
        func = function() {
          return this[callback]();
        };
      }
      if (token2) {
        formatTokenFunctions[token2] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal2) {
        formatTokenFunctions[ordinal2] = function() {
          return this.localeData().ordinal(
            func.apply(this, arguments),
            token2
          );
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, "");
      }
      return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format2) {
      var array2 = format2.match(formattingTokens), i2, length;
      for (i2 = 0, length = array2.length; i2 < length; i2++) {
        if (formatTokenFunctions[array2[i2]]) {
          array2[i2] = formatTokenFunctions[array2[i2]];
        } else {
          array2[i2] = removeFormattingTokens(array2[i2]);
        }
      }
      return function(mom) {
        var output = "", i3;
        for (i3 = 0; i3 < length; i3++) {
          output += isFunction$5(array2[i3]) ? array2[i3].call(mom, format2) : array2[i3];
        }
        return output;
      };
    }
    function formatMoment(m2, format2) {
      if (!m2.isValid()) {
        return m2.localeData().invalidDate();
      }
      format2 = expandFormat(format2, m2.localeData());
      formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
      return formatFunctions[format2](m2);
    }
    function expandFormat(format2, locale2) {
      var i2 = 5;
      function replaceLongDateFormatTokens(input) {
        return locale2.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i2 >= 0 && localFormattingTokens.test(format2)) {
        format2 = format2.replace(
          localFormattingTokens,
          replaceLongDateFormatTokens
        );
        localFormattingTokens.lastIndex = 0;
        i2 -= 1;
      }
      return format2;
    }
    var defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
      var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format2 || !formatUpper) {
        return format2;
      }
      this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
          return tok.slice(1);
        }
        return tok;
      }).join("");
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    function relativeTime(number, withoutSuffix, string2, isFuture) {
      var output = this._relativeTime[string2];
      return isFunction$5(output) ? output(number, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff2, output) {
      var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
      return isFunction$5(format2) ? format2(output) : format2.replace(/%s/i, output);
    }
    var aliases = {
      D: "date",
      dates: "date",
      date: "date",
      d: "day",
      days: "day",
      day: "day",
      e: "weekday",
      weekdays: "weekday",
      weekday: "weekday",
      E: "isoWeekday",
      isoweekdays: "isoWeekday",
      isoweekday: "isoWeekday",
      DDD: "dayOfYear",
      dayofyears: "dayOfYear",
      dayofyear: "dayOfYear",
      h: "hour",
      hours: "hour",
      hour: "hour",
      ms: "millisecond",
      milliseconds: "millisecond",
      millisecond: "millisecond",
      m: "minute",
      minutes: "minute",
      minute: "minute",
      M: "month",
      months: "month",
      month: "month",
      Q: "quarter",
      quarters: "quarter",
      quarter: "quarter",
      s: "second",
      seconds: "second",
      second: "second",
      gg: "weekYear",
      weekyears: "weekYear",
      weekyear: "weekYear",
      GG: "isoWeekYear",
      isoweekyears: "isoWeekYear",
      isoweekyear: "isoWeekYear",
      w: "week",
      weeks: "week",
      week: "week",
      W: "isoWeek",
      isoweeks: "isoWeek",
      isoweek: "isoWeek",
      y: "year",
      years: "year",
      year: "year"
    };
    function normalizeUnits(units) {
      return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {}, normalizedProp, prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    var priorities = {
      date: 9,
      day: 11,
      weekday: 11,
      isoWeekday: 11,
      dayOfYear: 4,
      hour: 13,
      millisecond: 16,
      minute: 14,
      month: 8,
      quarter: 7,
      second: 15,
      weekYear: 1,
      isoWeekYear: 1,
      week: 5,
      isoWeek: 5,
      year: 1
    };
    function getPrioritizedUnits(unitsObj) {
      var units = [], u2;
      for (u2 in unitsObj) {
        if (hasOwnProp(unitsObj, u2)) {
          units.push({ unit: u2, priority: priorities[u2] });
        }
      }
      units.sort(function(a2, b2) {
        return a2.priority - b2.priority;
      });
      return units;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
    regexes = {};
    function addRegexToken(token2, regex2, strictRegex) {
      regexes[token2] = isFunction$5(regex2) ? regex2 : function(isStrict, localeData2) {
        return isStrict && strictRegex ? strictRegex : regex2;
      };
    }
    function getParseRegexForToken(token2, config2) {
      if (!hasOwnProp(regexes, token2)) {
        return new RegExp(unescapeFormat(token2));
      }
      return regexes[token2](config2._strict, config2._locale);
    }
    function unescapeFormat(s2) {
      return regexEscape(
        s2.replace("\\", "").replace(
          /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
          function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }
        )
      );
    }
    function regexEscape(s2) {
      return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion, value = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }
      return value;
    }
    var tokens = {};
    function addParseToken(token2, callback) {
      var i2, func = callback, tokenLen;
      if (typeof token2 === "string") {
        token2 = [token2];
      }
      if (isNumber(callback)) {
        func = function(input, array2) {
          array2[callback] = toInt(input);
        };
      }
      tokenLen = token2.length;
      for (i2 = 0; i2 < tokenLen; i2++) {
        tokens[token2[i2]] = func;
      }
    }
    function addWeekParseToken(token2, callback) {
      addParseToken(token2, function(input, array2, config2, token3) {
        config2._w = config2._w || {};
        callback(input, config2._w, config2, token3);
      });
    }
    function addTimeToArrayFromToken(token2, input, config2) {
      if (input != null && hasOwnProp(tokens, token2)) {
        tokens[token2](input, config2._a, config2, token2);
      }
    }
    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    addFormatToken("Y", 0, 0, function() {
      var y2 = this.year();
      return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array2) {
      array2[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array2) {
      array2[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array2) {
      array2[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    function makeGetSet(unit, keepTime) {
      return function(value) {
        if (value != null) {
          set$1$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get$2(this, unit);
        }
      };
    }
    function get$2(mom, unit) {
      if (!mom.isValid()) {
        return NaN;
      }
      var d2 = mom._d, isUTC = mom._isUTC;
      switch (unit) {
        case "Milliseconds":
          return isUTC ? d2.getUTCMilliseconds() : d2.getMilliseconds();
        case "Seconds":
          return isUTC ? d2.getUTCSeconds() : d2.getSeconds();
        case "Minutes":
          return isUTC ? d2.getUTCMinutes() : d2.getMinutes();
        case "Hours":
          return isUTC ? d2.getUTCHours() : d2.getHours();
        case "Date":
          return isUTC ? d2.getUTCDate() : d2.getDate();
        case "Day":
          return isUTC ? d2.getUTCDay() : d2.getDay();
        case "Month":
          return isUTC ? d2.getUTCMonth() : d2.getMonth();
        case "FullYear":
          return isUTC ? d2.getUTCFullYear() : d2.getFullYear();
        default:
          return NaN;
      }
    }
    function set$1$1(mom, unit, value) {
      var d2, isUTC, year, month, date2;
      if (!mom.isValid() || isNaN(value)) {
        return;
      }
      d2 = mom._d;
      isUTC = mom._isUTC;
      switch (unit) {
        case "Milliseconds":
          return void (isUTC ? d2.setUTCMilliseconds(value) : d2.setMilliseconds(value));
        case "Seconds":
          return void (isUTC ? d2.setUTCSeconds(value) : d2.setSeconds(value));
        case "Minutes":
          return void (isUTC ? d2.setUTCMinutes(value) : d2.setMinutes(value));
        case "Hours":
          return void (isUTC ? d2.setUTCHours(value) : d2.setHours(value));
        case "Date":
          return void (isUTC ? d2.setUTCDate(value) : d2.setDate(value));
        case "FullYear":
          break;
        default:
          return;
      }
      year = value;
      month = mom.month();
      date2 = mom.date();
      date2 = date2 === 29 && month === 1 && !isLeapYear(year) ? 28 : date2;
      void (isUTC ? d2.setUTCFullYear(year, month, date2) : d2.setFullYear(year, month, date2));
    }
    function stringGet(units) {
      units = normalizeUnits(units);
      if (isFunction$5(this[units])) {
        return this[units]();
      }
      return this;
    }
    function stringSet(units, value) {
      if (typeof units === "object") {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
        for (i2 = 0; i2 < prioritizedLen; i2++) {
          this[prioritized[i2].unit](units[prioritized[i2].unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (isFunction$5(this[units])) {
          return this[units](value);
        }
      }
      return this;
    }
    function mod(n2, x2) {
      return (n2 % x2 + x2) % x2;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o2) {
        var i2;
        for (i2 = 0; i2 < this.length; ++i2) {
          if (this[i2] === o2) {
            return i2;
          }
        }
        return -1;
      };
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addRegexToken("M", match1to2, match1to2NoLeadingZero);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array2) {
      array2[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array2, config2, token2) {
      var month = config2._locale.monthsParse(input, token2, config2._strict);
      if (month != null) {
        array2[MONTH] = month;
      } else {
        getParsingFlags(config2).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m2, format2) {
      if (!m2) {
        return isArray$l(this._months) ? this._months : this._months["standalone"];
      }
      return isArray$l(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
    }
    function localeMonthsShort(m2, format2) {
      if (!m2) {
        return isArray$l(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
      }
      return isArray$l(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
    }
    function handleStrictParse(monthName, format2, strict) {
      var i2, ii2, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i2 = 0; i2 < 12; ++i2) {
          mom = createUTC([2e3, i2]);
          this._shortMonthsParse[i2] = this.monthsShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "MMM") {
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._longMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      } else {
        if (format2 === "MMM") {
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._longMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._longMonthsParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      }
    }
    function localeMonthsParse(monthName, format2, strict) {
      var i2, mom, regex2;
      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format2, strict);
      }
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i2 = 0; i2 < 12; i2++) {
        mom = createUTC([2e3, i2]);
        if (strict && !this._longMonthsParse[i2]) {
          this._longMonthsParse[i2] = new RegExp(
            "^" + this.months(mom, "").replace(".", "") + "$",
            "i"
          );
          this._shortMonthsParse[i2] = new RegExp(
            "^" + this.monthsShort(mom, "").replace(".", "") + "$",
            "i"
          );
        }
        if (!strict && !this._monthsParse[i2]) {
          regex2 = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
          this._monthsParse[i2] = new RegExp(regex2.replace(".", ""), "i");
        }
        if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
          return i2;
        } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
          return i2;
        } else if (!strict && this._monthsParse[i2].test(monthName)) {
          return i2;
        }
      }
    }
    function setMonth(mom, value) {
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value === "string") {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value);
          if (!isNumber(value)) {
            return mom;
          }
        }
      }
      var month = value, date2 = mom.date();
      date2 = date2 < 29 ? date2 : Math.min(date2, daysInMonth(mom.year(), month));
      void (mom._isUTC ? mom._d.setUTCMonth(month, date2) : mom._d.setMonth(month, date2));
      return mom;
    }
    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get$2(this, "Month");
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsShortRegex")) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsRegex")) {
          this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a2, b2) {
        return b2.length - a2.length;
      }
      var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, shortP, longP;
      for (i2 = 0; i2 < 12; i2++) {
        mom = createUTC([2e3, i2]);
        shortP = regexEscape(this.monthsShort(mom, ""));
        longP = regexEscape(this.months(mom, ""));
        shortPieces.push(shortP);
        longPieces.push(longP);
        mixedPieces.push(longP);
        mixedPieces.push(shortP);
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._monthsShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
    }
    function createDate(y2, m2, d2, h2, M2, s2, ms) {
      var date2;
      if (y2 < 100 && y2 >= 0) {
        date2 = new Date(y2 + 400, m2, d2, h2, M2, s2, ms);
        if (isFinite(date2.getFullYear())) {
          date2.setFullYear(y2);
        }
      } else {
        date2 = new Date(y2, m2, d2, h2, M2, s2, ms);
      }
      return date2;
    }
    function createUTCDate(y2) {
      var date2, args;
      if (y2 < 100 && y2 >= 0) {
        args = Array.prototype.slice.call(arguments);
        args[0] = y2 + 400;
        date2 = new Date(Date.UTC.apply(null, args));
        if (isFinite(date2.getUTCFullYear())) {
          date2.setUTCFullYear(y2);
        }
      } else {
        date2 = new Date(Date.UTC.apply(null, arguments));
      }
      return date2;
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addRegexToken("w", match1to2, match1to2NoLeadingZero);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2, match1to2NoLeadingZero);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week, config2, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      }
    );
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6
      // The week that contains Jan 6th is the first week of the year.
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config2, token2) {
      var weekday = config2._locale.weekdaysParse(input, token2, config2._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config2).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config2, token2) {
      week[token2] = toInt(input);
    });
    function parseWeekday(input, locale2) {
      if (typeof input !== "string") {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale2.weekdaysParse(input);
      if (typeof input === "number") {
        return input;
      }
      return null;
    }
    function parseIsoWeekday(input, locale2) {
      if (typeof input === "string") {
        return locale2.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n2) {
      return ws.slice(n2, 7).concat(ws.slice(0, n2));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m2, format2) {
      var weekdays = isArray$l(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
      return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
    }
    function localeWeekdaysShort(m2) {
      return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m2) {
      return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format2, strict) {
      var i2, ii2, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];
        for (i2 = 0; i2 < 7; ++i2) {
          mom = createUTC([2e3, 1]).day(i2);
          this._minWeekdaysParse[i2] = this.weekdaysMin(
            mom,
            ""
          ).toLocaleLowerCase();
          this._shortWeekdaysParse[i2] = this.weekdaysShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "dddd") {
          ii2 = indexOf.call(this._weekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else if (format2 === "ddd") {
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      } else {
        if (format2 === "dddd") {
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else if (format2 === "ddd") {
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      }
    }
    function localeWeekdaysParse(weekdayName, format2, strict) {
      var i2, mom, regex2;
      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format2, strict);
      }
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i2 = 0; i2 < 7; i2++) {
        mom = createUTC([2e3, 1]).day(i2);
        if (strict && !this._fullWeekdaysParse[i2]) {
          this._fullWeekdaysParse[i2] = new RegExp(
            "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._shortWeekdaysParse[i2] = new RegExp(
            "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._minWeekdaysParse[i2] = new RegExp(
            "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
        }
        if (!this._weekdaysParse[i2]) {
          regex2 = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
          this._weekdaysParse[i2] = new RegExp(regex2.replace(".", ""), "i");
        }
        if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
          return i2;
        } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
          return i2;
        } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
          return i2;
        } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
          return i2;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = get$2(this, "Day");
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, "d");
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }
    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }
    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }
    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }
    function computeWeekdaysParse() {
      function cmpLenRev(a2, b2) {
        return b2.length - a2.length;
      }
      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
      for (i2 = 0; i2 < 7; i2++) {
        mom = createUTC([2e3, 1]).day(i2);
        minp = regexEscape(this.weekdaysMin(mom, ""));
        shortp = regexEscape(this.weekdaysShort(mom, ""));
        longp = regexEscape(this.weekdays(mom, ""));
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      }
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._weekdaysShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
      this._weekdaysMinStrictRegex = new RegExp(
        "^(" + minPieces.join("|") + ")",
        "i"
      );
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    function kFormat() {
      return this.hours() || 24;
    }
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token2, lowercase) {
      addFormatToken(token2, 0, 0, function() {
        return this.localeData().meridiem(
          this.hours(),
          this.minutes(),
          lowercase
        );
      });
    }
    meridiem("a", true);
    meridiem("A", false);
    function matchMeridiem(isStrict, locale2) {
      return locale2._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2, match1to2HasZero);
    addRegexToken("h", match1to2, match1to2NoLeadingZero);
    addRegexToken("k", match1to2, match1to2NoLeadingZero);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array2, config2) {
      var kInput = toInt(input);
      array2[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array2, config2) {
      config2._isPm = config2._locale.isPM(input);
      config2._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array2, config2) {
      array2[HOUR] = toInt(input);
      getParsingFlags(config2).bigHour = true;
    });
    addParseToken("hmm", function(input, array2, config2) {
      var pos = input.length - 2;
      array2[HOUR] = toInt(input.substr(0, pos));
      array2[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config2).bigHour = true;
    });
    addParseToken("hmmss", function(input, array2, config2) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array2[HOUR] = toInt(input.substr(0, pos1));
      array2[MINUTE] = toInt(input.substr(pos1, 2));
      array2[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config2).bigHour = true;
    });
    addParseToken("Hmm", function(input, array2, config2) {
      var pos = input.length - 2;
      array2[HOUR] = toInt(input.substr(0, pos));
      array2[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array2, config2) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array2[HOUR] = toInt(input.substr(0, pos1));
      array2[MINUTE] = toInt(input.substr(pos1, 2));
      array2[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours2, minutes2, isLower) {
      if (hours2 > 11) {
        return isLower ? "pm" : "PM";
      } else {
        return isLower ? "am" : "AM";
      }
    }
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
      var i2, minl = Math.min(arr1.length, arr2.length);
      for (i2 = 0; i2 < minl; i2 += 1) {
        if (arr1[i2] !== arr2[i2]) {
          return i2;
        }
      }
      return minl;
    }
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
      var i2 = 0, j2, next, locale2, split;
      while (i2 < names.length) {
        split = normalizeLocale(names[i2]).split("-");
        j2 = split.length;
        next = normalizeLocale(names[i2 + 1]);
        next = next ? next.split("-") : null;
        while (j2 > 0) {
          locale2 = loadLocale(split.slice(0, j2).join("-"));
          if (locale2) {
            return locale2;
          }
          if (next && next.length >= j2 && commonPrefix(split, next) >= j2 - 1) {
            break;
          }
          j2--;
        }
        i2++;
      }
      return globalLocale;
    }
    function isLocaleNameSane(name2) {
      return !!(name2 && name2.match("^[^/\\\\]*$"));
    }
    function loadLocale(name2) {
      var oldLocale = null, aliasedRequire;
      if (locales[name2] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name2)) {
        try {
          oldLocale = globalLocale._abbr;
          aliasedRequire = require;
          aliasedRequire("./locale/" + name2);
          getSetGlobalLocale(oldLocale);
        } catch (e2) {
          locales[name2] = null;
        }
      }
      return locales[name2];
    }
    function getSetGlobalLocale(key, values2) {
      var data;
      if (key) {
        if (isUndefined(values2)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values2);
        }
        if (data) {
          globalLocale = data;
        } else {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(
              "Locale " + key + " not found. Did you forget to load it?"
            );
          }
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name2, config2) {
      if (config2 !== null) {
        var locale2, parentConfig = baseConfig;
        config2.abbr = name2;
        if (locales[name2] != null) {
          deprecateSimple(
            "defineLocaleOverride",
            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
          );
          parentConfig = locales[name2]._config;
        } else if (config2.parentLocale != null) {
          if (locales[config2.parentLocale] != null) {
            parentConfig = locales[config2.parentLocale]._config;
          } else {
            locale2 = loadLocale(config2.parentLocale);
            if (locale2 != null) {
              parentConfig = locale2._config;
            } else {
              if (!localeFamilies[config2.parentLocale]) {
                localeFamilies[config2.parentLocale] = [];
              }
              localeFamilies[config2.parentLocale].push({
                name: name2,
                config: config2
              });
              return null;
            }
          }
        }
        locales[name2] = new Locale(mergeConfigs(parentConfig, config2));
        if (localeFamilies[name2]) {
          localeFamilies[name2].forEach(function(x2) {
            defineLocale(x2.name, x2.config);
          });
        }
        getSetGlobalLocale(name2);
        return locales[name2];
      } else {
        delete locales[name2];
        return null;
      }
    }
    function updateLocale(name2, config2) {
      if (config2 != null) {
        var locale2, tmpLocale, parentConfig = baseConfig;
        if (locales[name2] != null && locales[name2].parentLocale != null) {
          locales[name2].set(mergeConfigs(locales[name2]._config, config2));
        } else {
          tmpLocale = loadLocale(name2);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config2 = mergeConfigs(parentConfig, config2);
          if (tmpLocale == null) {
            config2.abbr = name2;
          }
          locale2 = new Locale(config2);
          locale2.parentLocale = locales[name2];
          locales[name2] = locale2;
        }
        getSetGlobalLocale(name2);
      } else {
        if (locales[name2] != null) {
          if (locales[name2].parentLocale != null) {
            locales[name2] = locales[name2].parentLocale;
            if (name2 === getSetGlobalLocale()) {
              getSetGlobalLocale(name2);
            }
          } else if (locales[name2] != null) {
            delete locales[name2];
          }
        }
      }
      return locales[name2];
    }
    function getLocale(key) {
      var locale2;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray$l(key)) {
        locale2 = loadLocale(key);
        if (locale2) {
          return locale2;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function listLocales() {
      return keys$8(locales);
    }
    function checkOverflow(m2) {
      var overflow, a2 = m2._a;
      if (a2 && getParsingFlags(m2).overflow === -2) {
        overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }
        if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }
        if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }
        getParsingFlags(m2).overflow = overflow;
      }
      return m2;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ], isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function configFromISO(config2) {
      var i2, l2, string2 = config2._i, match = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
      if (match) {
        getParsingFlags(config2).iso = true;
        for (i2 = 0, l2 = isoDatesLen; i2 < l2; i2++) {
          if (isoDates[i2][1].exec(match[1])) {
            dateFormat = isoDates[i2][0];
            allowTime = isoDates[i2][2] !== false;
            break;
          }
        }
        if (dateFormat == null) {
          config2._isValid = false;
          return;
        }
        if (match[3]) {
          for (i2 = 0, l2 = isoTimesLen; i2 < l2; i2++) {
            if (isoTimes[i2][1].exec(match[3])) {
              timeFormat = (match[2] || " ") + isoTimes[i2][0];
              break;
            }
          }
          if (timeFormat == null) {
            config2._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config2._isValid = false;
          return;
        }
        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = "Z";
          } else {
            config2._isValid = false;
            return;
          }
        }
        config2._f = dateFormat + (timeFormat || "") + (tzFormat || "");
        configFromStringAndFormat(config2);
      } else {
        config2._isValid = false;
      }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
      ];
      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }
      return result;
    }
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
        return 2e3 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }
      return year;
    }
    function preprocessRFC2822(s2) {
      return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config2) {
      if (weekdayStr) {
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
          parsedInput[0],
          parsedInput[1],
          parsedInput[2]
        ).getDay();
        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config2).weekdayMismatch = true;
          config2._isValid = false;
          return false;
        }
      }
      return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        return 0;
      } else {
        var hm = parseInt(numOffset, 10), m2 = hm % 100, h2 = (hm - m2) / 100;
        return h2 * 60 + m2;
      }
    }
    function configFromRFC2822(config2) {
      var match = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
      if (match) {
        parsedArray = extractFromRFC2822Strings(
          match[4],
          match[3],
          match[2],
          match[5],
          match[6],
          match[7]
        );
        if (!checkWeekday(match[1], parsedArray, config2)) {
          return;
        }
        config2._a = parsedArray;
        config2._tzm = calculateOffset(match[8], match[9], match[10]);
        config2._d = createUTCDate.apply(null, config2._a);
        config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
        getParsingFlags(config2).rfc2822 = true;
      } else {
        config2._isValid = false;
      }
    }
    function configFromString(config2) {
      var matched = aspNetJsonRegex.exec(config2._i);
      if (matched !== null) {
        config2._d = /* @__PURE__ */ new Date(+matched[1]);
        return;
      }
      configFromISO(config2);
      if (config2._isValid === false) {
        delete config2._isValid;
      } else {
        return;
      }
      configFromRFC2822(config2);
      if (config2._isValid === false) {
        delete config2._isValid;
      } else {
        return;
      }
      if (config2._strict) {
        config2._isValid = false;
      } else {
        hooks.createFromInputFallback(config2);
      }
    }
    hooks.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config2) {
        config2._d = /* @__PURE__ */ new Date(config2._i + (config2._useUTC ? " UTC" : ""));
      }
    );
    function defaults$2(a2, b2, c2) {
      if (a2 != null) {
        return a2;
      }
      if (b2 != null) {
        return b2;
      }
      return c2;
    }
    function currentDateArray(config2) {
      var nowValue = new Date(hooks.now());
      if (config2._useUTC) {
        return [
          nowValue.getUTCFullYear(),
          nowValue.getUTCMonth(),
          nowValue.getUTCDate()
        ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config2) {
      var i2, date2, input = [], currentDate, expectedWeekday, yearToUse;
      if (config2._d) {
        return;
      }
      currentDate = currentDateArray(config2);
      if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config2);
      }
      if (config2._dayOfYear != null) {
        yearToUse = defaults$2(config2._a[YEAR], currentDate[YEAR]);
        if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
          getParsingFlags(config2)._overflowDayOfYear = true;
        }
        date2 = createUTCDate(yearToUse, 0, config2._dayOfYear);
        config2._a[MONTH] = date2.getUTCMonth();
        config2._a[DATE] = date2.getUTCDate();
      }
      for (i2 = 0; i2 < 3 && config2._a[i2] == null; ++i2) {
        config2._a[i2] = input[i2] = currentDate[i2];
      }
      for (; i2 < 7; i2++) {
        config2._a[i2] = input[i2] = config2._a[i2] == null ? i2 === 2 ? 1 : 0 : config2._a[i2];
      }
      if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
        config2._nextDay = true;
        config2._a[HOUR] = 0;
      }
      config2._d = (config2._useUTC ? createUTCDate : createDate).apply(
        null,
        input
      );
      expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
      if (config2._tzm != null) {
        config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
      }
      if (config2._nextDay) {
        config2._a[HOUR] = 24;
      }
      if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
        getParsingFlags(config2).weekdayMismatch = true;
      }
    }
    function dayOfYearFromWeekInfo(config2) {
      var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
      w2 = config2._w;
      if (w2.GG != null || w2.W != null || w2.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults$2(
          w2.GG,
          config2._a[YEAR],
          weekOfYear(createLocal(), 1, 4).year
        );
        week = defaults$2(w2.W, 1);
        weekday = defaults$2(w2.E, 1);
        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config2._locale._week.dow;
        doy = config2._locale._week.doy;
        curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults$2(w2.gg, config2._a[YEAR], curWeek.year);
        week = defaults$2(w2.w, curWeek.week);
        if (w2.d != null) {
          weekday = w2.d;
          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w2.e != null) {
          weekday = w2.e + dow;
          if (w2.e < 0 || w2.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday = dow;
        }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config2)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config2)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config2._a[YEAR] = temp.year;
        config2._dayOfYear = temp.dayOfYear;
      }
    }
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    function configFromStringAndFormat(config2) {
      if (config2._f === hooks.ISO_8601) {
        configFromISO(config2);
        return;
      }
      if (config2._f === hooks.RFC_2822) {
        configFromRFC2822(config2);
        return;
      }
      config2._a = [];
      getParsingFlags(config2).empty = true;
      var string2 = "" + config2._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era, tokenLen;
      tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
      tokenLen = tokens2.length;
      for (i2 = 0; i2 < tokenLen; i2++) {
        token2 = tokens2[i2];
        parsedInput = (string2.match(getParseRegexForToken(token2, config2)) || [])[0];
        if (parsedInput) {
          skipped = string2.substr(0, string2.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config2).unusedInput.push(skipped);
          }
          string2 = string2.slice(
            string2.indexOf(parsedInput) + parsedInput.length
          );
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token2]) {
          if (parsedInput) {
            getParsingFlags(config2).empty = false;
          } else {
            getParsingFlags(config2).unusedTokens.push(token2);
          }
          addTimeToArrayFromToken(token2, parsedInput, config2);
        } else if (config2._strict && !parsedInput) {
          getParsingFlags(config2).unusedTokens.push(token2);
        }
      }
      getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
      if (string2.length > 0) {
        getParsingFlags(config2).unusedInput.push(string2);
      }
      if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
        getParsingFlags(config2).bigHour = void 0;
      }
      getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
      getParsingFlags(config2).meridiem = config2._meridiem;
      config2._a[HOUR] = meridiemFixWrap(
        config2._locale,
        config2._a[HOUR],
        config2._meridiem
      );
      era = getParsingFlags(config2).era;
      if (era !== null) {
        config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
      }
      configFromArray(config2);
      checkOverflow(config2);
    }
    function meridiemFixWrap(locale2, hour, meridiem2) {
      var isPm;
      if (meridiem2 == null) {
        return hour;
      }
      if (locale2.meridiemHour != null) {
        return locale2.meridiemHour(hour, meridiem2);
      } else if (locale2.isPM != null) {
        isPm = locale2.isPM(meridiem2);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config2) {
      var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config2._f.length;
      if (configfLen === 0) {
        getParsingFlags(config2).invalidFormat = true;
        config2._d = /* @__PURE__ */ new Date(NaN);
        return;
      }
      for (i2 = 0; i2 < configfLen; i2++) {
        currentScore = 0;
        validFormatFound = false;
        tempConfig = copyConfig({}, config2);
        if (config2._useUTC != null) {
          tempConfig._useUTC = config2._useUTC;
        }
        tempConfig._f = config2._f[i2];
        configFromStringAndFormat(tempConfig);
        if (isValid(tempConfig)) {
          validFormatFound = true;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (!bestFormatIsValid) {
          if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (validFormatFound) {
              bestFormatIsValid = true;
            }
          }
        } else {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
      }
      extend$1(config2, bestMoment || tempConfig);
    }
    function configFromObject(config2) {
      if (config2._d) {
        return;
      }
      var i2 = normalizeObjectUnits(config2._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
      config2._a = map$1(
        [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
        function(obj) {
          return obj && parseInt(obj, 10);
        }
      );
      configFromArray(config2);
    }
    function createFromConfig(config2) {
      var res = new Moment(checkOverflow(prepareConfig(config2)));
      if (res._nextDay) {
        res.add(1, "d");
        res._nextDay = void 0;
      }
      return res;
    }
    function prepareConfig(config2) {
      var input = config2._i, format2 = config2._f;
      config2._locale = config2._locale || getLocale(config2._l);
      if (input === null || format2 === void 0 && input === "") {
        return createInvalid({ nullInput: true });
      }
      if (typeof input === "string") {
        config2._i = input = config2._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config2._d = input;
      } else if (isArray$l(format2)) {
        configFromStringAndArray(config2);
      } else if (format2) {
        configFromStringAndFormat(config2);
      } else {
        configFromInput(config2);
      }
      if (!isValid(config2)) {
        config2._d = null;
      }
      return config2;
    }
    function configFromInput(config2) {
      var input = config2._i;
      if (isUndefined(input)) {
        config2._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config2._d = new Date(input.valueOf());
      } else if (typeof input === "string") {
        configFromString(config2);
      } else if (isArray$l(input)) {
        config2._a = map$1(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config2);
      } else if (isObject$d(input)) {
        configFromObject(config2);
      } else if (isNumber(input)) {
        config2._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config2);
      }
    }
    function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
      var c2 = {};
      if (format2 === true || format2 === false) {
        strict = format2;
        format2 = void 0;
      }
      if (locale2 === true || locale2 === false) {
        strict = locale2;
        locale2 = void 0;
      }
      if (isObject$d(input) && isObjectEmpty(input) || isArray$l(input) && input.length === 0) {
        input = void 0;
      }
      c2._isAMomentObject = true;
      c2._useUTC = c2._isUTC = isUTC;
      c2._l = locale2;
      c2._i = input;
      c2._f = format2;
      c2._strict = strict;
      return createFromConfig(c2);
    }
    function createLocal(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, false);
    }
    var prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    ), prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    function pickBy(fn2, moments) {
      var res, i2;
      if (moments.length === 1 && isArray$l(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return createLocal();
      }
      res = moments[0];
      for (i2 = 1; i2 < moments.length; ++i2) {
        if (!moments[i2].isValid() || moments[i2][fn2](res)) {
          res = moments[i2];
        }
      }
      return res;
    }
    function min$3() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isBefore", args);
    }
    function max$2() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isAfter", args);
    }
    var now = function() {
      return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
    };
    var ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    function isDurationValid(m2) {
      var key, unitHasDecimal = false, i2, orderLen = ordering.length;
      for (key in m2) {
        if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
          return false;
        }
      }
      for (i2 = 0; i2 < orderLen; ++i2) {
        if (m2[ordering[i2]]) {
          if (unitHasDecimal) {
            return false;
          }
          if (parseFloat(m2[ordering[i2]]) !== toInt(m2[ordering[i2]])) {
            unitHasDecimal = true;
          }
        }
      }
      return true;
    }
    function isValid$1() {
      return this._isValid;
    }
    function createInvalid$1() {
      return createDuration(NaN);
    }
    function Duration(duration2) {
      var normalizedInput = normalizeObjectUnits(duration2), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput);
      this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
      minutes2 * 6e4 + // 1000 * 60
      hours2 * 1e3 * 60 * 60;
      this._days = +days2 + weeks2 * 7;
      this._months = +months2 + quarters * 3 + years2 * 12;
      this._data = {};
      this._locale = getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    }
    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
      for (i2 = 0; i2 < len; i2++) {
        if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function offset$1(token2, separator) {
      addFormatToken(token2, 0, 0, function() {
        var offset2 = this.utcOffset(), sign2 = "+";
        if (offset2 < 0) {
          offset2 = -offset2;
          sign2 = "-";
        }
        return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
      });
    }
    offset$1("Z", ":");
    offset$1("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array2, config2) {
      config2._useUTC = true;
      config2._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string2) {
      var matches2 = (string2 || "").match(matcher), chunk, parts, minutes2;
      if (matches2 === null) {
        return null;
      }
      chunk = matches2[matches2.length - 1] || [];
      parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
      minutes2 = +(parts[1] * 60) + toInt(parts[2]);
      return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
    }
    function cloneWithOffset(input, model) {
      var res, diff2;
      if (model._isUTC) {
        res = model.clone();
        diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        res._d.setTime(res._d.valueOf() + diff2);
        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }
    function getDateOffset(m2) {
      return -Math.round(m2._d.getTimezoneOffset());
    }
    hooks.updateOffset = function() {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset2 = this._offset || 0, localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === "string") {
          input = offsetFromString(matchShortOffset, input);
          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, "m");
        }
        if (offset2 !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(
              this,
              createDuration(input - offset2, "m"),
              1,
              false
            );
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset2 : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== "string") {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), "m");
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === "string") {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c2 = {}, other;
      copyConfig(c2, this);
      c2 = prepareConfig(c2);
      if (c2._a) {
        other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
        this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
      var duration2 = input, match = null, sign2, ret, diffRes;
      if (isDuration(input)) {
        duration2 = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input) || !isNaN(+input)) {
        duration2 = {};
        if (key) {
          duration2[key] = +input;
        } else {
          duration2.milliseconds = +input;
        }
      } else if (match = aspNetRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration2 = {
          y: 0,
          d: toInt(match[DATE]) * sign2,
          h: toInt(match[HOUR]) * sign2,
          m: toInt(match[MINUTE]) * sign2,
          s: toInt(match[SECOND]) * sign2,
          ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
          // the millisecond decimal point is included in the match
        };
      } else if (match = isoRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration2 = {
          y: parseIso(match[2], sign2),
          M: parseIso(match[3], sign2),
          w: parseIso(match[4], sign2),
          d: parseIso(match[5], sign2),
          h: parseIso(match[6], sign2),
          m: parseIso(match[7], sign2),
          s: parseIso(match[8], sign2)
        };
      } else if (duration2 == null) {
        duration2 = {};
      } else if (typeof duration2 === "object" && ("from" in duration2 || "to" in duration2)) {
        diffRes = momentsDifference(
          createLocal(duration2.from),
          createLocal(duration2.to)
        );
        duration2 = {};
        duration2.ms = diffRes.milliseconds;
        duration2.M = diffRes.months;
      }
      ret = new Duration(duration2);
      if (isDuration(input) && hasOwnProp(input, "_locale")) {
        ret._locale = input._locale;
      }
      if (isDuration(input) && hasOwnProp(input, "_isValid")) {
        ret._isValid = input._isValid;
      }
      return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign2) {
      var res = inp && parseFloat(inp.replace(",", "."));
      return (isNaN(res) ? 0 : res) * sign2;
    }
    function positiveMomentsDifference(base2, other) {
      var res = {};
      res.months = other.month() - base2.month() + (other.year() - base2.year()) * 12;
      if (base2.clone().add(res.months, "M").isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +base2.clone().add(res.months, "M");
      return res;
    }
    function momentsDifference(base2, other) {
      var res;
      if (!(base2.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
      }
      other = cloneWithOffset(other, base2);
      if (base2.isBefore(other)) {
        res = positiveMomentsDifference(base2, other);
      } else {
        res = positiveMomentsDifference(other, base2);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name2) {
      return function(val, period) {
        var dur, tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(
            name2,
            "moment()." + name2 + "(period, number) is deprecated. Please use moment()." + name2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
          );
          tmp = val;
          val = period;
          period = tmp;
        }
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }
    function addSubtract(mom, duration2, isAdding, updateOffset) {
      var milliseconds2 = duration2._milliseconds, days2 = absRound(duration2._days), months2 = absRound(duration2._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (months2) {
        setMonth(mom, get$2(mom, "Month") + months2 * isAdding);
      }
      if (days2) {
        set$1$1(mom, "Date", get$2(mom, "Date") + days2 * isAdding);
      }
      if (milliseconds2) {
        mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
      }
      if (updateOffset) {
        hooks.updateOffset(mom, days2 || months2);
      }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString$2(input) {
      return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
      return isMoment(input) || isDate(input) || isString$2(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
    }
    function isMomentInputObject(input) {
      var objectTest = isObject$d(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "years",
        "year",
        "y",
        "months",
        "month",
        "M",
        "days",
        "day",
        "d",
        "dates",
        "date",
        "D",
        "hours",
        "hour",
        "h",
        "minutes",
        "minute",
        "m",
        "seconds",
        "second",
        "s",
        "milliseconds",
        "millisecond",
        "ms"
      ], i2, property2, propertyLen = properties.length;
      for (i2 = 0; i2 < propertyLen; i2 += 1) {
        property2 = properties[i2];
        propertyTest = propertyTest || hasOwnProp(input, property2);
      }
      return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
      var arrayTest = isArray$l(input), dataTypeTest = false;
      if (arrayTest) {
        dataTypeTest = input.filter(function(item) {
          return !isNumber(item) && isString$2(input);
        }).length === 0;
      }
      return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
      var objectTest = isObject$d(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "sameDay",
        "nextDay",
        "lastDay",
        "nextWeek",
        "lastWeek",
        "sameElse"
      ], i2, property2;
      for (i2 = 0; i2 < properties.length; i2 += 1) {
        property2 = properties[i2];
        propertyTest = propertyTest || hasOwnProp(input, property2);
      }
      return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now2) {
      var diff2 = myMoment.diff(now2, "days", true);
      return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats2) {
      if (arguments.length === 1) {
        if (!arguments[0]) {
          time = void 0;
          formats2 = void 0;
        } else if (isMomentInput(arguments[0])) {
          time = arguments[0];
          formats2 = void 0;
        } else if (isCalendarSpec(arguments[0])) {
          formats2 = arguments[0];
          time = void 0;
        }
      }
      var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats2 && (isFunction$5(formats2[format2]) ? formats2[format2].call(this, now2) : formats2[format2]);
      return this.format(
        output || this.localeData().calendar(format2, this, createLocal(now2))
      );
    }
    function clone$2() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }
    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }
    function isBetween$1(from2, to2, units, inclusivity) {
      var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }
      inclusivity = inclusivity || "()";
      return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input), inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }
    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
      var that, zoneDelta, output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);
      switch (units) {
        case "year":
          output = monthDiff(this, that) / 12;
          break;
        case "month":
          output = monthDiff(this, that);
          break;
        case "quarter":
          output = monthDiff(this, that) / 3;
          break;
        case "second":
          output = (this - that) / 1e3;
          break;
        case "minute":
          output = (this - that) / 6e4;
          break;
        case "hour":
          output = (this - that) / 36e5;
          break;
        case "day":
          output = (this - that - zoneDelta) / 864e5;
          break;
        case "week":
          output = (this - that - zoneDelta) / 6048e5;
          break;
        default:
          output = this - that;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a2, b2) {
      if (a2.date() < b2.date()) {
        return -monthDiff(b2, a2);
      }
      var wholeMonthDiff = (b2.year() - a2.year()) * 12 + (b2.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
      if (b2 - anchor < 0) {
        anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
        adjust = (b2 - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
        adjust = (b2 - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString$a() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }
      var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
      if (m2.year() < 0 || m2.year() > 9999) {
        return formatMoment(
          m2,
          utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      if (isFunction$5(Date.prototype.toISOString)) {
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
        }
      }
      return formatMoment(
        m2,
        utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
      );
    }
    function inspect() {
      if (!this.isValid()) {
        return "moment.invalid(/* " + this._i + " */)";
      }
      var func = "moment", zone = "", prefix, year, datetime, suffix;
      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
        zone = "Z";
      }
      prefix = "[" + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
      datetime = "-MM-DD[T]HH:mm:ss.SSS";
      suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
      var newLocaleData;
      if (key === void 0) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    function localeData() {
      return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y2, m2, d2) {
      if (y2 < 100 && y2 >= 0) {
        return new Date(y2 + 400, m2, d2) - MS_PER_400_YEARS;
      } else {
        return new Date(y2, m2, d2).valueOf();
      }
    }
    function utcStartOfDate(y2, m2, d2) {
      if (y2 < 100 && y2 >= 0) {
        return Date.UTC(y2 + 400, m2, d2) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y2, m2, d2);
      }
    }
    function startOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year(), 0, 1);
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3,
            1
          );
          break;
        case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday()
          );
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1)
          );
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;
        case "hour":
          time = this._d.valueOf();
          time -= mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          );
          break;
        case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;
        case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function endOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3 + 3,
            1
          ) - 1;
          break;
        case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday() + 7
          ) - 1;
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1) + 7
          ) - 1;
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          ) - 1;
          break;
        case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;
        case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
      return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
      return new Date(this.valueOf());
    }
    function toArray() {
      var m2 = this;
      return [
        m2.year(),
        m2.month(),
        m2.date(),
        m2.hour(),
        m2.minute(),
        m2.second(),
        m2.millisecond()
      ];
    }
    function toObject() {
      var m2 = this;
      return {
        years: m2.year(),
        months: m2.month(),
        date: m2.date(),
        hours: m2.hours(),
        minutes: m2.minutes(),
        seconds: m2.seconds(),
        milliseconds: m2.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
      return isValid(this);
    }
    function parsingFlags() {
      return extend$1({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array2, config2, token2) {
        var era = config2._locale.erasParse(input, token2, config2._strict);
        if (era) {
          getParsingFlags(config2).era = era;
        } else {
          getParsingFlags(config2).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array2, config2, token2) {
      var match;
      if (config2._locale._eraYearOrdinalRegex) {
        match = input.match(config2._locale._eraYearOrdinalRegex);
      }
      if (config2._locale.eraYearOrdinalParse) {
        array2[YEAR] = config2._locale.eraYearOrdinalParse(input, match);
      } else {
        array2[YEAR] = parseInt(input, 10);
      }
    });
    function localeEras(m2, format2) {
      var i2, l2, date2, eras = this._eras || getLocale("en")._eras;
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        switch (typeof eras[i2].since) {
          case "string":
            date2 = hooks(eras[i2].since).startOf("day");
            eras[i2].since = date2.valueOf();
            break;
        }
        switch (typeof eras[i2].until) {
          case "undefined":
            eras[i2].until = Infinity;
            break;
          case "string":
            date2 = hooks(eras[i2].until).startOf("day").valueOf();
            eras[i2].until = date2.valueOf();
            break;
        }
      }
      return eras;
    }
    function localeErasParse(eraName, format2, strict) {
      var i2, l2, eras = this.eras(), name2, abbr, narrow;
      eraName = eraName.toUpperCase();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        name2 = eras[i2].name.toUpperCase();
        abbr = eras[i2].abbr.toUpperCase();
        narrow = eras[i2].narrow.toUpperCase();
        if (strict) {
          switch (format2) {
            case "N":
            case "NN":
            case "NNN":
              if (abbr === eraName) {
                return eras[i2];
              }
              break;
            case "NNNN":
              if (name2 === eraName) {
                return eras[i2];
              }
              break;
            case "NNNNN":
              if (narrow === eraName) {
                return eras[i2];
              }
              break;
          }
        } else if ([name2, abbr, narrow].indexOf(eraName) >= 0) {
          return eras[i2];
        }
      }
    }
    function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? 1 : -1;
      if (year === void 0) {
        return hooks(era.since).year();
      } else {
        return hooks(era.since).year() + (year - era.offset) * dir;
      }
    }
    function getEraName() {
      var i2, l2, val, eras = this.localeData().eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until) {
          return eras[i2].name;
        }
        if (eras[i2].until <= val && val <= eras[i2].since) {
          return eras[i2].name;
        }
      }
      return "";
    }
    function getEraNarrow() {
      var i2, l2, val, eras = this.localeData().eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until) {
          return eras[i2].narrow;
        }
        if (eras[i2].until <= val && val <= eras[i2].since) {
          return eras[i2].narrow;
        }
      }
      return "";
    }
    function getEraAbbr() {
      var i2, l2, val, eras = this.localeData().eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until) {
          return eras[i2].abbr;
        }
        if (eras[i2].until <= val && val <= eras[i2].since) {
          return eras[i2].abbr;
        }
      }
      return "";
    }
    function getEraYear() {
      var i2, l2, dir, val, eras = this.localeData().eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        dir = eras[i2].since <= eras[i2].until ? 1 : -1;
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
          return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
        }
      }
      return this.year();
    }
    function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNameRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, "_erasAbbrRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNarrowRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale2) {
      return locale2.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale2) {
      return locale2.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale2) {
      return locale2.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale2) {
      return locale2._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
      var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l2, erasName, erasAbbr, erasNarrow, eras = this.eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        erasName = regexEscape(eras[i2].name);
        erasAbbr = regexEscape(eras[i2].abbr);
        erasNarrow = regexEscape(eras[i2].narrow);
        namePieces.push(erasName);
        abbrPieces.push(erasAbbr);
        narrowPieces.push(erasNarrow);
        mixedPieces.push(erasName);
        mixedPieces.push(erasAbbr);
        mixedPieces.push(erasNarrow);
      }
      this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
      this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
      this._erasNarrowRegex = new RegExp(
        "^(" + narrowPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token2, getter) {
      addFormatToken(0, [token2, token2.length], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config2, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week, config2, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.week(),
        this.weekday() + this.localeData()._week.dow,
        this.localeData()._week.dow,
        this.localeData()._week.doy
      );
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.isoWeek(),
        this.isoWeekday(),
        1,
        4
      );
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
          week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date2 = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date2.getUTCFullYear());
      this.month(date2.getUTCMonth());
      this.date(date2.getUTCDate());
      return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array2) {
      array2[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", ["DD", 2], "Do", "date");
    addRegexToken("D", match1to2, match1to2NoLeadingZero);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array2) {
      array2[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array2, config2) {
      config2._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round(
        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
      ) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", ["mm", 2], 0, "minute");
    addRegexToken("m", match1to2, match1to2HasZero);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addRegexToken("s", match1to2, match1to2HasZero);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token, getSetMillisecond;
    for (token = "SSSS"; token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array2) {
      array2[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
      return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone$2;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween$1;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString$a;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    function createUnix(input) {
      return createLocal(input * 1e3);
    }
    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string2) {
      return string2;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set$1;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1$1(format2, index2, field, setter) {
      var locale2 = getLocale(), utc = createUTC().set(setter, index2);
      return locale2[field](utc, format2);
    }
    function listMonthsImpl(format2, index2, field) {
      if (isNumber(format2)) {
        index2 = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
      if (index2 != null) {
        return get$1$1(format2, index2, field, "month");
      }
      var i2, out = [];
      for (i2 = 0; i2 < 12; i2++) {
        out[i2] = get$1$1(format2, i2, field, "month");
      }
      return out;
    }
    function listWeekdaysImpl(localeSorted, format2, index2, field) {
      if (typeof localeSorted === "boolean") {
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      } else {
        format2 = localeSorted;
        index2 = format2;
        localeSorted = false;
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      }
      var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
      if (index2 != null) {
        return get$1$1(format2, (index2 + shift) % 7, field, "day");
      }
      for (i2 = 0; i2 < 7; i2++) {
        out[i2] = get$1$1(format2, (i2 + shift) % 7, field, "day");
      }
      return out;
    }
    function listMonths(format2, index2) {
      return listMonthsImpl(format2, index2, "months");
    }
    function listMonthsShort(format2, index2) {
      return listMonthsImpl(format2, index2, "monthsShort");
    }
    function listWeekdays(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b2 = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale
    );
    var mathAbs = Math.abs;
    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function addSubtract$1(duration2, input, value, direction) {
      var other = createDuration(input, value);
      duration2._milliseconds += direction * other._milliseconds;
      duration2._days += direction * other._days;
      duration2._months += direction * other._months;
      return duration2._bubble();
    }
    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }
    function bubble() {
      var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
      if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
        milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
        days2 = 0;
        months2 = 0;
      }
      data.milliseconds = milliseconds2 % 1e3;
      seconds2 = absFloor(milliseconds2 / 1e3);
      data.seconds = seconds2 % 60;
      minutes2 = absFloor(seconds2 / 60);
      data.minutes = minutes2 % 60;
      hours2 = absFloor(minutes2 / 60);
      data.hours = hours2 % 24;
      days2 += absFloor(hours2 / 24);
      monthsFromDays = absFloor(daysToMonths(days2));
      months2 += monthsFromDays;
      days2 -= absCeil(monthsToDays(monthsFromDays));
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      data.days = days2;
      data.months = months2;
      data.years = years2;
      return this;
    }
    function daysToMonths(days2) {
      return days2 * 4800 / 146097;
    }
    function monthsToDays(months2) {
      return months2 * 146097 / 4800;
    }
    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }
      var days2, months2, milliseconds2 = this._milliseconds;
      units = normalizeUnits(units);
      if (units === "month" || units === "quarter" || units === "year") {
        days2 = this._days + milliseconds2 / 864e5;
        months2 = this._months + daysToMonths(days2);
        switch (units) {
          case "month":
            return months2;
          case "quarter":
            return months2 / 3;
          case "year":
            return months2 / 12;
        }
      } else {
        days2 = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case "week":
            return days2 / 7 + milliseconds2 / 6048e5;
          case "day":
            return days2 + milliseconds2 / 864e5;
          case "hour":
            return days2 * 24 + milliseconds2 / 36e5;
          case "minute":
            return days2 * 1440 + milliseconds2 / 6e4;
          case "second":
            return days2 * 86400 + milliseconds2 / 1e3;
          case "millisecond":
            return Math.floor(days2 * 864e5) + milliseconds2;
          default:
            throw new Error("Unknown unit " + units);
        }
      }
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
    function clone$1$1() {
      return createDuration(this);
    }
    function get$2$1(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name2) {
      return function() {
        return this.isValid() ? this._data[name2] : NaN;
      };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round$1 = Math.round, thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month/week
      w: null,
      // weeks to month
      M: 11
      // months to year
    };
    function substituteTimeAgo(string2, number, withoutSuffix, isFuture, locale2) {
      return locale2.relativeTime(number || 1, !!withoutSuffix, string2, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
      var duration2 = createDuration(posNegDuration).abs(), seconds2 = round$1(duration2.as("s")), minutes2 = round$1(duration2.as("m")), hours2 = round$1(duration2.as("h")), days2 = round$1(duration2.as("d")), months2 = round$1(duration2.as("M")), weeks2 = round$1(duration2.as("w")), years2 = round$1(duration2.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
      if (thresholds2.w != null) {
        a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
      }
      a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
      a2[2] = withoutSuffix;
      a2[3] = +posNegDuration > 0;
      a2[4] = locale2;
      return substituteTimeAgo.apply(null, a2);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === void 0) {
        return round$1;
      }
      if (typeof roundingFunction === "function") {
        round$1 = roundingFunction;
        return true;
      }
      return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit2) {
      if (thresholds[threshold] === void 0) {
        return false;
      }
      if (limit2 === void 0) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit2;
      if (threshold === "s") {
        thresholds.ss = limit2 - 1;
      }
      return true;
    }
    function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var withSuffix = false, th = thresholds, locale2, output;
      if (typeof argWithSuffix === "object") {
        argThresholds = argWithSuffix;
        argWithSuffix = false;
      }
      if (typeof argWithSuffix === "boolean") {
        withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === "object") {
        th = Object.assign({}, thresholds, argThresholds);
        if (argThresholds.s != null && argThresholds.ss == null) {
          th.ss = argThresholds.s - 1;
        }
      }
      locale2 = this.localeData();
      output = relativeTime$1(this, !withSuffix, th, locale2);
      if (withSuffix) {
        output = locale2.pastFuture(+this, output);
      }
      return locale2.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x2) {
      return (x2 > 0) - (x2 < 0) || +x2;
    }
    function toISOString$1() {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
      if (!total) {
        return "P0D";
      }
      minutes2 = absFloor(seconds2 / 60);
      hours2 = absFloor(minutes2 / 60);
      seconds2 %= 60;
      minutes2 %= 60;
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
      totalSign = total < 0 ? "-" : "";
      ymSign = sign(this._months) !== sign(total) ? "-" : "";
      daysSign = sign(this._days) !== sign(total) ? "-" : "";
      hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
      return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1$1;
    proto$2.get = get$2$1;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array2, config2) {
      config2._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array2, config2) {
      config2._d = new Date(toInt(input));
    });
    //! moment.js
    hooks.version = "2.30.1";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min$3;
    hooks.max = max$2;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      // <input type="datetime-local" step="0.001" />
      DATE: "YYYY-MM-DD",
      // <input type="date" />
      TIME: "HH:mm",
      // <input type="time" />
      TIME_SECONDS: "HH:mm:ss",
      // <input type="time" step="1" />
      TIME_MS: "HH:mm:ss.SSS",
      // <input type="time" step="0.001" />
      WEEK: "GGGG-[W]WW",
      // <input type="week" />
      MONTH: "YYYY-MM"
      // <input type="month" />
    };
    /*!
     * Vueform v1.10.3 (https://github.com/vueform/vueform)
     * Copyright (c) 2024 Adam Berecz <adam@vueform.com>
     * Licensed under the MIT License
     */
    function asyncGeneratorStep(n2, t2, e2, r2, o2, a2, c2) {
      try {
        var i2 = n2[a2](c2), u2 = i2.value;
      } catch (n3) {
        return void e2(n3);
      }
      i2.done ? t2(u2) : Promise.resolve(u2).then(r2, o2);
    }
    function _asyncToGenerator(n2) {
      return function() {
        var t2 = this, e2 = arguments;
        return new Promise(function(r2, o2) {
          var a2 = n2.apply(t2, e2);
          function _next(n3) {
            asyncGeneratorStep(a2, r2, o2, _next, _throw, "next", n3);
          }
          function _throw(n3) {
            asyncGeneratorStep(a2, r2, o2, _next, _throw, "throw", n3);
          }
          _next(void 0);
        });
      };
    }
    function _defineProperty$2(e2, r2, t2) {
      return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
        value: t2,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e2[r2] = t2, e2;
    }
    function ownKeys$1(e2, r2) {
      var t2 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var o2 = Object.getOwnPropertySymbols(e2);
        r2 && (o2 = o2.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
        })), t2.push.apply(t2, o2);
      }
      return t2;
    }
    function _objectSpread2$1(e2) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
          _defineProperty$2(e2, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e2;
    }
    function _toPrimitive(t2, r2) {
      if ("object" != typeof t2 || !t2)
        return t2;
      var e2 = t2[Symbol.toPrimitive];
      if (void 0 !== e2) {
        var i2 = e2.call(t2, r2 || "default");
        if ("object" != typeof i2)
          return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _toPropertyKey(t2) {
      var i2 = _toPrimitive(t2, "string");
      return "symbol" == typeof i2 ? i2 : i2 + "";
    }
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    var each$1 = { exports: {} };
    function arrayEach$2(array2, iteratee) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (iteratee(array2[index2], index2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    var _arrayEach = arrayEach$2;
    function createBaseFor$1(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    var _createBaseFor = createBaseFor$1;
    var createBaseFor = _createBaseFor;
    var baseFor$2 = createBaseFor();
    var _baseFor = baseFor$2;
    function baseTimes$1(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    var _baseTimes = baseTimes$1;
    var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var _freeGlobal = freeGlobal$1;
    var freeGlobal = _freeGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root$8 = freeGlobal || freeSelf || Function("return this")();
    var _root = root$8;
    var root$7 = _root;
    var Symbol$7 = root$7.Symbol;
    var _Symbol = Symbol$7;
    var Symbol$6 = _Symbol;
    var objectProto$g = Object.prototype;
    var hasOwnProperty$e = objectProto$g.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$g.toString;
    var symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
    function getRawTag$1(value) {
      var isOwn = hasOwnProperty$e.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var _getRawTag = getRawTag$1;
    var objectProto$f = Object.prototype;
    var nativeObjectToString = objectProto$f.toString;
    function objectToString$1(value) {
      return nativeObjectToString.call(value);
    }
    var _objectToString = objectToString$1;
    var Symbol$5 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
    function baseGetTag$7(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    var _baseGetTag = baseGetTag$7;
    function isObjectLike$a(value) {
      return value != null && typeof value == "object";
    }
    var isObjectLike_1 = isObjectLike$a;
    var baseGetTag$6 = _baseGetTag, isObjectLike$9 = isObjectLike_1;
    var argsTag$3 = "[object Arguments]";
    function baseIsArguments$1(value) {
      return isObjectLike$9(value) && baseGetTag$6(value) == argsTag$3;
    }
    var _baseIsArguments = baseIsArguments$1;
    var baseIsArguments = _baseIsArguments, isObjectLike$8 = isObjectLike_1;
    var objectProto$e = Object.prototype;
    var hasOwnProperty$d = objectProto$e.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable;
    var isArguments$5 = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike$8(value) && hasOwnProperty$d.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    var isArguments_1 = isArguments$5;
    var isArray$k = Array.isArray;
    var isArray_1 = isArray$k;
    var isBuffer$6 = { exports: {} };
    function stubFalse() {
      return false;
    }
    var stubFalse_1 = stubFalse;
    (function(module2, exports2) {
      var root2 = _root, stubFalse2 = stubFalse_1;
      var freeExports = exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root2.Buffer : void 0;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer2 = nativeIsBuffer || stubFalse2;
      module2.exports = isBuffer2;
    })(isBuffer$6, isBuffer$6.exports);
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex$4(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    var _isIndex = isIndex$4;
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength$3(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    var isLength_1 = isLength$3;
    var baseGetTag$5 = _baseGetTag, isLength$2 = isLength_1, isObjectLike$7 = isObjectLike_1;
    var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", mapTag$6 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$6 = "[object Set]", stringTag$4 = "[object String]", weakMapTag$2 = "[object WeakMap]";
    var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;
    function baseIsTypedArray$1(value) {
      return isObjectLike$7(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$5(value)];
    }
    var _baseIsTypedArray = baseIsTypedArray$1;
    function baseUnary$5(func) {
      return function(value) {
        return func(value);
      };
    }
    var _baseUnary = baseUnary$5;
    var _nodeUtil = { exports: {} };
    (function(module2, exports2) {
      var freeGlobal2 = _freeGlobal;
      var freeExports = exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal2.process;
      var nodeUtil2 = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      module2.exports = nodeUtil2;
    })(_nodeUtil, _nodeUtil.exports);
    var baseIsTypedArray = _baseIsTypedArray, baseUnary$4 = _baseUnary, nodeUtil$2 = _nodeUtil.exports;
    var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
    var isTypedArray$4 = nodeIsTypedArray ? baseUnary$4(nodeIsTypedArray) : baseIsTypedArray;
    var isTypedArray_1 = isTypedArray$4;
    var baseTimes = _baseTimes, isArguments$4 = isArguments_1, isArray$j = isArray_1, isBuffer$5 = isBuffer$6.exports, isIndex$3 = _isIndex, isTypedArray$3 = isTypedArray_1;
    var objectProto$d = Object.prototype;
    var hasOwnProperty$c = objectProto$d.hasOwnProperty;
    function arrayLikeKeys$2(value, inherited) {
      var isArr = isArray$j(value), isArg = !isArr && isArguments$4(value), isBuff = !isArr && !isArg && isBuffer$5(value), isType = !isArr && !isArg && !isBuff && isTypedArray$3(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$c.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex$3(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    var _arrayLikeKeys = arrayLikeKeys$2;
    var objectProto$c = Object.prototype;
    function isPrototype$4(value) {
      var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$c;
      return value === proto2;
    }
    var _isPrototype = isPrototype$4;
    function overArg$2(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var _overArg = overArg$2;
    var overArg$1 = _overArg;
    var nativeKeys$1 = overArg$1(Object.keys, Object);
    var _nativeKeys = nativeKeys$1;
    var isPrototype$3 = _isPrototype, nativeKeys = _nativeKeys;
    var objectProto$b = Object.prototype;
    var hasOwnProperty$b = objectProto$b.hasOwnProperty;
    function baseKeys$2(object2) {
      if (!isPrototype$3(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty$b.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    var _baseKeys = baseKeys$2;
    function isObject$b(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    var isObject_1 = isObject$b;
    var baseGetTag$4 = _baseGetTag, isObject$a = isObject_1;
    var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction$4(value) {
      if (!isObject$a(value)) {
        return false;
      }
      var tag = baseGetTag$4(value);
      return tag == funcTag$1 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }
    var isFunction_1 = isFunction$4;
    var isFunction$3 = isFunction_1, isLength$1 = isLength_1;
    function isArrayLike$9(value) {
      return value != null && isLength$1(value.length) && !isFunction$3(value);
    }
    var isArrayLike_1 = isArrayLike$9;
    var arrayLikeKeys$1 = _arrayLikeKeys, baseKeys$1 = _baseKeys, isArrayLike$8 = isArrayLike_1;
    function keys$7(object2) {
      return isArrayLike$8(object2) ? arrayLikeKeys$1(object2) : baseKeys$1(object2);
    }
    var keys_1 = keys$7;
    var baseFor$1 = _baseFor, keys$6 = keys_1;
    function baseForOwn$2(object2, iteratee) {
      return object2 && baseFor$1(object2, iteratee, keys$6);
    }
    var _baseForOwn = baseForOwn$2;
    var isArrayLike$7 = isArrayLike_1;
    function createBaseEach$1(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike$7(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index2-- : ++index2 < length) {
          if (iteratee(iterable[index2], index2, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    var _createBaseEach = createBaseEach$1;
    var baseForOwn$1 = _baseForOwn, createBaseEach = _createBaseEach;
    var baseEach$5 = createBaseEach(baseForOwn$1);
    var _baseEach = baseEach$5;
    function identity$5(value) {
      return value;
    }
    var identity_1 = identity$5;
    var identity$4 = identity_1;
    function castFunction$1(value) {
      return typeof value == "function" ? value : identity$4;
    }
    var _castFunction = castFunction$1;
    var arrayEach$1 = _arrayEach, baseEach$4 = _baseEach, castFunction = _castFunction, isArray$i = isArray_1;
    function forEach(collection, iteratee) {
      var func = isArray$i(collection) ? arrayEach$1 : baseEach$4;
      return func(collection, castFunction(iteratee));
    }
    var forEach_1 = forEach;
    (function(module2) {
      module2.exports = forEach_1;
    })(each$1);
    var each = /* @__PURE__ */ getDefaultExportFromCjs(each$1.exports);
    function listCacheClear$1() {
      this.__data__ = [];
      this.size = 0;
    }
    var _listCacheClear = listCacheClear$1;
    function eq$5(value, other) {
      return value === other || value !== value && other !== other;
    }
    var eq_1 = eq$5;
    var eq$4 = eq_1;
    function assocIndexOf$4(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq$4(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var _assocIndexOf = assocIndexOf$4;
    var assocIndexOf$3 = _assocIndexOf;
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete$1(key) {
      var data = this.__data__, index2 = assocIndexOf$3(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    var _listCacheDelete = listCacheDelete$1;
    var assocIndexOf$2 = _assocIndexOf;
    function listCacheGet$1(key) {
      var data = this.__data__, index2 = assocIndexOf$2(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    var _listCacheGet = listCacheGet$1;
    var assocIndexOf$1 = _assocIndexOf;
    function listCacheHas$1(key) {
      return assocIndexOf$1(this.__data__, key) > -1;
    }
    var _listCacheHas = listCacheHas$1;
    var assocIndexOf = _assocIndexOf;
    function listCacheSet$1(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    var _listCacheSet = listCacheSet$1;
    var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
    function ListCache$4(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache$4.prototype.clear = listCacheClear;
    ListCache$4.prototype["delete"] = listCacheDelete;
    ListCache$4.prototype.get = listCacheGet;
    ListCache$4.prototype.has = listCacheHas;
    ListCache$4.prototype.set = listCacheSet;
    var _ListCache = ListCache$4;
    var ListCache$3 = _ListCache;
    function stackClear$1() {
      this.__data__ = new ListCache$3();
      this.size = 0;
    }
    var _stackClear = stackClear$1;
    function stackDelete$1(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    var _stackDelete = stackDelete$1;
    function stackGet$1(key) {
      return this.__data__.get(key);
    }
    var _stackGet = stackGet$1;
    function stackHas$1(key) {
      return this.__data__.has(key);
    }
    var _stackHas = stackHas$1;
    var root$6 = _root;
    var coreJsData$1 = root$6["__core-js_shared__"];
    var _coreJsData = coreJsData$1;
    var coreJsData = _coreJsData;
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked$1(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var _isMasked = isMasked$1;
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource$2(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    var _toSource = toSource$2;
    var isFunction$2 = isFunction_1, isMasked = _isMasked, isObject$9 = isObject_1, toSource$1 = _toSource;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$a = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$a = objectProto$a.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative$1(value) {
      if (!isObject$9(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource$1(value));
    }
    var _baseIsNative = baseIsNative$1;
    function getValue$1(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    var _getValue = getValue$1;
    var baseIsNative = _baseIsNative, getValue = _getValue;
    function getNative$7(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var _getNative = getNative$7;
    var getNative$6 = _getNative, root$5 = _root;
    var Map$4 = getNative$6(root$5, "Map");
    var _Map = Map$4;
    var getNative$5 = _getNative;
    var nativeCreate$4 = getNative$5(Object, "create");
    var _nativeCreate = nativeCreate$4;
    var nativeCreate$3 = _nativeCreate;
    function hashClear$1() {
      this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
      this.size = 0;
    }
    var _hashClear = hashClear$1;
    function hashDelete$1(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var _hashDelete = hashDelete$1;
    var nativeCreate$2 = _nativeCreate;
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
    function hashGet$1(key) {
      var data = this.__data__;
      if (nativeCreate$2) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
    }
    var _hashGet = hashGet$1;
    var nativeCreate$1 = _nativeCreate;
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
    function hashHas$1(key) {
      var data = this.__data__;
      return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
    }
    var _hashHas = hashHas$1;
    var nativeCreate = _nativeCreate;
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet$1(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
      return this;
    }
    var _hashSet = hashSet$1;
    var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
    function Hash$1(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash$1.prototype.clear = hashClear;
    Hash$1.prototype["delete"] = hashDelete;
    Hash$1.prototype.get = hashGet;
    Hash$1.prototype.has = hashHas;
    Hash$1.prototype.set = hashSet;
    var _Hash = Hash$1;
    var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
    function mapCacheClear$1() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$3 || ListCache$2)(),
        "string": new Hash()
      };
    }
    var _mapCacheClear = mapCacheClear$1;
    function isKeyable$1(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    var _isKeyable = isKeyable$1;
    var isKeyable = _isKeyable;
    function getMapData$4(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    var _getMapData = getMapData$4;
    var getMapData$3 = _getMapData;
    function mapCacheDelete$1(key) {
      var result = getMapData$3(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    var _mapCacheDelete = mapCacheDelete$1;
    var getMapData$2 = _getMapData;
    function mapCacheGet$1(key) {
      return getMapData$2(this, key).get(key);
    }
    var _mapCacheGet = mapCacheGet$1;
    var getMapData$1 = _getMapData;
    function mapCacheHas$1(key) {
      return getMapData$1(this, key).has(key);
    }
    var _mapCacheHas = mapCacheHas$1;
    var getMapData = _getMapData;
    function mapCacheSet$1(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    var _mapCacheSet = mapCacheSet$1;
    var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
    function MapCache$3(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache$3.prototype.clear = mapCacheClear;
    MapCache$3.prototype["delete"] = mapCacheDelete;
    MapCache$3.prototype.get = mapCacheGet;
    MapCache$3.prototype.has = mapCacheHas;
    MapCache$3.prototype.set = mapCacheSet;
    var _MapCache = MapCache$3;
    var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$2 = _MapCache;
    var LARGE_ARRAY_SIZE$2 = 200;
    function stackSet$1(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache$1) {
        var pairs = data.__data__;
        if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache$2(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    var _stackSet = stackSet$1;
    var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
    function Stack$4(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack$4.prototype.clear = stackClear;
    Stack$4.prototype["delete"] = stackDelete;
    Stack$4.prototype.get = stackGet;
    Stack$4.prototype.has = stackHas;
    Stack$4.prototype.set = stackSet;
    var _Stack = Stack$4;
    var getNative$4 = _getNative;
    var defineProperty$2 = function() {
      try {
        var func = getNative$4(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    var _defineProperty$1 = defineProperty$2;
    var defineProperty$1 = _defineProperty$1;
    function baseAssignValue$4(object2, key, value) {
      if (key == "__proto__" && defineProperty$1) {
        defineProperty$1(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    var _baseAssignValue = baseAssignValue$4;
    var baseAssignValue$3 = _baseAssignValue, eq$3 = eq_1;
    function assignMergeValue$2(object2, key, value) {
      if (value !== void 0 && !eq$3(object2[key], value) || value === void 0 && !(key in object2)) {
        baseAssignValue$3(object2, key, value);
      }
    }
    var _assignMergeValue = assignMergeValue$2;
    var _cloneBuffer = { exports: {} };
    (function(module2, exports2) {
      var root2 = _root;
      var freeExports = exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer2(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      module2.exports = cloneBuffer2;
    })(_cloneBuffer, _cloneBuffer.exports);
    var root$4 = _root;
    var Uint8Array$2 = root$4.Uint8Array;
    var _Uint8Array = Uint8Array$2;
    var Uint8Array$1 = _Uint8Array;
    function cloneArrayBuffer$3(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
      return result;
    }
    var _cloneArrayBuffer = cloneArrayBuffer$3;
    var cloneArrayBuffer$2 = _cloneArrayBuffer;
    function cloneTypedArray$2(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    var _cloneTypedArray = cloneTypedArray$2;
    function copyArray$3(source, array2) {
      var index2 = -1, length = source.length;
      array2 || (array2 = Array(length));
      while (++index2 < length) {
        array2[index2] = source[index2];
      }
      return array2;
    }
    var _copyArray = copyArray$3;
    var isObject$8 = isObject_1;
    var objectCreate = Object.create;
    var baseCreate$1 = function() {
      function object2() {
      }
      return function(proto2) {
        if (!isObject$8(proto2)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto2);
        }
        object2.prototype = proto2;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    var _baseCreate = baseCreate$1;
    var overArg = _overArg;
    var getPrototype$3 = overArg(Object.getPrototypeOf, Object);
    var _getPrototype = getPrototype$3;
    var baseCreate = _baseCreate, getPrototype$2 = _getPrototype, isPrototype$2 = _isPrototype;
    function initCloneObject$2(object2) {
      return typeof object2.constructor == "function" && !isPrototype$2(object2) ? baseCreate(getPrototype$2(object2)) : {};
    }
    var _initCloneObject = initCloneObject$2;
    var isArrayLike$6 = isArrayLike_1, isObjectLike$6 = isObjectLike_1;
    function isArrayLikeObject$4(value) {
      return isObjectLike$6(value) && isArrayLike$6(value);
    }
    var isArrayLikeObject_1 = isArrayLikeObject$4;
    var baseGetTag$3 = _baseGetTag, getPrototype$1 = _getPrototype, isObjectLike$5 = isObjectLike_1;
    var objectTag$3 = "[object Object]";
    var funcProto = Function.prototype, objectProto$7 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject$2(value) {
      if (!isObjectLike$5(value) || baseGetTag$3(value) != objectTag$3) {
        return false;
      }
      var proto2 = getPrototype$1(value);
      if (proto2 === null) {
        return true;
      }
      var Ctor = hasOwnProperty$7.call(proto2, "constructor") && proto2.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isPlainObject_1 = isPlainObject$2;
    function safeGet$2(object2, key) {
      if (key === "constructor" && typeof object2[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object2[key];
    }
    var _safeGet = safeGet$2;
    var baseAssignValue$2 = _baseAssignValue, eq$2 = eq_1;
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
    function assignValue$3(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty$6.call(object2, key) && eq$2(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue$2(object2, key, value);
      }
    }
    var _assignValue = assignValue$3;
    var assignValue$2 = _assignValue, baseAssignValue$1 = _baseAssignValue;
    function copyObject$6(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index2 = -1, length = props.length;
      while (++index2 < length) {
        var key = props[index2];
        var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue$1(object2, key, newValue);
        } else {
          assignValue$2(object2, key, newValue);
        }
      }
      return object2;
    }
    var _copyObject = copyObject$6;
    function nativeKeysIn$1(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    var _nativeKeysIn = nativeKeysIn$1;
    var isObject$7 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
    function baseKeysIn$1(object2) {
      if (!isObject$7(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype$1(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    var _baseKeysIn = baseKeysIn$1;
    var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$5 = isArrayLike_1;
    function keysIn$5(object2) {
      return isArrayLike$5(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    var keysIn_1 = keysIn$5;
    var copyObject$5 = _copyObject, keysIn$4 = keysIn_1;
    function toPlainObject$1(value) {
      return copyObject$5(value, keysIn$4(value));
    }
    var toPlainObject_1 = toPlainObject$1;
    var assignMergeValue$1 = _assignMergeValue, cloneBuffer$1 = _cloneBuffer.exports, cloneTypedArray$1 = _cloneTypedArray, copyArray$2 = _copyArray, initCloneObject$1 = _initCloneObject, isArguments$3 = isArguments_1, isArray$h = isArray_1, isArrayLikeObject$3 = isArrayLikeObject_1, isBuffer$4 = isBuffer$6.exports, isFunction$1 = isFunction_1, isObject$6 = isObject_1, isPlainObject$1 = isPlainObject_1, isTypedArray$2 = isTypedArray_1, safeGet$1 = _safeGet, toPlainObject = toPlainObject_1;
    function baseMergeDeep$1(object2, source, key, srcIndex, mergeFunc, customizer, stack2) {
      var objValue = safeGet$1(object2, key), srcValue = safeGet$1(source, key), stacked = stack2.get(srcValue);
      if (stacked) {
        assignMergeValue$1(object2, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack2) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray$h(srcValue), isBuff = !isArr && isBuffer$4(srcValue), isTyped = !isArr && !isBuff && isTypedArray$2(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray$h(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject$3(objValue)) {
            newValue = copyArray$2(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer$1(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray$1(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject$1(srcValue) || isArguments$3(srcValue)) {
          newValue = objValue;
          if (isArguments$3(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject$6(objValue) || isFunction$1(objValue)) {
            newValue = initCloneObject$1(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack2.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
        stack2["delete"](srcValue);
      }
      assignMergeValue$1(object2, key, newValue);
    }
    var _baseMergeDeep = baseMergeDeep$1;
    var Stack$3 = _Stack, assignMergeValue = _assignMergeValue, baseFor = _baseFor, baseMergeDeep = _baseMergeDeep, isObject$5 = isObject_1, keysIn$3 = keysIn_1, safeGet = _safeGet;
    function baseMerge$1(object2, source, srcIndex, customizer, stack2) {
      if (object2 === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack2 || (stack2 = new Stack$3());
        if (isObject$5(srcValue)) {
          baseMergeDeep(object2, source, key, srcIndex, baseMerge$1, customizer, stack2);
        } else {
          var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack2) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object2, key, newValue);
        }
      }, keysIn$3);
    }
    var _baseMerge = baseMerge$1;
    function apply$1(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    var _apply = apply$1;
    var apply = _apply;
    var nativeMax$3 = Math.max;
    function overRest$2(func, start2, transform) {
      start2 = nativeMax$3(start2 === void 0 ? func.length - 1 : start2, 0);
      return function() {
        var args = arguments, index2 = -1, length = nativeMax$3(args.length - start2, 0), array2 = Array(length);
        while (++index2 < length) {
          array2[index2] = args[start2 + index2];
        }
        index2 = -1;
        var otherArgs = Array(start2 + 1);
        while (++index2 < start2) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start2] = transform(array2);
        return apply(func, this, otherArgs);
      };
    }
    var _overRest = overRest$2;
    function constant$1(value) {
      return function() {
        return value;
      };
    }
    var constant_1 = constant$1;
    var constant = constant_1, defineProperty = _defineProperty$1, identity$3 = identity_1;
    var baseSetToString$1 = !defineProperty ? identity$3 : function(func, string2) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    var _baseSetToString = baseSetToString$1;
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut$1(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    var _shortOut = shortOut$1;
    var baseSetToString = _baseSetToString, shortOut = _shortOut;
    var setToString$2 = shortOut(baseSetToString);
    var _setToString = setToString$2;
    var identity$2 = identity_1, overRest$1 = _overRest, setToString$1 = _setToString;
    function baseRest$5(func, start2) {
      return setToString$1(overRest$1(func, start2, identity$2), func + "");
    }
    var _baseRest = baseRest$5;
    var eq$1 = eq_1, isArrayLike$4 = isArrayLike_1, isIndex$2 = _isIndex, isObject$4 = isObject_1;
    function isIterateeCall$3(value, index2, object2) {
      if (!isObject$4(object2)) {
        return false;
      }
      var type = typeof index2;
      if (type == "number" ? isArrayLike$4(object2) && isIndex$2(index2, object2.length) : type == "string" && index2 in object2) {
        return eq$1(object2[index2], value);
      }
      return false;
    }
    var _isIterateeCall = isIterateeCall$3;
    var baseRest$4 = _baseRest, isIterateeCall$2 = _isIterateeCall;
    function createAssigner$1(assigner) {
      return baseRest$4(function(object2, sources) {
        var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall$2(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object2 = Object(object2);
        while (++index2 < length) {
          var source = sources[index2];
          if (source) {
            assigner(object2, source, index2, customizer);
          }
        }
        return object2;
      });
    }
    var _createAssigner = createAssigner$1;
    var baseMerge = _baseMerge, createAssigner = _createAssigner;
    var merge = createAssigner(function(object2, source, srcIndex) {
      baseMerge(object2, source, srcIndex);
    });
    var merge_1 = merge;
    function arraySome$2(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    var _arraySome = arraySome$2;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd$1(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    var _setCacheAdd = setCacheAdd$1;
    function setCacheHas$1(value) {
      return this.__data__.has(value);
    }
    var _setCacheHas = setCacheHas$1;
    var MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
    function SetCache$3(values2) {
      var index2 = -1, length = values2 == null ? 0 : values2.length;
      this.__data__ = new MapCache$1();
      while (++index2 < length) {
        this.add(values2[index2]);
      }
    }
    SetCache$3.prototype.add = SetCache$3.prototype.push = setCacheAdd;
    SetCache$3.prototype.has = setCacheHas;
    var _SetCache = SetCache$3;
    function cacheHas$3(cache, key) {
      return cache.has(key);
    }
    var _cacheHas = cacheHas$3;
    var SetCache$2 = _SetCache, arraySome$1 = _arraySome, cacheHas$2 = _cacheHas;
    var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
    function equalArrays$2(array2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack2.get(array2);
      var othStacked = stack2.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache$2() : void 0;
      stack2.set(array2, other);
      stack2.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome$1(other, function(othValue2, othIndex) {
            if (!cacheHas$2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array2);
      stack2["delete"](other);
      return result;
    }
    var _equalArrays = equalArrays$2;
    function mapToArray$1(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    var _mapToArray = mapToArray$1;
    function setToArray$3(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var _setToArray = setToArray$3;
    var Symbol$4 = _Symbol, Uint8Array$3 = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray$2 = _setToArray;
    var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
    var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", mapTag$5 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]";
    var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
    function equalByTag$1(object2, other, tag, bitmask, customizer, equalFunc, stack2) {
      switch (tag) {
        case dataViewTag$3:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag$2:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$3(object2), new Uint8Array$3(other))) {
            return false;
          }
          return true;
        case boolTag$2:
        case dateTag$2:
        case numberTag$2:
          return eq(+object2, +other);
        case errorTag$1:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag$2:
        case stringTag$3:
          return object2 == other + "";
        case mapTag$5:
          var convert = mapToArray;
        case setTag$5:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert || (convert = setToArray$2);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;
          stack2.set(object2, other);
          var result = equalArrays$1(convert(object2), convert(other), bitmask, customizer, equalFunc, stack2);
          stack2["delete"](object2);
          return result;
        case symbolTag$3:
          if (symbolValueOf$1) {
            return symbolValueOf$1.call(object2) == symbolValueOf$1.call(other);
          }
      }
      return false;
    }
    var _equalByTag = equalByTag$1;
    function arrayPush$4(array2, values2) {
      var index2 = -1, length = values2.length, offset2 = array2.length;
      while (++index2 < length) {
        array2[offset2 + index2] = values2[index2];
      }
      return array2;
    }
    var _arrayPush = arrayPush$4;
    var arrayPush$3 = _arrayPush, isArray$g = isArray_1;
    function baseGetAllKeys$2(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray$g(object2) ? result : arrayPush$3(result, symbolsFunc(object2));
    }
    var _baseGetAllKeys = baseGetAllKeys$2;
    function arrayFilter$2(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    var _arrayFilter = arrayFilter$2;
    function stubArray$2() {
      return [];
    }
    var stubArray_1 = stubArray$2;
    var arrayFilter$1 = _arrayFilter, stubArray$1 = stubArray_1;
    var objectProto$4 = Object.prototype;
    var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter$1(nativeGetSymbols$1(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    var _getSymbols = getSymbols$3;
    var baseGetAllKeys$1 = _baseGetAllKeys, getSymbols$2 = _getSymbols, keys$5 = keys_1;
    function getAllKeys$2(object2) {
      return baseGetAllKeys$1(object2, keys$5, getSymbols$2);
    }
    var _getAllKeys = getAllKeys$2;
    var getAllKeys$1 = _getAllKeys;
    var COMPARE_PARTIAL_FLAG$3 = 1;
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$4 = objectProto$3.hasOwnProperty;
    function equalObjects$1(object2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys$1(object2), objLength = objProps.length, othProps = getAllKeys$1(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack2.get(object2);
      var othStacked = stack2.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack2.set(object2, other);
      stack2.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack2) : customizer(objValue, othValue, key, object2, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object2);
      stack2["delete"](other);
      return result;
    }
    var _equalObjects = equalObjects$1;
    var getNative$3 = _getNative, root$3 = _root;
    var DataView$1 = getNative$3(root$3, "DataView");
    var _DataView = DataView$1;
    var getNative$2 = _getNative, root$2 = _root;
    var Promise$2 = getNative$2(root$2, "Promise");
    var _Promise = Promise$2;
    var getNative$1 = _getNative, root$1 = _root;
    var Set$2 = getNative$1(root$1, "Set");
    var _Set = Set$2;
    var getNative = _getNative, root = _root;
    var WeakMap$1 = getNative(root, "WeakMap");
    var _WeakMap = WeakMap$1;
    var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$2 = _WeakMap, baseGetTag$2 = _baseGetTag, toSource = _toSource;
    var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
    var dataViewTag$2 = "[object DataView]";
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$2);
    var getTag$5 = baseGetTag$2;
    if (DataView && getTag$5(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$5(new Map$1()) != mapTag$4 || Promise$1 && getTag$5(Promise$1.resolve()) != promiseTag || Set$1 && getTag$5(new Set$1()) != setTag$4 || WeakMap$2 && getTag$5(new WeakMap$2()) != weakMapTag$1) {
      getTag$5 = function(value) {
        var result = baseGetTag$2(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$2;
            case mapCtorString:
              return mapTag$4;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$4;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }
    var _getTag = getTag$5;
    var Stack$2 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag$4 = _getTag, isArray$f = isArray_1, isBuffer$3 = isBuffer$6.exports, isTypedArray$1 = isTypedArray_1;
    var COMPARE_PARTIAL_FLAG$2 = 1;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$1 = "[object Object]";
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
    function baseIsEqualDeep$1(object2, other, bitmask, customizer, equalFunc, stack2) {
      var objIsArr = isArray$f(object2), othIsArr = isArray$f(other), objTag = objIsArr ? arrayTag$1 : getTag$4(object2), othTag = othIsArr ? arrayTag$1 : getTag$4(other);
      objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
      othTag = othTag == argsTag$1 ? objectTag$1 : othTag;
      var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer$3(object2)) {
        if (!isBuffer$3(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack$2());
        return objIsArr || isTypedArray$1(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack2);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty$3.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$3.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack$2());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack$2());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack2);
    }
    var _baseIsEqualDeep = baseIsEqualDeep$1;
    var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$4 = isObjectLike_1;
    function baseIsEqual$3(value, other, bitmask, customizer, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike$4(value) && !isObjectLike$4(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack2);
    }
    var _baseIsEqual = baseIsEqual$3;
    var Stack$1 = _Stack, baseIsEqual$2 = _baseIsEqual;
    var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function baseIsMatch$1(object2, source, matchData, customizer) {
      var index2 = matchData.length, length = index2, noCustomizer = !customizer;
      if (object2 == null) {
        return !length;
      }
      object2 = Object(object2);
      while (index2--) {
        var data = matchData[index2];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
          return false;
        }
      }
      while (++index2 < length) {
        data = matchData[index2];
        var key = data[0], objValue = object2[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack2 = new Stack$1();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object2, source, stack2);
          }
          if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    var _baseIsMatch = baseIsMatch$1;
    var isObject$3 = isObject_1;
    function isStrictComparable$2(value) {
      return value === value && !isObject$3(value);
    }
    var _isStrictComparable = isStrictComparable$2;
    var isStrictComparable$1 = _isStrictComparable, keys$4 = keys_1;
    function getMatchData$1(object2) {
      var result = keys$4(object2), length = result.length;
      while (length--) {
        var key = result[length], value = object2[key];
        result[length] = [key, value, isStrictComparable$1(value)];
      }
      return result;
    }
    var _getMatchData = getMatchData$1;
    function matchesStrictComparable$2(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    var _matchesStrictComparable = matchesStrictComparable$2;
    var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
    function baseMatches$1(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    var _baseMatches = baseMatches$1;
    var baseGetTag$1 = _baseGetTag, isObjectLike$3 = isObjectLike_1;
    var symbolTag$2 = "[object Symbol]";
    function isSymbol$5(value) {
      return typeof value == "symbol" || isObjectLike$3(value) && baseGetTag$1(value) == symbolTag$2;
    }
    var isSymbol_1 = isSymbol$5;
    var isArray$e = isArray_1, isSymbol$4 = isSymbol_1;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey$3(value, object2) {
      if (isArray$e(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$4(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    var _isKey = isKey$3;
    var MapCache = _MapCache;
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize$1(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize$1.Cache || MapCache)();
      return memoized;
    }
    memoize$1.Cache = MapCache;
    var memoize_1 = memoize$1;
    var memoize = memoize_1;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped$1(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    var _memoizeCapped = memoizeCapped$1;
    var memoizeCapped = _memoizeCapped;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath$1 = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    var _stringToPath = stringToPath$1;
    function arrayMap$6(array2, iteratee) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    var _arrayMap = arrayMap$6;
    var Symbol$3 = _Symbol, arrayMap$5 = _arrayMap, isArray$d = isArray_1, isSymbol$3 = isSymbol_1;
    var INFINITY$4 = 1 / 0;
    var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
    function baseToString$4(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray$d(value)) {
        return arrayMap$5(value, baseToString$4) + "";
      }
      if (isSymbol$3(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$4 ? "-0" : result;
    }
    var _baseToString = baseToString$4;
    var baseToString$3 = _baseToString;
    function toString$9(value) {
      return value == null ? "" : baseToString$3(value);
    }
    var toString_1 = toString$9;
    var isArray$c = isArray_1, isKey$2 = _isKey, stringToPath = _stringToPath, toString$8 = toString_1;
    function castPath$6(value, object2) {
      if (isArray$c(value)) {
        return value;
      }
      return isKey$2(value, object2) ? [value] : stringToPath(toString$8(value));
    }
    var _castPath = castPath$6;
    var isSymbol$2 = isSymbol_1;
    var INFINITY$3 = 1 / 0;
    function toKey$6(value) {
      if (typeof value == "string" || isSymbol$2(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
    }
    var _toKey = toKey$6;
    var castPath$5 = _castPath, toKey$5 = _toKey;
    function baseGet$5(object2, path) {
      path = castPath$5(path, object2);
      var index2 = 0, length = path.length;
      while (object2 != null && index2 < length) {
        object2 = object2[toKey$5(path[index2++])];
      }
      return index2 && index2 == length ? object2 : void 0;
    }
    var _baseGet = baseGet$5;
    var baseGet$4 = _baseGet;
    function get$1(object2, path, defaultValue) {
      var result = object2 == null ? void 0 : baseGet$4(object2, path);
      return result === void 0 ? defaultValue : result;
    }
    var get_1 = get$1;
    function baseHasIn$1(object2, key) {
      return object2 != null && key in Object(object2);
    }
    var _baseHasIn = baseHasIn$1;
    var castPath$4 = _castPath, isArguments$2 = isArguments_1, isArray$b = isArray_1, isIndex$1 = _isIndex, isLength = isLength_1, toKey$4 = _toKey;
    function hasPath$1(object2, path, hasFunc) {
      path = castPath$4(path, object2);
      var index2 = -1, length = path.length, result = false;
      while (++index2 < length) {
        var key = toKey$4(path[index2]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result || ++index2 != length) {
        return result;
      }
      length = object2 == null ? 0 : object2.length;
      return !!length && isLength(length) && isIndex$1(key, length) && (isArray$b(object2) || isArguments$2(object2));
    }
    var _hasPath = hasPath$1;
    var baseHasIn = _baseHasIn, hasPath = _hasPath;
    function hasIn$2(object2, path) {
      return object2 != null && hasPath(object2, path, baseHasIn);
    }
    var hasIn_1 = hasIn$2;
    var baseIsEqual$1 = _baseIsEqual, get = get_1, hasIn$1 = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$3 = _toKey;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty$1(path, srcValue) {
      if (isKey$1(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey$3(path), srcValue);
      }
      return function(object2) {
        var objValue = get(object2, path);
        return objValue === void 0 && objValue === srcValue ? hasIn$1(object2, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    var _baseMatchesProperty = baseMatchesProperty$1;
    function baseProperty$1(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    var _baseProperty = baseProperty$1;
    var baseGet$3 = _baseGet;
    function basePropertyDeep$1(path) {
      return function(object2) {
        return baseGet$3(object2, path);
      };
    }
    var _basePropertyDeep = basePropertyDeep$1;
    var baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey$2 = _toKey;
    function property$1(path) {
      return isKey(path) ? baseProperty(toKey$2(path)) : basePropertyDeep(path);
    }
    var property_1 = property$1;
    var baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity$1 = identity_1, isArray$a = isArray_1, property = property_1;
    function baseIteratee$9(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity$1;
      }
      if (typeof value == "object") {
        return isArray$a(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    var _baseIteratee = baseIteratee$9;
    var baseEach$3 = _baseEach;
    function baseSome$1(collection, predicate) {
      var result;
      baseEach$3(collection, function(value, index2, collection2) {
        result = predicate(value, index2, collection2);
        return !result;
      });
      return !!result;
    }
    var _baseSome = baseSome$1;
    var arraySome = _arraySome, baseIteratee$8 = _baseIteratee, baseSome = _baseSome, isArray$9 = isArray_1, isIterateeCall$1 = _isIterateeCall;
    function some(collection, predicate, guard) {
      var func = isArray$9(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall$1(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee$8(predicate));
    }
    var some_1 = some;
    var baseKeys = _baseKeys, getTag$3 = _getTag, isArguments$1 = isArguments_1, isArray$8 = isArray_1, isArrayLike$3 = isArrayLike_1, isBuffer$2 = isBuffer$6.exports, isPrototype = _isPrototype, isTypedArray = isTypedArray_1;
    var mapTag$3 = "[object Map]", setTag$3 = "[object Set]";
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike$3(value) && (isArray$8(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer$2(value) || isTypedArray(value) || isArguments$1(value))) {
        return !value.length;
      }
      var tag = getTag$3(value);
      if (tag == mapTag$3 || tag == setTag$3) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty$2.call(value, key)) {
          return false;
        }
      }
      return true;
    }
    var isEmpty_1 = isEmpty;
    function baseSlice$2(array2, start2, end2) {
      var index2 = -1, length = array2.length;
      if (start2 < 0) {
        start2 = -start2 > length ? 0 : length + start2;
      }
      end2 = end2 > length ? length : end2;
      if (end2 < 0) {
        end2 += length;
      }
      length = start2 > end2 ? 0 : end2 - start2 >>> 0;
      start2 >>>= 0;
      var result = Array(length);
      while (++index2 < length) {
        result[index2] = array2[index2 + start2];
      }
      return result;
    }
    var _baseSlice = baseSlice$2;
    var baseSlice$1 = _baseSlice;
    function castSlice$2(array2, start2, end2) {
      var length = array2.length;
      end2 = end2 === void 0 ? length : end2;
      return !start2 && end2 >= length ? array2 : baseSlice$1(array2, start2, end2);
    }
    var _castSlice = castSlice$2;
    var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
    var rsZWJ$2 = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
    function hasUnicode$2(string2) {
      return reHasUnicode.test(string2);
    }
    var _hasUnicode = hasUnicode$2;
    function asciiToArray$1(string2) {
      return string2.split("");
    }
    var _asciiToArray = asciiToArray$1;
    var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
    var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
    function unicodeToArray$1(string2) {
      return string2.match(reUnicode) || [];
    }
    var _unicodeToArray = unicodeToArray$1;
    var asciiToArray = _asciiToArray, hasUnicode$1 = _hasUnicode, unicodeToArray = _unicodeToArray;
    function stringToArray$2(string2) {
      return hasUnicode$1(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    var _stringToArray = stringToArray$2;
    var castSlice$1 = _castSlice, hasUnicode = _hasUnicode, stringToArray$1 = _stringToArray, toString$7 = toString_1;
    function createCaseFirst$2(methodName) {
      return function(string2) {
        string2 = toString$7(string2);
        var strSymbols = hasUnicode(string2) ? stringToArray$1(string2) : void 0;
        var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
        var trailing = strSymbols ? castSlice$1(strSymbols, 1).join("") : string2.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    var _createCaseFirst = createCaseFirst$2;
    var createCaseFirst$1 = _createCaseFirst;
    var upperFirst$1 = createCaseFirst$1("toUpperCase");
    var upperFirst_1 = upperFirst$1;
    var baseEach$2 = _baseEach;
    function baseFilter$1(collection, predicate) {
      var result = [];
      baseEach$2(collection, function(value, index2, collection2) {
        if (predicate(value, index2, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    var _baseFilter = baseFilter$1;
    var arrayFilter = _arrayFilter, baseFilter = _baseFilter, baseIteratee$7 = _baseIteratee, isArray$7 = isArray_1;
    function filter(collection, predicate) {
      var func = isArray$7(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee$7(predicate));
    }
    var filter_1 = filter;
    var copyObject$4 = _copyObject, keys$3 = keys_1;
    function baseAssign$1(object2, source) {
      return object2 && copyObject$4(source, keys$3(source), object2);
    }
    var _baseAssign = baseAssign$1;
    var copyObject$3 = _copyObject, keysIn$2 = keysIn_1;
    function baseAssignIn$1(object2, source) {
      return object2 && copyObject$3(source, keysIn$2(source), object2);
    }
    var _baseAssignIn = baseAssignIn$1;
    var copyObject$2 = _copyObject, getSymbols$1 = _getSymbols;
    function copySymbols$1(source, object2) {
      return copyObject$2(source, getSymbols$1(source), object2);
    }
    var _copySymbols = copySymbols$1;
    var arrayPush$2 = _arrayPush, getPrototype = _getPrototype, getSymbols = _getSymbols, stubArray = stubArray_1;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object2) {
      var result = [];
      while (object2) {
        arrayPush$2(result, getSymbols(object2));
        object2 = getPrototype(object2);
      }
      return result;
    };
    var _getSymbolsIn = getSymbolsIn$2;
    var copyObject$1 = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
    function copySymbolsIn$1(source, object2) {
      return copyObject$1(source, getSymbolsIn$1(source), object2);
    }
    var _copySymbolsIn = copySymbolsIn$1;
    var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
    function getAllKeysIn$2(object2) {
      return baseGetAllKeys(object2, keysIn$1, getSymbolsIn);
    }
    var _getAllKeysIn = getAllKeysIn$2;
    var objectProto = Object.prototype;
    var hasOwnProperty$1 = objectProto.hasOwnProperty;
    function initCloneArray$1(array2) {
      var length = array2.length, result = new array2.constructor(length);
      if (length && typeof array2[0] == "string" && hasOwnProperty$1.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    var _initCloneArray = initCloneArray$1;
    var cloneArrayBuffer$1 = _cloneArrayBuffer;
    function cloneDataView$1(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer$1(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    var _cloneDataView = cloneDataView$1;
    var reFlags = /\w*$/;
    function cloneRegExp$1(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    var _cloneRegExp = cloneRegExp$1;
    var Symbol$2 = _Symbol;
    var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol$1(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    var _cloneSymbol = cloneSymbol$1;
    var cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray;
    var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$2 = "[object String]", symbolTag$1 = "[object Symbol]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    function initCloneByTag$1(object2, tag, isDeep) {
      var Ctor = object2.constructor;
      switch (tag) {
        case arrayBufferTag$1:
          return cloneArrayBuffer(object2);
        case boolTag$1:
        case dateTag$1:
          return new Ctor(+object2);
        case dataViewTag$1:
          return cloneDataView(object2, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return cloneTypedArray(object2, isDeep);
        case mapTag$2:
          return new Ctor();
        case numberTag$1:
        case stringTag$2:
          return new Ctor(object2);
        case regexpTag$1:
          return cloneRegExp(object2);
        case setTag$2:
          return new Ctor();
        case symbolTag$1:
          return cloneSymbol(object2);
      }
    }
    var _initCloneByTag = initCloneByTag$1;
    var getTag$2 = _getTag, isObjectLike$2 = isObjectLike_1;
    var mapTag$1 = "[object Map]";
    function baseIsMap$1(value) {
      return isObjectLike$2(value) && getTag$2(value) == mapTag$1;
    }
    var _baseIsMap = baseIsMap$1;
    var baseIsMap = _baseIsMap, baseUnary$3 = _baseUnary, nodeUtil$1 = _nodeUtil.exports;
    var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
    var isMap$1 = nodeIsMap ? baseUnary$3(nodeIsMap) : baseIsMap;
    var isMap_1 = isMap$1;
    var getTag$1 = _getTag, isObjectLike$1 = isObjectLike_1;
    var setTag$1 = "[object Set]";
    function baseIsSet$1(value) {
      return isObjectLike$1(value) && getTag$1(value) == setTag$1;
    }
    var _baseIsSet = baseIsSet$1;
    var baseIsSet = _baseIsSet, baseUnary$2 = _baseUnary, nodeUtil = _nodeUtil.exports;
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet$1 = nodeIsSet ? baseUnary$2(nodeIsSet) : baseIsSet;
    var isSet_1 = isSet$1;
    var Stack = _Stack, arrayEach = _arrayEach, assignValue$1 = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBuffer.exports, copyArray$1 = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn$1 = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray$6 = isArray_1, isBuffer$1 = isBuffer$6.exports, isMap = isMap_1, isObject$2 = isObject_1, isSet$2 = isSet_1, keys$2 = keys_1, keysIn = keysIn_1;
    var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$3 = 4;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag$1] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone$3(value, bitmask, customizer, key, object2, stack2) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$3;
      if (customizer) {
        result = object2 ? customizer(value, key, object2, stack2) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject$2(value)) {
        return value;
      }
      var isArr = isArray$6(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray$1(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer$1(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object2) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object2 ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack2 || (stack2 = new Stack());
      var stacked = stack2.get(value);
      if (stacked) {
        return stacked;
      }
      stack2.set(value, result);
      if (isSet$2(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone$3(subValue, bitmask, customizer, subValue, value, stack2));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone$3(subValue, bitmask, customizer, key2, value, stack2));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn$1 : getAllKeys : isFlat ? keysIn : keys$2;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue$1(result, key2, baseClone$3(subValue, bitmask, customizer, key2, value, stack2));
      });
      return result;
    }
    var _baseClone = baseClone$3;
    var baseClone$2 = _baseClone;
    var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$2 = 4;
    function cloneDeep(value) {
      return baseClone$2(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$2);
    }
    var cloneDeep_1 = cloneDeep;
    var assignValue = _assignValue, castPath$3 = _castPath, isIndex = _isIndex, isObject$1 = isObject_1, toKey$1 = _toKey;
    function baseSet$2(object2, path, value, customizer) {
      if (!isObject$1(object2)) {
        return object2;
      }
      path = castPath$3(path, object2);
      var index2 = -1, length = path.length, lastIndex = length - 1, nested = object2;
      while (nested != null && ++index2 < length) {
        var key = toKey$1(path[index2]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object2;
        }
        if (index2 != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject$1(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object2;
    }
    var _baseSet = baseSet$2;
    var baseSet$1 = _baseSet;
    function set(object2, path, value) {
      return object2 == null ? object2 : baseSet$1(object2, path, value);
    }
    var set_1 = set;
    var Symbol$1 = _Symbol, isArguments = isArguments_1, isArray$5 = isArray_1;
    var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
    function isFlattenable$1(value) {
      return isArray$5(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    var _isFlattenable = isFlattenable$1;
    var arrayPush$1 = _arrayPush, isFlattenable = _isFlattenable;
    function baseFlatten$6(array2, depth, predicate, isStrict, result) {
      var index2 = -1, length = array2.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index2 < length) {
        var value = array2[index2];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten$6(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush$1(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    var _baseFlatten = baseFlatten$6;
    function baseFindIndex$3(array2, predicate, fromIndex, fromRight) {
      var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array2[index2], index2, array2)) {
          return index2;
        }
      }
      return -1;
    }
    var _baseFindIndex = baseFindIndex$3;
    function baseIsNaN$1(value) {
      return value !== value;
    }
    var _baseIsNaN = baseIsNaN$1;
    function strictIndexOf$1(array2, value, fromIndex) {
      var index2 = fromIndex - 1, length = array2.length;
      while (++index2 < length) {
        if (array2[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    var _strictIndexOf = strictIndexOf$1;
    var baseFindIndex$2 = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
    function baseIndexOf$4(array2, value, fromIndex) {
      return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex$2(array2, baseIsNaN, fromIndex);
    }
    var _baseIndexOf = baseIndexOf$4;
    var baseIndexOf$3 = _baseIndexOf;
    function arrayIncludes$2(array2, value) {
      var length = array2 == null ? 0 : array2.length;
      return !!length && baseIndexOf$3(array2, value, 0) > -1;
    }
    var _arrayIncludes = arrayIncludes$2;
    function arrayIncludesWith$2(array2, value, comparator2) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (comparator2(value, array2[index2])) {
          return true;
        }
      }
      return false;
    }
    var _arrayIncludesWith = arrayIncludesWith$2;
    function noop$1() {
    }
    var noop_1 = noop$1;
    var Set$3 = _Set, noop = noop_1, setToArray$1 = _setToArray;
    var INFINITY$2 = 1 / 0;
    var createSet$1 = !(Set$3 && 1 / setToArray$1(new Set$3([, -0]))[1] == INFINITY$2) ? noop : function(values2) {
      return new Set$3(values2);
    };
    var _createSet = createSet$1;
    var SetCache$1 = _SetCache, arrayIncludes$1 = _arrayIncludes, arrayIncludesWith$1 = _arrayIncludesWith, cacheHas$1 = _cacheHas, createSet = _createSet, setToArray = _setToArray;
    var LARGE_ARRAY_SIZE$1 = 200;
    function baseUniq$1(array2, iteratee, comparator2) {
      var index2 = -1, includes2 = arrayIncludes$1, length = array2.length, isCommon = true, result = [], seen = result;
      if (comparator2) {
        isCommon = false;
        includes2 = arrayIncludesWith$1;
      } else if (length >= LARGE_ARRAY_SIZE$1) {
        var set2 = iteratee ? null : createSet(array2);
        if (set2) {
          return setToArray(set2);
        }
        isCommon = false;
        includes2 = cacheHas$1;
        seen = new SetCache$1();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index2 < length) {
          var value = array2[index2], computed2 = iteratee ? iteratee(value) : value;
          value = comparator2 || value !== 0 ? value : 0;
          if (isCommon && computed2 === computed2) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed2) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed2);
            }
            result.push(value);
          } else if (!includes2(seen, computed2, comparator2)) {
            if (seen !== result) {
              seen.push(computed2);
            }
            result.push(value);
          }
        }
      return result;
    }
    var _baseUniq = baseUniq$1;
    var baseFlatten$5 = _baseFlatten, baseRest$3 = _baseRest, baseUniq = _baseUniq, isArrayLikeObject$2 = isArrayLikeObject_1;
    var union = baseRest$3(function(arrays) {
      return baseUniq(baseFlatten$5(arrays, 1, isArrayLikeObject$2, true));
    });
    var union_1 = union;
    var baseFlatten$4 = _baseFlatten;
    var INFINITY$1 = 1 / 0;
    function flattenDeep(array2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseFlatten$4(array2, INFINITY$1) : [];
    }
    var flattenDeep_1 = flattenDeep;
    var MERGE_KEYS = ["presets", "usePresets", "addClasses", "prependClasses", "removeClasses", "replaceClasses", "overrideClasses"];
    var LOCALS_KEYS = ["addClass", "removeClass", "replaceClass", "overrideClass"];
    class MergeClasses {
      constructor() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.options = options;
        if (this.shouldMergeTemplateClasses) {
          this.componentClasses = this.templateClasses;
          this.merge({
            overrideClasses: {
              [this.component]: this.themeClasses
            }
          });
        } else {
          this.componentClasses = this.templateClasses;
        }
        this.merge(this.config);
        each(options.merge, (merge2) => {
          this.merge(merge2);
        });
        this.merge(this.locals || this.component$.value, true);
        if (this.config.classHelpers && this.config.env !== "production") {
          this.merge({
            prependClasses: {
              [this.component]: this.getClassHelpers(this.componentClasses, [this.component])
            }
          });
        }
      }
      get classes() {
        return new Proxy(this.componentClasses, {
          get: (target, prop) => {
            if (typeof prop !== "string") {
              return target[prop];
            }
            return this.getDynamicClasses(target, prop);
          }
        });
      }
      get config() {
        return this.options.config || {};
      }
      get component() {
        return this.options.component;
      }
      get component$() {
        return this.options.component$;
      }
      get locals() {
        return this.options.locals;
      }
      get view() {
        return this.options.view;
      }
      get theme() {
        return this.options.theme;
      }
      get presets() {
        return this.config.presets;
      }
      get templates() {
        return this.options.templates || {};
      }
      get template() {
        return this.view && this.templates["".concat(this.component, "_").concat(this.view)] ? this.templates["".concat(this.component, "_").concat(this.view)] : this.templates[this.component] || {};
      }
      get themeClasses() {
        return cloneDeep_1(this.toArray(this.view && this.theme.classes["".concat(this.component, "_").concat(this.view)] ? this.theme.classes["".concat(this.component, "_").concat(this.view)] : this.theme.classes[this.component]));
      }
      get templateClasses() {
        return cloneDeep_1(this.toArray(this.defaultClasses));
      }
      get shouldMergeTemplateClasses() {
        var merge2 = typeof this.template.data === "function" && this.template.data().merge !== void 0 ? this.template.data().merge : this.component$.value.merge;
        return merge2 !== void 0 ? merge2 : false;
      }
      get defaultClasses() {
        return typeof this.template.data === "function" && this.template.data().defaultClasses ? this.template.data().defaultClasses : this.component$.value.defaultClasses;
      }
      get mainClass() {
        var defaultClasses = typeof this.template.data === "function" && this.template.data().defaultClasses ? this.template.data().defaultClasses : this.component$.value.defaultClasses;
        return Object.keys(defaultClasses)[0];
      }
      merge(merge2) {
        var locals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        each(this.pick(merge2, locals ? LOCALS_KEYS : MERGE_KEYS), (mergables, key) => {
          if (typeof mergables === "function") {
            mergables = mergables(this.component$.value.form$, "el$" in this.component$.value && typeof this.component$.value.el$ === "object" ? this.component$.value.el$ : void 0, this.component$.value);
          }
          switch (key) {
            case "addClasses":
            case "prependClasses":
            case "overrideClasses":
              if (!mergables || mergables[this.component] === void 0) {
                return;
              }
              this.mergeComponentClasses(this.toArray(mergables[this.component]), key);
              break;
            case "removeClasses":
            case "replaceClasses":
              if (!mergables || mergables[this.component] === void 0) {
                return;
              }
              this.mergeComponentClasses(mergables[this.component], key);
              break;
            case "addClass":
            case "removeClass":
            case "replaceClass":
            case "overrideClass":
              if (!mergables) {
                return;
              }
              if (typeof mergables === "string" || Array.isArray(mergables)) {
                if (!Array.isArray(mergables)) {
                  mergables = mergables.length > 0 ? mergables.split(" ") : [];
                }
                this.mergeComponentClasses({
                  [this.mainClass]: mergables
                }, "".concat(key, "es"));
              } else if (key === "replaceClass") {
                this.mergeComponentClasses(mergables, "".concat(key, "es"));
              } else if (isPlainObject_1(mergables)) {
                this.mergeComponentClasses(this.toArray(mergables), "".concat(key, "es"));
              } else
                ;
              break;
            case "presets":
            case "usePresets":
              if (!Array.isArray(mergables)) {
                return;
              }
              each(mergables, (presetName) => {
                this.merge(this.presets[presetName]);
              });
              break;
          }
        });
      }
      mergeComponentClasses(componentClasses, key) {
        each(componentClasses, (classes2, className) => {
          this[key](classes2, [className]);
        });
      }
      addClasses(add2, levels) {
        var base2 = get_1(this.componentClasses, levels.join("."));
        if (add2.length == 1 && !add2[0]) {
          return;
        }
        if (isPlainObject_1(base2)) {
          each(add2, (subclasses, subclassName) => {
            this.addClasses(subclasses, levels.concat(subclassName));
          });
        } else {
          set_1(this.componentClasses, levels.join("."), union_1(base2, add2));
        }
      }
      prependClasses(prepend, levels) {
        var base2 = get_1(this.componentClasses, levels.join("."));
        if (prepend.length == 1 && !prepend[0]) {
          return;
        }
        if (isPlainObject_1(base2)) {
          each(prepend, (subclasses, subclassName) => {
            this.prependClasses(subclasses, levels.concat(subclassName));
          });
        } else {
          set_1(this.componentClasses, levels.join("."), union_1(prepend, base2));
        }
      }
      removeClasses(remove2, levels) {
        var base2 = get_1(this.componentClasses, levels.join("."));
        if (isPlainObject_1(base2)) {
          each(remove2, (subclasses, subclassName) => {
            this.removeClasses(subclasses, levels.concat(subclassName));
          });
        } else if (Array.isArray(base2)) {
          set_1(this.componentClasses, levels.join("."), base2.filter((c2) => {
            return typeof c2 !== "string" || remove2.indexOf(c2) === -1;
          }));
        }
      }
      replaceClasses(replace, levels) {
        var base2 = get_1(this.componentClasses, levels.join("."));
        if (Array.isArray(replace)) {
          var tempReplace = {};
          replace.forEach((r2) => {
            tempReplace = _objectSpread2$1(_objectSpread2$1({}, tempReplace), r2);
          });
          replace = tempReplace;
        }
        if (isPlainObject_1(base2)) {
          each(replace, (subclasses, subclassName) => {
            this.replaceClasses(subclasses, levels.concat(subclassName));
          });
        } else if (Array.isArray(base2)) {
          set_1(this.componentClasses, levels.join("."), base2.map((c2) => {
            return typeof c2 !== "string" || Object.keys(replace).indexOf(c2) === -1 ? c2 : replace[c2];
          }));
        }
      }
      overrideClasses(override, levels) {
        var base2 = get_1(this.componentClasses, levels.join("."));
        if (isPlainObject_1(base2)) {
          each(override, (subclasses, subclassName) => {
            this.overrideClasses(subclasses, levels.concat(subclassName));
          });
        } else {
          set_1(this.componentClasses, levels.join("."), override);
        }
      }
      toArray(componentClasses) {
        var arrayClasses = {};
        each(componentClasses, (classes2, className) => {
          arrayClasses[className] = this.classesToArray(classes2, [className]);
        });
        return arrayClasses;
      }
      classesToArray(classes2, path) {
        var _classes$constructor;
        var arrayClasses = classes2;
        var base2 = path ? get_1(this.componentClasses, path.join(".")) : void 0;
        if (typeof classes2 === "string") {
          arrayClasses = classes2.length > 0 ? classes2.split(" ") : [];
        } else if (isPlainObject_1(classes2)) {
          if (base2 && Array.isArray(base2)) {
            arrayClasses = [classes2];
          } else if (!base2 || isPlainObject_1(base2)) {
            arrayClasses = {};
            each(classes2, (subclasses, subclassName) => {
              arrayClasses[subclassName] = this.classesToArray(subclasses, path.concat([subclassName]));
            });
          }
        } else if (typeof classes2 === "boolean" || typeof classes2 === "object" && ["ComputedRefImpl", "RefImpl"].indexOf(classes2 === null || classes2 === void 0 || (_classes$constructor = classes2.constructor) === null || _classes$constructor === void 0 ? void 0 : _classes$constructor.name) !== -1) {
          throw Error("Cannot add conditional class to ".concat(this.component, ": '").concat(path.join("."), "'"));
        }
        return arrayClasses;
      }
      getDynamicClasses(target, prop, mainTarget) {
        if (!mainTarget) {
          mainTarget = target;
        }
        var classes2 = Array.isArray(target[prop]) ? flattenDeep_1(target[prop]) : target[prop];
        if (target["$".concat(prop)]) {
          var propVal = target["$".concat(prop)](mainTarget, this.component$.value);
          return typeof propVal === "function" ? propVal : flattenDeep_1(propVal);
        }
        if (isPlainObject_1(classes2)) {
          classes2 = cloneDeep_1(classes2);
          each(classes2, (classList, className) => {
            classes2[className] = this.getDynamicClasses(classes2, className, target);
          });
        }
        return classes2;
      }
      getClassHelpers(componentClasses, path) {
        var classHelpers = {};
        each(componentClasses, (classes2, className) => {
          if (className.match(/[$]/)) {
            return;
          }
          if (isPlainObject_1(classes2)) {
            classHelpers[className] = this.getClassHelpers(componentClasses[className], path.concat([className]));
          } else {
            classHelpers[className] = ["".concat(path.join("."), ".").concat(className, "-->")];
          }
        });
        return classHelpers;
      }
      pick(from2, picks) {
        var picked = {};
        if (!from2) {
          return picked;
        }
        each(picks, (pick2) => {
          if (pick2 in from2) {
            picked[pick2] = from2[pick2];
          }
        });
        return picked;
      }
    }
    var _getFormData = function getFormData(data, formData, namespace) {
      if (formData === void 0) {
        formData = new FormData();
      }
      if (namespace === void 0) {
        namespace = "";
      }
      if (isArray_1(data)) {
        each(data, (value, key) => {
          _getFormData(value, formData, namespace + "[" + key + "]");
        });
      } else if (isPlainObject_1(data)) {
        each(data, (value, key) => {
          _getFormData(value, formData, namespace ? namespace + "[" + key + "]" : key);
        });
      } else {
        formData.append(namespace, data === null ? "" : data);
      }
      return formData;
    };
    var arrayMap$4 = _arrayMap;
    function baseValues$1(object2, props) {
      return arrayMap$4(props, function(key) {
        return object2[key];
      });
    }
    var _baseValues = baseValues$1;
    var baseValues = _baseValues, keys$1 = keys_1;
    function values$1(object2) {
      return object2 == null ? [] : baseValues(object2, keys$1(object2));
    }
    var values_1 = values$1;
    function asyncForEach(_x, _x2) {
      return _asyncForEach.apply(this, arguments);
    }
    function _asyncForEach() {
      _asyncForEach = _asyncToGenerator(function* (array2, callback) {
        for (var index2 = 0; index2 < (isPlainObject_1(array2) ? values_1(array2) : array2).length; index2++) {
          var key = isPlainObject_1(array2) ? keys_1(array2)[index2] : index2;
          yield callback(array2[key], key, array2);
        }
      });
      return _asyncForEach.apply(this, arguments);
    }
    var baseAssignValue = _baseAssignValue, baseForOwn = _baseForOwn, baseIteratee$6 = _baseIteratee;
    function mapValues(object2, iteratee) {
      var result = {};
      iteratee = baseIteratee$6(iteratee);
      baseForOwn(object2, function(value, key, object3) {
        baseAssignValue(result, key, iteratee(value, key, object3));
      });
      return result;
    }
    var mapValues_1 = mapValues;
    var baseIsEqual = _baseIsEqual;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    var isEqual_1 = isEqual;
    var fileToObject = function fileToObject2(file2) {
      return {
        lastModified: file2.lastModified,
        name: file2.name,
        size: file2.size,
        type: file2.type
      };
    };
    var _dataToComperable = function dataToComperable(data) {
      if (data instanceof File) {
        return fileToObject(data);
      } else if (data instanceof Date) {
        return data.toString();
      } else if (Array.isArray(data)) {
        return data.map(_dataToComperable);
      } else if (typeof data === "object" && data !== null) {
        return mapValues_1(data, _dataToComperable);
      }
      return data;
    };
    function dataEquals(a2, b2) {
      return isEqual_1(_dataToComperable(a2), _dataToComperable(b2));
    }
    function isComponentRegistered(vm, component) {
      return vm.appContext !== void 0 ? typeof vm.appContext.app.component(component) !== "string" : !!vm.proxy.$root.$options.components[component];
    }
    var flatten$3 = (source) => {
      var collection = [];
      source.forEach((item) => {
        collection.push(item.path);
        if (item.children) {
          flatten$3(item.children).forEach((child) => {
            collection.push(child);
          });
        }
      });
      return collection;
    };
    var _collect = function collect(elements, pages) {
      var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      var createMember = (name2) => {
        var element = elements[name2];
        var path = prefix.length ? "".concat(prefix, ".").concat(name2) : name2;
        var member = {
          name: name2,
          path,
          type: element.type
        };
        if (["group", "object"].indexOf(element.type) !== -1 && Object.keys(element.schema || {}).length) {
          member.children = _collect(element.schema, null, path);
        }
        if (element.type === "list" && Object.keys((element === null || element === void 0 ? void 0 : element.element) || {}).length) {
          member.children = _collect({
            0: element.element
          }, null, path);
        }
        return member;
      };
      var children = [];
      if (pages && Object.keys(pages).length) {
        Object.values(pages).forEach((page) => {
          page.elements.forEach((name2) => {
            children.push(createMember(name2));
          });
        });
      } else {
        Object.keys(elements).forEach((name2) => {
          children.push(createMember(name2));
        });
      }
      return children;
    };
    var toString$6 = toString_1, upperFirst = upperFirst_1;
    function capitalize$1(string2) {
      return upperFirst(toString$6(string2).toLowerCase());
    }
    var capitalize_1 = capitalize$1;
    function arrayReduce$2(array2, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      if (initAccum && length) {
        accumulator = array2[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array2[index2], index2, array2);
      }
      return accumulator;
    }
    var _arrayReduce = arrayReduce$2;
    function basePropertyOf$1(object2) {
      return function(key) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    var _basePropertyOf = basePropertyOf$1;
    var basePropertyOf = _basePropertyOf;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var deburrLetter$1 = basePropertyOf(deburredLetters);
    var _deburrLetter = deburrLetter$1;
    var deburrLetter = _deburrLetter, toString$5 = toString_1;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
    var rsCombo$1 = "[" + rsComboRange$1 + "]";
    var reComboMark = RegExp(rsCombo$1, "g");
    function deburr$1(string2) {
      string2 = toString$5(string2);
      return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var deburr_1 = deburr$1;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords$1(string2) {
      return string2.match(reAsciiWord) || [];
    }
    var _asciiWords = asciiWords$1;
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord$1(string2) {
      return reHasUnicodeWord.test(string2);
    }
    var _hasUnicodeWord = hasUnicodeWord$1;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos$1 = "['’]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords$1(string2) {
      return string2.match(reUnicodeWord) || [];
    }
    var _unicodeWords = unicodeWords$1;
    var asciiWords = _asciiWords, hasUnicodeWord = _hasUnicodeWord, toString$4 = toString_1, unicodeWords = _unicodeWords;
    function words$1(string2, pattern, guard) {
      string2 = toString$4(string2);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
      }
      return string2.match(pattern) || [];
    }
    var words_1 = words$1;
    var arrayReduce$1 = _arrayReduce, deburr = deburr_1, words = words_1;
    var rsApos = "['’]";
    var reApos = RegExp(rsApos, "g");
    function createCompounder$1(callback) {
      return function(string2) {
        return arrayReduce$1(words(deburr(string2).replace(reApos, "")), callback, "");
      };
    }
    var _createCompounder = createCompounder$1;
    var capitalize = capitalize_1, createCompounder = _createCompounder;
    var camelCase = createCompounder(function(result, word, index2) {
      word = word.toLowerCase();
      return result + (index2 ? capitalize(word) : word);
    });
    var camelCase_1 = camelCase;
    var base$1c = function base2(props, context, dependencies2) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (!options.events) {
        throw new Error("`events` option is required for useEvents");
      }
      var events = ref(options.events);
      var listeners = ref({});
      var on2 = (evt, callback) => {
        if (!listeners.value[evt]) {
          listeners.value[evt] = [];
        }
        listeners.value[evt].push(callback);
      };
      var off2 = (evt) => {
        delete listeners.value[evt];
      };
      var fire = function fire2() {
        var evt = arguments[0];
        var args = [].slice.call(arguments).splice(1);
        each(listeners.value[evt], (callback) => {
          callback(...args);
        });
        if (!listeners.value[evt] || !listeners.value[evt].length) {
          context.emit(...[evt].concat(args));
        }
      };
      each(events.value, (evt) => {
        var callback = props["on" + upperFirst_1(camelCase_1(evt))];
        if (callback) {
          on2(evt, callback);
        }
      });
      return {
        events,
        listeners,
        on: on2,
        off: off2,
        fire
      };
    };
    function useModel(props, context, dependencies2) {
      var {
        value: v2,
        modelValue: mv,
        sync
      } = toRefs(props);
      var $this = dependencies2.$this;
      var externalValue = $this.$vueform.vueVersion === 3 ? mv : v2;
      var internalData = ref({});
      var intermediaryValue = ref(externalValue && externalValue.value ? cloneDeep_1(externalValue.value) : null);
      var isSync = computed(() => {
        return sync.value && externalValue && externalValue.value !== void 0;
      });
      var model = computed(() => {
        return cloneDeep_1(externalValue.value || internalData.value);
      });
      var updateModel = (dataPath, val) => {
        if (externalValue.value) {
          if (dataPath) {
            var parts = dataPath.split(".");
            var element = parts.pop();
            var parent2 = parts.join(".") || null;
            var externalValueObject = parent2 ? get_1(externalValue.value, parent2) : externalValue.value;
            if (externalValueObject !== void 0) {
              $this.$set(externalValueObject, element, val);
            }
            intermediaryValue.value = cloneDeep_1(externalValue.value);
          } else {
            each(val, (v3, key) => {
              if (externalValue.value !== void 0) {
                $this.$set(externalValue.value, key, v3);
              }
              if (intermediaryValue.value !== void 0) {
                $this.$set(intermediaryValue.value, key, v3);
              }
            });
          }
        } else {
          var _model = cloneDeep_1(externalValue.value || internalData.value);
          if (dataPath) {
            set_1(_model, dataPath, val);
          } else {
            _model = Object.assign({}, _model, val);
          }
          internalData.value = _model;
        }
      };
      if (externalValue && externalValue.value) {
        watch(model, (n2, o2) => {
          if (dataEquals(n2, o2)) {
            return;
          }
          internalData.value = n2;
        }, {
          deep: true,
          immediate: false
        });
      }
      return {
        model,
        internalData,
        intermediaryValue,
        externalValue,
        isSync,
        updateModel
      };
    }
    var base$1b = function base2(props, context) {
      var {
        schema,
        tabs,
        steps,
        size: size2,
        view,
        views,
        addClass: addClass2,
        removeClass: removeClass2,
        replaceClass,
        overrideClass,
        addClasses,
        removeClasses,
        replaceClasses,
        overrideClasses,
        presets,
        templates,
        theme,
        messages,
        columns: columns2,
        languages,
        formKey,
        endpoint,
        method,
        formData,
        language,
        locale: locale2,
        validateOn,
        forceLabels,
        floatPlaceholders,
        multilingual: multilingual2,
        stepsControls,
        displayErrors,
        displayMessages,
        formatLoad,
        formatData,
        forceNumbers,
        prepare,
        default: default_,
        disabled,
        loading,
        providers,
        useProviders,
        providerOptions,
        onChange: _onChange,
        onReset: _onReset,
        onClear: _onClear,
        onSubmit: _onSubmit,
        onSuccess: _onSuccess,
        onError: _onError,
        onLanguage: _onLanguage,
        onBeforeMount: _onBeforeMount,
        onMounted: _onMounted,
        onBeforeUpdate: _onBeforeUpdate,
        onUpdated: _onUpdated,
        onBeforeUnmount: _onBeforeUnmount,
        onUnmounted: _onUnmounted
      } = toRefs(props);
      var evts = ["change", "reset", "clear", "submit", "success", "error", "language", "response", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"];
      var vm = getCurrentInstance();
      var $this = vm.proxy;
      var {
        events,
        listeners,
        fire,
        on: on2,
        off: off2
      } = base$1c(props, context, {
        form$: $this
      }, {
        events: evts
      });
      var {
        externalValue,
        model,
        internalData,
        intermediaryValue,
        isSync,
        updateModel
      } = useModel(props, context, {
        $this,
        fire
      });
      var elements$ = ref({});
      var tabs$ = ref(null);
      var steps$ = ref(null);
      var validation2 = ref(true);
      var conditions = ref(true);
      var messageBag2 = ref({});
      var submitting = ref(false);
      var preparing = ref(false);
      var cancelToken = ref(null);
      var selectedLanguage = ref(null);
      var userConfig = ref({});
      var mounted = ref(false);
      var messagesRegistered = ref(isComponentRegistered(vm, "FormMessages"));
      var errorsRegistered = ref(isComponentRegistered(vm, "FormErrors"));
      var languagesRegistered = ref(isComponentRegistered(vm, "FormLanguages"));
      var tabsRegistered = ref(isComponentRegistered(vm, "FormTabs"));
      var stepsRegistered = ref(isComponentRegistered(vm, "FormSteps"));
      var form$ = computed(() => {
        return $this;
      });
      var baseConfig2 = computed(() => {
        return $this.$vueform;
      });
      var config$ = computed(() => {
        return baseConfig2.value;
      });
      var locale$ = computed(() => {
        return options.value.locale || baseConfig2.value.i18n.locale;
      });
      var services = computed(() => {
        return $this.$vueform.services;
      });
      var options = computed(() => {
        var options2 = {
          schema: orderedSchema.value,
          tabs: formTabs.value,
          steps: formSteps.value
        };
        var override = {
          columns: columns2,
          languages,
          language,
          theme,
          method,
          validateOn,
          messages,
          formKey,
          multilingual: multilingual2,
          formatLoad,
          formatData,
          prepare,
          default: default_,
          formData,
          templates,
          addClass: addClass2,
          removeClass: removeClass2,
          replaceClass,
          overrideClass,
          addClasses,
          removeClasses,
          replaceClasses,
          overrideClasses,
          presets,
          size: size2,
          view,
          views,
          locale: locale2
        };
        var ifPropSet = {
          stepsControls,
          displayErrors,
          displayMessages,
          forceLabels,
          disabled,
          loading,
          floatPlaceholders,
          endpoint,
          forceNumbers,
          onChange: _onChange.value,
          onReset: _onReset.value,
          onClear: _onClear.value,
          onSubmit: _onSubmit.value,
          onSuccess: _onSuccess.value,
          onError: _onError.value,
          onLanguage: _onLanguage.value,
          onBeforeMount: _onBeforeMount.value,
          onMounted: _onMounted.value,
          onBeforeUpdate: _onBeforeUpdate.value,
          onUpdated: _onUpdated.value,
          onBeforeUnmount: _onBeforeUnmount.value,
          onUnmounted: _onUnmounted.value
        };
        var toMerge = {
          useProviders,
          providers,
          providerOptions
        };
        var defaults2 = {
          providers: baseConfig2.value.config.providers,
          useProviders: baseConfig2.value.config.useProviders,
          providerOptions: baseConfig2.value.config.providerOptions,
          languages: baseConfig2.value.config.languages,
          language: baseConfig2.value.config.language,
          endpoint: typeof baseConfig2.value.config.endpoints.submit === "function" ? baseConfig2.value.config.endpoints.submit : baseConfig2.value.config.endpoints.submit.url,
          method: typeof baseConfig2.value.config.endpoints.submit === "function" ? null : baseConfig2.value.config.endpoints.submit.method,
          validateOn: baseConfig2.value.config.validateOn,
          displayErrors: baseConfig2.value.config.displayErrors,
          displayMessages: baseConfig2.value.config.displayMessages,
          forceLabels: baseConfig2.value.config.forceLabels,
          floatPlaceholders: baseConfig2.value.config.floatPlaceholders,
          formData: baseConfig2.value.config.formData,
          theme: baseConfig2.value.theme,
          view: baseConfig2.value.config.view,
          views: {},
          columns: {},
          size: null,
          addClass: null,
          removeClass: null,
          replaceClass: null,
          overrideClass: null,
          addClasses: {},
          removeClasses: {},
          replaceClasses: {},
          overrideClasses: {},
          presets: [],
          templates: {},
          messages: {},
          default: {},
          formKey: null,
          formatLoad: null,
          formatData: null,
          forceNumbers: null,
          prepare: null,
          multilingual: false,
          stepsControls: true,
          disabled: false,
          loading: false
        };
        each(override, (val, key) => {
          options2[key] = userConfig.value[key] !== void 0 ? userConfig.value[key] : (val && val.value ? val.value : void 0) || defaults2[key];
        });
        each(ifPropSet, (val, key) => {
          options2[key] = userConfig.value[key] !== void 0 ? userConfig.value[key] : val && val.value !== null ? val.value : defaults2[key];
        });
        each(toMerge, (val, key) => {
          options2[key] = merge_1({}, defaults2[key], userConfig.value[key] || {}, val && val.value ? val.value : {});
        });
        return options2;
      });
      var orderedSchema = computed(() => {
        var blocks;
        var orderedSchema2 = formSchema.value;
        if (Object.keys(formSteps.value).length > 0) {
          blocks = formSteps.value;
        }
        if (Object.keys(formTabs.value).length > 0) {
          blocks = formTabs.value;
        }
        if (blocks) {
          orderedSchema2 = {};
          each(blocks, (block) => {
            each(block.elements, (name2) => {
              if (formSchema.value[name2]) {
                orderedSchema2[name2] = formSchema.value[name2];
              }
            });
          });
          each(Object.keys(formSchema.value), (name2) => {
            if (orderedSchema2[name2] === void 0) {
              orderedSchema2[name2] = formSchema.value[name2];
            }
          });
        }
        return orderedSchema2;
      });
      var formSchema = computed(() => {
        return merge_1({}, schema && schema.value ? schema.value : {}, userConfig.value.schema || {});
      });
      var formTabs = computed(() => {
        return merge_1({}, tabs && tabs.value ? tabs.value : {}, userConfig.value.tabs || {});
      });
      var formSteps = computed(() => {
        return merge_1({}, steps && steps.value ? steps.value : {}, userConfig.value.steps || {});
      });
      var tree = computed(() => {
        return _collect(formSchema.value, hasTabs.value ? formTabs.value : formSteps.value);
      });
      var flatTree = computed(() => {
        return flatten$3(tree.value);
      });
      var data = computed(() => {
        var data2 = {};
        each(elements$.value, (e$) => {
          if (e$.isStatic) {
            return;
          }
          data2 = Object.assign({}, data2, e$.data);
        });
        return data2;
      });
      var requestData = computed(() => {
        var requestData2 = {};
        each(elements$.value, (e$) => {
          if (e$.isStatic) {
            return;
          }
          requestData2 = Object.assign({}, requestData2, e$.requestData);
        });
        return formatData.value ? formatData.value(requestData2) : requestData2;
      });
      var dirty = computed(() => {
        return some_1(elements$.value, (element$) => {
          return element$.isStatic === false && element$.available === true && element$.dirty === true;
        });
      });
      var invalid = computed(() => {
        return some_1(elements$.value, (element$) => {
          return element$.isStatic === false && element$.available === true && element$.invalid === true;
        });
      });
      var debouncing = computed(() => {
        return some_1(elements$.value, (element$) => {
          return element$.isStatic === false && element$.available === true && element$.debouncing === true;
        });
      });
      var pending = computed(() => {
        return some_1(elements$.value, (element$) => {
          return element$.isStatic === false && element$.available === true && element$.pending === true;
        });
      });
      var validated = computed(() => {
        return !some_1(elements$.value, (element$) => {
          return element$.isStatic === false && element$.available === true && element$.validated === false;
        });
      });
      var busy = computed(() => {
        return some_1(elements$.value, (element$) => {
          return element$.isStatic === false && element$.available === true && element$.busy === true;
        }) || submitting.value || preparing.value || isLoading.value;
      });
      var elementErrors = computed(() => {
        var errors = [];
        each(filter_1(elements$.value, {
          available: true,
          isStatic: false
        }), (element$) => {
          each(element$.errors, (error) => {
            errors.push(error);
          });
        });
        return errors;
      });
      var formErrors = computed(() => {
        return messageBag2.value.errors;
      });
      var hasErrors = computed(() => {
        return formErrors.value.length > 0;
      });
      var showErrors = computed(() => {
        return hasErrors.value && options.value.displayErrors && errorsRegistered.value;
      });
      var formMessages = computed(() => {
        return messageBag2.value.messages;
      });
      var hasMessages = computed(() => {
        return formMessages.value.length > 0;
      });
      var showMessages = computed(() => {
        return hasMessages.value && options.value.displayMessages && messagesRegistered.value;
      });
      var isMultilingual = computed(() => {
        return options.value.multilingual;
      });
      var showLanguages = computed(() => {
        return isMultilingual.value && languagesRegistered.value;
      });
      var isDisabled = computed(() => {
        return invalid.value && shouldValidateOnChange.value || busy.value || options.value.disabled;
      });
      var isLoading = computed(() => {
        return options.value.loading;
      });
      var shouldValidateOnChange = computed(() => {
        return options.value.validateOn.split("|").indexOf("change") !== -1;
      });
      var shouldValidateOnStep = computed(() => {
        return options.value.validateOn.split("|").indexOf("step") !== -1;
      });
      var hasSteps = computed(() => {
        return !isEmpty_1(options.value.steps);
      });
      var showSteps = computed(() => {
        return hasSteps.value && stepsRegistered.value;
      });
      var showStepsControls = computed(() => {
        return hasSteps.value && options.value.stepsControls && stepsRegistered.value;
      });
      var hasTabs = computed(() => {
        return !isEmpty_1(options.value.tabs);
      });
      var showTabs = computed(() => {
        return hasTabs.value && tabsRegistered.value;
      });
      var extendedTheme = computed(() => {
        var presetTemplates = {};
        each(baseConfig2.value.config.usePresets.concat(options.value.presets), (presetName) => {
          var preset = baseConfig2.value.config.presets[presetName];
          if (!preset || !preset.templates) {
            return;
          }
          presetTemplates = Object.assign({}, presetTemplates, preset.templates);
        });
        return Object.assign({}, options.value.theme, {
          // Add registered component to theme (or overwrite)
          templates: Object.assign({}, options.value.theme.templates, baseConfig2.value.templates, presetTemplates, options.value.templates || {})
        });
      });
      var Templates = computed(() => {
        return extendedTheme.value.templates;
      });
      var template = computed(() => {
        return View.value && Templates.value["Vueform_".concat(View.value)] ? Templates.value["Vueform_".concat(View.value)] : Templates.value.Vueform;
      });
      var classes2 = computed(() => {
        return new MergeClasses({
          component: "Vueform",
          component$: form$,
          theme: extendedTheme.value,
          config: baseConfig2.value.config,
          templates: Templates.value,
          view: View.value,
          locals: options.value,
          merge: [options.value]
        }).classes;
      });
      var Size = computed(() => {
        var Size2;
        if (options.value.size) {
          Size2 = options.value.size;
        } else {
          each(baseConfig2.value.config.usePresets.concat(options.value.presets), (presetName) => {
            var preset = baseConfig2.value.config.presets[presetName];
            if (!preset || !preset.size) {
              return;
            }
            Size2 = preset.size;
          });
        }
        if (!Size2) {
          Size2 = baseConfig2.value.config.size;
        }
        return Size2;
      });
      var Views = computed(() => {
        var Views2 = baseConfig2.value.config.views;
        each(baseConfig2.value.config.usePresets.concat(options.value.presets), (presetName) => {
          var preset = baseConfig2.value.config.presets[presetName];
          if (!preset || !preset.views) {
            return;
          }
          Views2 = Object.assign({}, Views2, preset.views);
        });
        Views2 = Object.assign({}, Views2, options.value.views);
        return Views2;
      });
      var View = computed(() => {
        if (options.value.view) {
          return options.value.view;
        }
        return Views.value.Vueform;
      });
      var translations = computed(() => {
        var i18n2 = $this.$vueform.i18n;
        var locales2 = i18n2.locales;
        var currentLocale = locale2.value || i18n2.locale;
        var fallbackLocale = i18n2.fallbackLocale || "en";
        return currentLocale ? merge_1({}, locales2[fallbackLocale], locales2[currentLocale]) : locales2[fallbackLocale];
      });
      var update = function update2(data2) {
        var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        if (path) {
          el$(path).update(data2);
          return;
        }
        each(elements$.value, (element$) => {
          if (element$.isStatic) {
            return;
          }
          if (data2[element$.name] === void 0 && !element$.flat) {
            return;
          }
          element$.update(element$.flat ? data2 : data2[element$.name]);
        });
      };
      var load = /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator(function* (data2) {
          var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (steps$.value !== null) {
            steps$.value.enableAllSteps();
          }
          var formatted = format2 && options.value.formatLoad !== null ? options.value.formatLoad(data2) : data2;
          yield asyncForEach(elements$.value, /* @__PURE__ */ function() {
            var _ref2 = _asyncToGenerator(function* (e$) {
              if (e$.isStatic) {
                return;
              }
              var loadValue = e$.flat ? formatted : formatted[e$.name];
              if (loadValue === void 0) {
                e$.clear();
                return;
              }
              yield e$.load(loadValue, format2);
            });
            return function(_x2) {
              return _ref2.apply(this, arguments);
            };
          }());
        });
        return function load2(_x) {
          return _ref.apply(this, arguments);
        };
      }();
      var reset = () => {
        each(elements$.value, (e$) => {
          if (e$.isStatic) {
            return;
          }
          e$.reset();
        });
        if (steps$.value !== null) {
          steps$.value.reset();
        }
        if (tabs$.value !== null) {
          tabs$.value.reset();
        }
        fire("reset");
      };
      var clear2 = () => {
        each(elements$.value, (e$) => {
          if (e$.isStatic) {
            return;
          }
          e$.clear();
        });
        if (steps$.value !== null) {
          steps$.value.reset();
        }
        if (tabs$.value !== null) {
          tabs$.value.reset();
        }
        fire("clear");
      };
      var clean = () => {
        each(elements$.value, (e$) => {
          if (e$.isStatic) {
            return;
          }
          e$.clean();
        });
      };
      var clearMessages = () => {
        if (messageBag2.value) {
          messageBag2.value.clear();
        }
        each(elements$.value, (e$) => {
          if (e$.isStatic) {
            return;
          }
          e$.clearMessages();
        });
      };
      var validate = /* @__PURE__ */ function() {
        var _ref3 = _asyncToGenerator(function* () {
          if (!invalid.value && validated.value && shouldValidateOnChange.value) {
            return;
          }
          var validatableElements = Object.values(elements$.value).filter((e$) => {
            return e$.available && !e$.isStatic && (!e$.validated || !shouldValidateOnChange.value);
          });
          yield asyncForEach(validatableElements, /* @__PURE__ */ function() {
            var _ref4 = _asyncToGenerator(function* (e$) {
              yield e$.validate();
            });
            return function(_x3) {
              return _ref4.apply(this, arguments);
            };
          }());
        });
        return function validate2() {
          return _ref3.apply(this, arguments);
        };
      }();
      var resetValidators = () => {
        each(elements$.value, (e$) => {
          if (e$.isStatic) {
            return;
          }
          e$.resetValidators();
        });
      };
      var submit = /* @__PURE__ */ function() {
        var _ref5 = _asyncToGenerator(function* () {
          if (isDisabled.value) {
            return;
          }
          yield validate();
          if (invalid.value) {
            return;
          }
          preparing.value = true;
          try {
            yield prepareElements();
            if (typeof options.value.prepare === "function") {
              yield options.value.prepare(form$.value);
            }
            if (typeof $this.$vueform.config.beforeSend === "function") {
              yield $this.$vueform.config.beforeSend(form$.value);
            }
          } catch (error) {
            fire("error", error, {
              type: "prepare"
            }, form$.value);
            console.error(error);
            return;
          } finally {
            preparing.value = false;
          }
          var data2 = options.value.formData(form$.value);
          fire("submit", form$.value, data2);
          if (!options.value.endpoint) {
            return;
          }
          send();
        });
        return function submit2() {
          return _ref5.apply(this, arguments);
        };
      }();
      var send = /* @__PURE__ */ function() {
        var _ref6 = _asyncToGenerator(function* () {
          submitting.value = true;
          var response = {};
          try {
            var _response2, _response3;
            resetValidators();
            var _data = options.value.formData(form$.value);
            if (typeof options.value.endpoint === "function") {
              response = yield options.value.endpoint(_data, form$.value);
            } else {
              var _$this$$vueform$confi, _$this$$vueform$confi2;
              cancelToken.value = services.value.axios.CancelToken.source();
              var url2 = ((_$this$$vueform$confi = $this.$vueform.config.endpoints[options.value.endpoint]) === null || _$this$$vueform$confi === void 0 ? void 0 : _$this$$vueform$confi.url) || options.value.endpoint;
              var _method = ((_$this$$vueform$confi2 = $this.$vueform.config.endpoints[options.value.endpoint]) === null || _$this$$vueform$confi2 === void 0 ? void 0 : _$this$$vueform$confi2.method) || options.value.method;
              response = yield services.value.axios.request({
                url: url2,
                method: _method.toLowerCase(),
                [_method.toLowerCase() === "get" ? "params" : "data"]: _data,
                cancelToken: cancelToken.value.token
              });
            }
            if (response && !(response instanceof Promise)) {
              var _response;
              if ((_response = response) !== null && _response !== void 0 && (_response = _response.data) !== null && _response !== void 0 && (_response = _response.payload) !== null && _response !== void 0 && _response.updates) {
                update(response.data.payload.updates);
              }
            }
            if (((_response2 = response) === null || _response2 === void 0 ? void 0 : _response2.status) >= 200 && ((_response3 = response) === null || _response3 === void 0 ? void 0 : _response3.status) < 300) {
              fire("success", response, form$.value);
            } else {
              fire("error", {
                response
              }, {
                type: "submit"
              }, form$.value);
            }
          } catch (error) {
            if (error.response) {
              fire("error", error, {
                type: "submit"
              }, form$.value);
              fire("response", error.response, form$.value);
            } else if (services.value.axios.isCancel(error)) {
              fire("error", error, {
                type: "cancel"
              }, form$.value);
            } else {
              fire("error", error, {
                type: "other"
              }, form$.value);
            }
            console.error(error);
            return;
          } finally {
            cancelToken.value = null;
            submitting.value = false;
          }
          fire("response", response, form$.value);
        });
        return function send2() {
          return _ref6.apply(this, arguments);
        };
      }();
      var cancel = () => {
        if (!cancelToken.value) {
          return;
        }
        cancelToken.value.cancel();
      };
      var prepareElements = /* @__PURE__ */ function() {
        var _ref7 = _asyncToGenerator(function* () {
          try {
            yield asyncForEach(elements$.value, /* @__PURE__ */ function() {
              var _ref8 = _asyncToGenerator(function* (e$) {
                if (e$.prepare) {
                  yield e$.prepare();
                }
              });
              return function(_x4) {
                return _ref8.apply(this, arguments);
              };
            }());
          } catch (e2) {
            throw new Error(e2);
          }
        });
        return function prepareElements2() {
          return _ref7.apply(this, arguments);
        };
      }();
      var disableValidation = () => {
        validation2.value = false;
      };
      var enableValidation = () => {
        validation2.value = true;
      };
      var enableConditions = () => {
        conditions.value = true;
      };
      var disableConditions = () => {
        conditions.value = false;
      };
      var setLanguage = (code) => {
        selectedLanguage.value = code;
        fire("language", code);
      };
      var handleSubmit = () => {
        submit();
      };
      var convertFormData = (data2) => {
        return _getFormData(data2);
      };
      var el$ = (path, elements) => {
        if (elements === void 0) {
          elements = elements$.value;
        }
        if (isEmpty_1(elements) || !path) {
          return null;
        }
        var matches2 = String(path).match(/^[^.]+\./);
        if (matches2) {
          var current = matches2[0].replace(".", "");
          if (!elements[current]) {
            return null;
          }
          return el$(path.replace(matches2[0], ""), elements[current].children$);
        } else if (elements[path] !== void 0) {
          return elements[path];
        }
        return null;
      };
      var siblings$ = (path) => {
        var _el$;
        if (!/\.+/.test(path)) {
          return elements$.value;
        }
        return ((_el$ = el$(path.match(/.*(?=\.)/)[0])) === null || _el$ === void 0 ? void 0 : _el$.children$) || {};
      };
      var initMessageBag = () => {
        messageBag2.value = new services.value.messageBag(elementErrors);
      };
      provide("form$", form$);
      provide("theme", extendedTheme);
      provide("Size", Size);
      provide("Views", Views);
      provide("translations", translations);
      provide("config$", config$);
      initMessageBag();
      setLanguage(options.value.language);
      onBeforeMount(() => {
        userConfig.value = $this.vueform || {};
        each(evts, (evt) => {
          var callback = options.value["on" + upperFirst_1(evt)];
          if (callback) {
            on2(evt, callback);
          }
        });
        fire("beforeMount", $this);
      });
      onMounted(() => {
        mounted.value = true;
        watch(data, (n2, o2) => {
          if (dataEquals(n2, o2)) {
            return;
          }
          fire("change", n2, o2, $this);
          if (externalValue && externalValue.value !== void 0) {
            context.emit("input", n2);
            context.emit("update:modelValue", n2);
          }
        }, {
          deep: true,
          immediate: false
        });
        if (externalValue && externalValue.value !== void 0 && JSON.stringify(externalValue.value) !== JSON.stringify(data.value)) {
          context.emit("input", data.value);
          context.emit("update:modelValue", data.value);
        }
        fire("mounted", $this);
      });
      onBeforeUpdate(() => fire("beforeUpdate", $this));
      onUpdated(() => fire("updated", $this));
      onBeforeUnmount(() => fire("beforeUnmount", $this));
      onUnmounted(() => fire("unmounted", $this));
      watch(computed(() => options.value.language), (n2, o2) => {
        if (n2) {
          setLanguage(n2);
        }
      });
      return {
        tabs$,
        steps$,
        elements$,
        options,
        validation: validation2,
        conditions,
        messageBag: messageBag2,
        selectedLanguage,
        submitting,
        preparing,
        cancelToken,
        events,
        listeners,
        internalData,
        data,
        requestData,
        dirty,
        invalid,
        debouncing,
        pending,
        validated,
        busy,
        formErrors,
        formMessages,
        isDisabled,
        isLoading,
        shouldValidateOnChange,
        shouldValidateOnStep,
        hasSteps,
        hasTabs,
        hasErrors,
        hasMessages,
        isMultilingual,
        showErrors,
        showMessages,
        showLanguages,
        showSteps,
        showTabs,
        showStepsControls,
        classes: classes2,
        Templates,
        template,
        extendedTheme,
        Size,
        View,
        Views,
        form$,
        model,
        intermediaryValue,
        userConfig,
        isSync,
        tree,
        flatTree,
        translations,
        locale$,
        prepareElements,
        updateModel,
        update,
        load,
        reset,
        clear: clear2,
        clean,
        clearMessages,
        validate,
        resetValidators,
        convertFormData,
        submit,
        send,
        cancel,
        disableValidation,
        enableValidation,
        enableConditions,
        disableConditions,
        setLanguage,
        handleSubmit,
        el$,
        siblings$,
        initMessageBag,
        fire,
        on: on2,
        off: off2,
        messagesRegistered,
        errorsRegistered,
        languagesRegistered,
        tabsRegistered,
        stepsRegistered
      };
    };
    var base$1a = function base2(props, context, dependencies2) {
      var componentName = context.name;
      var form$ = dependencies2.form$;
      var el$ = dependencies2.el$;
      var component$ = dependencies2.component$ || dependencies2.el$;
      var theme = dependencies2.theme;
      var Templates = dependencies2.Templates;
      var View = dependencies2.View;
      var classesInstance = computed(() => {
        return new MergeClasses({
          component: componentName.value,
          component$,
          theme: theme.value,
          config: form$.value.$vueform.config,
          templates: Templates.value,
          view: View.value,
          merge: [form$.value.options, el$.value]
        });
      });
      var classes2 = computed(() => {
        var _classesInstance$valu;
        return _objectSpread2$1({}, (_classesInstance$valu = classesInstance.value) === null || _classesInstance$valu === void 0 ? void 0 : _classesInstance$valu.classes);
      });
      return {
        classes: classes2,
        classesInstance
      };
    };
    var VueformComponent = {
      name: "Vueform",
      emits: ["input", "update:modelValue", "change", "reset", "clear", "submit", "success", "error", "response", "language", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      slots: ["default", "empty"],
      setup: (props, context) => {
        context.emits = ["input", "update:modelValue", "change", "reset", "clear", "submit", "success", "error", "response", "language", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"];
        context.name = ref("Vueform");
        var {
          tabs$,
          steps$,
          elements$,
          options,
          validation: validation2,
          conditions,
          messageBag: messageBag2,
          selectedLanguage,
          submitting,
          preparing,
          cancelToken,
          events,
          listeners,
          internalData,
          data,
          requestData,
          dirty,
          invalid,
          debouncing,
          pending,
          validated,
          busy,
          formErrors,
          formMessages,
          isDisabled,
          isLoading,
          shouldValidateOnChange,
          shouldValidateOnStep,
          hasSteps,
          hasTabs,
          hasErrors,
          hasMessages,
          isMultilingual,
          showErrors,
          showMessages,
          showLanguages,
          showSteps,
          showTabs,
          showStepsControls,
          classes: classes2,
          Templates,
          template,
          extendedTheme,
          Size,
          View,
          Views,
          form$,
          model,
          intermediaryValue,
          userConfig,
          isSync,
          tree,
          flatTree,
          translations,
          locale$,
          prepareElements,
          updateModel,
          update,
          load,
          reset,
          clear: clear2,
          clean,
          clearMessages,
          validate,
          resetValidators,
          convertFormData,
          submit,
          send,
          cancel,
          disableValidation,
          enableValidation,
          enableConditions,
          disableConditions,
          setLanguage,
          handleSubmit,
          el$,
          siblings$,
          initMessageBag,
          fire,
          on: on2,
          off: off2,
          messagesRegistered,
          errorsRegistered,
          languagesRegistered,
          tabsRegistered,
          stepsRegistered
        } = base$1b(props, context);
        return {
          tabs$,
          steps$,
          elements$,
          options,
          validation: validation2,
          conditions,
          messageBag: messageBag2,
          selectedLanguage,
          submitting,
          preparing,
          cancelToken,
          events,
          listeners,
          internalData,
          data,
          requestData,
          dirty,
          invalid,
          debouncing,
          pending,
          validated,
          busy,
          formErrors,
          formMessages,
          isDisabled,
          isLoading,
          shouldValidateOnChange,
          shouldValidateOnStep,
          hasSteps,
          hasTabs,
          hasErrors,
          hasMessages,
          isMultilingual,
          showErrors,
          showMessages,
          showLanguages,
          showSteps,
          showTabs,
          showStepsControls,
          classes: classes2,
          Templates,
          template,
          extendedTheme,
          Size,
          View,
          Views,
          form$,
          model,
          intermediaryValue,
          userConfig,
          isSync,
          tree,
          flatTree,
          translations,
          locale$,
          prepareElements,
          updateModel,
          update,
          load,
          reset,
          clear: clear2,
          clean,
          clearMessages,
          validate,
          resetValidators,
          convertFormData,
          submit,
          send,
          cancel,
          disableValidation,
          enableValidation,
          enableConditions,
          disableConditions,
          setLanguage,
          handleSubmit,
          el$,
          siblings$,
          initMessageBag,
          fire,
          on: on2,
          off: off2,
          messagesRegistered,
          errorsRegistered,
          languagesRegistered,
          tabsRegistered,
          stepsRegistered
        };
      },
      props: {
        schema: {
          type: Object,
          required: false,
          default: null
        },
        name: {
          type: String,
          required: false,
          default: null,
          private: true
        },
        tabs: {
          type: Object,
          required: false,
          default: null
        },
        steps: {
          type: Object,
          required: false,
          default: null
        },
        stepsControls: {
          type: Boolean,
          required: false,
          default: null,
          "@default": true
        },
        validateOn: {
          type: String,
          required: false,
          default: null
        },
        displayErrors: {
          type: Boolean,
          required: false,
          default: null
        },
        displayMessages: {
          type: Boolean,
          required: false,
          default: null
        },
        messages: {
          type: Object,
          required: false,
          default: null
        },
        endpoint: {
          type: [String, Boolean, Function, Promise],
          required: false,
          default: null
        },
        method: {
          type: String,
          required: false,
          default: null
        },
        prepare: {
          type: Function,
          required: false,
          default: null
        },
        formKey: {
          type: [String, Number],
          required: false,
          default: null
        },
        formData: {
          type: Function,
          required: false,
          default: null
        },
        value: {
          type: Object,
          required: false,
          default: void 0
        },
        modelValue: {
          type: Object,
          required: false,
          default: void 0
        },
        sync: {
          type: Boolean,
          required: false,
          default: false
        },
        default: {
          type: Object,
          required: false,
          default: null
        },
        forceNumbers: {
          required: false,
          type: [Boolean],
          default: null
        },
        formatData: {
          type: Function,
          required: false,
          default: null
        },
        formatLoad: {
          type: Function,
          required: false,
          default: null
        },
        loading: {
          type: Boolean,
          required: false,
          default: null
        },
        disabled: {
          type: Boolean,
          required: false,
          default: null
        },
        columns: {
          type: Object,
          required: false,
          default: null
        },
        forceLabels: {
          type: Boolean,
          required: false,
          default: null
        },
        floatPlaceholders: {
          type: Boolean,
          required: false,
          default: null
        },
        size: {
          required: false,
          type: [String],
          default: null
        },
        view: {
          required: false,
          type: [String],
          default: null
        },
        views: {
          required: false,
          type: [Object],
          default: null
        },
        addClasses: {
          required: false,
          type: [Object, Function],
          default: null
        },
        addClass: {
          required: false,
          type: [Array, Object, String, Function],
          default: null
        },
        removeClasses: {
          required: false,
          type: [Object, Function],
          default: null
        },
        removeClass: {
          required: false,
          type: [Array, Object, Function],
          default: null
        },
        replaceClasses: {
          required: false,
          type: [Object, Function],
          default: null
        },
        replaceClass: {
          required: false,
          type: [Object, Function],
          default: null
        },
        overrideClasses: {
          required: false,
          type: [Object, Function],
          default: null
        },
        overrideClass: {
          required: false,
          type: [Array, Object, String, Function],
          default: null
        },
        templates: {
          type: Object,
          required: false,
          default: null
        },
        presets: {
          required: false,
          type: [Array],
          default: null
        },
        multilingual: {
          type: Boolean,
          required: false,
          default: null
        },
        languages: {
          type: Object,
          required: false,
          default: null
        },
        language: {
          type: String,
          required: false,
          default: null
        },
        locale: {
          type: String,
          required: false,
          default: null
        },
        providers: {
          type: [Object],
          required: false,
          default: null
        },
        useProviders: {
          type: [Object],
          required: false,
          default: null
        },
        providerOptions: {
          type: [Object],
          required: false,
          default: null
        },
        onChange: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onReset: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onClear: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onSubmit: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onResponse: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onSuccess: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onError: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onLanguage: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onBeforeMount: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onMounted: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onBeforeUpdate: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onUpdated: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onBeforeUnmount: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onUnmounted: {
          required: false,
          type: [Function],
          default: null,
          private: true
        }
      },
      render() {
        return this.template.render.apply(this, arguments);
      }
      // staticRenderFns() {
      //   return this.templates.Vueform.staticRenderFns
      // }
    };
    var baseEach$1 = _baseEach, isArrayLike$2 = isArrayLike_1;
    function baseMap$2(collection, iteratee) {
      var index2 = -1, result = isArrayLike$2(collection) ? Array(collection.length) : [];
      baseEach$1(collection, function(value, key, collection2) {
        result[++index2] = iteratee(value, key, collection2);
      });
      return result;
    }
    var _baseMap = baseMap$2;
    var arrayMap$3 = _arrayMap, baseIteratee$5 = _baseIteratee, baseMap$1 = _baseMap, isArray$4 = isArray_1;
    function map(collection, iteratee) {
      var func = isArray$4(collection) ? arrayMap$3 : baseMap$1;
      return func(collection, baseIteratee$5(iteratee));
    }
    var map_1 = map;
    var baseGetTag = _baseGetTag, isArray$3 = isArray_1, isObjectLike = isObjectLike_1;
    var stringTag = "[object String]";
    function isString$1(value) {
      return typeof value == "string" || !isArray$3(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    var isString_1 = isString$1;
    var reWhitespace = /\s/;
    function trimmedEndIndex$1(string2) {
      var index2 = string2.length;
      while (index2-- && reWhitespace.test(string2.charAt(index2))) {
      }
      return index2;
    }
    var _trimmedEndIndex = trimmedEndIndex$1;
    var trimmedEndIndex = _trimmedEndIndex;
    var reTrimStart = /^\s+/;
    function baseTrim$2(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    var _baseTrim = baseTrim$2;
    var baseIndexOf$2 = _baseIndexOf;
    function charsEndIndex$1(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf$2(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    var _charsEndIndex = charsEndIndex$1;
    var baseIndexOf$1 = _baseIndexOf;
    function charsStartIndex$1(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf$1(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    var _charsStartIndex = charsStartIndex$1;
    var baseToString$2 = _baseToString, baseTrim$1 = _baseTrim, castSlice = _castSlice, charsEndIndex = _charsEndIndex, charsStartIndex = _charsStartIndex, stringToArray = _stringToArray, toString$3 = toString_1;
    function trim(string2, chars, guard) {
      string2 = toString$3(string2);
      if (string2 && (guard || chars === void 0)) {
        return baseTrim$1(string2);
      }
      if (!string2 || !(chars = baseToString$2(chars))) {
        return string2;
      }
      var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
      return castSlice(strSymbols, start2, end2).join("");
    }
    var trim_1 = trim;
    var Validator = class {
      constructor(rule, props) {
        var _props$element$;
        this.rule = rule;
        this.attributes = rule.attributes || {};
        this.conditions = rule.conditions || [];
        this.dependents = rule.dependents || [];
        this.element$ = props.element$;
        this.form$ = ((_props$element$ = props.element$) === null || _props$element$ === void 0 ? void 0 : _props$element$.form$) || {};
        this.numeric = props.numeric || false;
        this.elementMessages = props.element$.messages;
        this.invalid = false;
        this.pending = false;
        this.debouncer = null;
        this.lastValue = null;
        this.watchers = {};
        this.dependents.forEach((dependent) => {
          watch(computed(() => get_1(this.form$.data, dependent)), () => {
            if (this.element$.validated) {
              if (this.name === "nullable") {
                this.element$.validate();
              } else {
                this.revalidate();
              }
            }
          });
        });
        watch(computed(() => props.element$.messages), (n2, o2) => {
          if (isEqual_1(n2, o2)) {
            return;
          }
          this.elementMessages = props.element$.messages;
        }, {
          deep: true
        });
        this.init();
      }
      get moment() {
        return this.form$.$vueform.services.moment;
      }
      get name() {
        return this.rule.name;
      }
      get failing() {
        return this.invalid;
      }
      get defaultMessage() {
        return this.form$.translations.vueform.defaultMessage;
      }
      get message() {
        var _this$form$$translati;
        var message = "";
        if (this.msg) {
          message = this.msg;
        } else if (this.elementMessages[this.name]) {
          message = this.elementMessages[this.name];
        } else if (this.form$.options.messages[this.name]) {
          message = this.form$.options.messages[this.name];
        } else if (this.name !== "_class" && ((_this$form$$translati = this.form$.translations.validation) === null || _this$form$$translati === void 0 ? void 0 : _this$form$$translati[this.name]) !== void 0) {
          message = this.form$.translations.validation[this.name];
          if (isPlainObject_1(message)) {
            message = message[this.messageType];
          }
        } else {
          message = this.defaultMessage;
        }
        each(map_1(message.match(/:\w+/g), (p2) => p2.replace(":", "")), (param) => {
          message = message.replace(":".concat(param), this.messageParams[param]);
        });
        each(map_1(message.match(/{[^}]+/g), (p2) => p2.replace("{", "")), (param) => {
          message = message.replace("{".concat(param, "}"), this.messageParams[param]);
        });
        return message;
      }
      get messageType() {
        if (this.isNumeric) {
          return "numeric";
        } else if (this.isFile) {
          return "file";
        } else if (this.isArray) {
          return "array";
        }
        return "string";
      }
      get messageParams() {
        return {
          attribute: this.attributeName
        };
      }
      get attributeName() {
        return this.element$.genericName;
      }
      get type() {
        if (this.isNumeric) {
          return "numeric";
        } else if (this.isFile) {
          return "file";
        } else if (this.isArray) {
          return "array";
        }
        return "string";
      }
      get isNumeric() {
        return some_1(this.element$.Validators, {
          name: "numeric"
        }) || some_1(this.element$.Validators, {
          name: "integer"
        });
      }
      get isNullable() {
        var nullable2 = false;
        each(this.element$.Validators, (Validator2) => {
          if (Validator2.name !== "nullable") {
            return;
          }
          if (!Validator2.conditions.length) {
            nullable2 = true;
            return;
          }
          nullable2 = Validator2.conditions(this.form$, this, this.element$);
        });
        return nullable2;
      }
      get isFile() {
        return this.element$.isFileType;
      }
      get isArray() {
        return this.element$.isArrayType;
      }
      get isAsync() {
        return false;
      }
      get debounce() {
        if (this.attributes.debounce) {
          return this.attributes.debounce;
        }
        if (this.element$.debounce) {
          return this.element$.debounce;
        }
        return false;
      }
      get debouncing() {
        return this.debouncer !== null;
      }
      init() {
      }
      validate(value) {
        var _this = this;
        return _asyncToGenerator(function* () {
          if (value === void 0) {
            var _this$element$;
            value = (_this$element$ = _this.element$) === null || _this$element$ === void 0 ? void 0 : _this$element$.value;
          }
          if (!_this.form$.validation) {
            return;
          }
          if (_this.isNullable && !_this.filled(value)) {
            _this.invalid = false;
            return;
          }
          if (_this.conditions.length) {
            if (!_this.conditions(_this.form$, _this, _this.element$)) {
              _this.invalid = false;
              return;
            }
          }
          if (_this.debounce && _this.filled(value)) {
            yield _this._validateWithDebounce(value);
          } else {
            if (_this.debounce && _this.debouncer) {
              clearTimeout(_this.debouncer);
            }
            yield _this._validate(value);
          }
        })();
      }
      replaceParams(message) {
        each(map_1(message.match(/:\w+/g), (p2) => p2.replace(":", "")), (param) => {
          message = message.replace(":".concat(param), this.messageParams[param]);
        });
        each(map_1(message.match(/{[^}]+/g), (p2) => p2.replace("{", "")), (param) => {
          message = message.replace("{".concat(param, "}"), this.messageParams[param]);
        });
        return message;
      }
      reset() {
        this.invalid = false;
      }
      watch(variables) {
        if (!Array.isArray(variables)) {
          variables = [variables];
        }
        variables.forEach((variable) => {
          this.addWatcher(variable);
        });
      }
      addWatcher(variable) {
        if (this.watchers[variable]) {
          return;
        }
        this.watchers[variable] = watch(computed(() => get_1(this.form$.data, variable)), () => {
          this.revalidate();
        });
      }
      revalidate() {
        this.element$.Validators.forEach((Validator2) => {
          if (Validator2.rule.name === this.rule.name) {
            Validator2.validate();
          }
        });
      }
      watchOther() {
        this.form$.$nextTick(() => {
          if (!this.other$) {
            return;
          }
          this.form$.$watch(() => {
            var _this$other$;
            return (_this$other$ = this.other$) === null || _this$other$ === void 0 ? void 0 : _this$other$.value;
          }, () => {
            if (this.element$.validated) {
              this.element$.validate();
            }
          });
        });
      }
      size(value) {
        if (this.isNumeric) {
          if (!isNaN(value)) {
            var num = parseFloat(value);
            if (Number.isInteger(num)) {
              return parseInt(value);
            }
            return num;
          }
          return null;
        } else if (this.isFile) {
          return value ? value.size / 1e3 : 0;
        } else if (this.isArray) {
          return value.length;
        } else if (value === null) {
          return 0;
        } else if (value === void 0) {
          return 0;
        } else if (value === "") {
          return 0;
        }
        return String(value).length;
      }
      filled(value) {
        if (value === void 0 || value === null && value !== this.element$.trueValue || value === this.element$.falseValue) {
          return false;
        } else if (this.isNumeric && trim_1(value) === "") {
          return false;
        } else if (isString_1(value) && trim_1(value) === "") {
          return false;
        } else if (isArray_1(value) && value.length < 1) {
          return false;
        } else if (value instanceof File && value.name === "") {
          return false;
        }
        return true;
      }
      _validate(value) {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          if (_this2.isAsync) {
            yield _this2._validateAsync(value);
          } else {
            _this2._validateSync(value);
          }
        })();
      }
      _validateAsync(value) {
        var _this3 = this;
        return _asyncToGenerator(function* () {
          _this3.lastValue = value;
          _this3.pending = true;
          var valid = yield _this3.check(value);
          if (dataEquals(_this3.lastValue, value)) {
            _this3.invalid = !valid;
            _this3.pending = false;
          }
        })();
      }
      _validateSync(value) {
        this.invalid = !this.check(value);
      }
      _validateWithDebounce(value) {
        var _this4 = this;
        return _asyncToGenerator(function* () {
          return new Promise((resolve2, reject) => {
            if (_this4.debouncer) {
              resolve2();
              clearTimeout(_this4.debouncer);
            }
            _this4.debouncer = setTimeout(/* @__PURE__ */ _asyncToGenerator(function* () {
              yield _this4._validate(value);
              _this4.debouncer = null;
              resolve2();
            }), _this4.debounce);
          });
        })();
      }
    };
    function last$1(array2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? array2[length - 1] : void 0;
    }
    var last_1 = last$1;
    var baseGet$2 = _baseGet, baseSlice = _baseSlice;
    function parent$1(object2, path) {
      return path.length < 2 ? object2 : baseGet$2(object2, baseSlice(path, 0, -1));
    }
    var _parent = parent$1;
    var castPath$2 = _castPath, last = last_1, parent = _parent, toKey = _toKey;
    function baseUnset$1(object2, path) {
      path = castPath$2(path, object2);
      object2 = parent(object2, path);
      return object2 == null || delete object2[toKey(last(path))];
    }
    var _baseUnset = baseUnset$1;
    var isPlainObject = isPlainObject_1;
    function customOmitClone$1(value) {
      return isPlainObject(value) ? void 0 : value;
    }
    var _customOmitClone = customOmitClone$1;
    var baseFlatten$3 = _baseFlatten;
    function flatten$2(array2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseFlatten$3(array2, 1) : [];
    }
    var flatten_1 = flatten$2;
    var flatten$1 = flatten_1, overRest = _overRest, setToString = _setToString;
    function flatRest$2(func) {
      return setToString(overRest(func, void 0, flatten$1), func + "");
    }
    var _flatRest = flatRest$2;
    var arrayMap$2 = _arrayMap, baseClone$1 = _baseClone, baseUnset = _baseUnset, castPath$1 = _castPath, copyObject = _copyObject, customOmitClone = _customOmitClone, flatRest$1 = _flatRest, getAllKeysIn = _getAllKeysIn;
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
    var omit = flatRest$1(function(object2, paths) {
      var result = {};
      if (object2 == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap$2(paths, function(path) {
        path = castPath$1(path, object2);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object2, getAllKeysIn(object2), result);
      if (isDeep) {
        result = baseClone$1(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG$1, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });
    var omit_1 = omit;
    var baseGet$1 = _baseGet, baseSet = _baseSet, castPath = _castPath;
    function basePickBy$1(object2, paths, predicate) {
      var index2 = -1, length = paths.length, result = {};
      while (++index2 < length) {
        var path = paths[index2], value = baseGet$1(object2, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object2), value);
        }
      }
      return result;
    }
    var _basePickBy = basePickBy$1;
    var basePickBy = _basePickBy, hasIn = hasIn_1;
    function basePick$1(object2, paths) {
      return basePickBy(object2, paths, function(value, path) {
        return hasIn(object2, path);
      });
    }
    var _basePick = basePick$1;
    var basePick = _basePick, flatRest = _flatRest;
    var pick = flatRest(function(object2, paths) {
      return object2 == null ? {} : basePick(object2, paths);
    });
    var pick_1 = pick;
    var SetCache = _SetCache, arrayIncludes = _arrayIncludes, arrayIncludesWith = _arrayIncludesWith, arrayMap$1 = _arrayMap, baseUnary$1 = _baseUnary, cacheHas = _cacheHas;
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference$2(array2, values2, iteratee, comparator2) {
      var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array2.length, result = [], valuesLength = values2.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values2 = arrayMap$1(values2, baseUnary$1(iteratee));
      }
      if (comparator2) {
        includes2 = arrayIncludesWith;
        isCommon = false;
      } else if (values2.length >= LARGE_ARRAY_SIZE) {
        includes2 = cacheHas;
        isCommon = false;
        values2 = new SetCache(values2);
      }
      outer:
        while (++index2 < length) {
          var value = array2[index2], computed2 = iteratee == null ? value : iteratee(value);
          value = comparator2 || value !== 0 ? value : 0;
          if (isCommon && computed2 === computed2) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values2[valuesIndex] === computed2) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes2(values2, computed2, comparator2)) {
            result.push(value);
          }
        }
      return result;
    }
    var _baseDifference = baseDifference$2;
    var baseDifference$1 = _baseDifference, baseRest$2 = _baseRest, isArrayLikeObject$1 = isArrayLikeObject_1;
    var without = baseRest$2(function(array2, values2) {
      return isArrayLikeObject$1(array2) ? baseDifference$1(array2, values2) : [];
    });
    var without_1 = without;
    function isBuffer(obj) {
      return obj && obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function keyIdentity(key) {
      return key;
    }
    function flatten(target, opts) {
      opts = opts || {};
      var delimiter = opts.delimiter || ".";
      var maxDepth = opts.maxDepth;
      var transformKey = opts.transformKey || keyIdentity;
      var output = {};
      function step(object2, prev, currentDepth) {
        currentDepth = currentDepth || 1;
        Object.keys(object2).forEach(function(key) {
          var value = object2[key];
          var isarray = opts.safe && Array.isArray(value);
          var type = Object.prototype.toString.call(value);
          var isbuffer = isBuffer(value);
          var isobject = type === "[object Object]" || type === "[object Array]";
          var newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);
          if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {
            return step(value, newKey, currentDepth + 1);
          }
          output[newKey] = value;
        });
      }
      step(target);
      return output;
    }
    var baseDifference = _baseDifference, baseFlatten$2 = _baseFlatten, baseRest$1 = _baseRest, isArrayLikeObject = isArrayLikeObject_1;
    var difference = baseRest$1(function(array2, values2) {
      return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten$2(values2, 1, isArrayLikeObject, true)) : [];
    });
    var difference_1 = difference;
    function shouldApplyPlugin(name2, plugin) {
      if (!plugin.apply && difference_1(Object.keys(plugin), ["config", "install"]).length > 0) {
        return true;
      }
      var apply2 = plugin.apply;
      if (!Array.isArray(apply2)) {
        apply2 = [apply2];
      }
      var shouldApply = false;
      each(apply2, (condition2) => {
        if (typeof condition2 === "string" && condition2 === name2) {
          shouldApply = true;
          return false;
        } else if (typeof condition2 === "object" && condition2 instanceof RegExp && name2.match(condition2)) {
          shouldApply = true;
          return false;
        }
      });
      return shouldApply;
    }
    var name = "@vueform/vueform";
    var version$1 = "1.10.3";
    var description = "Open-Source Form Framework for Vue";
    var homepage = "https://vueform.com";
    var license = "MIT";
    var authors = [
      {
        name: "Adam Berecz",
        email: "adam@vueform.com"
      }
    ];
    var sideEffects = [
      "./themes/tailwind/templates/**/*.css",
      "./themes/vueform/templates/**/*.css"
    ];
    var main$1 = "./dist/index.mjs";
    var module$1 = "./dist/index.mjs";
    var types = "./types/index.d.ts";
    var exports = {
      ".": {
        types: "./types/index.d.ts",
        "default": "./dist/index.mjs"
      },
      "./core": {
        types: "./types/index.d.ts",
        "default": "./dist/core.mjs"
      },
      "./core.js": {
        types: "./types/index.d.ts",
        "default": "./dist/core.mjs"
      },
      "./element": "./element.mjs",
      "./element.js": "./element.mjs",
      "./plugin": "./plugin.mjs",
      "./plugin.js": "./plugin.mjs",
      "./locales/*.js": "./locales/*/index.mjs",
      "./locales/*": "./locales/*/index.mjs",
      "./src/*": "./src/*",
      "./src/components": "./src/components/index.js",
      "./src/services/validation/rules": "./src/services/validation/rules/index.js",
      "./types/*": "./types/*",
      "./dist/*.js": "./dist/*.mjs",
      "./dist/*": "./dist/*.mjs",
      "./dist/*.css": "./dist/*.css",
      "./tailwind": "./tailwind.js",
      "./tailwind.js": "./tailwind.js",
      "./vite": "./vite.js",
      "./vite.js": "./vite.js",
      "./vite.d.ts": "./vite.d.ts",
      "./tailwind-prefixer": "./tailwind-prefixer.js",
      "./tailwind-prefixer.js": "./tailwind-prefixer.js",
      "./postcss.config": "./postcss.config.js",
      "./postcss.config.js": "./postcss.config.js",
      "./tailwind.config": "./tailwind.config.js",
      "./tailwind.config.js": "./tailwind.config.js",
      "./package.json": "./package.json",
      "./themes/blank/templates/*": "./themes/blank/templates/*",
      "./themes/blank/*": "./themes/blank/*.mjs",
      "./themes/blank/*.js": "./themes/blank/*.mjs",
      "./themes/bootstrap/css/*": "./themes/bootstrap/css/*",
      "./themes/bootstrap/scss/*": "./themes/bootstrap/scss/*",
      "./themes/bootstrap/*": "./themes/bootstrap/*.mjs",
      "./themes/bootstrap/*.js": "./themes/bootstrap/*.mjs",
      "./themes/bootstrap.js": "./themes/bootstrap/index.mjs",
      "./themes/material/css/*": "./themes/material/css/*",
      "./themes/material/scss/*": "./themes/material/scss/*",
      "./themes/material/*": "./themes/material/*.mjs",
      "./themes/material/*.js": "./themes/material/*.mjs",
      "./themes/material.js": "./themes/material/index.mjs",
      "./themes/tailwind/templates/*": "./themes/tailwind/templates/*",
      "./themes/tailwind/*": "./themes/tailwind/*.mjs",
      "./themes/tailwind/*.js": "./themes/tailwind/*.mjs",
      "./themes/tailwind.js": "./themes/tailwind/index.mjs",
      "./themes/tailwind-material/css/*": "./themes/tailwind-material/css/*",
      "./themes/tailwind-material/scss/*": "./themes/tailwind-material/scss/*",
      "./themes/tailwind-material/*": "./themes/tailwind-material/*.mjs",
      "./themes/tailwind-material/*.js": "./themes/tailwind-material/*.mjs",
      "./themes/tailwind-material.js": "./themes/tailwind-material/index.mjs",
      "./themes/vueform/css/*": "./themes/vueform/css/*",
      "./themes/vueform/scss/*": "./themes/vueform/scss/*",
      "./themes/vueform/templates/*": "./themes/vueform/templates/*",
      "./themes/vueform/*": "./themes/vueform/*.mjs",
      "./themes/vueform/*.js": "./themes/vueform/*.mjs",
      "./themes/vueform.js": "./themes/vueform/index.mjs",
      "./themes/*": {
        types: "./dist/*.d.mts",
        "default": "./themes/*/index.mjs"
      }
    };
    var scripts = {
      build: "npm run build3 && npm run build2 && npm run generate",
      build2: "node ./scripts/pre-build-vue2 && rollup --config build/rollup.vue2.config.js && node ./scripts/post-build-vue2",
      build3: "rollup --config build/rollup.config.js",
      test: 'npm run generate:elements-base && NODE_OPTIONS="--max_old_space_size=5120 --no-experimental-fetch" VUE=3 jest --config=./tests/jest.config.js',
      "generate:types": "npx babel-node  scripts/generate-types.js --presets @babel/preset-env",
      "generate:common-features": "npx babel-node scripts/generate-common-features.js --presets @babel/preset-env",
      "generate:element-features": "npx babel-node scripts/generate-element-features.js --presets @babel/preset-env",
      "generate:elements-base": "npx babel-node scripts/generate-elements-base.js --presets @babel/preset-env",
      "generate:elements": "npx babel-node scripts/generate-elements.js --presets @babel/preset-env",
      "generate:components": "npx babel-node scripts/generate-components.js --presets @babel/preset-env",
      generate: "npm run generate:common-features; npm run generate:element-features; npm run generate:elements-base; npm run generate:elements; npm run generate:components; npm run generate:types; npm run fix-locales",
      "fix-locales": "npx babel-node --presets @babel/preset-env ./scripts/fix-locales.js"
    };
    var devDependencies = {
      "@babel/core": "^7.2.2",
      "@babel/node": "^7.12.10",
      "@babel/preset-env": "^7.3.1",
      "@rollup/plugin-alias": "^5.1.0",
      "@rollup/plugin-babel": "^5.3.0",
      "@rollup/plugin-commonjs": "^22.0.1",
      "@rollup/plugin-json": "^4.1.0",
      "@rollup/plugin-node-resolve": "^13.0.6",
      "@testing-library/jest-dom": "^5.11.5",
      "@vue/compiler-sfc": "^3.0.0",
      "@vue/test-utils": "2.0.0-rc.16",
      autoprefixer: "^9",
      autosize: "^6.0.1",
      "babel-core": "^7.0.0-bridge.0",
      "babel-loader": "^8.0.5",
      "core-js": "^3.10.1",
      "css-loader": "^2.1.0",
      flatpickr: "^4.6.13",
      "flush-promises": "^1.0.2",
      "html-loader": "^1.3.2",
      jest: "^27.3.1",
      "jest-canvas-mock": "^2.3.1",
      "jest-environment-jsdom-sixteen": "^1.0.3",
      "jest-transform-stub": "^2.0.0",
      "json-loader": "^0.5.7",
      locutus: "^2.0.16",
      "module-alias": "^2.2.3",
      moxios: "^0.4.0",
      "mutationobserver-shim": "^0.3.7",
      ncp: "^2.0.0",
      "rollup-plugin-license": "^3.2.0",
      "rollup-plugin-postcss": "^4.0.1",
      "rollup-plugin-terser": "^7.0.2",
      "rollup-plugin-vue": "^6.0.0",
      "rollup-plugin-vue2": "npm:rollup-plugin-vue@^5.1.9",
      "sass-loader": "^7.1.0",
      signature_pad: "^5.0.2",
      sortablejs: "^1.15.0",
      tailwindcss: "npm:@tailwindcss/postcss7-compat@^2.0.2",
      vue: "3.3.13",
      "vue-jest": "npm:@vue/vue3-jest@^27.0.0-alpha.1",
      "vue-loader": "^15.10.0",
      "vue-template-compiler": "^2.7.8",
      vue2: "npm:vue@^2.7.0"
    };
    var dependencies = {
      "@popperjs/core": "^2.11.8",
      "@vueform/country-phones": "^1.0.3",
      "@vueform/multiselect": "^2.6.9",
      "@vueform/slider": "^2.1.10",
      "@vueform/toggle": "^2.1.4",
      axios: "^1.7.2",
      color: "^4.2.3",
      lodash: "^4.17.21",
      "mini-svg-data-uri": "^1.4.4",
      moment: "^2.30.1",
      nouislider: "^15.8.0",
      sass: "^1.66.1",
      trix: "^2.1.1",
      wnumb: "^1.2.0"
    };
    var packageJson = {
      "private": false,
      name,
      version: version$1,
      description,
      homepage,
      license,
      authors,
      sideEffects,
      main: main$1,
      module: module$1,
      types,
      exports,
      scripts,
      devDependencies,
      dependencies
    };
    var normalize$1 = function normalize2(value) {
      if (value === void 0 || typeof value != "string") {
        return value;
      }
      if (value.match(/^-*\d+$/)) {
        return parseInt(value, 10);
      } else if (value.match(/^\d+\.\d+$/)) {
        return parseFloat(value);
      } else {
        return value;
      }
    };
    var parse = (string2) => {
      var parseRule = () => {
        return string2.split(":")[0];
      };
      var parseAttributes = () => {
        var parts = string2.split(":");
        if (parts.length <= 1) {
          return null;
        }
        var attributes = {};
        var rule = parts[0];
        parts.shift();
        var params = parts.join(":");
        if (["regex", "not_regex"].indexOf(rule) !== -1) {
          attributes[0] = params;
          return attributes;
        }
        each(params.split(","), (attribute, index2) => {
          var attrParts = attribute.split("=");
          if (attrParts.length <= 1) {
            attributes[index2] = normalize$1(attribute);
          } else {
            attributes[attrParts[0]] = normalize$1(attrParts[1]);
          }
        });
        return attributes;
      };
      return {
        name: parseRule(),
        attributes: parseAttributes()
      };
    };
    function replaceWildcards(fillable, fill) {
      if (!fill.match(/\.([0-9]+)(?![a-zA-Z]+)/g)) {
        return fillable;
      }
      fill.match(/\.([0-9]+)(?![a-zA-Z]+)/g).forEach((match) => {
        fillable = fillable.replace(".*", match);
      });
      return fillable;
    }
    var baseTrim = _baseTrim, isObject$c = isObject_1, isSymbol$1 = isSymbol_1;
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber$1(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol$1(value)) {
        return NAN;
      }
      if (isObject$c(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject$c(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    var toNumber_1 = toNumber$1;
    var toNumber = toNumber_1;
    var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
    function toFinite$1(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign2 = value < 0 ? -1 : 1;
        return sign2 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    var toFinite_1 = toFinite$1;
    var toFinite = toFinite_1;
    function toInteger$5(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    var toInteger_1 = toInteger$5;
    var baseIndexOf = _baseIndexOf, isArrayLike$1 = isArrayLike_1, isString = isString_1, toInteger$4 = toInteger_1, values = values_1;
    var nativeMax$2 = Math.max;
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike$1(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger$4(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax$2(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    var includes_1 = includes;
    function baseClamp$2(number, lower, upper) {
      if (number === number) {
        if (upper !== void 0) {
          number = number <= upper ? number : upper;
        }
        if (lower !== void 0) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }
    var _baseClamp = baseClamp$2;
    var baseClamp$1 = _baseClamp, baseToString$1 = _baseToString, toInteger$3 = toInteger_1, toString$2 = toString_1;
    function startsWith(string2, target, position) {
      string2 = toString$2(string2);
      position = position == null ? 0 : baseClamp$1(toInteger$3(position), 0, string2.length);
      target = baseToString$1(target);
      return string2.slice(position, position + target.length) == target;
    }
    var startsWith_1 = startsWith;
    var baseClamp = _baseClamp, baseToString = _baseToString, toInteger$2 = toInteger_1, toString$1 = toString_1;
    function endsWith(string2, target, position) {
      string2 = toString$1(string2);
      target = baseToString(target);
      var length = string2.length;
      position = position === void 0 ? length : baseClamp(toInteger$2(position), 0, length);
      var end2 = position;
      position -= target.length;
      return position >= 0 && string2.slice(position, end2) == target;
    }
    var endsWith_1 = endsWith;
    function compare(actual, operator, expected, el$, form$) {
      if (!operator) {
        return false;
      }
      actual = Array.isArray(actual) ? actual.map((e2) => normalize$1(e2)) : normalize$1(actual);
      expected = Array.isArray(expected) ? expected.map((e2) => normalize$1(e2)) : normalize$1(expected);
      var moment = form$.$vueform.services.moment;
      switch (operator.toLowerCase()) {
        case ">":
          return isArray_1(actual) ? actual.every((a2) => a2 > expected) : actual > expected;
        case ">=":
          return isArray_1(actual) ? actual.every((a2) => a2 >= expected) : actual >= expected;
        case "<":
          return isArray_1(actual) ? actual.every((a2) => a2 < expected) : actual < expected;
        case "<=":
          return isArray_1(actual) ? actual.every((a2) => a2 <= expected) : actual <= expected;
        case "between":
          return actual > expected[0] && actual < expected[1];
        case "empty":
          if (isArray_1(actual)) {
            return !actual.length;
          } else if (actual && actual instanceof File) {
            return false;
          } else if (actual && actual instanceof Blob) {
            return false;
          } else if (actual && typeof actual === "object") {
            var values2 = Object.values(actual);
            return !values2.length || values2.every((v2) => ["", null, void 0].indexOf(v2) !== -1);
          } else {
            return ["", null, void 0].indexOf(actual) !== -1;
          }
        case "not_empty":
          if (isArray_1(actual)) {
            return !!actual.length;
          } else if (actual && actual instanceof File) {
            return true;
          } else if (actual && actual instanceof Blob) {
            return true;
          } else if (actual && typeof actual === "object") {
            var _values = Object.values(actual);
            return _values.length && _values.some((v2) => ["", null, void 0].indexOf(v2) === -1);
          } else {
            return ["", null, void 0].indexOf(actual) === -1;
          }
        case "==":
        case "in":
          if (isArray_1(expected)) {
            if (isArray_1(actual)) {
              return !expected.length ? !actual.length : actual.filter((a2) => includes_1(expected, a2)).length > 0;
            } else {
              return expected.indexOf(actual) !== -1;
            }
          } else {
            if (isArray_1(actual)) {
              return actual.indexOf(expected) !== -1;
            } else {
              return actual == expected;
            }
          }
        case "!=":
        case "not_in":
          if (isArray_1(expected)) {
            if (isArray_1(actual)) {
              return !expected.length ? !!actual.length : actual.filter((e2) => includes_1(expected, e2)).length == 0;
            } else {
              return expected.indexOf(actual) === -1;
            }
          } else {
            if (isArray_1(actual)) {
              return actual.indexOf(expected) === -1;
            } else {
              return actual != expected;
            }
          }
        case "today":
          if (!isArray_1(actual)) {
            actual = [actual];
          }
          return actual.length && actual.every((a2) => moment(a2, el$.valueDateFormat).isSame(moment(), "day"));
        case "before":
          if (!isArray_1(actual)) {
            actual = [actual];
          }
          return actual.length && actual.every((a2) => {
            var date2 = moment(a2, el$.valueDateFormat);
            return date2.isValid() && date2.isBefore(moment(expected === "today" ? void 0 : expected), "day");
          });
        case "after":
          if (!isArray_1(actual)) {
            actual = [actual];
          }
          return actual.length && actual.every((a2) => {
            var date2 = moment(a2, el$.valueDateFormat);
            return date2.isValid() && date2.isAfter(moment(expected === "today" ? void 0 : expected), "day");
          });
        case "^":
          return startsWith_1(actual, expected);
        case "$":
          return endsWith_1(actual, expected);
        case "*":
          return includes_1(actual, expected);
      }
    }
    var Factory = class {
      constructor(path, form$) {
        this.form$ = form$;
        this.element$ = form$.el$(path);
      }
      get rules() {
        var rules2 = Object.assign({}, this.form$.$vueform.services.validation.rules, this.form$.$vueform.rules);
        if (!rules2.in && rules2.in_) {
          rules2.in = rules2.in_;
        }
        return rules2;
      }
      makeAll(rules2) {
        var parsedRules = this.parseRules(rules2);
        if (parsedRules.length == 0) {
          return [];
        }
        return map_1(parsedRules, (rule) => {
          return this.make(rule);
        });
      }
      make(rule) {
        var ruleClass = typeof rule == "function" ? rule : Array.isArray(rule) ? rule[0] : this.rules[rule.name];
        if (!ruleClass) {
          throw new Error("Unknown rule: '".concat(rule.name, "'"));
        }
        return new ruleClass(rule !== null && rule !== void 0 && rule.name ? rule : {
          name: "custom_rule_".concat(Math.floor(Math.random() * 9e6) + 1e6),
          attributes: Array.isArray(rule) && rule[1] ? rule[1] : []
        }, {
          element$: this.element$
        });
      }
      parseRules(rules2) {
        if (!isArray_1(rules2)) {
          rules2 = rules2.split("|");
        }
        return rules2.map((rule) => {
          if (typeof rule == "function" || Array.isArray(rule)) {
            return rule;
          }
          return this.isConditional(rule) ? this.parseConditional(rule) : this.parse(rule);
        });
      }
      parse(rule) {
        return parse(rule);
      }
      isConditional(rule) {
        return isPlainObject_1(rule);
      }
      parseConditional(rule) {
        var _conditions = values_1(rule)[0];
        if (!Array.isArray(_conditions[0])) {
          _conditions = [_conditions];
        }
        var parsed = _objectSpread2$1(_objectSpread2$1({}, parse(keys_1(rule)[0])), {}, {
          conditions: (form$, Validator2, el$) => {
            return _conditions.every((condition2) => {
              if (isArray_1(condition2)) {
                if (isArray_1(condition2[0])) {
                  return condition2.some((subcondition) => {
                    if (isArray_1(subcondition)) {
                      return this.createConditionFromArray(subcondition)(form$, Validator2, el$);
                    } else {
                      return condition2(form$, Validator2, el$);
                    }
                  });
                } else {
                  return this.createConditionFromArray(condition2)(form$, Validator2, el$);
                }
              } else {
                return condition2(form$, Validator2, el$);
              }
            });
          },
          dependents: []
        });
        _conditions.forEach((condition2) => {
          if (isArray_1(condition2)) {
            if (isArray_1(condition2[0])) {
              condition2.forEach((subcondition) => {
                if (isArray_1(subcondition)) {
                  parsed.dependents.push(replaceWildcards(subcondition[0], this.element$.path));
                }
              });
            } else {
              parsed.dependents.push(replaceWildcards(condition2[0], this.element$.path));
            }
          }
        });
        return parsed;
      }
      createConditionFromArray(condition2) {
        var field = replaceWildcards(condition2[0], this.element$.path);
        var operator = condition2.length == 3 || ["empty", "not_empty", "today"].indexOf(condition2[1]) !== -1 ? condition2[1] : "==";
        var value = condition2.length == 3 ? condition2[2] : ["empty", "not_empty", "today"].indexOf(condition2[1]) === -1 ? condition2[1] : true;
        return (form$, Validator2, el$) => {
          var actual = get_1(form$.requestData, field);
          var expected = value;
          return compare(actual, operator, expected, this.element$, form$);
        };
      }
    };
    class accepted extends Validator {
      check(value) {
        return ["yes", "on", "1", 1, true, "true"].indexOf(value) !== -1;
      }
    }
    class active_url extends Validator {
      get isAsync() {
        return true;
      }
      check(value) {
        var _this = this;
        return _asyncToGenerator(function* () {
          var endpoint = _this.form$.$vueform.config.endpoints.activeUrl;
          var method = typeof endpoint !== "function" ? endpoint.method : null;
          var res;
          if (typeof endpoint === "function") {
            res = yield endpoint(value, _this.element$, _this.form$);
          } else {
            res = yield _this.form$.$vueform.services.axios.request({
              url: endpoint.url,
              method,
              [method.toLowerCase() === "get" ? "params" : "data"]: {
                url: value
              }
            });
          }
          return res.data;
        })();
      }
    }
    class after extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          date: this.date.format(this.format)
        };
      }
      get param() {
        return this.attributes[0];
      }
      get format() {
        return ["date", "dates"].indexOf(this.element$.type) !== -1 && this.element$.valueFormat ? this.element$.valueFormat : "YYYY-MM-DD";
      }
      get otherFormat() {
        if (this.dateType != "element") {
          return this.format;
        }
        return ["date", "dates"].indexOf(this.other$.type) !== -1 && this.other$.valueFormat ? this.other$.valueFormat : this.format;
      }
      get otherPath() {
        if (this.dateType != "element") {
          return null;
        }
        return this.param;
      }
      get other$() {
        if (this.dateType != "element") {
          return {};
        }
        return this.form$.el$(this.param);
      }
      get date() {
        var date2 = "";
        switch (this.dateType) {
          case "relative":
            if (this.param === "today") {
              date2 = this.moment().startOf("day");
            }
            if (this.param === "tomorrow") {
              date2 = this.moment().startOf("day").add(1, "days");
            }
            if (this.param === "yesterday") {
              date2 = this.moment().startOf("day").subtract(1, "days");
            }
            break;
          case "element":
            date2 = this.moment(this.other$.value, this.otherFormat);
            break;
          case "absolute":
            date2 = this.moment(this.param, this.format);
            break;
        }
        return date2;
      }
      get dateType() {
        if (["today", "tomorrow", "yesterday"].indexOf(this.param) !== -1) {
          return "relative";
        } else if (this.form$.el$(this.param)) {
          return "element";
        } else {
          return "absolute";
        }
      }
      init() {
        this.form$.$nextTick(() => {
          if (this.dateType == "element") {
            this.watchOther();
          }
        });
      }
      check(value) {
        if (isArray_1(value)) {
          var valid = true;
          each(value, (date2) => {
            if (!this.checkDate(date2)) {
              valid = false;
            }
          });
          return valid;
        }
        return this.checkDate(value);
      }
      checkDate(value) {
        return this.moment(value, this.format).isAfter(this.moment(this.date, this.otherFormat));
      }
    }
    class after_or_equal extends after {
      checkDate(value) {
        return this.moment(value, this.format).isSameOrAfter(this.moment(this.date, this.otherFormat));
      }
    }
    class alpha extends Validator {
      check(value) {
        return /^[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/.test(value);
      }
    }
    class alpha_dash extends Validator {
      check(value) {
        return /^[0-9-_\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/.test(value);
      }
    }
    class alpha_num extends Validator {
      check(value) {
        return /^[0-9\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/.test(value);
      }
    }
    class array$2 extends Validator {
      check(value) {
        return isArray_1(value);
      }
    }
    class before extends after {
      checkDate(value) {
        return this.moment(value, this.format).isBefore(this.moment(this.date, this.otherFormat));
      }
    }
    class before_or_equal extends after {
      checkDate(value) {
        return this.moment(value, this.format).isSameOrBefore(this.moment(this.date, this.otherFormat));
      }
    }
    class between extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          min: this.min,
          max: this.max
        };
      }
      get min() {
        return this.attributes[0];
      }
      get max() {
        return this.attributes[1];
      }
      check(value) {
        if (!value) {
          return true;
        }
        var size2 = this.size(value);
        return size2 >= this.min && size2 <= this.max;
      }
    }
    class boolean$1 extends Validator {
      check(value) {
        var accepted2 = [true, false, 0, 1, "0", "1"];
        return accepted2.indexOf(value) !== -1;
      }
    }
    class captcha$2 extends Validator {
      get isAsync() {
        return true;
      }
      check(value) {
        var _this = this;
        return _asyncToGenerator(function* () {
          if (!_this.element$.shouldVerify) {
            return true;
          }
          return yield _this.element$.Provider.validate(_this.element$.Provider.getResponse());
        })();
      }
    }
    class completed extends Validator {
      get debounce() {
        if (this.attributes.debounce !== void 0) {
          return this.attributes.debounce;
        }
        if (this.element$.debounce !== null) {
          return this.element$.debounce;
        }
        return 1e3;
      }
      check(value) {
        var _this$element$$Mask$m;
        if (!this.element$.Mask) {
          return this.filled(value);
        }
        var isComplete = (_this$element$$Mask$m = this.element$.Mask.masked.currentMask) === null || _this$element$$Mask$m === void 0 ? void 0 : _this$element$$Mask$m.isComplete;
        return isComplete === void 0 || this.element$.empty ? true : isComplete;
      }
    }
    class confirmed extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          other: this.other$.genericName
        };
      }
      get otherPath() {
        return "".concat(this.element$.path, "_confirmation");
      }
      get other$() {
        return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
      }
      init() {
        this.watchOther();
      }
      check(value) {
        if (!this.filled(this.other$.value)) {
          return true;
        }
        return value == this.other$.value;
      }
    }
    var reSpace = "[ \\t]+";
    var reSpaceOpt = "[ \\t]*";
    var reMeridian = "(?:([ap])\\.?m\\.?([\\t ]|$))";
    var reHour24 = "(2[0-4]|[01]?[0-9])";
    var reHour24lz = "([01][0-9]|2[0-4])";
    var reHour12 = "(0?[1-9]|1[0-2])";
    var reMinute = "([0-5]?[0-9])";
    var reMinutelz = "([0-5][0-9])";
    var reSecond = "(60|[0-5]?[0-9])";
    var reSecondlz = "(60|[0-5][0-9])";
    var reFrac = "(?:\\.([0-9]+))";
    var reDayfull = "sunday|monday|tuesday|wednesday|thursday|friday|saturday";
    var reDayabbr = "sun|mon|tue|wed|thu|fri|sat";
    var reDaytext = reDayfull + "|" + reDayabbr + "|weekdays?";
    var reReltextnumber = "first|second|third|fourth|fifth|sixth|seventh|eighth?|ninth|tenth|eleventh|twelfth";
    var reReltexttext = "next|last|previous|this";
    var reReltextunit = "(?:second|sec|minute|min|hour|day|fortnight|forthnight|month|year)s?|weeks|" + reDaytext;
    var reYear = "([0-9]{1,4})";
    var reYear2 = "([0-9]{2})";
    var reYear4 = "([0-9]{4})";
    var reYear4withSign = "([+-]?[0-9]{4})";
    var reMonth = "(1[0-2]|0?[0-9])";
    var reMonthlz = "(0[0-9]|1[0-2])";
    var reDay = "(?:(3[01]|[0-2]?[0-9])(?:st|nd|rd|th)?)";
    var reDaylz = "(0[0-9]|[1-2][0-9]|3[01])";
    var reMonthFull = "january|february|march|april|may|june|july|august|september|october|november|december";
    var reMonthAbbr = "jan|feb|mar|apr|may|jun|jul|aug|sept?|oct|nov|dec";
    var reMonthroman = "i[vx]|vi{0,3}|xi{0,2}|i{1,3}";
    var reMonthText = "(" + reMonthFull + "|" + reMonthAbbr + "|" + reMonthroman + ")";
    var reTzCorrection = "((?:GMT)?([+-])" + reHour24 + ":?" + reMinute + "?)";
    var reTzAbbr = "\\(?([a-zA-Z]{1,6})\\)?";
    var reDayOfYear = "(00[1-9]|0[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6])";
    var reWeekOfYear = "(0[1-9]|[1-4][0-9]|5[0-3])";
    var reDateNoYear = reMonthText + "[ .\\t-]*" + reDay + "[,.stndrh\\t ]*";
    function processMeridian(hour, meridian) {
      meridian = meridian && meridian.toLowerCase();
      switch (meridian) {
        case "a":
          hour += hour === 12 ? -12 : 0;
          break;
        case "p":
          hour += hour !== 12 ? 12 : 0;
          break;
      }
      return hour;
    }
    function processYear(yearStr) {
      var year = +yearStr;
      if (yearStr.length < 4 && year < 100) {
        year += year < 70 ? 2e3 : 1900;
      }
      return year;
    }
    function lookupMonth(monthStr) {
      return {
        jan: 0,
        january: 0,
        i: 0,
        feb: 1,
        february: 1,
        ii: 1,
        mar: 2,
        march: 2,
        iii: 2,
        apr: 3,
        april: 3,
        iv: 3,
        may: 4,
        v: 4,
        jun: 5,
        june: 5,
        vi: 5,
        jul: 6,
        july: 6,
        vii: 6,
        aug: 7,
        august: 7,
        viii: 7,
        sep: 8,
        sept: 8,
        september: 8,
        ix: 8,
        oct: 9,
        october: 9,
        x: 9,
        nov: 10,
        november: 10,
        xi: 10,
        dec: 11,
        december: 11,
        xii: 11
      }[monthStr.toLowerCase()];
    }
    function lookupWeekday(dayStr) {
      var desiredSundayNumber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var dayNumbers = {
        mon: 1,
        monday: 1,
        tue: 2,
        tuesday: 2,
        wed: 3,
        wednesday: 3,
        thu: 4,
        thursday: 4,
        fri: 5,
        friday: 5,
        sat: 6,
        saturday: 6,
        sun: 0,
        sunday: 0
      };
      return dayNumbers[dayStr.toLowerCase()] || desiredSundayNumber;
    }
    function lookupRelative(relText) {
      var relativeNumbers = {
        last: -1,
        previous: -1,
        this: 0,
        first: 1,
        next: 1,
        second: 2,
        third: 3,
        fourth: 4,
        fifth: 5,
        sixth: 6,
        seventh: 7,
        eight: 8,
        eighth: 8,
        ninth: 9,
        tenth: 10,
        eleventh: 11,
        twelfth: 12
      };
      var relativeBehavior = {
        this: 1
      };
      var relTextLower = relText.toLowerCase();
      return {
        amount: relativeNumbers[relTextLower],
        behavior: relativeBehavior[relTextLower] || 0
      };
    }
    function processTzCorrection(tzOffset, oldValue) {
      var reTzCorrectionLoose = /(?:GMT)?([+-])(\d+)(:?)(\d{0,2})/i;
      tzOffset = tzOffset && tzOffset.match(reTzCorrectionLoose);
      if (!tzOffset) {
        return oldValue;
      }
      var sign2 = tzOffset[1] === "-" ? -1 : 1;
      var hours2 = +tzOffset[2];
      var minutes2 = +tzOffset[4];
      if (!tzOffset[4] && !tzOffset[3]) {
        minutes2 = Math.floor(hours2 % 100);
        hours2 = Math.floor(hours2 / 100);
      }
      return sign2 * (hours2 * 60 + minutes2) * 60;
    }
    var tzAbbrOffsets = {
      acdt: 37800,
      acst: 34200,
      addt: -7200,
      adt: -10800,
      aedt: 39600,
      aest: 36e3,
      ahdt: -32400,
      ahst: -36e3,
      akdt: -28800,
      akst: -32400,
      amt: -13840,
      apt: -10800,
      ast: -14400,
      awdt: 32400,
      awst: 28800,
      awt: -10800,
      bdst: 7200,
      bdt: -36e3,
      bmt: -14309,
      bst: 3600,
      cast: 34200,
      cat: 7200,
      cddt: -14400,
      cdt: -18e3,
      cemt: 10800,
      cest: 7200,
      cet: 3600,
      cmt: -15408,
      cpt: -18e3,
      cst: -21600,
      cwt: -18e3,
      chst: 36e3,
      dmt: -1521,
      eat: 10800,
      eddt: -10800,
      edt: -14400,
      eest: 10800,
      eet: 7200,
      emt: -26248,
      ept: -14400,
      est: -18e3,
      ewt: -14400,
      ffmt: -14660,
      fmt: -4056,
      gdt: 39600,
      gmt: 0,
      gst: 36e3,
      hdt: -34200,
      hkst: 32400,
      hkt: 28800,
      hmt: -19776,
      hpt: -34200,
      hst: -36e3,
      hwt: -34200,
      iddt: 14400,
      idt: 10800,
      imt: 25025,
      ist: 7200,
      jdt: 36e3,
      jmt: 8440,
      jst: 32400,
      kdt: 36e3,
      kmt: 5736,
      kst: 30600,
      lst: 9394,
      mddt: -18e3,
      mdst: 16279,
      mdt: -21600,
      mest: 7200,
      met: 3600,
      mmt: 9017,
      mpt: -21600,
      msd: 14400,
      msk: 10800,
      mst: -25200,
      mwt: -21600,
      nddt: -5400,
      ndt: -9052,
      npt: -9e3,
      nst: -12600,
      nwt: -9e3,
      nzdt: 46800,
      nzmt: 41400,
      nzst: 43200,
      pddt: -21600,
      pdt: -25200,
      pkst: 21600,
      pkt: 18e3,
      plmt: 25590,
      pmt: -13236,
      ppmt: -17340,
      ppt: -25200,
      pst: -28800,
      pwt: -25200,
      qmt: -18840,
      rmt: 5794,
      sast: 7200,
      sdmt: -16800,
      sjmt: -20173,
      smt: -13884,
      sst: -39600,
      tbmt: 10751,
      tmt: 12344,
      uct: 0,
      utc: 0,
      wast: 7200,
      wat: 3600,
      wemt: 7200,
      west: 3600,
      wet: 0,
      wib: 25200,
      wita: 28800,
      wit: 32400,
      wmt: 5040,
      yddt: -25200,
      ydt: -28800,
      ypt: -28800,
      yst: -32400,
      ywt: -28800,
      a: 3600,
      b: 7200,
      c: 10800,
      d: 14400,
      e: 18e3,
      f: 21600,
      g: 25200,
      h: 28800,
      i: 32400,
      k: 36e3,
      l: 39600,
      m: 43200,
      n: -3600,
      o: -7200,
      p: -10800,
      q: -14400,
      r: -18e3,
      s: -21600,
      t: -25200,
      u: -28800,
      v: -32400,
      w: -36e3,
      x: -39600,
      y: -43200,
      z: 0
    };
    var formats$1 = {
      yesterday: {
        regex: /^yesterday/i,
        name: "yesterday",
        callback: function callback() {
          this.rd -= 1;
          return this.resetTime();
        }
      },
      now: {
        regex: /^now/i,
        name: "now"
        // do nothing
      },
      noon: {
        regex: /^noon/i,
        name: "noon",
        callback: function callback() {
          return this.resetTime() && this.time(12, 0, 0, 0);
        }
      },
      midnightOrToday: {
        regex: /^(midnight|today)/i,
        name: "midnight | today",
        callback: function callback() {
          return this.resetTime();
        }
      },
      tomorrow: {
        regex: /^tomorrow/i,
        name: "tomorrow",
        callback: function callback() {
          this.rd += 1;
          return this.resetTime();
        }
      },
      timestamp: {
        regex: /^@(-?\d+)/i,
        name: "timestamp",
        callback: function callback(match, timestamp) {
          this.rs += +timestamp;
          this.y = 1970;
          this.m = 0;
          this.d = 1;
          this.dates = 0;
          return this.resetTime() && this.zone(0);
        }
      },
      firstOrLastDay: {
        regex: /^(first|last) day of/i,
        name: "firstdayof | lastdayof",
        callback: function callback(match, day) {
          if (day.toLowerCase() === "first") {
            this.firstOrLastDayOfMonth = 1;
          } else {
            this.firstOrLastDayOfMonth = -1;
          }
        }
      },
      backOrFrontOf: {
        regex: RegExp("^(back|front) of " + reHour24 + reSpaceOpt + reMeridian + "?", "i"),
        name: "backof | frontof",
        callback: function callback(match, side, hours2, meridian) {
          var back = side.toLowerCase() === "back";
          var hour = +hours2;
          var minute = 15;
          if (!back) {
            hour -= 1;
            minute = 45;
          }
          hour = processMeridian(hour, meridian);
          return this.resetTime() && this.time(hour, minute, 0, 0);
        }
      },
      weekdayOf: {
        regex: RegExp("^(" + reReltextnumber + "|" + reReltexttext + ")" + reSpace + "(" + reDayfull + "|" + reDayabbr + ")" + reSpace + "of", "i"),
        name: "weekdayof"
        // todo
      },
      mssqltime: {
        regex: RegExp("^" + reHour12 + ":" + reMinutelz + ":" + reSecondlz + "[:.]([0-9]+)" + reMeridian, "i"),
        name: "mssqltime",
        callback: function callback(match, hour, minute, second, frac, meridian) {
          return this.time(processMeridian(+hour, meridian), +minute, +second, +frac.substr(0, 3));
        }
      },
      oracledate: {
        regex: /^(\d{2})-([A-Z]{3})-(\d{2})$/i,
        name: "d-M-y",
        callback: function callback(match, day, monthText, year) {
          var month = {
            JAN: 0,
            FEB: 1,
            MAR: 2,
            APR: 3,
            MAY: 4,
            JUN: 5,
            JUL: 6,
            AUG: 7,
            SEP: 8,
            OCT: 9,
            NOV: 10,
            DEC: 11
          }[monthText.toUpperCase()];
          return this.ymd(2e3 + parseInt(year, 10), month, parseInt(day, 10));
        }
      },
      timeLong12: {
        regex: RegExp("^" + reHour12 + "[:.]" + reMinute + "[:.]" + reSecondlz + reSpaceOpt + reMeridian, "i"),
        name: "timelong12",
        callback: function callback(match, hour, minute, second, meridian) {
          return this.time(processMeridian(+hour, meridian), +minute, +second, 0);
        }
      },
      timeShort12: {
        regex: RegExp("^" + reHour12 + "[:.]" + reMinutelz + reSpaceOpt + reMeridian, "i"),
        name: "timeshort12",
        callback: function callback(match, hour, minute, meridian) {
          return this.time(processMeridian(+hour, meridian), +minute, 0, 0);
        }
      },
      timeTiny12: {
        regex: RegExp("^" + reHour12 + reSpaceOpt + reMeridian, "i"),
        name: "timetiny12",
        callback: function callback(match, hour, meridian) {
          return this.time(processMeridian(+hour, meridian), 0, 0, 0);
        }
      },
      soap: {
        regex: RegExp("^" + reYear4 + "-" + reMonthlz + "-" + reDaylz + "T" + reHour24lz + ":" + reMinutelz + ":" + reSecondlz + reFrac + reTzCorrection + "?", "i"),
        name: "soap",
        callback: function callback(match, year, month, day, hour, minute, second, frac, tzCorrection) {
          return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, +frac.substr(0, 3)) && this.zone(processTzCorrection(tzCorrection));
        }
      },
      wddx: {
        regex: RegExp("^" + reYear4 + "-" + reMonth + "-" + reDay + "T" + reHour24 + ":" + reMinute + ":" + reSecond),
        name: "wddx",
        callback: function callback(match, year, month, day, hour, minute, second) {
          return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
        }
      },
      exif: {
        regex: RegExp("^" + reYear4 + ":" + reMonthlz + ":" + reDaylz + " " + reHour24lz + ":" + reMinutelz + ":" + reSecondlz, "i"),
        name: "exif",
        callback: function callback(match, year, month, day, hour, minute, second) {
          return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
        }
      },
      xmlRpc: {
        regex: RegExp("^" + reYear4 + reMonthlz + reDaylz + "T" + reHour24 + ":" + reMinutelz + ":" + reSecondlz),
        name: "xmlrpc",
        callback: function callback(match, year, month, day, hour, minute, second) {
          return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
        }
      },
      xmlRpcNoColon: {
        regex: RegExp("^" + reYear4 + reMonthlz + reDaylz + "[Tt]" + reHour24 + reMinutelz + reSecondlz),
        name: "xmlrpcnocolon",
        callback: function callback(match, year, month, day, hour, minute, second) {
          return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
        }
      },
      clf: {
        regex: RegExp("^" + reDay + "/(" + reMonthAbbr + ")/" + reYear4 + ":" + reHour24lz + ":" + reMinutelz + ":" + reSecondlz + reSpace + reTzCorrection, "i"),
        name: "clf",
        callback: function callback(match, day, month, year, hour, minute, second, tzCorrection) {
          return this.ymd(+year, lookupMonth(month), +day) && this.time(+hour, +minute, +second, 0) && this.zone(processTzCorrection(tzCorrection));
        }
      },
      iso8601long: {
        regex: RegExp("^t?" + reHour24 + "[:.]" + reMinute + "[:.]" + reSecond + reFrac, "i"),
        name: "iso8601long",
        callback: function callback(match, hour, minute, second, frac) {
          return this.time(+hour, +minute, +second, +frac.substr(0, 3));
        }
      },
      dateTextual: {
        regex: RegExp("^" + reMonthText + "[ .\\t-]*" + reDay + "[,.stndrh\\t ]+" + reYear, "i"),
        name: "datetextual",
        callback: function callback(match, month, day, year) {
          return this.ymd(processYear(year), lookupMonth(month), +day);
        }
      },
      pointedDate4: {
        regex: RegExp("^" + reDay + "[.\\t-]" + reMonth + "[.-]" + reYear4),
        name: "pointeddate4",
        callback: function callback(match, day, month, year) {
          return this.ymd(+year, month - 1, +day);
        }
      },
      pointedDate2: {
        regex: RegExp("^" + reDay + "[.\\t]" + reMonth + "\\." + reYear2),
        name: "pointeddate2",
        callback: function callback(match, day, month, year) {
          return this.ymd(processYear(year), month - 1, +day);
        }
      },
      timeLong24: {
        regex: RegExp("^t?" + reHour24 + "[:.]" + reMinute + "[:.]" + reSecond),
        name: "timelong24",
        callback: function callback(match, hour, minute, second) {
          return this.time(+hour, +minute, +second, 0);
        }
      },
      dateNoColon: {
        regex: RegExp("^" + reYear4 + reMonthlz + reDaylz),
        name: "datenocolon",
        callback: function callback(match, year, month, day) {
          return this.ymd(+year, month - 1, +day);
        }
      },
      pgydotd: {
        regex: RegExp("^" + reYear4 + "\\.?" + reDayOfYear),
        name: "pgydotd",
        callback: function callback(match, year, day) {
          return this.ymd(+year, 0, +day);
        }
      },
      timeShort24: {
        regex: RegExp("^t?" + reHour24 + "[:.]" + reMinute, "i"),
        name: "timeshort24",
        callback: function callback(match, hour, minute) {
          return this.time(+hour, +minute, 0, 0);
        }
      },
      iso8601noColon: {
        regex: RegExp("^t?" + reHour24lz + reMinutelz + reSecondlz, "i"),
        name: "iso8601nocolon",
        callback: function callback(match, hour, minute, second) {
          return this.time(+hour, +minute, +second, 0);
        }
      },
      iso8601dateSlash: {
        // eventhough the trailing slash is optional in PHP
        // here it's mandatory and inputs without the slash
        // are handled by dateslash
        regex: RegExp("^" + reYear4 + "/" + reMonthlz + "/" + reDaylz + "/"),
        name: "iso8601dateslash",
        callback: function callback(match, year, month, day) {
          return this.ymd(+year, month - 1, +day);
        }
      },
      dateSlash: {
        regex: RegExp("^" + reYear4 + "/" + reMonth + "/" + reDay),
        name: "dateslash",
        callback: function callback(match, year, month, day) {
          return this.ymd(+year, month - 1, +day);
        }
      },
      american: {
        regex: RegExp("^" + reMonth + "/" + reDay + "/" + reYear),
        name: "american",
        callback: function callback(match, month, day, year) {
          return this.ymd(processYear(year), month - 1, +day);
        }
      },
      americanShort: {
        regex: RegExp("^" + reMonth + "/" + reDay),
        name: "americanshort",
        callback: function callback(match, month, day) {
          return this.ymd(this.y, month - 1, +day);
        }
      },
      gnuDateShortOrIso8601date2: {
        // iso8601date2 is complete subset of gnudateshort
        regex: RegExp("^" + reYear + "-" + reMonth + "-" + reDay),
        name: "gnudateshort | iso8601date2",
        callback: function callback(match, year, month, day) {
          return this.ymd(processYear(year), month - 1, +day);
        }
      },
      iso8601date4: {
        regex: RegExp("^" + reYear4withSign + "-" + reMonthlz + "-" + reDaylz),
        name: "iso8601date4",
        callback: function callback(match, year, month, day) {
          return this.ymd(+year, month - 1, +day);
        }
      },
      gnuNoColon: {
        regex: RegExp("^t?" + reHour24lz + reMinutelz, "i"),
        name: "gnunocolon",
        callback: function callback(match, hour, minute) {
          switch (this.times) {
            case 0:
              return this.time(+hour, +minute, 0, this.f);
            case 1:
              this.y = hour * 100 + +minute;
              this.times++;
              return true;
            default:
              return false;
          }
        }
      },
      gnuDateShorter: {
        regex: RegExp("^" + reYear4 + "-" + reMonth),
        name: "gnudateshorter",
        callback: function callback(match, year, month) {
          return this.ymd(+year, month - 1, 1);
        }
      },
      pgTextReverse: {
        // note: allowed years are from 32-9999
        // years below 32 should be treated as days in datefull
        regex: RegExp("^(\\d{3,4}|[4-9]\\d|3[2-9])-(" + reMonthAbbr + ")-" + reDaylz, "i"),
        name: "pgtextreverse",
        callback: function callback(match, year, month, day) {
          return this.ymd(processYear(year), lookupMonth(month), +day);
        }
      },
      dateFull: {
        regex: RegExp("^" + reDay + "[ \\t.-]*" + reMonthText + "[ \\t.-]*" + reYear, "i"),
        name: "datefull",
        callback: function callback(match, day, month, year) {
          return this.ymd(processYear(year), lookupMonth(month), +day);
        }
      },
      dateNoDay: {
        regex: RegExp("^" + reMonthText + "[ .\\t-]*" + reYear4, "i"),
        name: "datenoday",
        callback: function callback(match, month, year) {
          return this.ymd(+year, lookupMonth(month), 1);
        }
      },
      dateNoDayRev: {
        regex: RegExp("^" + reYear4 + "[ .\\t-]*" + reMonthText, "i"),
        name: "datenodayrev",
        callback: function callback(match, year, month) {
          return this.ymd(+year, lookupMonth(month), 1);
        }
      },
      pgTextShort: {
        regex: RegExp("^(" + reMonthAbbr + ")-" + reDaylz + "-" + reYear, "i"),
        name: "pgtextshort",
        callback: function callback(match, month, day, year) {
          return this.ymd(processYear(year), lookupMonth(month), +day);
        }
      },
      dateNoYear: {
        regex: RegExp("^" + reDateNoYear, "i"),
        name: "datenoyear",
        callback: function callback(match, month, day) {
          return this.ymd(this.y, lookupMonth(month), +day);
        }
      },
      dateNoYearRev: {
        regex: RegExp("^" + reDay + "[ .\\t-]*" + reMonthText, "i"),
        name: "datenoyearrev",
        callback: function callback(match, day, month) {
          return this.ymd(this.y, lookupMonth(month), +day);
        }
      },
      isoWeekDay: {
        regex: RegExp("^" + reYear4 + "-?W" + reWeekOfYear + "(?:-?([0-7]))?"),
        name: "isoweekday | isoweek",
        callback: function callback(match, year, week, day) {
          day = day ? +day : 1;
          if (!this.ymd(+year, 0, 1)) {
            return false;
          }
          var dayOfWeek = new Date(this.y, this.m, this.d).getDay();
          dayOfWeek = 0 - (dayOfWeek > 4 ? dayOfWeek - 7 : dayOfWeek);
          this.rd += dayOfWeek + (week - 1) * 7 + day;
        }
      },
      relativeText: {
        regex: RegExp("^(" + reReltextnumber + "|" + reReltexttext + ")" + reSpace + "(" + reReltextunit + ")", "i"),
        name: "relativetext",
        callback: function callback(match, relValue, relUnit) {
          var _lookupRelative = lookupRelative(relValue), amount = _lookupRelative.amount;
          switch (relUnit.toLowerCase()) {
            case "sec":
            case "secs":
            case "second":
            case "seconds":
              this.rs += amount;
              break;
            case "min":
            case "mins":
            case "minute":
            case "minutes":
              this.ri += amount;
              break;
            case "hour":
            case "hours":
              this.rh += amount;
              break;
            case "day":
            case "days":
              this.rd += amount;
              break;
            case "fortnight":
            case "fortnights":
            case "forthnight":
            case "forthnights":
              this.rd += amount * 14;
              break;
            case "week":
            case "weeks":
              this.rd += amount * 7;
              break;
            case "month":
            case "months":
              this.rm += amount;
              break;
            case "year":
            case "years":
              this.ry += amount;
              break;
            case "mon":
            case "monday":
            case "tue":
            case "tuesday":
            case "wed":
            case "wednesday":
            case "thu":
            case "thursday":
            case "fri":
            case "friday":
            case "sat":
            case "saturday":
            case "sun":
            case "sunday":
              this.resetTime();
              this.weekday = lookupWeekday(relUnit, 7);
              this.weekdayBehavior = 1;
              this.rd += (amount > 0 ? amount - 1 : amount) * 7;
              break;
          }
        }
      },
      relative: {
        regex: RegExp("^([+-]*)[ \\t]*(\\d+)" + reSpaceOpt + "(" + reReltextunit + "|week)", "i"),
        name: "relative",
        callback: function callback(match, signs, relValue, relUnit) {
          var minuses = signs.replace(/[^-]/g, "").length;
          var amount = +relValue * Math.pow(-1, minuses);
          switch (relUnit.toLowerCase()) {
            case "sec":
            case "secs":
            case "second":
            case "seconds":
              this.rs += amount;
              break;
            case "min":
            case "mins":
            case "minute":
            case "minutes":
              this.ri += amount;
              break;
            case "hour":
            case "hours":
              this.rh += amount;
              break;
            case "day":
            case "days":
              this.rd += amount;
              break;
            case "fortnight":
            case "fortnights":
            case "forthnight":
            case "forthnights":
              this.rd += amount * 14;
              break;
            case "week":
            case "weeks":
              this.rd += amount * 7;
              break;
            case "month":
            case "months":
              this.rm += amount;
              break;
            case "year":
            case "years":
              this.ry += amount;
              break;
            case "mon":
            case "monday":
            case "tue":
            case "tuesday":
            case "wed":
            case "wednesday":
            case "thu":
            case "thursday":
            case "fri":
            case "friday":
            case "sat":
            case "saturday":
            case "sun":
            case "sunday":
              this.resetTime();
              this.weekday = lookupWeekday(relUnit, 7);
              this.weekdayBehavior = 1;
              this.rd += (amount > 0 ? amount - 1 : amount) * 7;
              break;
          }
        }
      },
      dayText: {
        regex: RegExp("^(" + reDaytext + ")", "i"),
        name: "daytext",
        callback: function callback(match, dayText) {
          this.resetTime();
          this.weekday = lookupWeekday(dayText, 0);
          if (this.weekdayBehavior !== 2) {
            this.weekdayBehavior = 1;
          }
        }
      },
      relativeTextWeek: {
        regex: RegExp("^(" + reReltexttext + ")" + reSpace + "week", "i"),
        name: "relativetextweek",
        callback: function callback(match, relText) {
          this.weekdayBehavior = 2;
          switch (relText.toLowerCase()) {
            case "this":
              this.rd += 0;
              break;
            case "next":
              this.rd += 7;
              break;
            case "last":
            case "previous":
              this.rd -= 7;
              break;
          }
          if (isNaN(this.weekday)) {
            this.weekday = 1;
          }
        }
      },
      monthFullOrMonthAbbr: {
        regex: RegExp("^(" + reMonthFull + "|" + reMonthAbbr + ")", "i"),
        name: "monthfull | monthabbr",
        callback: function callback(match, month) {
          return this.ymd(this.y, lookupMonth(month), this.d);
        }
      },
      tzCorrection: {
        regex: RegExp("^" + reTzCorrection, "i"),
        name: "tzcorrection",
        callback: function callback(tzCorrection) {
          return this.zone(processTzCorrection(tzCorrection));
        }
      },
      tzAbbr: {
        regex: RegExp("^" + reTzAbbr),
        name: "tzabbr",
        callback: function callback(match, abbr) {
          var offset2 = tzAbbrOffsets[abbr.toLowerCase()];
          if (isNaN(offset2)) {
            return false;
          }
          return this.zone(offset2);
        }
      },
      ago: {
        regex: /^ago/i,
        name: "ago",
        callback: function callback() {
          this.ry = -this.ry;
          this.rm = -this.rm;
          this.rd = -this.rd;
          this.rh = -this.rh;
          this.ri = -this.ri;
          this.rs = -this.rs;
          this.rf = -this.rf;
        }
      },
      year4: {
        regex: RegExp("^" + reYear4),
        name: "year4",
        callback: function callback(match, year) {
          this.y = +year;
          return true;
        }
      },
      whitespace: {
        regex: /^[ .,\t]+/,
        name: "whitespace"
        // do nothing
      },
      dateShortWithTimeLong: {
        regex: RegExp("^" + reDateNoYear + "t?" + reHour24 + "[:.]" + reMinute + "[:.]" + reSecond, "i"),
        name: "dateshortwithtimelong",
        callback: function callback(match, month, day, hour, minute, second) {
          return this.ymd(this.y, lookupMonth(month), +day) && this.time(+hour, +minute, +second, 0);
        }
      },
      dateShortWithTimeLong12: {
        regex: RegExp("^" + reDateNoYear + reHour12 + "[:.]" + reMinute + "[:.]" + reSecondlz + reSpaceOpt + reMeridian, "i"),
        name: "dateshortwithtimelong12",
        callback: function callback(match, month, day, hour, minute, second, meridian) {
          return this.ymd(this.y, lookupMonth(month), +day) && this.time(processMeridian(+hour, meridian), +minute, +second, 0);
        }
      },
      dateShortWithTimeShort: {
        regex: RegExp("^" + reDateNoYear + "t?" + reHour24 + "[:.]" + reMinute, "i"),
        name: "dateshortwithtimeshort",
        callback: function callback(match, month, day, hour, minute) {
          return this.ymd(this.y, lookupMonth(month), +day) && this.time(+hour, +minute, 0, 0);
        }
      },
      dateShortWithTimeShort12: {
        regex: RegExp("^" + reDateNoYear + reHour12 + "[:.]" + reMinutelz + reSpaceOpt + reMeridian, "i"),
        name: "dateshortwithtimeshort12",
        callback: function callback(match, month, day, hour, minute, meridian) {
          return this.ymd(this.y, lookupMonth(month), +day) && this.time(processMeridian(+hour, meridian), +minute, 0, 0);
        }
      }
    };
    var resultProto = {
      // date
      y: NaN,
      m: NaN,
      d: NaN,
      // time
      h: NaN,
      i: NaN,
      s: NaN,
      f: NaN,
      // relative shifts
      ry: 0,
      rm: 0,
      rd: 0,
      rh: 0,
      ri: 0,
      rs: 0,
      rf: 0,
      // weekday related shifts
      weekday: NaN,
      weekdayBehavior: 0,
      // first or last day of month
      // 0 none, 1 first, -1 last
      firstOrLastDayOfMonth: 0,
      // timezone correction in minutes
      z: NaN,
      // counters
      dates: 0,
      times: 0,
      zones: 0,
      // helper functions
      ymd: function ymd(y2, m2, d2) {
        if (this.dates > 0) {
          return false;
        }
        this.dates++;
        this.y = y2;
        this.m = m2;
        this.d = d2;
        return true;
      },
      time: function time(h2, i2, s2, f2) {
        if (this.times > 0) {
          return false;
        }
        this.times++;
        this.h = h2;
        this.i = i2;
        this.s = s2;
        this.f = f2;
        return true;
      },
      resetTime: function resetTime() {
        this.h = 0;
        this.i = 0;
        this.s = 0;
        this.f = 0;
        this.times = 0;
        return true;
      },
      zone: function zone(minutes2) {
        if (this.zones <= 1) {
          this.zones++;
          this.z = minutes2;
          return true;
        }
        return false;
      },
      toDate: function toDate2(relativeTo) {
        if (this.dates && !this.times) {
          this.h = this.i = this.s = this.f = 0;
        }
        if (isNaN(this.y)) {
          this.y = relativeTo.getFullYear();
        }
        if (isNaN(this.m)) {
          this.m = relativeTo.getMonth();
        }
        if (isNaN(this.d)) {
          this.d = relativeTo.getDate();
        }
        if (isNaN(this.h)) {
          this.h = relativeTo.getHours();
        }
        if (isNaN(this.i)) {
          this.i = relativeTo.getMinutes();
        }
        if (isNaN(this.s)) {
          this.s = relativeTo.getSeconds();
        }
        if (isNaN(this.f)) {
          this.f = relativeTo.getMilliseconds();
        }
        switch (this.firstOrLastDayOfMonth) {
          case 1:
            this.d = 1;
            break;
          case -1:
            this.d = 0;
            this.m += 1;
            break;
        }
        if (!isNaN(this.weekday)) {
          var date2 = new Date(relativeTo.getTime());
          date2.setFullYear(this.y, this.m, this.d);
          date2.setHours(this.h, this.i, this.s, this.f);
          var dow = date2.getDay();
          if (this.weekdayBehavior === 2) {
            if (dow === 0 && this.weekday !== 0) {
              this.weekday = -6;
            }
            if (this.weekday === 0 && dow !== 0) {
              this.weekday = 7;
            }
            this.d -= dow;
            this.d += this.weekday;
          } else {
            var diff2 = this.weekday - dow;
            if (this.rd < 0 && diff2 < 0 || this.rd >= 0 && diff2 <= -this.weekdayBehavior) {
              diff2 += 7;
            }
            if (this.weekday >= 0) {
              this.d += diff2;
            } else {
              this.d -= 7 - (Math.abs(this.weekday) - dow);
            }
            this.weekday = NaN;
          }
        }
        this.y += this.ry;
        this.m += this.rm;
        this.d += this.rd;
        this.h += this.rh;
        this.i += this.ri;
        this.s += this.rs;
        this.f += this.rf;
        this.ry = this.rm = this.rd = 0;
        this.rh = this.ri = this.rs = this.rf = 0;
        var result = new Date(relativeTo.getTime());
        result.setFullYear(this.y, this.m, this.d);
        result.setHours(this.h, this.i, this.s, this.f);
        switch (this.firstOrLastDayOfMonth) {
          case 1:
            result.setDate(1);
            break;
          case -1:
            result.setMonth(result.getMonth() + 1, 0);
            break;
        }
        if (!isNaN(this.z) && result.getTimezoneOffset() !== this.z) {
          result.setUTCFullYear(result.getFullYear(), result.getMonth(), result.getDate());
          result.setUTCHours(result.getHours(), result.getMinutes(), result.getSeconds() - this.z, result.getMilliseconds());
        }
        return result;
      }
    };
    var strtotime = function strtotime2(str, now2) {
      if (now2 == null) {
        now2 = Math.floor(Date.now() / 1e3);
      }
      var rules2 = [
        formats$1.yesterday,
        formats$1.now,
        formats$1.noon,
        formats$1.midnightOrToday,
        formats$1.tomorrow,
        formats$1.timestamp,
        formats$1.firstOrLastDay,
        formats$1.backOrFrontOf,
        // formats.weekdayOf, // not yet implemented
        formats$1.timeTiny12,
        formats$1.timeShort12,
        formats$1.timeLong12,
        formats$1.mssqltime,
        formats$1.oracledate,
        formats$1.timeShort24,
        formats$1.timeLong24,
        formats$1.iso8601long,
        formats$1.gnuNoColon,
        formats$1.iso8601noColon,
        formats$1.americanShort,
        formats$1.american,
        formats$1.iso8601date4,
        formats$1.iso8601dateSlash,
        formats$1.dateSlash,
        formats$1.gnuDateShortOrIso8601date2,
        formats$1.gnuDateShorter,
        formats$1.dateFull,
        formats$1.pointedDate4,
        formats$1.pointedDate2,
        formats$1.dateNoDay,
        formats$1.dateNoDayRev,
        formats$1.dateTextual,
        formats$1.dateNoYear,
        formats$1.dateNoYearRev,
        formats$1.dateNoColon,
        formats$1.xmlRpc,
        formats$1.xmlRpcNoColon,
        formats$1.soap,
        formats$1.wddx,
        formats$1.exif,
        formats$1.pgydotd,
        formats$1.isoWeekDay,
        formats$1.pgTextShort,
        formats$1.pgTextReverse,
        formats$1.clf,
        formats$1.year4,
        formats$1.ago,
        formats$1.dayText,
        formats$1.relativeTextWeek,
        formats$1.relativeText,
        formats$1.monthFullOrMonthAbbr,
        formats$1.tzCorrection,
        formats$1.tzAbbr,
        formats$1.dateShortWithTimeShort12,
        formats$1.dateShortWithTimeLong12,
        formats$1.dateShortWithTimeShort,
        formats$1.dateShortWithTimeLong,
        formats$1.relative,
        formats$1.whitespace
      ];
      var result = Object.create(resultProto);
      while (str.length) {
        var longestMatch = null;
        var finalRule = null;
        for (var i2 = 0, l2 = rules2.length; i2 < l2; i2++) {
          var format2 = rules2[i2];
          var match = str.match(format2.regex);
          if (match) {
            if (!longestMatch || match[0].length > longestMatch[0].length) {
              longestMatch = match;
              finalRule = format2;
            }
          }
        }
        if (!finalRule || finalRule.callback && finalRule.callback.apply(result, longestMatch) === false) {
          return false;
        }
        str = str.substr(longestMatch[0].length);
        finalRule = null;
        longestMatch = null;
      }
      return Math.floor(result.toDate(new Date(now2 * 1e3)) / 1e3);
    };
    class date$4 extends Validator {
      check(value) {
        return !!strtotime(value);
      }
    }
    class date_equals extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          date: this.date
        };
      }
      get date() {
        return this.attributes[0];
      }
      check(value) {
        return value === this.date;
      }
    }
    class date_format extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          format: this.format
        };
      }
      get format() {
        return this.attributes[0];
      }
      check(value) {
        return value && this.moment(value, this.format).format(this.format) === value;
      }
    }
    class different extends Validator {
      get otherPath() {
        return this.attributes[0];
      }
      get other$() {
        return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
      }
      get messageParams() {
        return {
          attribute: this.attributeName,
          other: this.other$.genericName
        };
      }
      init() {
        this.watchOther();
      }
      check(value) {
        if (!this.filled(value) && !this.filled(this.other$.value)) {
          return true;
        }
        return value != this.other$.value;
      }
    }
    class digits extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          digits: this.digits
        };
      }
      get digits() {
        return this.attributes[0];
      }
      check(value) {
        return /^\d+$/.test(value) && value.toString().length == this.digits;
      }
    }
    class digits_between extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          min: this.min,
          max: this.max
        };
      }
      get min() {
        return this.attributes[0];
      }
      get max() {
        return this.attributes[1];
      }
      check(value) {
        var length = value.toString().length;
        return /^\d+$/.test(value) && length >= this.min && length <= this.max;
      }
    }
    class dimensions extends Validator {
      get isAsync() {
        return true;
      }
      readImage(inputFile) {
        return _asyncToGenerator(function* () {
          var reader = new FileReader();
          return new Promise((resolve2, reject) => {
            reader.onerror = () => {
              temporaryFileReader.abort();
              reject(new DOMException("File cannot be parsed."));
            };
            reader.onloadend = (event) => {
              resolve2(event.target.result);
            };
            reader.readAsDataURL(inputFile);
          });
        })();
      }
      loadImage(value) {
        var _this = this;
        return _asyncToGenerator(function* () {
          var source = yield _this.readImage(value);
          var image2 = new Image();
          return new Promise((resolve2, reject) => {
            image2.onerror = () => {
              reject(new DOMException("Image could not be loaded."));
            };
            image2.onload = (event) => {
              resolve2(event.target);
            };
            image2.src = source;
          });
        })();
      }
      hasAttribute(attribute) {
        return Object.keys(this.attributes).map((a2) => a2.toLowerCase()).indexOf(attribute) !== -1;
      }
      check(value) {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          if (_this2.isFile && !value) {
            return true;
          }
          if (!_this2.isFile || !(value instanceof File)) {
            return false;
          }
          var image2 = yield _this2.loadImage(value);
          if (_this2.hasAttribute("min_width")) {
            if (image2.width < _this2.attributes["min_width"]) {
              return false;
            }
          }
          if (_this2.hasAttribute("max_width")) {
            if (image2.width > _this2.attributes["max_width"]) {
              return false;
            }
          }
          if (_this2.hasAttribute("min_height")) {
            if (image2.height < _this2.attributes["min_height"]) {
              return false;
            }
          }
          if (_this2.hasAttribute("max_height")) {
            if (image2.height > _this2.attributes["max_height"]) {
              return false;
            }
          }
          if (_this2.hasAttribute("width")) {
            if (image2.width != _this2.attributes["width"]) {
              return false;
            }
          }
          if (_this2.hasAttribute("height")) {
            if (image2.height != _this2.attributes["height"]) {
              return false;
            }
          }
          if (_this2.hasAttribute("ratio")) {
            var ratio = _this2.attributes["ratio"];
            var precision = 1 / (Math.min(image2.width, image2.height) + 1);
            var numerator = /\//.test(ratio) ? ratio.split("/")[0] : ratio;
            var denominator = /\//.test(ratio) ? ratio.split("/")[1] : 1;
            if (Math.abs(numerator / denominator - image2.width / image2.height) > precision) {
              return false;
            }
          }
          return true;
        })();
      }
    }
    function pregQuote(str, delimiter) {
      return (str + "").replace(new RegExp("[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\" + (delimiter || "") + "-]", "g"), "\\$&");
    }
    function baseReduce$1(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    var _baseReduce = baseReduce$1;
    var arrayReduce = _arrayReduce, baseEach = _baseEach, baseIteratee$4 = _baseIteratee, baseReduce = _baseReduce, isArray$2 = isArray_1;
    function reduce(collection, iteratee, accumulator) {
      var func = isArray$2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee$4(iteratee), accumulator, initAccum, baseEach);
    }
    var reduce_1 = reduce;
    var _flattenKeys = function flattenKeys(obj) {
      var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return !isObject_1(obj) ? {
        [path.join(".")]: obj
      } : reduce_1(obj, (cum, next, key) => merge_1(cum, _flattenKeys(next, [...path, key])), {});
    };
    class distinct extends Validator {
      check(value) {
        var attribute = this.element$.path;
        var attributeName = attribute.replace(/\d+(?!\d+)/, "*");
        var rootVariable = attribute.match(/^[\w-]+/)[0];
        var attributeData = {
          [rootVariable]: this.form$.data[rootVariable]
        };
        var pattern = pregQuote(attributeName, "#").replace("\\*", "[^.]+");
        var data = {};
        each(_flattenKeys(attributeData), (v2, k2) => {
          if (k2 != attribute && k2.match("^" + pattern + "$") !== null) {
            data[k2] = v2;
          }
        });
        return !(values_1(data).indexOf(value) !== -1);
      }
    }
    class email extends Validator {
      check(value) {
        var re2 = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        return re2.test(String(value).toLowerCase());
      }
    }
    class exists extends Validator {
      get isAsync() {
        return true;
      }
      get requestParams() {
        var params = {};
        each(this.attributes, (param, key) => {
          var requestParam = key;
          if (!isNaN(key)) {
            requestParam = param;
          }
          if (requestParam == "debounce") {
            return;
          }
          var el = this.form$.el$(requestParam);
          params[keys_1(params).length] = el && key != 0 ? el.value : requestParam;
        });
        return params;
      }
      check(value) {
        var _this = this;
        return _asyncToGenerator(function* () {
          var name2 = _this.element$.name;
          var endpoint = _this.form$.$vueform.config.endpoints.exists;
          var method = typeof endpoint !== "function" ? endpoint.method : null;
          var res;
          if (typeof endpoint === "function") {
            res = yield endpoint(value, name2, _this.requestParams, _this.element$, _this.form$);
          } else {
            res = yield _this.form$.$vueform.services.axios.request({
              url: endpoint.url,
              method,
              [method.toLowerCase() === "get" ? "params" : "data"]: {
                params: _this.requestParams,
                [name2]: value,
                vueformFieldName: name2,
                value,
                name: name2
              }
            });
            res = res.data;
          }
          return res;
        })();
      }
    }
    class file$5 extends Validator {
      check(value) {
        return (!value || value instanceof File) && this.isFile;
      }
    }
    class filled extends Validator {
      check(value) {
        return this.filled(value);
      }
    }
    let gt$1 = class gt extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          value: this.other$.value != null ? this.size(this.other$.value) : 0
        };
      }
      get otherPath() {
        return this.attributes[0];
      }
      get other$() {
        return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
      }
      init() {
        this.watchOther();
      }
      check(value) {
        var otherValue = this.other$.value;
        return this.compare(value, otherValue);
      }
      compare(value, otherValue) {
        var otherSize = this.size(otherValue);
        return otherSize == 0 || this.size(value) > otherSize;
      }
    };
    class gte extends gt$1 {
      compare(value, otherValue) {
        var otherSize = this.size(otherValue);
        return otherSize == 0 || this.size(value) >= otherSize;
      }
    }
    class image extends Validator {
      check(value) {
        if (this.isFile && !value) {
          return true;
        }
        if (!this.isFile || !(value instanceof File) || !value.name) {
          return false;
        }
        var extension = value.name.split(".").pop();
        return ["jpg", "jpeg", "png", "gif", "bmp", "svg", "webp"].indexOf(extension) !== -1;
      }
    }
    class in_ extends Validator {
      check(value) {
        return values_1(this.attributes).indexOf(normalize$1(String(value).trim())) !== -1;
      }
    }
    class in_array extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          other: this.other$.genericName
        };
      }
      get other$() {
        return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
      }
      get otherPath() {
        var matches2 = this.attributes[0].match(/.*(?=\.\*)/);
        if (matches2 === null) {
          throw new Error("in_array rule's other attribute should end with .*");
        }
        return matches2[0];
      }
      init() {
        this.watchOther();
      }
      check(value) {
        var data = this.other$.value;
        if (!data) {
          return false;
        }
        return data.indexOf(value) !== -1;
      }
    }
    class integer extends Validator {
      check(value) {
        var normalized = normalize$1(String(value).trim());
        return normalized === parseInt(normalized, 10);
      }
    }
    var checker$1 = function checker2(value) {
      var re2 = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\/([0-9]|[1-2][0-9]|3[0-2]))?$/;
      return re2.test(value);
    };
    class ipv4 extends Validator {
      check(value) {
        return checker$1(value);
      }
    }
    var checker = function checker2(value) {
      var re2 = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*(\/(\d|\d\d|1[0-1]\d|12[0-8]))?$/;
      return re2.test(value);
    };
    class ipv6 extends Validator {
      check(value) {
        return checker(value);
      }
    }
    class ip extends Validator {
      check(value) {
        return checker$1(value) || checker(value);
      }
    }
    function isJson(str) {
      try {
        JSON.parse(str);
      } catch (e2) {
        return false;
      }
      return true;
    }
    class json extends Validator {
      check(value) {
        return isJson(value);
      }
    }
    let lt$1 = class lt extends gt$1 {
      compare(value, otherValue) {
        var size2 = this.size(value);
        var otherSize = this.size(otherValue);
        return otherSize == 0 && size2 == 0 || this.size(value) < otherSize;
      }
    };
    class lte extends gt$1 {
      compare(value, otherValue) {
        var size2 = this.size(value);
        var otherSize = this.size(otherValue);
        return otherSize == 0 && size2 == 0 || this.size(value) <= otherSize;
      }
    }
    let max$1 = class max extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          max: this.max
        };
      }
      get max() {
        return this.attributes[0];
      }
      check(value) {
        if (!value) {
          return true;
        }
        return this.size(value) <= this.max;
      }
    };
    class mimes extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          values: this.accepted.join(", ")
        };
      }
      get accepted() {
        return Object.values(this.attributes).map((a2) => a2.toLowerCase());
      }
      check(value) {
        if (this.isFile && !value) {
          return true;
        }
        if (!this.isFile || !(value instanceof File) || !value.name) {
          return false;
        }
        var extension = value.name.split(".").pop();
        return this.accepted.indexOf(extension.toLowerCase()) !== -1;
      }
    }
    class mimetypes extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          values: this.accepted.join(", ")
        };
      }
      get accepted() {
        return Object.values(this.attributes).map((a2) => a2.toLowerCase());
      }
      check(value) {
        if (this.isFile && !value) {
          return true;
        }
        if (!this.isFile || !(value instanceof File) || !value.type) {
          return false;
        }
        return this.accepted.indexOf(value.type.toLowerCase()) !== -1;
      }
    }
    class min$1 extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          min: this.min
        };
      }
      get min() {
        return this.attributes[0];
      }
      check(value) {
        if (!value) {
          return true;
        }
        return this.size(value) >= this.min;
      }
    }
    class not_in extends Validator {
      check(value) {
        return values_1(this.attributes).indexOf(value) === -1;
      }
    }
    class not_regex extends Validator {
      check(value) {
        var regex2 = new RegExp(this.attributes[0].replace(/^\/|\/[^\/]*$/g, ""));
        return !regex2.test(value);
      }
    }
    class nullable extends Validator {
      check(value) {
        return true;
      }
    }
    class numeric extends Validator {
      check(value) {
        return !isNaN(parseFloat(value)) && isFinite(value) && !/\s/.test(String(value)) && !Boolean(String(value).match(/^0x[0-9a-f]+$/i));
      }
    }
    class regex extends Validator {
      check(value) {
        var regex2 = new RegExp(this.attributes[0].replace(/^\/|\/[^\/]*$/g, ""));
        return regex2.test(value);
      }
    }
    class required extends Validator {
      check(value) {
        return this.filled(value);
      }
    }
    class same extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          other: this.other$.genericName
        };
      }
      get otherPath() {
        return this.attributes[0];
      }
      get other$() {
        return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
      }
      init() {
        this.watchOther();
      }
      check(value) {
        if (!this.filled(value) && !this.filled(this.other$.value)) {
          return true;
        }
        return value == this.other$.value;
      }
    }
    class size extends Validator {
      get messageParams() {
        return {
          attribute: this.attributeName,
          size: this.size_
        };
      }
      get size_() {
        return this.attributes[0];
      }
      check(value) {
        if (!value) {
          return true;
        }
        return this.size(value) == this.size_;
      }
    }
    class string extends Validator {
      check(value) {
        return isString_1(value);
      }
    }
    class timezone extends Validator {
      check(value) {
        try {
          Intl.DateTimeFormat(void 0, {
            timeZone: value
          });
          return true;
        } catch (ex) {
          return false;
        }
      }
    }
    let unique$1 = class unique extends Validator {
      get isAsync() {
        return true;
      }
      get requestParams() {
        var params = {};
        each(this.attributes, (param, key) => {
          var requestParam = key;
          if (!isNaN(key)) {
            requestParam = param;
          }
          if (requestParam == "debounce") {
            return;
          }
          var el = this.form$.el$(requestParam);
          params[keys_1(params).length] = el && key != 0 ? el.value : requestParam;
        });
        return params;
      }
      check(value) {
        var _this = this;
        return _asyncToGenerator(function* () {
          var name2 = _this.element$.name;
          var endpoint = _this.form$.$vueform.config.endpoints.unique;
          var method = typeof endpoint !== "function" ? endpoint.method : null;
          var res;
          if (typeof endpoint === "function") {
            res = yield endpoint(value, name2, _this.requestParams, _this.element$, _this.form$);
          } else {
            res = yield _this.form$.$vueform.services.axios.request({
              url: endpoint.url,
              method,
              [method.toLowerCase() === "get" ? "params" : "data"]: {
                params: _this.requestParams,
                name: name2,
                value
              }
            });
            res = res.data;
          }
          return res;
        })();
      }
    };
    class url extends Validator {
      check(value) {
        var regex2 = new RegExp("^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$", "i");
        return regex2.test(value);
      }
    }
    class uuid extends Validator {
      check(value) {
        var regex2 = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/i;
        return regex2.test(value);
      }
    }
    var index$2 = {
      accepted,
      active_url,
      after,
      after_or_equal,
      alpha,
      alpha_dash,
      alpha_num,
      array: array$2,
      before,
      before_or_equal,
      between,
      boolean: boolean$1,
      confirmed,
      date: date$4,
      date_equals,
      date_format,
      different,
      digits,
      digits_between,
      dimensions,
      distinct,
      email,
      exists,
      file: file$5,
      filled,
      gt: gt$1,
      gte,
      image,
      in: in_,
      in_array,
      integer,
      ip,
      ipv4,
      ipv6,
      json,
      lt: lt$1,
      lte,
      max: max$1,
      mimes,
      mimetypes,
      min: min$1,
      not_in,
      not_regex,
      nullable,
      numeric,
      regex,
      required,
      same,
      size,
      string,
      timezone,
      unique: unique$1,
      url,
      uuid
    };
    var rules = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      accepted,
      active_url,
      after,
      after_or_equal,
      alpha,
      alpha_dash,
      alpha_num,
      array: array$2,
      before,
      before_or_equal,
      between,
      boolean: boolean$1,
      captcha: captcha$2,
      completed,
      confirmed,
      date: date$4,
      date_equals,
      date_format,
      different,
      digits,
      digits_between,
      dimensions,
      distinct,
      email,
      exists,
      file: file$5,
      filled,
      gt: gt$1,
      gte,
      image,
      in_,
      in_array,
      integer,
      ip,
      ipv4,
      ipv6,
      json,
      lt: lt$1,
      lte,
      max: max$1,
      mimes,
      mimetypes,
      min: min$1,
      not_in,
      not_regex,
      nullable,
      numeric,
      regex,
      required,
      same,
      size,
      string,
      timezone,
      unique: unique$1,
      url,
      uuid,
      "default": index$2
    });
    var validation = {
      factory: Factory,
      rules: {}
    };
    var arrayPush = _arrayPush, baseFlatten$1 = _baseFlatten, copyArray = _copyArray, isArray$1 = isArray_1;
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1), array2 = arguments[0], index2 = length;
      while (index2--) {
        args[index2 - 1] = arguments[index2];
      }
      return arrayPush(isArray$1(array2) ? copyArray(array2) : [array2], baseFlatten$1(args, 1));
    }
    var concat_1 = concat;
    function head(array2) {
      return array2 && array2.length ? array2[0] : void 0;
    }
    var head_1 = head;
    class messageBag {
      constructor(baseErrors) {
        this.baseErrors = baseErrors;
        this.prepends = {
          errors: [],
          messages: []
        };
        this.appends = {
          errors: [],
          messages: []
        };
      }
      get errors() {
        return concat_1(this.prepends.errors, this.baseErrors, this.appends.errors);
      }
      get messages() {
        return concat_1(this.prepends.messages, this.appends.messages);
      }
      /**
       * The first error
       * 
       * @type {string}
       */
      get error() {
        return head_1(this.errors);
      }
      /**
       * The first message
       * 
       * @type {string}
       */
      get message() {
        return head_1(this.messages);
      }
      prepend(msg, type) {
        if (type === void 0) {
          type = "error";
        }
        this.prepends[type == "error" ? "errors" : "messages"].unshift(msg);
      }
      append(msg, type) {
        if (type === void 0) {
          type = "error";
        }
        this.appends[type == "error" ? "errors" : "messages"].push(msg);
      }
      remove(msg, type) {
        if (type === void 0) {
          type = "any";
        }
        if (["any", "error"].indexOf(type) !== -1) {
          each(this.prepends.errors, (error, index2) => {
            if (error == msg) {
              this.rm("prepends", "errors", index2);
            }
          });
          each(this.appends.errors, (error, index2) => {
            if (error == msg) {
              this.rm("appends", "errors", index2);
            }
          });
        }
        if (["any", "message"].indexOf(type) !== -1) {
          each(this.prepends.messages, (error, index2) => {
            if (error == msg) {
              this.rm("prepends", "messages", index2);
            }
          });
          each(this.appends.messages, (error, index2) => {
            if (error == msg) {
              this.rm("appends", "messages", index2);
            }
          });
        }
      }
      rm(group2, type, index2) {
        this[group2][type].splice(index2, 1);
      }
      clear(type) {
        if (type === void 0) {
          type = "all";
        }
        if (type == "all") {
          this.prepends = {
            errors: [],
            messages: []
          };
          this.appends = {
            errors: [],
            messages: []
          };
        } else {
          this.prepends[type] = [];
          this.appends[type] = [];
        }
      }
      clearPrepended(type) {
        if (type === void 0) {
          type = "all";
        }
        if (type == "all") {
          this.prepends = {
            errors: [],
            messages: []
          };
        } else {
          this.prepends[type] = [];
        }
      }
      clearAppended(type) {
        if (type === void 0) {
          type = "all";
        }
        if (type == "all") {
          this.appends = {
            errors: [],
            messages: []
          };
        } else {
          this.appends[type] = [];
        }
      }
    }
    var e$1 = /* @__PURE__ */ new Map();
    function t$1(t2) {
      var o2 = e$1.get(t2);
      o2 && o2.destroy();
    }
    function o$1(t2) {
      var o2 = e$1.get(t2);
      o2 && o2.update();
    }
    var r$1 = null;
    "undefined" == typeof window ? ((r$1 = function(e2) {
      return e2;
    }).destroy = function(e2) {
      return e2;
    }, r$1.update = function(e2) {
      return e2;
    }) : ((r$1 = function(t2, o2) {
      return t2 && Array.prototype.forEach.call(t2.length ? t2 : [t2], function(t3) {
        return function(t4) {
          if (t4 && t4.nodeName && "TEXTAREA" === t4.nodeName && !e$1.has(t4)) {
            var o3, r2 = null, n2 = window.getComputedStyle(t4), i2 = (o3 = t4.value, function() {
              a2({ testForHeightReduction: "" === o3 || !t4.value.startsWith(o3), restoreTextAlign: null }), o3 = t4.value;
            }), l2 = (function(o4) {
              t4.removeEventListener("autosize:destroy", l2), t4.removeEventListener("autosize:update", s2), t4.removeEventListener("input", i2), window.removeEventListener("resize", s2), Object.keys(o4).forEach(function(e2) {
                return t4.style[e2] = o4[e2];
              }), e$1.delete(t4);
            }).bind(t4, { height: t4.style.height, resize: t4.style.resize, textAlign: t4.style.textAlign, overflowY: t4.style.overflowY, overflowX: t4.style.overflowX, wordWrap: t4.style.wordWrap });
            t4.addEventListener("autosize:destroy", l2), t4.addEventListener("autosize:update", s2), t4.addEventListener("input", i2), window.addEventListener("resize", s2), t4.style.overflowX = "hidden", t4.style.wordWrap = "break-word", e$1.set(t4, { destroy: l2, update: s2 }), s2();
          }
          function a2(e2) {
            var o4, i3, l3 = e2.restoreTextAlign, s3 = void 0 === l3 ? null : l3, d2 = e2.testForHeightReduction, u2 = void 0 === d2 || d2, c2 = n2.overflowY;
            if (0 !== t4.scrollHeight && ("vertical" === n2.resize ? t4.style.resize = "none" : "both" === n2.resize && (t4.style.resize = "horizontal"), u2 && (o4 = function(e3) {
              for (var t5 = []; e3 && e3.parentNode && e3.parentNode instanceof Element; )
                e3.parentNode.scrollTop && t5.push([e3.parentNode, e3.parentNode.scrollTop]), e3 = e3.parentNode;
              return function() {
                return t5.forEach(function(e4) {
                  var t6 = e4[0], o5 = e4[1];
                  t6.style.scrollBehavior = "auto", t6.scrollTop = o5, t6.style.scrollBehavior = null;
                });
              };
            }(t4), t4.style.height = ""), i3 = "content-box" === n2.boxSizing ? t4.scrollHeight - (parseFloat(n2.paddingTop) + parseFloat(n2.paddingBottom)) : t4.scrollHeight + parseFloat(n2.borderTopWidth) + parseFloat(n2.borderBottomWidth), "none" !== n2.maxHeight && i3 > parseFloat(n2.maxHeight) ? ("hidden" === n2.overflowY && (t4.style.overflow = "scroll"), i3 = parseFloat(n2.maxHeight)) : "hidden" !== n2.overflowY && (t4.style.overflow = "hidden"), t4.style.height = i3 + "px", s3 && (t4.style.textAlign = s3), o4 && o4(), r2 !== i3 && (t4.dispatchEvent(new Event("autosize:resized", { bubbles: true })), r2 = i3), c2 !== n2.overflow && !s3)) {
              var v2 = n2.textAlign;
              "hidden" === n2.overflow && (t4.style.textAlign = "start" === v2 ? "end" : "start"), a2({ restoreTextAlign: v2, testForHeightReduction: true });
            }
          }
          function s2() {
            a2({ testForHeightReduction: true, restoreTextAlign: null });
          }
        }(t3);
      }), t2;
    }).destroy = function(e2) {
      return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], t$1), e2;
    }, r$1.update = function(e2) {
      return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], o$1), e2;
    });
    var n$1 = r$1;
    class google {
      constructor() {
        this.autocomplete = null;
        this.autocompleteListener = null;
        this.options = {};
      }
      init(container, onChange, options) {
        if (window.google === void 0 || window.google.maps === void 0 || window.google.maps.places === void 0 || window.google.maps.places.Autocomplete === void 0)
          ;
        this.options = options;
        this.autocomplete = new window.google.maps.places.Autocomplete(container, options);
        this.autocompleteListener = this.autocomplete.addListener("place_changed", () => {
          var place = this.autocomplete.getPlace();
          onChange(this.formatValue(place), place);
        });
      }
      destroy() {
        window.google.maps.event.removeListener(this.autocompleteListener);
        window.google.maps.event.clearInstanceListeners(this.autocomplete);
        var pac = document.querySelector(".pac-container");
        if (pac) {
          pac.remove();
        }
      }
      formatValue(value) {
        if (!isPlainObject_1(value)) {
          return value;
        }
        var addressComponents = value.address_components;
        var street = this.addressComponent(addressComponents, "street");
        var streetNumber = this.addressComponent(addressComponents, "street_number");
        var address = null;
        if (street !== null) {
          address = street;
        }
        if (streetNumber !== null) {
          address += (street !== null ? " " : "") + streetNumber;
        }
        return {
          country: this.addressComponent(addressComponents, "country"),
          country_code: this.addressComponent(addressComponents, "country_code"),
          state: this.addressComponent(addressComponents, "state"),
          state_code: this.addressComponent(addressComponents, "state_code"),
          city: this.addressComponent(addressComponents, "city"),
          zip: this.addressComponent(addressComponents, "zip"),
          address,
          formatted_address: value.formatted_address || null,
          lat: value.geometry.location.lat() || null,
          lng: value.geometry.location.lng() || null
        };
      }
      addressComponent(addressComponents, type) {
        var typeMap = {
          country: {
            field: "country",
            type: "long_name"
          },
          country_code: {
            field: "country",
            type: "short_name"
          },
          state: {
            field: "administrative_area_level_1",
            type: "long_name"
          },
          state_code: {
            field: "administrative_area_level_1",
            type: "short_name"
          },
          city: {
            field: "locality",
            type: "long_name"
          },
          zip: {
            field: "postal_code",
            type: "long_name"
          },
          street: {
            field: "route",
            type: "long_name"
          },
          street_number: {
            field: "street_number",
            type: "long_name"
          }
        };
        var addressComponent = null;
        each(addressComponents, (component) => {
          if (component.types.indexOf(typeMap[type].field) !== -1) {
            if (["state", "state_code"].indexOf(type) !== -1 && this.addressComponent(addressComponents, "country_code") != "US") {
              return;
            }
            addressComponent = component[typeMap[type].type] || null;
          }
        });
        return addressComponent;
      }
    }
    class algolia {
      constructor() {
        this.places = null;
        this.options = {};
      }
      init(container, onChange, options) {
        if (window.places === void 0) {
          throw new Error("Algolia Places API missing. Please include script in your project from https://community.algolia.com/places/documentation.html#cdn-script or install via npm and set to `window.places`.");
        }
        this.options = options;
        this.places = window.places(Object.assign({}, {
          container
        }, options));
        this.places.on("change", (e2) => {
          onChange(this.formatValue(e2.suggestion), e2.suggestion);
        });
      }
      destroy() {
        this.places.destroy();
      }
      formatValue(value) {
        if (!isPlainObject_1(value)) {
          return value;
        }
        return {
          country: value.country,
          country_code: value.countryCode ? value.countryCode.toUpperCase() : null,
          state: value.countryCode == "us" ? value.administrative : null,
          state_code: value.countryCode == "us" ? this.stateCode(value.administrative.toLowerCase()) : null,
          city: value.city,
          zip: value.postcode,
          address: value.name,
          formatted_address: value.value,
          lat: value.latlng.lat,
          lng: value.latlng.lng
        };
      }
      stateCode(name2) {
        var states = {
          AL: "alabama",
          AK: "alaska",
          AZ: "arizona",
          AR: "arkansas",
          CA: "california",
          CO: "colorado",
          CT: "connecticut",
          DE: "delaware",
          DC: "district of columbia",
          FL: "florida",
          GA: "georgia",
          HI: "hawaii",
          ID: "idaho",
          IL: "illinois",
          IN: "indiana",
          IA: "iowa",
          KS: "kansas",
          KY: "kentucky",
          LA: "louisiana",
          ME: "maine",
          MD: "maryland",
          MA: "massachusetts",
          MI: "michigan",
          MN: "minnesota",
          MS: "mississippi",
          MO: "missouri",
          MT: "montana",
          NE: "nebraska",
          NV: "nevada",
          NH: "new hampshire",
          NJ: "new Jersey",
          NM: "new Mexico",
          NY: "new york",
          NC: "north carolina",
          ND: "north dakota",
          OH: "ohio",
          OK: "oklahoma",
          OR: "oregon",
          PA: "pennsylvania",
          RI: "rhode Island",
          SC: "south carolina",
          SD: "south dakota",
          TN: "tennessee",
          TX: "texas",
          UT: "utah",
          VT: "vermont",
          VA: "virginia",
          WA: "washington",
          WV: "west virginia",
          WI: "wisconsin",
          WY: "wyoming"
        };
        if (values_1(states).indexOf(name2) === -1) {
          return null;
        }
        return keys_1(states)[values_1(states).indexOf(name2)];
      }
    }
    var location$4 = {
      google,
      algolia
    };
    var check = (condition2, elementPath, form$, el$) => {
      var checkFunction = () => {
        return condition2(form$, el$);
      };
      var checkArray = (condition3) => {
        var {
          conditionPath,
          operator,
          expected
        } = details(condition3);
        var element$ = form$.el$(conditionPath);
        var hasCircularCondition = false;
        if (element$ && elementPath) {
          each(element$.conditions, (condition4) => {
            if (!Array.isArray(condition4)) {
              return;
            }
            if (condition4[0] == elementPath) {
              hasCircularCondition = true;
            }
          });
        }
        if (!element$ || !hasCircularCondition && !element$.available) {
          return false;
        }
        return compareValues(element$.value, expected, operator);
      };
      var details = (condition3) => {
        return {
          conditionPath: elementPath ? replaceWildcards(condition3[0], elementPath) : condition3[0],
          operator: condition3.length == 3 || ["empty", "not_empty", "today"].indexOf(condition3[1]) !== -1 ? condition3[1] : "==",
          expected: condition3.length == 3 ? condition3[2] : ["empty", "not_empty", "today"].indexOf(condition3[1]) === -1 ? condition3[1] : true
        };
      };
      var compareValues = (actual, expected, operator) => {
        return compare(actual, operator, expected, el$, form$);
      };
      if (typeof condition2 == "function") {
        return checkFunction();
      } else if (isArray_1(condition2) && isArray_1(condition2[0])) {
        return condition2.reduce((prev, curr) => {
          if (prev) {
            return prev;
          }
          if (isArray_1(curr[0])) {
            return curr.reduce((p2, c2) => !p2 ? p2 : checkArray(c2), true);
          }
          return checkArray(curr);
        }, false);
      } else if (isArray_1(condition2)) {
        return checkArray(condition2);
      }
      throw new Error("Condition must be a function or an array");
    };
    var condition = {
      check
    };
    class i18n {
      constructor(options) {
        this.locales = options.locales;
        this.locale = options.locale;
        this.fallbackLocale = options.fallbackLocale;
      }
      $t(expr) {
        var data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var tag = get_1(this.locales[this.locale], expr) || expr;
        if (tag === expr) {
          tag = get_1(this.locales[this.fallbackLocale], expr) || expr;
        }
        each(data, (value, key) => {
          tag = tag.replace(":" + key, value);
        });
        each(data, (value, key) => {
          tag = tag.replace("{" + key + "}", value);
        });
        return tag;
      }
    }
    class Columns {
      constructor(options, hasLabel, getClass, presets) {
        _defineProperty$2(this, "defaultBreakpoint", "default");
        this.presets = presets;
        this.configPresetColumns = this.serialize(this.columnsFromPresets(options.configPresetColumns) || {});
        this.configColumns = this.serialize(options.configColumns || {});
        this.formPresetColumns = this.serialize(this.columnsFromPresets(options.formPresetColumns) || {});
        this.formColumns = this.serialize(options.formColumns || {});
        this.presetColumns = this.serialize(this.columnsFromPresets(options.elementPresetColumns) || {});
        this.columns = this.serialize(options.elementColumns || {});
        this.hasLabel = hasLabel;
        this.getClass = getClass;
        this.cols = this.getCols();
      }
      get classes() {
        return {
          container: this.getClasses("container"),
          label: this.getClasses("label"),
          innerContainer: this.getClasses("innerContainer"),
          wrapper: this.getClasses("wrapper")
        };
      }
      serialize(columns2) {
        if (["number", "string"].indexOf(typeof columns2) !== -1) {
          return {
            [this.defaultBreakpoint]: {
              container: columns2
            }
          };
        }
        if (typeof columns2 === "object" && ["container", "label", "wrapper"].indexOf(Object.keys(columns2)[0]) !== -1) {
          var serialized = {};
          each(columns2, (size2, type) => {
            if (["number", "string"].indexOf(typeof size2) !== -1) {
              if (serialized[this.defaultBreakpoint] === void 0) {
                serialized[this.defaultBreakpoint] = {};
              }
              serialized[this.defaultBreakpoint][type] = size2;
            } else {
              each(size2, (s2, breakpoint) => {
                if (serialized[breakpoint] === void 0) {
                  serialized[breakpoint] = {};
                }
                serialized[breakpoint][type] = s2;
              });
            }
          });
          return serialized;
        } else {
          var _serialized = {};
          each(columns2, (size2, breakpoint) => {
            if (["number", "string"].indexOf(typeof size2) !== -1) {
              if (_serialized[breakpoint] === void 0) {
                _serialized[breakpoint] = {};
              }
              _serialized[breakpoint].container = size2;
            } else {
              _serialized[breakpoint] = size2;
            }
          });
          return _serialized;
        }
      }
      columnsFromPresets(presets) {
        var columns2;
        each(presets, (presetName) => {
          var preset = this.presets[presetName];
          if (!preset || !preset.columns) {
            return;
          }
          columns2 = preset.columns;
        });
        return columns2;
      }
      getNullClass() {
        return [this.getClass(this.defaultBreakpoint, 0)];
      }
      getClasses(type) {
        var classes2 = [];
        Object.keys(this.cols).forEach((breakpoint) => {
          var size2;
          if (type === "innerContainer") {
            size2 = this.cols[breakpoint].label;
            size2 = size2 >= 12 || !this.hasLabel ? 12 : 12 - size2;
          } else {
            size2 = this.cols[breakpoint][type];
            if (type === "label" && !this.hasLabel) {
              size2 = 0;
            }
          }
          if (size2 !== void 0 && !isNaN(size2)) {
            classes2.push(this.getClass(breakpoint, size2));
          }
        });
        return classes2;
      }
      getCols() {
        return merge_1({}, {
          [this.defaultBreakpoint]: {
            container: 12,
            label: 12,
            wrapper: 12
          }
        }, this.configPresetColumns || {}, this.configColumns || {}, this.formPresetColumns || {}, this.formColumns || {}, this.presetColumns || {}, this.columns || {});
      }
    }
    class CaptchaProviderInterface {
      constructor(element, options, el$) {
      }
      init() {
      }
      render() {
      }
      reset() {
      }
      getResponse() {
      }
      validate(response) {
        return _asyncToGenerator(function* () {
        })();
      }
    }
    class Recaptcha2Provider extends CaptchaProviderInterface {
      constructor(element, options, el$) {
        super(element, options, el$);
        _defineProperty$2(this, "src", "https://www.google.com/recaptcha/api.js?onload=recaptcha2LoadCallback&render=explicit");
        _defineProperty$2(this, "element", void 0);
        _defineProperty$2(this, "options", {});
        _defineProperty$2(this, "el$", {});
        _defineProperty$2(this, "id", void 0);
        _defineProperty$2(this, "rendered", false);
        _defineProperty$2(this, "interval", void 0);
        this.element = element;
        this.options = options;
        this.el$ = el$;
        this.init();
      }
      init() {
        this.loadScript();
      }
      render() {
        this.id = window.grecaptcha.render(this.element, _objectSpread2$1({
          callback: (token2) => {
            this.el$.update(token2);
          },
          "expired-callback": () => {
            this.el$.clear();
          },
          "error-callback": () => {
            this.el$.clear();
          }
        }, this.options));
        this.rendered = true;
      }
      reset() {
        if (!this.rendered) {
          return;
        }
        return window.grecaptcha.reset(this.id);
      }
      getResponse() {
        return window.grecaptcha.getResponse(this.id);
      }
      validate(response) {
        return _asyncToGenerator(function* () {
          return !!response;
        })();
      }
      loadScript() {
        if (this.isCaptchaLoaded()) {
          this.render();
          return;
        }
        if (this.isScriptAdded()) {
          this.interval = setInterval(() => {
            if (this.isCaptchaLoaded()) {
              this.render();
              clearInterval(this.interval);
            }
          }, 500);
          return;
        }
        window.recaptcha2LoadCallback = () => {
          this.render();
        };
        var script2 = document.createElement("script");
        script2.src = this.src;
        script2.async = true;
        script2.defer = true;
        document.head.appendChild(script2);
        script2.onload = () => {
        };
        script2.onerror = () => {
          console.error("Error loading reCAPTCHA!");
        };
      }
      isCaptchaLoaded() {
        return typeof window !== "undefined" && window.grecaptcha;
      }
      isScriptAdded() {
        var scripts2 = document.getElementsByTagName("script");
        for (var i2 = 0; i2 < scripts2.length; i2++) {
          if (scripts2[i2].src.includes("https://www.google.com/recaptcha/api.js")) {
            return true;
          }
        }
        return false;
      }
    }
    var config = {
      /**
       * General
       */
      env: "development",
      plugins: [],
      elements: [],
      /**
       * Theme & layout
       */
      theme: {},
      templates: {},
      views: {},
      size: "md",
      addClasses: {},
      removeClasses: {},
      replaceClasses: {},
      overrideClasses: {},
      presets: {},
      usePresets: [],
      classHelpers: false,
      columns: {},
      forceLabels: false,
      floatPlaceholders: true,
      displayErrors: true,
      displayMessages: true,
      breakpoints: ["sm", "md", "lg", "xl", "2xl"],
      /**
       * Localization
       */
      languages: {
        en: "English"
      },
      language: "en",
      locales: {},
      locale: null,
      fallbackLocale: "en",
      /**
       * Sorting
       */
      orderFrom: 1,
      /**
       * Validation
       */
      rules: {},
      validateOn: "change|step",
      /**
       * Data
       */
      forceNumbers: false,
      /**
       * Submitting
       */
      endpoints: {
        submit: {
          url: "/vueform/process",
          method: "post"
        },
        uploadTempFile: {
          url: "/vueform/file/upload-temp",
          method: "post"
        },
        removeTempFile: {
          url: "/vueform/file/remove-temp",
          method: "post"
        },
        removeFile: {
          url: "/vueform/file/remove",
          method: "post"
        },
        attachment: {
          url: "/vueform/editor/attachment",
          method: "post"
        },
        activeUrl: {
          url: "/vueform/validators/active_url",
          method: "post"
        },
        unique: {
          url: "/vueform/validators/unique",
          method: "post"
        },
        exists: {
          url: "/vueform/validators/exists",
          method: "post"
        }
      },
      formData(form$) {
        return form$.convertFormData(_objectSpread2$1(_objectSpread2$1({}, form$.requestData), form$.formKey ? {
          formKey: form$.formKey
        } : {}));
      },
      beforeSend: null,
      axios: {},
      /**
       * Providers
       */
      locationProvider: "google",
      providers: {
        captcha: {
          recaptcha2: Recaptcha2Provider
        }
      },
      useProviders: {
        captcha: "recaptcha2"
      },
      providerOptions: {
        recaptcha2: {
          sitekey: "6LeIxAcTAAAAAJcZVRqyHh71UMIEGNQ_MXjiZKhI"
        }
      },
      /**
       * Services
       */
      services: {
        algolia: {
          app_id: "",
          api_key: ""
        }
      }
    };
    function installer() {
      var config$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : config;
      var components2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rules2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var services = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var Vueform = class {
        constructor() {
          this.options = {
            config: omit_1(config$1, ["theme", "templates", "locales", "rules", "plugins"]),
            templates: config$1.templates || {},
            components: config$1.components || {},
            theme: config$1.theme || {},
            rules: _objectSpread2$1(_objectSpread2$1({}, rules2), config$1.rules || {}),
            locales: config$1.locales || {},
            plugins: config$1.plugins || [],
            i18n: null,
            vueVersion: null,
            services: _objectSpread2$1({
              validation,
              axios: axios$1,
              messageBag,
              autosize: n$1,
              location: location$4,
              condition,
              columns: Columns
            }, services),
            version: packageJson.version
          };
        }
        config(config2) {
          each(["theme", "templates", "locales", "rules"], (attr) => {
            if (config2[attr] !== void 0) {
              this.options[attr] = Object.assign({}, this.options[attr], config2[attr]);
            }
          });
          each(["plugins", "components"], (attr) => {
            if (config2[attr] !== void 0) {
              this.options[attr] = config2[attr];
            }
          });
          each(["languages", "services", "presets", "views"], (attr) => {
            if (config2[attr] !== void 0) {
              this.options.config[attr] = Object.assign({}, this.options.config[attr], config2[attr]);
            }
          });
          each(["addClasses", "removeClasses", "replaceClasses", "overrideClasses"], (attr) => {
            if (config2[attr] !== void 0) {
              this.options.config[attr] = typeof config2[attr] === "function" ? config2[attr] : Object.assign({}, this.options.config[attr], config2[attr]);
            }
          });
          each(["endpoints", "providers", "useProviders", "providerOptions"], (attr) => {
            if (config2[attr] !== void 0) {
              this.options.config[attr] = merge_1({}, this.options.config[attr], config2[attr]);
            }
          });
          each(["columns", "forceLabels", "displayErrors", "floatPlaceholders", "displayErrors", "displayMessages", "language", "locale", "fallbackLocale", "orderFrom", "validateOn", "formData", "beforeSend", "locationProvider", "classHelpers", "env", "usePresets", "plugins", "size", "apiKey", "forceNumbers"], (attr) => {
            if (config2[attr] !== void 0) {
              this.options.config[attr] = config2[attr];
            }
          });
          if (config2.elements) {
            config2.elements.forEach((element) => {
              components2[element.name] = omit_1(element, ["render", "staticRenderFns", "components"]);
            });
            config2.elements.forEach((element) => {
              if (this.options.templates[element.name] === void 0) {
                this.options.templates[element.name] = pick_1(element, ["render", "staticRenderFns", "components"]);
              }
            });
          }
          if (config2.axios !== void 0) {
            if (typeof config2.axios === "function") {
              this.options.services.axios = config2.axios;
            } else {
              this.options.config.axios = config2.axios;
            }
          }
        }
        registerComponents(appOrVue) {
          each(components2, (comp, name2) => {
            if (comp.register === false) {
              return;
            }
            var component = _objectSpread2$1({}, comp);
            component.setup = (props, context) => {
              context = Object.assign({}, context, {
                name: ref(name2),
                emits: component.emits
              });
              var setup = comp.setup(props, context);
              this.options.plugins.forEach((p2) => {
                if (typeof p2 === "function") {
                  p2 = p2();
                }
                p2 = Array.isArray(p2) ? p2 : [p2];
                p2.forEach((plugin) => {
                  var pluginOptions = typeof plugin === "function" ? plugin() : plugin;
                  if (pluginOptions.setup && shouldApplyPlugin(name2, pluginOptions)) {
                    setup = pluginOptions.setup(props, context, setup);
                  }
                });
              });
              return setup;
            };
            if (component.components === void 0) {
              var _this$options$templat, _this$options$theme$t;
              component.components = ((_this$options$templat = this.options.templates[name2]) === null || _this$options$templat === void 0 ? void 0 : _this$options$templat.components) || ((_this$options$theme$t = this.options.theme.templates[name2]) === null || _this$options$theme$t === void 0 ? void 0 : _this$options$theme$t.components) || {};
            }
            component.render = function() {
              return this.template.render.apply(this, arguments);
            };
            component.staticRenderFns = function() {
              return this.template.staticRenderFns;
            };
            this.options.plugins.forEach((p2) => {
              if (typeof p2 === "function") {
                p2 = p2();
              }
              p2 = Array.isArray(p2) ? p2 : [p2];
              p2.forEach((plugin) => {
                var pluginOptions = typeof plugin === "function" ? plugin() : plugin;
                each(without_1(Object.keys(pluginOptions), "setup", "apply", "config", "install"), (key) => {
                  if (pluginOptions[key] && shouldApplyPlugin(name2, pluginOptions)) {
                    if (Array.isArray(pluginOptions[key])) {
                      var base2 = component[key] || [];
                      component[key] = base2.concat(pluginOptions[key]);
                    } else if (isPlainObject_1(pluginOptions[key])) {
                      component[key] = Object.assign({}, component[key] || {}, pluginOptions[key]);
                    } else {
                      component[key] = pluginOptions[key];
                    }
                  }
                });
              });
            });
            appOrVue.component(name2, component);
          });
        }
        initAxios() {
          var $axios = this.options.services.axios;
          var axiosConfig = this.options.config.axios;
          var axiosConfigFlat = flatten(this.options.config.axios);
          Object.keys(axiosConfigFlat).forEach((key) => {
            var value = axiosConfigFlat[key];
            if (["onUnauthenticated"].indexOf(key) === -1 && key.indexOf("csrfRequest.") === -1) {
              set_1($axios.defaults, key, value);
            }
          });
          $axios.interceptors.response.use((r2) => r2, (error) => {
            if (!error.response) {
              return Promise.reject(error);
            }
            return new Promise((resolve2, reject) => {
              var response = error.response;
              var originalRequest = response.config;
              if ([401, 419].indexOf(error.response.status) !== -1) {
                if (axiosConfig.csrfRequest && !originalRequest.CSRF) {
                  $axios.request(_objectSpread2$1(_objectSpread2$1({}, axiosConfig.csrfRequest), {}, {
                    CSRF: true
                  })).then(() => {
                    resolve2($axios.request(_objectSpread2$1(_objectSpread2$1({}, originalRequest), {}, {
                      CSRF: true
                    })));
                  }).catch((error2) => {
                    reject(error2);
                  });
                } else if (axiosConfig.onUnauthenticated) {
                  axiosConfig.onUnauthenticated(originalRequest);
                } else {
                  reject(error);
                }
              } else {
                reject(error);
              }
            });
          });
        }
        initI18n() {
          this.options.i18n = new i18n({
            locales: this.options.locales,
            locale: this.options.config.locale,
            fallbackLocale: this.options.config.fallbackLocale
          });
        }
        install(appOrVue) {
          var _this$options$theme;
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var version2 = parseInt(appOrVue.version.split(".")[0]);
          var minor = parseInt(appOrVue.version.split(".")[1]);
          this.options.vueVersion = version2;
          var plugins2 = options.plugins || [];
          plugins2.forEach((p2) => {
            if (typeof p2 === "function") {
              p2 = p2();
            }
            p2 = Array.isArray(p2) ? p2 : [p2];
            p2.forEach((plugin) => {
              var pluginOptions = typeof plugin === "function" ? plugin() : plugin;
              if (pluginOptions.config) {
                pluginOptions.config(options);
              }
            });
          });
          if (options) {
            this.config(options);
          }
          this.options.plugins.forEach((p2) => {
            if (typeof p2 === "function") {
              p2 = p2();
            }
            p2 = Array.isArray(p2) ? p2 : [p2];
            p2.forEach((plugin) => {
              var pluginOptions = typeof plugin === "function" ? plugin() : plugin;
              if (pluginOptions.install) {
                pluginOptions.install(appOrVue, this.options);
              }
            });
          });
          if (typeof config$1.axios !== "function") {
            this.initAxios();
          }
          this.initI18n();
          Object.keys(this.options.components).forEach((componentName) => {
            components2[componentName] = this.options.components[componentName];
          });
          this.registerComponents(appOrVue);
          var themeTemplates = ((_this$options$theme = this.options.theme) === null || _this$options$theme === void 0 ? void 0 : _this$options$theme.templates) || {};
          Object.keys(themeTemplates).forEach((componentName) => {
            themeTemplates[componentName] = markRaw(themeTemplates[componentName]);
          });
          var $vueform = ref(_objectSpread2$1(_objectSpread2$1({}, this.options), {}, {
            theme: _objectSpread2$1(_objectSpread2$1({}, this.options.theme), {}, {
              templates: themeTemplates
            })
          }));
          switch (version2) {
            case 2:
              appOrVue.config.ignoredElements = ["trix-editor"];
              appOrVue.config.unwrapInjectedRef = true;
              if (!appOrVue.prototype.$vueform) {
                appOrVue.prototype.$vueform = new Proxy($vueform, {
                  get: (target, prop, receiver) => {
                    return target.value[prop];
                  }
                });
              }
              if (!appOrVue.__VUEFORM__) {
                appOrVue.__VUEFORM__ = true;
                appOrVue.mixin({
                  methods: {
                    __: (expr, data) => {
                      if (!data) {
                        console.warn("DEPRECATED: __ method should be no longer used for translating labels, only if they contain variables. For general translation use form$.translation.TAG instead.");
                      }
                      return this.options.i18n.$t(expr, data);
                    }
                  }
                });
              }
              break;
            case 3:
              if (minor < 3) {
                appOrVue.config.unwrapInjectedRef = true;
              }
              if (!appOrVue.component("trix-editor")) {
                appOrVue.component("trix-editor", {
                  render() {
                    return h$1("trix-editor");
                  }
                });
              }
              appOrVue.config.globalProperties.$vueform = new Proxy($vueform, {
                get: (target, prop, receiver) => {
                  return target.value[prop];
                }
              });
              appOrVue.provide("$vueform", $vueform);
              appOrVue.mixin({
                methods: {
                  $set(obj, key, value) {
                    obj[key] = value;
                  },
                  $delete(obj, key) {
                    delete obj[key];
                  },
                  __: (expr, data) => {
                    if (!data) {
                      console.warn("DEPRECATED: __ method should be no longer used for translating labels, only if they contain variables. For general translation use form$.translation.TAG instead.");
                    }
                    return this.options.i18n.$t(expr, data);
                  }
                }
              });
              break;
          }
        }
      };
      return new Vueform();
    }
    var base$19 = function base2(props, context, dependencies2) {
      var form$ = inject("form$");
      return {
        form$
      };
    };
    var base$18 = function base2(props, context, dependencies2) {
      var theme = inject("theme");
      return {
        theme
      };
    };
    var base$17 = function base2(props, context, dependencies2) {
      var Size = inject("Size");
      return {
        Size
      };
    };
    var base$16 = function base2(props, context, dependencies2) {
      var {
        view
      } = toRefs(props);
      var componentName = context.name;
      var Views = inject("Views") || ref({});
      var ViewInject = inject("View", ref(void 0));
      var View = computed(() => {
        if (view && view.value) {
          return view.value;
        }
        if (Views.value[componentName.value]) {
          return Views.value[componentName.value];
        }
        return ViewInject.value;
      });
      return {
        View
      };
    };
    var base$15 = function base2(props, context, dependencies2) {
      var componentName = context.name;
      var {
        form$
      } = base$19();
      var {
        theme
      } = base$18();
      var {
        Size
      } = base$17();
      var {
        View
      } = base$16(props, context);
      var component$ = computed(() => {
        return getCurrentInstance().proxy;
      });
      var classesInstance = computed(() => {
        return new MergeClasses({
          component: componentName.value,
          component$,
          theme: theme.value,
          config: form$.value.$vueform.config,
          templates: Templates.value,
          view: View.value,
          merge: [form$.value.options]
        });
      });
      var classes2 = computed(() => {
        return classesInstance.value.classes;
      });
      var Templates = computed(() => {
        return theme.value.templates;
      });
      var template = computed(() => {
        return View.value && Templates.value["".concat(componentName.value, "_").concat(View.value)] ? Templates.value["".concat(componentName.value, "_").concat(View.value)] : Templates.value[componentName.value];
      });
      return {
        form$,
        theme,
        Size,
        View,
        classesInstance,
        classes: classes2,
        Templates,
        template
      };
    };
    var FormErrors = {
      name: "FormErrors",
      props: {
        view: {
          required: false,
          type: [String],
          default: void 0
        }
      },
      setup(props, context) {
        var {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template
        } = base$15(props, context);
        var errors = computed(() => {
          return form$.value.formErrors;
        });
        return {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template,
          errors
        };
      }
    };
    var FormMessages = {
      name: "FormMessages",
      props: {
        view: {
          required: false,
          type: [String],
          default: void 0
        }
      },
      setup(props, context) {
        var {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template
        } = base$15(props, context);
        var messages = computed(() => {
          return form$.value.formMessages;
        });
        return {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template,
          messages
        };
      }
    };
    var FormLanguages = {
      name: "FormLanguages",
      props: {
        view: {
          required: false,
          type: [String],
          default: void 0
        }
      },
      setup(props, context) {
        var {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template
        } = base$15(props, context);
        var language = computed(() => {
          return form$.value.selectedLanguage;
        });
        var languages = computed(() => {
          return form$.value.options.languages;
        });
        var select2 = (code) => {
          form$.value.setLanguage(code);
        };
        var handleSelect = (code) => {
          select2(code);
        };
        provide("View", View);
        return {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template,
          language,
          languages,
          select: select2,
          handleSelect
        };
      }
    };
    var FormLanguage = {
      name: "FormLanguage",
      emits: ["select"],
      props: {
        language: {
          type: String,
          required: true
        },
        code: {
          type: String,
          required: true
        },
        view: {
          required: false,
          type: [String],
          default: void 0
        }
      },
      setup(props, context) {
        var {
          code
        } = toRefs(props);
        var {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template
        } = base$15(props, context);
        var selectedLanguage = computed(() => {
          return form$.value.selectedLanguage;
        });
        var selected = computed(() => {
          return selectedLanguage.value == code.value;
        });
        var select2 = () => {
          context.emit("select", code.value);
        };
        return {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          selectedLanguage,
          selected,
          classes: classes2,
          Templates,
          template,
          select: select2
        };
      }
    };
    var baseIteratee$3 = _baseIteratee, isArrayLike = isArrayLike_1, keys = keys_1;
    function createFind$2(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee$3(predicate);
          collection = keys(collection);
          predicate = function(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }
        var index2 = findIndexFunc(collection, predicate, fromIndex);
        return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
      };
    }
    var _createFind = createFind$2;
    var baseFindIndex$1 = _baseFindIndex, baseIteratee$2 = _baseIteratee, toInteger$1 = toInteger_1;
    var nativeMax$1 = Math.max;
    function findIndex$1(array2, predicate, fromIndex) {
      var length = array2 == null ? 0 : array2.length;
      if (!length) {
        return -1;
      }
      var index2 = fromIndex == null ? 0 : toInteger$1(fromIndex);
      if (index2 < 0) {
        index2 = nativeMax$1(length + index2, 0);
      }
      return baseFindIndex$1(array2, baseIteratee$2(predicate), index2);
    }
    var findIndex_1 = findIndex$1;
    var createFind$1 = _createFind, findIndex = findIndex_1;
    var find$1 = createFind$1(findIndex);
    var find_1 = find$1;
    var baseFindIndex = _baseFindIndex, baseIteratee$1 = _baseIteratee, toInteger = toInteger_1;
    var nativeMax = Math.max, nativeMin = Math.min;
    function findLastIndex$1(array2, predicate, fromIndex) {
      var length = array2 == null ? 0 : array2.length;
      if (!length) {
        return -1;
      }
      var index2 = length - 1;
      if (fromIndex !== void 0) {
        index2 = toInteger(fromIndex);
        index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
      }
      return baseFindIndex(array2, baseIteratee$1(predicate), index2, true);
    }
    var findLastIndex_1 = findLastIndex$1;
    var createFind = _createFind, findLastIndex = findLastIndex_1;
    var findLast = createFind(findLastIndex);
    var findLast_1 = findLast;
    var FormTabs = {
      name: "FormTabs",
      emits: ["select"],
      props: {
        view: {
          required: false,
          type: [String],
          default: void 0
        }
      },
      setup(props, context) {
        var $this = getCurrentInstance().proxy;
        var {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template
        } = base$15(props, context);
        var {
          events,
          listeners,
          on: on2,
          off: off2,
          fire
        } = base$1c(props, context, {
          form$
        }, {
          events: context.emits
        });
        var tabs$Array = ref([]);
        var exists2 = ref(true);
        var elements$ = computed(() => {
          return form$.value.elements$;
        });
        var tabs = computed(() => {
          return form$.value.options.tabs;
        });
        var tabs$ = computed(() => {
          var tabList$ = {};
          each(tabs$Array.value, (formTab$) => {
            tabList$[formTab$.name] = formTab$;
          });
          return tabList$;
        });
        var visible$ = computed(() => {
          var tabList$ = {};
          each(tabs$.value, (tab$2) => {
            if (tab$2.visible) {
              tabList$[tab$2.name] = tab$2;
            }
          });
          return tabList$;
        });
        var current$ = computed(() => {
          var current = find_1(tabs$.value, {
            active: true
          });
          return current !== void 0 ? current : {};
        });
        var first$ = computed(() => {
          return find_1(visible$.value, (tab) => {
            return tab.visible;
          });
        });
        var last$ = computed(() => {
          return Object.values(visible$.value).pop();
        });
        var next$ = computed(() => {
          return find_1(visible$.value, (tab) => {
            return tab.index > current$.value.index && tab.visible;
          });
        });
        var previous$ = computed(() => {
          return findLast_1(visible$.value, (tab) => {
            return tab.index < current$.value.index && tab.visible;
          });
        });
        var goTo = (name2) => {
          var tab$2 = visible$.value[name2];
          tab$2.select();
        };
        var select2 = (tab$2) => {
          var curr$ = current$.value;
          each(elements$.value, (element$) => {
            element$.deactivate();
          });
          each(tabs$.value, (tab$3) => {
            tab$3.deactivate();
          });
          fire("select", tab$2, curr$);
        };
        var tab$ = (name2) => {
          return find_1(tabs$.value, {
            name: name2
          });
        };
        var reset = () => {
          first$.value.select();
        };
        var assignToParent = ($parent, assignToParent2) => {
          if ($parent.tabs$ !== void 0) {
            form$.value.$set($parent, "tabs$", $this);
          } else {
            assignToParent2($parent.$parent, assignToParent2);
          }
        };
        var removeFromParent = ($parent, removeFromParent2) => {
          if ($parent.tabs$ !== void 0) {
            form$.value.$set($parent, "tabs$", null);
          } else {
            removeFromParent2($parent.$parent, removeFromParent2);
          }
        };
        provide("View", View);
        watch(elements$, (newValue, oldValue) => {
          var newElements$ = difference_1(keys_1(newValue), keys_1(oldValue));
          each(newElements$, (newElement$) => {
            elements$.value[newElement$].deactivate();
          });
        }, {
          deep: false,
          lazy: true
        });
        watch(tabs, /* @__PURE__ */ _asyncToGenerator(function* () {
          yield nextTick();
          yield nextTick();
          if ((current$.value === void 0 || current$.value.index === void 0) && first$.value) {
            first$.value.select();
          }
        }), {
          deep: true,
          lazy: true
        });
        watch(tabs, (newValue) => {
          var newTabs$Array = [];
          each(newValue, (t2, name2) => {
            newTabs$Array.push(tabs$Array.value[tabs$Array.value.map((t$) => normalize$1(t$.name)).indexOf(normalize$1(name2))]);
          });
          tabs$Array.value = newTabs$Array;
        }, {
          flush: "post"
        });
        onBeforeMount(() => {
          assignToParent($this.$parent, assignToParent);
        });
        onBeforeUnmount(() => {
          removeFromParent($this.$parent, removeFromParent);
        });
        onMounted(() => {
          nextTick(() => {
            if (!find_1(tabs$.value, {
              active: true
            })) {
              first$.value.select();
            }
          });
        });
        return {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          tabs,
          elements$,
          tabs$Array,
          events,
          listeners,
          exists: exists2,
          classes: classes2,
          Templates,
          template,
          tabs$,
          visible$,
          current$,
          first$,
          last$,
          next$,
          previous$,
          goTo,
          select: select2,
          tab$,
          reset,
          on: on2,
          off: off2,
          fire
        };
      }
    };
    var base$14 = function base2(props, context, dependencies2) {
      var {
        parent: parent2,
        conditions
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var path = dependencies2.path || ref(null);
      var el$ = dependencies2.el$ || ref(void 0);
      var conditionList = ref(conditions.value);
      var additionalConditions = ref({});
      var available = computed(() => {
        if (!form$.value.conditions) {
          return true;
        }
        if (parent2 && parent2.value && parent2.value.available !== void 0 && !parent2.value.available) {
          return false;
        }
        if (!conditionList.value || !conditionList.value.length) {
          return true;
        }
        return !some_1(conditionList.value, (condition2) => {
          return !form$.value.$vueform.services.condition.check(condition2, path.value, form$.value, el$.value);
        });
      });
      var updateConditions = () => {
        conditionList.value = Object.values(additionalConditions.value).reduce((prev, curr) => {
          return prev.concat(curr);
        }, conditions.value);
      };
      var addConditions = (key, conditions2) => {
        additionalConditions.value[key] = conditions2;
        updateConditions();
      };
      var removeConditions = (key) => {
        delete additionalConditions.value[key];
        updateConditions();
      };
      return {
        conditionList,
        available,
        additionalConditions,
        updateConditions,
        addConditions,
        removeConditions
      };
    };
    var list$5 = function list2(props, context, dependencies2) {
      var {
        conditionList,
        available,
        additionalConditions,
        addConditions,
        removeConditions
      } = base$14(props, context, dependencies2);
      var {
        conditions
      } = toRefs(props);
      var children$Array = dependencies2.children$Array;
      var updateConditions = () => {
        conditionList.value = Object.values(additionalConditions.value).reduce((prev, curr) => {
          return prev.concat(curr);
        }, conditions.value);
        children$Array.value.forEach((child$) => {
          child$.updateConditions();
        });
      };
      return {
        conditionList,
        available,
        updateConditions,
        addConditions,
        removeConditions
      };
    };
    var object$8 = list$5;
    var group$8 = list$5;
    var {
      hasOwnProperty,
      toString
    } = Object.prototype;
    function isNonEmptyString(value) {
      return typeof value === "string" && value.trim().length > 0;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isNonEmptyArray(value) {
      return Array.isArray(value) && value.length > 0;
    }
    function isNonNullObject(value) {
      return !!value;
    }
    function isElement$1(value) {
      return isNonNullObject(value) && value.nodeType === 1 && toString.call(value).indexOf("Element") > -1;
    }
    function isVueComponent(value) {
      return isPlainObject_1(value) && (isNonEmptyString(value.template) || isFunction(value.render) || isNonEmptyString(value.el) || isElement$1(value.el) || isVueComponent(value.extends) || isNonEmptyArray(value.mixins) && value.mixins.some((val) => isVueComponent(val))) || typeof value === "function" && value.prototype && value.prototype.constructor.name === "VueComponent";
    }
    function localize(object2, $config, form$) {
      var locale2 = form$.locale$ || $config.i18n.locale;
      if (!locale2) {
        return object2;
      }
      return object2 && typeof object2 === "object" ? (object2 === null || object2 === void 0 ? void 0 : object2[locale2]) || (object2 === null || object2 === void 0 ? void 0 : object2[locale2.toUpperCase()]) || (object2 === null || object2 === void 0 ? void 0 : object2[$config.i18n.fallbackLocale]) || (object2 === null || object2 === void 0 ? void 0 : object2[$config.i18n.fallbackLocale.toUpperCase()]) || (object2 === null || object2 === void 0 ? void 0 : object2[Object.keys(object2)[0]]) || "" : object2;
    }
    var base$13 = function base2(props, context, dependencies2) {
      var labelDefinition = dependencies2.labelDefinition;
      var component$ = dependencies2.component$ || ref(null);
      var form$ = inject("form$");
      var config$ = inject("config$");
      var baseLabel = computed(() => {
        return labelDefinition.value;
      });
      var isLabelFunction = computed(() => {
        return typeof baseLabel.value === "function" && (!baseLabel.value.prototype || !baseLabel.value.prototype.constructor || baseLabel.value.prototype.constructor && baseLabel.value.prototype.constructor.name !== "VueComponent");
      });
      var isLabelComponent = computed(() => {
        return isVueComponent(baseLabel.value);
      });
      var label = computed(() => {
        var label2 = isLabelFunction.value ? baseLabel.value(component$.value) : baseLabel.value || null;
        if (!isLabelComponent.value) {
          label2 = localize(label2, config$.value, form$.value);
        }
        return label2;
      });
      return {
        label,
        isLabelComponent
      };
    };
    var FormTab = {
      name: "FormTab",
      emits: ["activate", "inactivate"],
      slots: ["default"],
      props: {
        /**
         * Name of tab within [tabs](reference/frontend-form#prop-tabs) object.
         */
        name: {
          type: [String, Number],
          required: true
        },
        label: {
          type: [String, Object, Function],
          required: false,
          default: null
        },
        elements: {
          type: [Array],
          required: false,
          default: () => []
        },
        conditions: {
          type: [Array],
          required: false,
          default: () => []
        },
        addClass: {
          required: false,
          type: [Array, Object, String],
          default: null
        },
        removeClass: {
          required: false,
          type: [Array, Object],
          default: null
        },
        replaceClass: {
          required: false,
          type: [Object],
          default: null
        },
        overrideClass: {
          required: false,
          type: [Array, Object, String],
          default: null
        },
        view: {
          required: false,
          type: [String],
          default: void 0
        },
        onActivate: {
          type: [Function],
          required: false,
          default: null,
          private: true
        },
        onInactivate: {
          type: [Function],
          required: false,
          default: null,
          private: true
        }
      },
      setup(props, context) {
        var {
          name: name2,
          label,
          elements
        } = toRefs(props);
        var $this = getCurrentInstance().proxy;
        var {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template
        } = base$15(props, context);
        var {
          available,
          conditionList,
          updateConditions
        } = base$14(props, context, {
          form$
        });
        var {
          isLabelComponent,
          label: tabLabel_
        } = base$13(props, context, {
          component$: form$,
          labelDefinition: label
        });
        var {
          events,
          listeners,
          on: on2,
          off: off2,
          fire
        } = base$1c(props, context, {
          form$
        }, {
          events: context.emits
        });
        var active = ref(false);
        var tabLabel = ref(tabLabel_.value && typeof tabLabel_.value === "object" ? markRaw(tabLabel_.value) : tabLabel_.value);
        var elements$ = computed(() => {
          return form$.value.elements$;
        });
        var tabs$ = computed(() => {
          return form$.value.tabs$;
        });
        var index2 = computed(() => {
          var _tabs$$value;
          return Object.keys((tabs$ === null || tabs$ === void 0 || (_tabs$$value = tabs$.value) === null || _tabs$$value === void 0 ? void 0 : _tabs$$value.tabs$) || /* istanbul ignore next: tab can not stand by itself */
          {}).indexOf(name2.value);
        });
        var isFirst = computed(() => {
          return index2.value === 0;
        });
        var isLast = computed(() => {
          return tabs$.value.last$.name === name2.value;
        });
        var children$ = computed(() => {
          return filter_1(elements$.value, (element$, key) => {
            return elements.value.indexOf(key) !== -1;
          });
        });
        var visible = computed(() => {
          return available.value;
        });
        var invalid = computed(() => {
          return some_1(children$.value, {
            available: true,
            invalid: true
          });
        });
        var tab$ = computed(() => {
          return form$.value.tabs$.tabs$[name2.value];
        });
        var select2 = () => {
          var _tabs$$value2, _tabs$$value3;
          if (active.value || !((_tabs$$value2 = tabs$.value) !== null && _tabs$$value2 !== void 0 && _tabs$$value2.select)) {
            return;
          }
          (_tabs$$value3 = tabs$.value) === null || _tabs$$value3 === void 0 || _tabs$$value3.select(tab$.value);
          activate();
        };
        var activate = () => {
          if (active.value) {
            return;
          }
          active.value = true;
          each(children$.value, (element$) => {
            element$.activate();
          });
          fire("activate");
        };
        var deactivate = () => {
          if (!active.value) {
            return;
          }
          active.value = false;
          each(children$.value, (element$) => {
            element$.deactivate();
          });
          fire("inactivate");
        };
        var addChildConditions = () => {
          if (conditionList.value.length == 0) {
            return;
          }
          Object.values(children$.value).forEach((element$) => {
            element$.addConditions("tab", conditionList.value);
          });
        };
        var removeChildConditions = () => {
          Object.values(children$.value).forEach((element$) => {
            element$.removeConditions("tab");
          });
        };
        var resetChildConditions = () => {
          removeChildConditions();
          addChildConditions();
        };
        var assignToParent = ($parent, assignToParent2) => {
          if ($parent.tabs$Array) {
            $parent.tabs$Array.push($this);
          } else {
            assignToParent2($parent.$parent, assignToParent2);
          }
        };
        var removeFromParent = ($parent, removeFromParent2) => {
          if ($parent.tabs$Array) {
            $parent.tabs$Array.splice($parent.tabs$Array.map((t$) => normalize$1(t$.name)).indexOf(normalize$1(name2.value)), 1);
          } else {
            removeFromParent2($parent.$parent, removeFromParent2);
          }
        };
        watch(children$, () => {
          if (!active.value) {
            return;
          }
          each(children$.value, (element$) => {
            element$.activate();
          });
        }, {
          deep: false,
          lazy: true
        });
        watch(tabLabel_, () => {
          tabLabel.value = tabLabel_.value && typeof tabLabel_.value === "object" ? markRaw(tabLabel_.value) : tabLabel_.value;
        });
        watch(conditionList, (n2, o2) => {
          if (!(n2 !== null && n2 !== void 0 && n2.length)) {
            removeChildConditions();
          } else {
            addChildConditions();
          }
        });
        onMounted(() => {
          nextTick(() => {
            addChildConditions();
          });
        });
        onBeforeMount(() => {
          assignToParent($this.$parent, assignToParent);
        });
        onBeforeUnmount(() => {
          removeChildConditions();
          removeFromParent($this.$parent, removeFromParent);
        });
        return {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          elements$,
          index: index2,
          isFirst,
          isLast,
          active,
          events,
          listeners,
          children$,
          visible,
          invalid,
          classes: classes2,
          Templates,
          template,
          available,
          isLabelComponent,
          tabLabel,
          tab$,
          tabs$,
          conditionList,
          select: select2,
          activate,
          deactivate,
          on: on2,
          off: off2,
          fire,
          addChildConditions,
          removeChildConditions,
          resetChildConditions,
          updateConditions
        };
      }
    };
    var FormSteps = {
      name: "FormSteps",
      emits: ["select", "next", "previous", "finish"],
      props: {
        view: {
          required: false,
          type: [String],
          default: void 0
        }
      },
      setup(props, context) {
        var $this = getCurrentInstance().proxy;
        var {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template
        } = base$15(props, context);
        var {
          events,
          listeners,
          on: on2,
          off: off2,
          fire
        } = base$1c(props, context, {
          form$
        }, {
          events: context.emits
        });
        var steps$Array = ref([]);
        var unwatchInvalid = ref(null);
        var exists2 = ref(true);
        var steps = computed(() => {
          return form$.value.options.steps;
        });
        var elements$ = computed(() => {
          return form$.value.elements$;
        });
        var pending = computed(() => {
          return some_1(visible$.value, {
            pending: true
          });
        });
        var debouncing = computed(() => {
          return some_1(visible$.value, {
            debouncing: true
          });
        });
        var invalid = computed(() => {
          return some_1(visible$.value, {
            invalid: true
          });
        });
        var done = computed(() => {
          return !some_1(visible$.value, {
            done: false
          });
        });
        var busy = computed(() => {
          return pending.value || debouncing.value;
        });
        var steps$ = computed(() => {
          var steps$2 = {};
          each(steps$Array.value, (step$2) => {
            steps$2[step$2.name] = step$2;
          });
          return steps$2;
        });
        var visible$ = computed(() => {
          var stepList$ = {};
          each(steps$.value, (step$2) => {
            if (step$2.visible) {
              stepList$[step$2.name] = step$2;
            }
          });
          return stepList$;
        });
        var first$ = computed(() => {
          return find_1(visible$.value, (step) => {
            return step.visible;
          });
        });
        var last$ = computed(() => {
          return Object.values(visible$.value).pop();
        });
        var current$ = computed(() => {
          var current = find_1(steps$.value, {
            active: true
          });
          return current !== void 0 ? current : {};
        });
        var next$ = computed(() => {
          return find_1(visible$.value, (step) => {
            return step.index > current$.value.index && step.visible;
          });
        });
        var previous$ = computed(() => {
          return findLast_1(visible$.value, (step) => {
            return step.index < current$.value.index && step.visible;
          });
        });
        var firstInvalid$ = computed(() => {
          return find_1(visible$.value, {
            invalid: true
          });
        });
        var firstNonDone$ = computed(() => {
          return find_1(visible$.value, {
            done: false
          });
        });
        var lastEnabled$ = computed(() => {
          return findLast_1(visible$.value, {
            isDisabled: false
          });
        });
        var isAtLastStep = computed(() => {
          var last2 = findLast_1(visible$.value, {
            visible: true
          });
          if (!current$.value || !last2) {
            return false;
          }
          return last2.index === current$.value.index;
        });
        var isAtFirstStep = computed(() => {
          return current$.value.index === 0;
        });
        var goTo = function goTo2(name2) {
          var enableUntil2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var step = visible$.value[name2];
          step.enable();
          step.select();
          if (enableUntil2) {
            nextTick(() => {
              enableUntilLastEnabled();
            });
          }
        };
        var next = () => {
          fire("next", next$.value);
          next$.value.enable();
          next$.value.select();
        };
        var previous = () => {
          fire("previous", previous$.value);
          previous$.value.select();
        };
        var complete = () => {
          each(steps$.value, (step$2) => {
            step$2.complete();
          });
        };
        var step$ = (name2) => {
          return find_1(visible$.value, {
            name: name2
          });
        };
        var reset = () => {
          each(steps$.value, (step$2) => {
            step$2.uncomplete();
            step$2.disable();
          });
          first$.value.enable();
          first$.value.select();
        };
        var enableAllSteps = () => {
          each(steps$.value, (step$2) => {
            step$2.enable();
          });
        };
        var submit = /* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(function* () {
            yield form$.value.submit();
            if (invalid.value) {
              firstInvalid$.value.select();
              return;
            }
            unwatchInvalid.value = watch(invalid, (isInvalid) => {
              if (isInvalid) {
                firstInvalid$.value.select();
              }
              unwatchInvalid.value();
            });
          });
          return function submit2() {
            return _ref.apply(this, arguments);
          };
        }();
        var select2 = (step$2) => {
          var curr$ = current$.value;
          each(elements$.value, (element$) => {
            element$.deactivate();
          });
          each(steps$.value, (step$3) => {
            step$3.deactivate();
          });
          fire("select", step$2, curr$);
        };
        var enableUntil = (index2) => {
          each(steps$.value, (step$2) => {
            if (step$2.index <= index2 && step$2.visible) {
              step$2.enable();
            }
          });
        };
        var enableUntilCurrent = () => {
          enableUntil(current$.value.index);
        };
        var enableUntilLastEnabled = () => {
          if (!lastEnabled$.value && !first$.value) {
            return;
          }
          enableUntil(lastEnabled$.value !== void 0 ? lastEnabled$.value.index : first$.value.index);
        };
        var assignToParent = ($parent, assignToParent2) => {
          if ($parent.steps$ !== void 0) {
            form$.value.$set($parent, "steps$", $this);
          } else {
            assignToParent2($parent.$parent, assignToParent2);
          }
        };
        var removeFromParent = ($parent, removeFromParent2) => {
          if ($parent.steps$ !== void 0) {
            form$.value.$set($parent, "steps$", null);
          } else {
            removeFromParent2($parent.$parent, removeFromParent2);
          }
        };
        provide("View", View);
        watch(elements$, (newValue, oldValue) => {
          var newElements$ = difference_1(keys_1(newValue), keys_1(oldValue));
          each(newElements$, (newElement$) => {
            elements$.value[newElement$].deactivate();
          });
        }, {
          deep: false,
          lazy: true
        });
        watch(steps, () => {
          nextTick(() => {
            if (lastEnabled$.value === void 0)
              ;
            if (current$.value.index === void 0 && first$.value) {
              first$.value.select();
            }
          });
        }, {
          deep: true,
          lazy: true
        });
        watch(steps, (newValue) => {
          var newSteps$Array = [];
          each(newValue, (t2, name2) => {
            newSteps$Array.push(steps$Array.value[steps$Array.value.map((t$) => normalize$1(t$.name)).indexOf(normalize$1(name2))]);
          });
          steps$Array.value = newSteps$Array;
        }, {
          flush: "post"
        });
        onBeforeMount(() => {
          assignToParent($this.$parent, assignToParent);
        });
        onBeforeUnmount(() => {
          removeFromParent($this.$parent, removeFromParent);
        });
        onMounted(() => {
          nextTick(() => {
            if (current$.value === void 0 || current$.value.index === void 0) {
              first$.value.enable();
              first$.value.select();
            }
            enableUntilCurrent();
            watch(visible$, () => {
              enableUntilLastEnabled();
            }, {
              flush: "post"
            });
          });
        });
        return {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          steps,
          elements$,
          steps$Array,
          events,
          listeners,
          exists: exists2,
          classes: classes2,
          Templates,
          template,
          steps$,
          pending,
          debouncing,
          invalid,
          done,
          busy,
          visible$,
          first$,
          last$,
          current$,
          next$,
          previous$,
          firstInvalid$,
          firstNonDone$,
          lastEnabled$,
          isAtLastStep,
          isAtFirstStep,
          goTo,
          next,
          previous,
          complete,
          step$,
          reset,
          enableAllSteps,
          submit,
          select: select2,
          enableUntil,
          enableUntilCurrent,
          enableUntilLastEnabled,
          on: on2,
          off: off2,
          fire
        };
      }
    };
    var FormStepsControls = {
      name: "FormStepsControls",
      slots: ["previous", "next", "finish"],
      props: {
        labels: {
          type: Boolean,
          required: false,
          default: true
        },
        view: {
          required: false,
          type: [String],
          default: void 0
        }
      },
      setup(props, context) {
        var {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template
        } = base$15(props, context);
        provide("View", View);
        return {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template
        };
      }
    };
    var FormStepsControl = {
      name: "FormStepsControl",
      slots: ["default"],
      props: {
        type: {
          type: [String],
          required: true
        },
        labels: {
          type: [Boolean],
          required: false,
          default: true,
          private: true
        },
        view: {
          required: false,
          type: [String],
          default: void 0
        }
      },
      setup(props, context) {
        var {
          type,
          labels
        } = toRefs(props);
        var {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template
        } = base$15(props, context);
        var baseLabel = computed(() => {
          if (!labels.value) {
            return null;
          }
          var stepLabels = current$ && current$.value ? current$.value.labels : (
            /* istanbul ignore next: failsafe only */
            null
          );
          switch (type.value) {
            case "previous":
              return stepLabels && stepLabels.previous ? stepLabels.previous : form$.value.translations.vueform.steps.previous;
            case "next":
              return stepLabels && stepLabels.next ? stepLabels.next : form$.value.translations.vueform.steps.next;
            case "finish":
              return stepLabels && stepLabels.finish ? stepLabels.finish : stepLabels && stepLabels.next ? stepLabels.next : form$.value.translations.vueform.steps.finish;
          }
        });
        var {
          isLabelComponent,
          label
        } = base$13(props, context, {
          component$: form$,
          labelDefinition: baseLabel
        });
        var steps$ = computed(() => {
          return form$.value.steps$;
        });
        var current$ = computed(() => {
          return steps$.value ? steps$.value.current$ : (
            /* istanbul ignore next: failsafe only */
            void 0
          );
        });
        var visible = computed(() => {
          var buttons = current$ && current$.value ? current$.value.buttons : (
            /* istanbul ignore next: failsafe only */
            null
          );
          switch (type.value) {
            case "previous":
              return !buttons ? true : buttons.previous !== false;
            case "next":
              return steps$.value && !steps$.value.isAtLastStep && (!buttons || buttons.next !== false);
            case "finish":
              return steps$.value && steps$.value.isAtLastStep && (!buttons || buttons.finish !== false);
          }
        });
        var isDisabled = computed(() => {
          switch (type.value) {
            case "previous":
              return steps$.value && steps$.value.isAtFirstStep;
            case "next":
              return current$.value !== void 0 && current$.value.index !== void 0 && // only disable next because of invalidity
              // if element validations are triggered on
              // change, otherwise it might occur that the
              // step has invalid fields, which values have
              // changed to valid, but still marked as invalid
              (current$.value.invalid && form$.value.shouldValidateOnChange || current$.value.busy || form$.value.isLoading);
            case "finish":
              return steps$.value.invalid && form$.value.shouldValidateOnChange || steps$.value.busy || form$.value.submitting || form$.value.isDisabled || form$.value.isLoading;
          }
        });
        var isLoading = computed(() => {
          return type.value === "previous" ? false : form$.value.isLoading || form$.value.submitting;
        });
        var previous = () => {
          steps$.value.previous();
        };
        var next = /* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(function* () {
            if (form$.value.shouldValidateOnStep) {
              yield current$.value.validate();
            }
            if (current$.value.invalid) {
              return;
            }
            current$.value.complete();
            steps$.value.next();
          });
          return function next2() {
            return _ref.apply(this, arguments);
          };
        }();
        var finish = /* @__PURE__ */ function() {
          var _ref2 = _asyncToGenerator(function* () {
            steps$.value.fire("finish");
            steps$.value.complete();
            steps$.value.submit();
          });
          return function finish2() {
            return _ref2.apply(this, arguments);
          };
        }();
        var handleClick = (e2) => {
          switch (type.value) {
            case "previous":
              previous();
              break;
            case "next":
              next();
              if (e2.key === "Enter" || e2.key === " ") {
                nextTick(() => {
                  nextTick(() => {
                    var _current$$value$child;
                    var firstEl$ = current$ === null || current$ === void 0 || (_current$$value$child = current$.value.children$) === null || _current$$value$child === void 0 ? void 0 : _current$$value$child.find((el$) => {
                      var _current$$value$eleme;
                      return el$.name === (current$ === null || current$ === void 0 || (_current$$value$eleme = current$.value.elements) === null || _current$$value$eleme === void 0 ? void 0 : _current$$value$eleme[0]);
                    });
                    if (!firstEl$) {
                      return;
                    }
                    firstEl$.focus();
                  });
                });
              }
              break;
            case "finish":
              finish();
              break;
          }
        };
        return {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          steps$,
          classes: classes2,
          Templates,
          template,
          visible,
          isDisabled,
          isLoading,
          current$,
          label,
          isLabelComponent,
          previous,
          next,
          finish,
          handleClick
        };
      }
    };
    var FormStep = {
      name: "FormStep",
      emits: ["activate", "inactivate", "enable", "disable", "complete"],
      slots: ["default"],
      props: {
        name: {
          type: [String, Number],
          required: true
        },
        label: {
          type: [String, Object, Function],
          required: false,
          default: null
        },
        labels: {
          type: [Object],
          required: false,
          default: () => ({})
        },
        buttons: {
          type: [Object],
          required: false,
          default: () => ({})
        },
        elements: {
          type: [Array],
          required: false,
          default: () => []
        },
        conditions: {
          type: [Array],
          required: false,
          default: () => []
        },
        addClass: {
          required: false,
          type: [Array, Object, String],
          default: null
        },
        removeClass: {
          required: false,
          type: [Array, Object],
          default: null
        },
        replaceClass: {
          required: false,
          type: [Object],
          default: null
        },
        overrideClass: {
          required: false,
          type: [Array, Object, String],
          default: null
        },
        view: {
          required: false,
          type: [String],
          default: void 0
        },
        onActivate: {
          type: [Function],
          required: false,
          default: null,
          private: true
        },
        onInactivate: {
          type: [Function],
          required: false,
          default: null,
          private: true
        },
        onDisable: {
          type: [Function],
          required: false,
          default: null,
          private: true
        },
        onEnable: {
          type: [Function],
          required: false,
          default: null,
          private: true
        }
      },
      setup(props, context) {
        var {
          name: name2,
          label,
          elements
        } = toRefs(props);
        var $this = getCurrentInstance().proxy;
        var {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template
        } = base$15(props, context);
        var {
          available,
          conditionList,
          updateConditions
        } = base$14(props, context, {
          form$
        });
        var {
          isLabelComponent,
          label: stepLabel_
        } = base$13(props, context, {
          component$: form$,
          labelDefinition: label
        });
        var {
          events,
          listeners,
          on: on2,
          off: off2,
          fire
        } = base$1c(props, context, {
          form$
        }, {
          events: context.emits
        });
        var stepLabel = ref(stepLabel_.value && typeof stepLabel_.value === "object" ? markRaw(stepLabel_.value) : stepLabel_.value);
        var active = ref(false);
        var isDisabled = ref(true);
        var completed2 = ref(false);
        var elements$ = computed(() => {
          return form$.value.elements$;
        });
        var steps$ = computed(() => {
          return form$.value.steps$ || /* istanbul ignore next: failsafe only, step can not exist by itself */
          {};
        });
        var baseLabel = computed(() => {
          return label.value;
        });
        var index2 = computed(() => {
          var _steps$$value;
          return Object.keys((steps$ === null || steps$ === void 0 || (_steps$$value = steps$.value) === null || _steps$$value === void 0 ? void 0 : _steps$$value.steps$) || /* istanbul ignore next: failsafe only, step can not exist by itself */
          {}).indexOf(name2.value);
        });
        var isFirst = computed(() => {
          return index2.value === 0;
        });
        var isLast = computed(() => {
          return steps$.value.last$.name === name2.value;
        });
        var children$ = computed(() => {
          return filter_1(elements$.value, (element$, key) => {
            return elements.value.indexOf(key) !== -1;
          });
        });
        var visible = computed(() => {
          return available.value;
        });
        var invalid = computed(() => {
          return some_1(children$.value, {
            available: true,
            invalid: true
          });
        });
        var pending = computed(() => {
          return some_1(children$.value, {
            available: true,
            pending: true
          });
        });
        var debouncing = computed(() => {
          return some_1(children$.value, {
            available: true,
            debouncing: true
          });
        });
        var validated = computed(() => {
          return !some_1(children$.value, {
            available: true,
            validated: false
          });
        });
        var busy = computed(() => {
          return pending.value || debouncing.value;
        });
        var done = computed(() => {
          return completed2.value && validated.value && !invalid.value && !pending.value;
        });
        var step$ = computed(() => {
          var _form$$value$steps$;
          return (_form$$value$steps$ = form$.value.steps$) === null || _form$$value$steps$ === void 0 ? void 0 : _form$$value$steps$.steps$[name2.value];
        });
        var validate = /* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(function* () {
            if (validated.value && !invalid.value && form$.value.shouldValidateOnChange) {
              return;
            }
            yield asyncForEach(children$.value, /* @__PURE__ */ function() {
              var _ref2 = _asyncToGenerator(function* (element$) {
                if ((!element$.validated || element$.invalid || !form$.value.shouldValidateOnChange) && element$.available && !element$.isStatic) {
                  yield element$.validate();
                }
              });
              return function(_x) {
                return _ref2.apply(this, arguments);
              };
            }());
          });
          return function validate2() {
            return _ref.apply(this, arguments);
          };
        }();
        var activate = () => {
          if (active.value) {
            return;
          }
          active.value = true;
          fire("activate");
        };
        var deactivate = () => {
          if (!active.value) {
            return;
          }
          active.value = false;
          fire("inactivate");
        };
        var enable = () => {
          if (!isDisabled.value) {
            return;
          }
          isDisabled.value = false;
          fire("enable");
        };
        var disable = () => {
          if (isDisabled.value) {
            return;
          }
          isDisabled.value = true;
          fire("disable");
        };
        var complete = () => {
          if (completed2.value) {
            return;
          }
          completed2.value = true;
          fire("complete");
        };
        var uncomplete = () => {
          completed2.value = false;
        };
        var select2 = () => {
          var _steps$$value2, _steps$$value3;
          if (isDisabled.value || !((_steps$$value2 = steps$.value) !== null && _steps$$value2 !== void 0 && _steps$$value2.select)) {
            return;
          }
          (_steps$$value3 = steps$.value) === null || _steps$$value3 === void 0 || _steps$$value3.select(step$.value);
          each(children$.value, (element$) => {
            element$.activate();
          });
          activate();
        };
        var addChildConditions = () => {
          if (conditionList.value.length == 0) {
            return;
          }
          Object.values(children$.value).forEach((element$) => {
            element$.addConditions("step", conditionList.value);
          });
        };
        var removeChildConditions = () => {
          Object.values(children$.value).forEach((element$) => {
            element$.removeConditions("step");
          });
        };
        var resetChildConditions = () => {
          removeChildConditions();
          addChildConditions();
        };
        var assignToParent = ($parent, assignToParent2) => {
          if ($parent.steps$Array) {
            $parent.steps$Array.push($this);
          } else {
            assignToParent2($parent.$parent, assignToParent2);
          }
        };
        var removeFromParent = ($parent, removeFromParent2) => {
          if ($parent.steps$Array) {
            $parent.steps$Array.splice($parent.steps$Array.map((t$) => normalize$1(t$.name)).indexOf(normalize$1(name2.value)), 1);
          } else {
            removeFromParent2($parent.$parent, removeFromParent2);
          }
        };
        watch(visible, (val) => {
          if (val && index2.value < form$.value.steps$.current$.index) {
            enable();
          }
        });
        watch(children$, () => {
          if (!active.value) {
            return;
          }
          each(children$.value, (element$) => {
            element$.activate();
          });
        }, {
          deep: false,
          lazy: true
        });
        watch(stepLabel_, () => {
          stepLabel.value = stepLabel_.value && typeof stepLabel_.value === "object" ? markRaw(stepLabel_.value) : stepLabel_.value;
        });
        watch(conditionList, (n2, o2) => {
          if (!(n2 !== null && n2 !== void 0 && n2.length)) {
            removeChildConditions();
          } else {
            addChildConditions();
          }
        });
        onMounted(() => {
          nextTick(() => {
            addChildConditions();
          });
        });
        onBeforeMount(() => {
          assignToParent($this.$parent, assignToParent);
        });
        onBeforeUnmount(() => {
          removeChildConditions();
          removeFromParent($this.$parent, removeFromParent);
        });
        return {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          steps$,
          elements$,
          active,
          isDisabled,
          isFirst,
          isLast,
          completed: completed2,
          events,
          listeners,
          children$,
          visible,
          invalid,
          pending,
          classes: classes2,
          Templates,
          template,
          available,
          baseLabel,
          debouncing,
          validated,
          busy,
          done,
          step$,
          isLabelComponent,
          stepLabel,
          index: index2,
          conditionList,
          validate,
          activate,
          deactivate,
          enable,
          disable,
          complete,
          uncomplete,
          select: select2,
          on: on2,
          off: off2,
          fire,
          addChildConditions,
          removeChildConditions,
          resetChildConditions,
          updateConditions
        };
      }
    };
    var base$12 = function base2(props, context, dependencies2) {
      var component = (element) => {
        return "".concat(upperFirst_1(camelCase_1(element.type)), "Element");
      };
      return {
        component
      };
    };
    var FormElements = {
      name: "FormElements",
      slots: ["default"],
      props: {
        view: {
          required: false,
          type: [String],
          default: void 0
        }
      },
      setup(props, context) {
        var {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template
        } = base$15(props, context);
        var {
          component
        } = base$12();
        var schema = computed(() => {
          return form$.value.options.schema;
        });
        return {
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template,
          schema,
          component
        };
      }
    };
    var base$11 = function base2(props, context, dependencies2) {
      var el$ = inject("el$");
      return {
        el$
      };
    };
    var base$10 = function base2(props, context, dependencies2) {
      var componentName = context.name;
      var {
        form$
      } = base$19();
      var {
        el$
      } = base$11();
      var {
        theme
      } = base$18();
      var {
        Size
      } = base$17();
      var {
        View
      } = base$16(props, context);
      var component$ = computed(() => {
        return getCurrentInstance().proxy;
      });
      var classesInstance = computed(() => {
        return new MergeClasses({
          component: componentName.value,
          component$,
          theme: theme.value,
          config: form$.value.$vueform.config,
          templates: Templates.value,
          view: View.value,
          merge: [form$.value.options, el$.value]
        });
      });
      var classes2 = computed(() => {
        return classesInstance.value.classes;
      });
      var Templates = computed(() => {
        return el$.value.Templates;
      });
      var template = computed(() => {
        return View.value && Templates.value["".concat(componentName.value, "_").concat(View.value)] ? Templates.value["".concat(componentName.value, "_").concat(View.value)] : Templates.value[componentName.value];
      });
      return {
        el$,
        form$,
        theme,
        Size,
        View,
        classesInstance,
        classes: classes2,
        Templates,
        template
      };
    };
    var ElementLayout = {
      name: "ElementLayout",
      slots: ["field", "label", "info", "description", "before", "between", "after"],
      props: {
        multiple: {
          type: [Boolean],
          required: false,
          default: false
        },
        view: {
          type: [String],
          required: false,
          default: void 0
        }
      },
      setup(props, context) {
        var {
          form$,
          el$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var visible = computed(() => {
          return el$.value.visible;
        });
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          theme,
          Templates,
          template,
          classes: classes2,
          visible
        };
      }
    };
    var ElementLayoutInline = {
      name: "ElementLayoutInline",
      slots: ["field", "label", "info", "description", "before", "between", "after"],
      setup(props, context) {
        var {
          form$,
          el$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var visible = computed(() => {
          return el$.value.visible;
        });
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          theme,
          Templates,
          template,
          classes: classes2,
          visible
          // hasLabel,
        };
      }
    };
    var ElementLoader = {
      name: "ElementLoader",
      setup(props, context) {
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template
        };
      }
    };
    var ElementLabelFloating = {
      name: "ElementLabelFloating",
      props: {
        visible: {
          type: Boolean,
          default: false
        }
      },
      setup(props, context) {
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var config$ = inject("config$");
        var floating = computed(() => {
          return localize(el$.value.floating || /* istanbul ignore next: tested, but not covered */
          (form$.value.options.floatPlaceholders ? el$.value.placeholder : null), config$.value, form$.value);
        });
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template,
          floating
        };
      }
    };
    var ElementLabel = {
      name: "ElementLabel",
      slots: ["default", "info"],
      setup(props, context) {
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var {
          label,
          isLabelComponent
        } = base$13(props, context, {
          labelDefinition: computed(() => {
            return el$.value.label;
          }),
          component$: el$
        });
        var name2 = computed(() => {
          return el$.value.fieldId;
        });
        var id = computed(() => {
          return el$.value.labelId;
        });
        var hasLabel = computed(() => {
          return el$.value.hasLabel;
        });
        var isSlot = computed(() => {
          var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
          return !!((_el$$value$slots = el$.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots.label || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots.label || /* istanbul ignore next: Vue2 is not checked */
          form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo.label);
        });
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template,
          label,
          isLabelComponent,
          name: name2,
          id,
          hasLabel,
          isSlot
        };
      }
    };
    function isInViewport(element) {
      var rect = element.getBoundingClientRect();
      return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
    }
    var ElementInfo = {
      name: "ElementInfo",
      slots: ["default"],
      setup(props, context) {
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var config$ = inject("config$");
        var position = ref(el$.value.infoPosition);
        var info = computed(() => {
          return localize(el$.value.info, config$.value, form$.value);
        });
        var id = computed(() => {
          return el$.value.infoId;
        });
        var isSlot = computed(() => {
          var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
          return !!((_el$$value$slots = el$.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots.info || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots.info || /* istanbul ignore next: Vue2 is not checked */
          form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo.info);
        });
        var handleMouseOver = /* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(function* (e2) {
            if (position.value !== el$.value.infoPosition) {
              return;
            }
            yield nextTick();
            var wrapper = e2.target.querySelector("div");
            if (!wrapper) {
              return;
            }
            if (!isInViewport(wrapper)) {
              position.value = "right";
            }
            yield nextTick();
            if (!isInViewport(wrapper)) {
              position.value = "top";
            }
            yield nextTick();
            if (!isInViewport(wrapper)) {
              position.value = "left";
            }
            yield nextTick();
            if (!isInViewport(wrapper)) {
              position.value = "bottom";
            }
          });
          return function handleMouseOver2(_x) {
            return _ref.apply(this, arguments);
          };
        }();
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template,
          info,
          isSlot,
          position,
          id,
          handleMouseOver
        };
      }
    };
    var ElementDescription = {
      name: "ElementDescription",
      slots: ["default"],
      setup(props, context) {
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var config$ = inject("config$");
        var description2 = computed(() => {
          return localize(el$.value.description, config$.value, form$.value);
        });
        var id = computed(() => {
          return el$.value.descriptionId;
        });
        var isSlot = computed(() => {
          var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
          return !!((_el$$value$slots = el$.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots.description || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots.description || /* istanbul ignore next: Vue2 is not checked */
          form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo.description);
        });
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template,
          description: description2,
          isSlot,
          id
        };
      }
    };
    var ElementError = {
      name: "ElementError",
      setup(props, context) {
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var error = computed(() => {
          return el$.value.error;
        });
        var id = computed(() => {
          return el$.value.errorId;
        });
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template,
          error,
          id
        };
      }
    };
    var ElementMessage = {
      name: "ElementMessage",
      setup(props, context) {
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var message = computed(() => {
          return el$.value.messageBag ? el$.value.messageBag.message : (
            /* istanbul ignore next: messageBag itself will always be defined */
            null
          );
        });
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template,
          message
        };
      }
    };
    var ElementText = {
      name: "ElementText",
      slots: ["default"],
      props: {
        type: {
          type: String,
          required: true
        }
      },
      setup(props, context) {
        var {
          type
        } = toRefs(props);
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var config$ = inject("config$");
        var content = computed(() => {
          return localize(el$.value[type.value], config$.value, form$.value);
        });
        var isSlot = computed(() => {
          var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
          return !!((_el$$value$slots = el$.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots[type.value] || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots[type.value] || /* istanbul ignore next: Vue2 is not checked */
          form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo[type.value]);
        });
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template,
          content,
          isSlot
        };
      }
    };
    var DragAndDrop = {
      name: "DragAndDrop",
      emits: ["click", "drop"],
      props: {
        title: {
          type: String,
          required: true
        },
        description: {
          type: String,
          required: true
        },
        disabled: {
          type: Boolean,
          required: false,
          default: false
        }
      },
      setup(props, context) {
        var {
          disabled
        } = toRefs(props);
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var dragging = ref(false);
        var area = ref(null);
        var handleClick = () => {
          context.emit("click");
        };
        onMounted(() => {
          each(["drag", "dragstart", "dragend", "dragover", "dragenter", "dragleave", "drop"], (event) => {
            area.value.addEventListener(event, (e2) => {
              e2.preventDefault();
              e2.stopPropagation();
            });
          });
          area.value.addEventListener("drop", (e2) => {
            if (disabled.value) {
              return;
            }
            context.emit("drop", e2);
            dragging.value = false;
          });
          area.value.addEventListener("dragover", (e2) => {
            if (disabled.value) {
              return;
            }
            if (dragging.value !== true) {
              dragging.value = true;
            }
          });
          area.value.addEventListener("dragleave", (e2) => {
            if (disabled.value) {
              return;
            }
            dragging.value = false;
          });
          area.value.addEventListener("dragend", (e2) => {
            if (disabled.value) {
              return;
            }
            dragging.value = false;
          });
        });
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme,
          dragging,
          area,
          handleClick
        };
      }
    };
    var ElementAddon = {
      name: "ElementAddon",
      slots: ["default"],
      props: {
        type: {
          required: true,
          type: String
        }
      },
      setup(props, context) {
        var {
          type
        } = toRefs(props);
        var {
          form$,
          el$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var config$ = inject("config$");
        var baseAddon = computed(() => {
          return el$.value.addons[type.value];
        });
        var addon = computed(() => {
          var addon2 = isAddonFunction.value ? baseAddon.value(el$.value) : baseAddon.value || /* istanbul ignore next: failsafe */
          null;
          if (!isAddonComponent.value) {
            addon2 = localize(addon2, config$.value, form$.value);
          }
          return addon2;
        });
        var isAddonFunction = computed(() => {
          return typeof baseAddon.value === "function" && (!baseAddon.value.prototype || !baseAddon.value.prototype.constructor || baseAddon.value.prototype.constructor && baseAddon.value.prototype.constructor.name !== "VueComponent");
        });
        var isAddonComponent = computed(() => {
          return isVueComponent(baseAddon.value);
        });
        var isSlot = computed(() => {
          var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
          return !!((_el$$value$slots = el$.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots["addon-".concat(type.value)] || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots["addon-".concat(type.value)] || /* istanbul ignore next: Vue2 is not checked */
          form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo["addon-".concat(type.value)] || /* istanbul ignore next */
          el$.value.slots["addon-".concat(type.value)]);
        });
        return {
          el$,
          form$,
          theme,
          Size,
          View,
          classesInstance,
          Templates,
          template,
          classes: classes2,
          addon,
          isAddonComponent,
          isSlot
        };
      }
    };
    var ElementAddonOptions = {
      name: "ElementAddonOptions",
      emits: ["select", "open", "close"],
      props: {
        options: {
          type: [Array],
          required: false,
          default: () => []
        },
        placeholder: {
          type: [String, Number, Object],
          required: false,
          default: ""
        },
        relaxed: {
          type: [Boolean],
          required: false,
          default: false
        },
        position: {
          type: [String],
          required: false,
          default: "over"
        },
        aria: {
          type: [Object],
          required: false,
          default: () => ({})
        }
      },
      setup(props, context) {
        var {
          options,
          position
        } = toRefs(props);
        var {
          form$,
          el$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var {
          events,
          listeners,
          on: on2,
          off: off2,
          fire
        } = base$1c(props, context, {
          form$
        }, {
          events: context.emits
        });
        var isOpen = ref(false);
        var selector = ref(null);
        var dropdown = ref(null);
        var left2 = ref(void 0);
        var right2 = ref(void 0);
        var top2 = ref(void 0);
        var bottom2 = ref(void 0);
        var search = ref("");
        var searchTimeout = ref(null);
        var resizeTimeout = ref(null);
        var hoverDisabled = ref(false);
        var fullHeight = ref(false);
        var selected = ref({});
        var pointed = ref({});
        var focused = computed(() => {
          if (!search.value) {
            return {};
          }
          return options.value.find((o2) => o2.label.toLowerCase().startsWith(search.value.toString().toLowerCase()));
        });
        var style = computed(() => {
          return {
            left: left2.value !== void 0 ? "".concat(left2.value, "px") : void 0,
            right: right2.value !== void 0 ? "".concat(right2.value, "px") : void 0,
            top: top2.value !== void 0 ? "".concat(top2.value, "px") : void 0,
            bottom: bottom2.value !== void 0 ? "".concat(bottom2.value, "px") : "auto"
          };
        });
        var close = () => {
          top2.value = void 0;
          bottom2.value = void 0;
          fullHeight.value = false;
          isOpen.value = false;
          document.removeEventListener("click", handleClickOutside);
          document.removeEventListener("keydown", handleKeydown);
          window.removeEventListener("resize", handleResize);
          window.removeEventListener("scroll", handleScroll);
          search.value = "";
          context.emit("close");
        };
        var open = /* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(function* () {
            isOpen.value = true;
            yield nextTick();
            var selectorRect = selector.value.getBoundingClientRect();
            if (selector.value.closest('[dir="rtl"]')) {
              left2.value = void 0;
              right2.value = window.innerWidth - (selectorRect.left + selectorRect.width);
            } else {
              right2.value = void 0;
              left2.value = selectorRect.left;
            }
            resizeDropdown();
            scrollToSelected();
            setTimeout(() => {
              document.addEventListener("click", handleClickOutside);
              document.addEventListener("keydown", handleKeydown);
              window.addEventListener("resize", handleResize);
              window.addEventListener("scroll", handleScroll);
            }, 0);
            context.emit("open");
          });
          return function open2() {
            return _ref.apply(this, arguments);
          };
        }();
        var scrollToOption = (option) => {
          if (fullHeight.value) {
            var selectorRect = selector.value.getBoundingClientRect();
            var optionRect = option.getBoundingClientRect();
            var targetCenterY = selectorRect.top + selectorRect.height / 2;
            var optionCenterY = optionRect.top + optionRect.height / 2;
            var centerDiff = targetCenterY - optionCenterY;
            var newScrollTop = dropdown.value.scrollTop - centerDiff;
            dropdown.value.scrollTop = newScrollTop;
          } else {
            var _optionRect = option.getBoundingClientRect();
            var dropdownRect = dropdown.value.getBoundingClientRect();
            var optionTopWithinDiv = _optionRect.top - dropdownRect.top;
            dropdown.value.scrollTop = optionTopWithinDiv + dropdown.value.scrollTop;
          }
        };
        var scrollToSelected = /* @__PURE__ */ function() {
          var _ref2 = _asyncToGenerator(function* () {
            yield nextTick();
            var option = document.querySelector('[data-dropdown-for="'.concat(el$.value.fieldId, '"] [data-selected="true"]'));
            if (!option) {
              return;
            }
            scrollToOption(option);
          });
          return function scrollToSelected2() {
            return _ref2.apply(this, arguments);
          };
        }();
        var resizeDropdown = () => {
          if (dropdown.value.getBoundingClientRect().height >= window.innerHeight - 32) {
            fullHeight.value = true;
            top2.value = 16;
            bottom2.value = 16;
          } else {
            fullHeight.value = false;
            var selectorRect = selector.value.getBoundingClientRect();
            var newTop = selectorRect.top;
            if (position.value === "bottom") {
              newTop += selectorRect.height;
            } else if (position.value === "top")
              ;
            top2.value = newTop;
            if (dropdown.value.getBoundingClientRect().height > window.innerHeight - selector.value.getBoundingClientRect().top - 16) {
              bottom2.value = 16;
            } else {
              bottom2.value = void 0;
            }
          }
        };
        var selectOption = (option) => {
          selected.value = option;
          fire("select", option);
        };
        var reset = () => {
          selected.value = {};
          fire("select", {});
        };
        var handleOptionPoint = (option) => {
          if (hoverDisabled.value) {
            return;
          }
          pointed.value = option;
        };
        var handleOptionClick = (option) => {
          selectOption(option);
          close();
          el$.value.input.focus();
        };
        var handleSelectorClick = (e2) => {
          open();
        };
        var handleSelectorKeydown = /* @__PURE__ */ function() {
          var _ref3 = _asyncToGenerator(function* (e2) {
            if (isOpen.value) {
              return;
            }
            if (["Enter", " ", "ArrowDown", "ArrowUp"].indexOf(e2.key) !== -1) {
              e2.preventDefault();
              open();
              yield nextTick();
              var index2 = selected.value.index !== void 0 ? selected.value.index : pointed.value.index || 0;
              var option = document.querySelector('[data-dropdown-for="'.concat(el$.value.fieldId, '"] [data-index="').concat(index2, '"]'));
              pointed.value = options.value.find((c2) => c2.index === index2);
              option.focus();
            }
          });
          return function handleSelectorKeydown2(_x) {
            return _ref3.apply(this, arguments);
          };
        }();
        var handleClickOutside = (e2) => {
          var _dropdown$value;
          if (!((_dropdown$value = dropdown.value) !== null && _dropdown$value !== void 0 && _dropdown$value.contains(e2.target))) {
            close();
          }
        };
        var handleKeydown = (e2) => {
          var _pointed$value;
          if (e2.key === "Escape") {
            close();
            selector.value.focus();
            return;
          }
          if (["Enter", " "].indexOf(e2.key) !== -1 && ((_pointed$value = pointed.value) === null || _pointed$value === void 0 ? void 0 : _pointed$value.index) !== void 0) {
            e2.preventDefault();
            selectOption(pointed.value);
            close();
            el$.value.input.focus();
            return;
          }
          if (e2.key === "Tab") {
            e2.preventDefault();
            close();
            el$.value.input.focus();
            return;
          }
          if (e2.key === "ArrowDown") {
            e2.preventDefault();
            var index2 = pointed.value.index === void 0 ? -1 : pointed.value.index;
            var nextIndex = index2 + 1;
            if (options.value.length < nextIndex + 1) {
              nextIndex = 0;
            }
            hoverDisabled.value = true;
            pointed.value = options.value.find((c2) => c2.index === nextIndex);
            var option = document.querySelector('[data-dropdown-for="'.concat(el$.value.fieldId, '"] [data-index="').concat(nextIndex, '"]'));
            scrollToOption(option);
            option.focus();
            setTimeout(() => {
              hoverDisabled.value = false;
            }, 2);
            return;
          }
          if (e2.key === "ArrowUp") {
            e2.preventDefault();
            var _index = pointed.value.index || 0;
            var prevIndex = _index - 1;
            if (prevIndex < 0) {
              prevIndex = options.value.length - 1;
            }
            hoverDisabled.value = true;
            pointed.value = options.value.find((c2) => c2.index === prevIndex);
            var _option = document.querySelector('[data-dropdown-for="'.concat(el$.value.fieldId, '"] [data-index="').concat(prevIndex, '"]'));
            scrollToOption(_option);
            _option.focus();
            setTimeout(() => {
              hoverDisabled.value = false;
            }, 0);
            return;
          }
          if (e2.key === "Backspace" && search.value.length) {
            search.value = search.value.slice(0, -1);
            return;
          }
          if (e2.key.length === 1 && !e2.ctrlKey && !e2.metaKey && !e2.altKey) {
            search.value += e2.key;
            hoverDisabled.value = true;
            if (searchTimeout.value) {
              clearTimeout(searchTimeout.value);
            }
            searchTimeout.value = setTimeout(() => {
              search.value = "";
            }, 1e3);
            setTimeout(() => {
              hoverDisabled.value = false;
            }, 0);
          }
        };
        var handleResize = () => {
          close();
        };
        var handleScroll = () => {
          if (resizeTimeout.value) {
            clearTimeout(resizeTimeout.value);
          }
          resizeTimeout.value = setTimeout(() => {
            resizeDropdown();
          }, 50);
        };
        onBeforeUnmount(() => {
          close();
        });
        watch(focused, (option) => {
          if (!option || option.index === void 0) {
            return;
          }
          var optionEl = document.querySelector('[data-dropdown-for="'.concat(el$.value.fieldId, '"] [data-index="').concat(option.index, '"]'));
          scrollToOption(optionEl);
          pointed.value = option;
          optionEl.focus();
        });
        return {
          form$,
          el$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme,
          events,
          listeners,
          on: on2,
          off: off2,
          fire,
          isOpen,
          selector,
          dropdown,
          left: left2,
          right: right2,
          top: top2,
          bottom: bottom2,
          style,
          search,
          searchTimeout,
          hoverDisabled,
          selected,
          pointed,
          focused,
          close,
          scrollToOption,
          scrollToSelected,
          selectOption,
          reset,
          handleOptionPoint,
          handleOptionClick,
          handleSelectorClick,
          handleSelectorKeydown,
          handleClickOutside,
          handleKeydown,
          handleResize
        };
      }
    };
    var HOOKS = [
      "onChange",
      "onClose",
      "onDayCreate",
      "onDestroy",
      "onKeyDown",
      "onMonthChange",
      "onOpen",
      "onParseConfig",
      "onReady",
      "onValueUpdate",
      "onYearChange",
      "onPreCalendarPosition"
    ];
    var defaults$1 = {
      _disable: [],
      allowInput: false,
      allowInvalidPreload: false,
      altFormat: "F j, Y",
      altInput: false,
      altInputClass: "form-control input",
      animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
      ariaDateFormat: "F j, Y",
      autoFillDefaultTime: true,
      clickOpens: true,
      closeOnSelect: true,
      conjunction: ", ",
      dateFormat: "Y-m-d",
      defaultHour: 12,
      defaultMinute: 0,
      defaultSeconds: 0,
      disable: [],
      disableMobile: false,
      enableSeconds: false,
      enableTime: false,
      errorHandler: function(err) {
        return typeof console !== "undefined" && console.warn(err);
      },
      getWeek: function(givenDate) {
        var date2 = new Date(givenDate.getTime());
        date2.setHours(0, 0, 0, 0);
        date2.setDate(date2.getDate() + 3 - (date2.getDay() + 6) % 7);
        var week1 = new Date(date2.getFullYear(), 0, 4);
        return 1 + Math.round(((date2.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
      },
      hourIncrement: 1,
      ignoredFocusElements: [],
      inline: false,
      locale: "default",
      minuteIncrement: 5,
      mode: "single",
      monthSelectorType: "dropdown",
      nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
      noCalendar: false,
      now: /* @__PURE__ */ new Date(),
      onChange: [],
      onClose: [],
      onDayCreate: [],
      onDestroy: [],
      onKeyDown: [],
      onMonthChange: [],
      onOpen: [],
      onParseConfig: [],
      onReady: [],
      onValueUpdate: [],
      onYearChange: [],
      onPreCalendarPosition: [],
      plugins: [],
      position: "auto",
      positionElement: void 0,
      prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
      shorthandCurrentMonth: false,
      showMonths: 1,
      static: false,
      time_24hr: false,
      weekNumbers: false,
      wrap: false
    };
    var english = {
      weekdays: {
        shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        longhand: [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday"
        ]
      },
      months: {
        shorthand: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ],
        longhand: [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ]
      },
      daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
      firstDayOfWeek: 0,
      ordinal: function(nth) {
        var s2 = nth % 100;
        if (s2 > 3 && s2 < 21)
          return "th";
        switch (s2 % 10) {
          case 1:
            return "st";
          case 2:
            return "nd";
          case 3:
            return "rd";
          default:
            return "th";
        }
      },
      rangeSeparator: " to ",
      weekAbbreviation: "Wk",
      scrollTitle: "Scroll to increment",
      toggleTitle: "Click to toggle",
      amPM: ["AM", "PM"],
      yearAriaLabel: "Year",
      monthAriaLabel: "Month",
      hourAriaLabel: "Hour",
      minuteAriaLabel: "Minute",
      time_24hr: false
    };
    var pad = function(number, length) {
      if (length === void 0) {
        length = 2;
      }
      return ("000" + number).slice(length * -1);
    };
    var int = function(bool) {
      return bool === true ? 1 : 0;
    };
    function debounce$1(fn2, wait) {
      var t2;
      return function() {
        var _this = this;
        var args = arguments;
        clearTimeout(t2);
        t2 = setTimeout(function() {
          return fn2.apply(_this, args);
        }, wait);
      };
    }
    var arrayify = function(obj) {
      return obj instanceof Array ? obj : [obj];
    };
    function toggleClass$1(elem, className, bool) {
      if (bool === true)
        return elem.classList.add(className);
      elem.classList.remove(className);
    }
    function createElement(tag, className, content) {
      var e2 = window.document.createElement(tag);
      className = className || "";
      content = content || "";
      e2.className = className;
      if (content !== void 0)
        e2.textContent = content;
      return e2;
    }
    function clearNode(node) {
      while (node.firstChild)
        node.removeChild(node.firstChild);
    }
    function findParent(node, condition2) {
      if (condition2(node))
        return node;
      else if (node.parentNode)
        return findParent(node.parentNode, condition2);
      return void 0;
    }
    function createNumberInput(inputClassName, opts) {
      var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
      if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
        numInput.type = "number";
      } else {
        numInput.type = "text";
        numInput.pattern = "\\d*";
      }
      if (opts !== void 0)
        for (var key in opts)
          numInput.setAttribute(key, opts[key]);
      wrapper.appendChild(numInput);
      wrapper.appendChild(arrowUp);
      wrapper.appendChild(arrowDown);
      return wrapper;
    }
    function getEventTarget(event) {
      try {
        if (typeof event.composedPath === "function") {
          var path = event.composedPath();
          return path[0];
        }
        return event.target;
      } catch (error) {
        return event.target;
      }
    }
    var doNothing = function() {
      return void 0;
    };
    var monthToStr = function(monthNumber, shorthand, locale2) {
      return locale2.months[shorthand ? "shorthand" : "longhand"][monthNumber];
    };
    var revFormat = {
      D: doNothing,
      F: function(dateObj, monthName, locale2) {
        dateObj.setMonth(locale2.months.longhand.indexOf(monthName));
      },
      G: function(dateObj, hour) {
        dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
      },
      H: function(dateObj, hour) {
        dateObj.setHours(parseFloat(hour));
      },
      J: function(dateObj, day) {
        dateObj.setDate(parseFloat(day));
      },
      K: function(dateObj, amPM, locale2) {
        dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale2.amPM[1], "i").test(amPM)));
      },
      M: function(dateObj, shortMonth, locale2) {
        dateObj.setMonth(locale2.months.shorthand.indexOf(shortMonth));
      },
      S: function(dateObj, seconds2) {
        dateObj.setSeconds(parseFloat(seconds2));
      },
      U: function(_2, unixSeconds) {
        return new Date(parseFloat(unixSeconds) * 1e3);
      },
      W: function(dateObj, weekNum, locale2) {
        var weekNumber = parseInt(weekNum);
        var date2 = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
        date2.setDate(date2.getDate() - date2.getDay() + locale2.firstDayOfWeek);
        return date2;
      },
      Y: function(dateObj, year) {
        dateObj.setFullYear(parseFloat(year));
      },
      Z: function(_2, ISODate) {
        return new Date(ISODate);
      },
      d: function(dateObj, day) {
        dateObj.setDate(parseFloat(day));
      },
      h: function(dateObj, hour) {
        dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
      },
      i: function(dateObj, minutes2) {
        dateObj.setMinutes(parseFloat(minutes2));
      },
      j: function(dateObj, day) {
        dateObj.setDate(parseFloat(day));
      },
      l: doNothing,
      m: function(dateObj, month) {
        dateObj.setMonth(parseFloat(month) - 1);
      },
      n: function(dateObj, month) {
        dateObj.setMonth(parseFloat(month) - 1);
      },
      s: function(dateObj, seconds2) {
        dateObj.setSeconds(parseFloat(seconds2));
      },
      u: function(_2, unixMillSeconds) {
        return new Date(parseFloat(unixMillSeconds));
      },
      w: doNothing,
      y: function(dateObj, year) {
        dateObj.setFullYear(2e3 + parseFloat(year));
      }
    };
    var tokenRegex = {
      D: "",
      F: "",
      G: "(\\d\\d|\\d)",
      H: "(\\d\\d|\\d)",
      J: "(\\d\\d|\\d)\\w+",
      K: "",
      M: "",
      S: "(\\d\\d|\\d)",
      U: "(.+)",
      W: "(\\d\\d|\\d)",
      Y: "(\\d{4})",
      Z: "(.+)",
      d: "(\\d\\d|\\d)",
      h: "(\\d\\d|\\d)",
      i: "(\\d\\d|\\d)",
      j: "(\\d\\d|\\d)",
      l: "",
      m: "(\\d\\d|\\d)",
      n: "(\\d\\d|\\d)",
      s: "(\\d\\d|\\d)",
      u: "(.+)",
      w: "(\\d\\d|\\d)",
      y: "(\\d{2})"
    };
    var formats = {
      Z: function(date2) {
        return date2.toISOString();
      },
      D: function(date2, locale2, options) {
        return locale2.weekdays.shorthand[formats.w(date2, locale2, options)];
      },
      F: function(date2, locale2, options) {
        return monthToStr(formats.n(date2, locale2, options) - 1, false, locale2);
      },
      G: function(date2, locale2, options) {
        return pad(formats.h(date2, locale2, options));
      },
      H: function(date2) {
        return pad(date2.getHours());
      },
      J: function(date2, locale2) {
        return locale2.ordinal !== void 0 ? date2.getDate() + locale2.ordinal(date2.getDate()) : date2.getDate();
      },
      K: function(date2, locale2) {
        return locale2.amPM[int(date2.getHours() > 11)];
      },
      M: function(date2, locale2) {
        return monthToStr(date2.getMonth(), true, locale2);
      },
      S: function(date2) {
        return pad(date2.getSeconds());
      },
      U: function(date2) {
        return date2.getTime() / 1e3;
      },
      W: function(date2, _2, options) {
        return options.getWeek(date2);
      },
      Y: function(date2) {
        return pad(date2.getFullYear(), 4);
      },
      d: function(date2) {
        return pad(date2.getDate());
      },
      h: function(date2) {
        return date2.getHours() % 12 ? date2.getHours() % 12 : 12;
      },
      i: function(date2) {
        return pad(date2.getMinutes());
      },
      j: function(date2) {
        return date2.getDate();
      },
      l: function(date2, locale2) {
        return locale2.weekdays.longhand[date2.getDay()];
      },
      m: function(date2) {
        return pad(date2.getMonth() + 1);
      },
      n: function(date2) {
        return date2.getMonth() + 1;
      },
      s: function(date2) {
        return date2.getSeconds();
      },
      u: function(date2) {
        return date2.getTime();
      },
      w: function(date2) {
        return date2.getDay();
      },
      y: function(date2) {
        return String(date2.getFullYear()).substring(2);
      }
    };
    var createDateFormatter = function(_a) {
      var _b = _a.config, config2 = _b === void 0 ? defaults$1 : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
      return function(dateObj, frmt, overrideLocale) {
        var locale2 = overrideLocale || l10n;
        if (config2.formatDate !== void 0 && !isMobile) {
          return config2.formatDate(dateObj, frmt, locale2);
        }
        return frmt.split("").map(function(c2, i2, arr) {
          return formats[c2] && arr[i2 - 1] !== "\\" ? formats[c2](dateObj, locale2, config2) : c2 !== "\\" ? c2 : "";
        }).join("");
      };
    };
    var createDateParser = function(_a) {
      var _b = _a.config, config2 = _b === void 0 ? defaults$1 : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
      return function(date2, givenFormat, timeless, customLocale) {
        if (date2 !== 0 && !date2)
          return void 0;
        var locale2 = customLocale || l10n;
        var parsedDate;
        var dateOrig = date2;
        if (date2 instanceof Date)
          parsedDate = new Date(date2.getTime());
        else if (typeof date2 !== "string" && date2.toFixed !== void 0)
          parsedDate = new Date(date2);
        else if (typeof date2 === "string") {
          var format2 = givenFormat || (config2 || defaults$1).dateFormat;
          var datestr = String(date2).trim();
          if (datestr === "today") {
            parsedDate = /* @__PURE__ */ new Date();
            timeless = true;
          } else if (config2 && config2.parseDate) {
            parsedDate = config2.parseDate(date2, format2);
          } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
            parsedDate = new Date(date2);
          } else {
            var matched = void 0, ops = [];
            for (var i2 = 0, matchIndex = 0, regexStr = ""; i2 < format2.length; i2++) {
              var token2 = format2[i2];
              var isBackSlash = token2 === "\\";
              var escaped = format2[i2 - 1] === "\\" || isBackSlash;
              if (tokenRegex[token2] && !escaped) {
                regexStr += tokenRegex[token2];
                var match = new RegExp(regexStr).exec(date2);
                if (match && (matched = true)) {
                  ops[token2 !== "Y" ? "push" : "unshift"]({
                    fn: revFormat[token2],
                    val: match[++matchIndex]
                  });
                }
              } else if (!isBackSlash)
                regexStr += ".";
            }
            parsedDate = !config2 || !config2.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
            ops.forEach(function(_a2) {
              var fn2 = _a2.fn, val = _a2.val;
              return parsedDate = fn2(parsedDate, val, locale2) || parsedDate;
            });
            parsedDate = matched ? parsedDate : void 0;
          }
        }
        if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
          config2.errorHandler(new Error("Invalid date provided: " + dateOrig));
          return void 0;
        }
        if (timeless === true)
          parsedDate.setHours(0, 0, 0, 0);
        return parsedDate;
      };
    };
    function compareDates(date1, date2, timeless) {
      if (timeless === void 0) {
        timeless = true;
      }
      if (timeless !== false) {
        return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
      }
      return date1.getTime() - date2.getTime();
    }
    var isBetween = function(ts, ts1, ts2) {
      return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
    };
    var calculateSecondsSinceMidnight = function(hours2, minutes2, seconds2) {
      return hours2 * 3600 + minutes2 * 60 + seconds2;
    };
    var parseSeconds = function(secondsSinceMidnight) {
      var hours2 = Math.floor(secondsSinceMidnight / 3600), minutes2 = (secondsSinceMidnight - hours2 * 3600) / 60;
      return [hours2, minutes2, secondsSinceMidnight - hours2 * 3600 - minutes2 * 60];
    };
    var duration = {
      DAY: 864e5
    };
    function getDefaultHours(config2) {
      var hours2 = config2.defaultHour;
      var minutes2 = config2.defaultMinute;
      var seconds2 = config2.defaultSeconds;
      if (config2.minDate !== void 0) {
        var minHour = config2.minDate.getHours();
        var minMinutes = config2.minDate.getMinutes();
        var minSeconds = config2.minDate.getSeconds();
        if (hours2 < minHour) {
          hours2 = minHour;
        }
        if (hours2 === minHour && minutes2 < minMinutes) {
          minutes2 = minMinutes;
        }
        if (hours2 === minHour && minutes2 === minMinutes && seconds2 < minSeconds)
          seconds2 = config2.minDate.getSeconds();
      }
      if (config2.maxDate !== void 0) {
        var maxHr = config2.maxDate.getHours();
        var maxMinutes = config2.maxDate.getMinutes();
        hours2 = Math.min(hours2, maxHr);
        if (hours2 === maxHr)
          minutes2 = Math.min(maxMinutes, minutes2);
        if (hours2 === maxHr && minutes2 === maxMinutes)
          seconds2 = config2.maxDate.getSeconds();
      }
      return { hours: hours2, minutes: minutes2, seconds: seconds2 };
    }
    if (typeof Object.assign !== "function") {
      Object.assign = function(target) {
        var args = [];
        for (var _i2 = 1; _i2 < arguments.length; _i2++) {
          args[_i2 - 1] = arguments[_i2];
        }
        if (!target) {
          throw TypeError("Cannot convert undefined or null to object");
        }
        var _loop_1 = function(source2) {
          if (source2) {
            Object.keys(source2).forEach(function(key) {
              return target[key] = source2[key];
            });
          }
        };
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
          var source = args_1[_a];
          _loop_1(source);
        }
        return target;
      };
    }
    var __assign = function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __spreadArrays = function() {
      for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s2 += arguments[i2].length;
      for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
        for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
          r2[k2] = a2[j2];
      return r2;
    };
    var DEBOUNCED_CHANGE_MS = 300;
    function FlatpickrInstance(element, instanceConfig) {
      var self2 = {
        config: __assign(__assign({}, defaults$1), flatpickr.defaultConfig),
        l10n: english
      };
      self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
      self2._handlers = [];
      self2.pluginElements = [];
      self2.loadedPlugins = [];
      self2._bind = bind2;
      self2._setHoursFromDate = setHoursFromDate;
      self2._positionCalendar = positionCalendar;
      self2.changeMonth = changeMonth;
      self2.changeYear = changeYear;
      self2.clear = clear2;
      self2.close = close;
      self2.onMouseOver = onMouseOver;
      self2._createElement = createElement;
      self2.createDay = createDay;
      self2.destroy = destroy;
      self2.isEnabled = isEnabled;
      self2.jumpToDate = jumpToDate;
      self2.updateValue = updateValue;
      self2.open = open;
      self2.redraw = redraw;
      self2.set = set2;
      self2.setDate = setDate;
      self2.toggle = toggle2;
      function setupHelperFunctions() {
        self2.utils = {
          getDaysInMonth: function(month, yr) {
            if (month === void 0) {
              month = self2.currentMonth;
            }
            if (yr === void 0) {
              yr = self2.currentYear;
            }
            if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
              return 29;
            return self2.l10n.daysInMonth[month];
          }
        };
      }
      function init() {
        self2.element = self2.input = element;
        self2.isOpen = false;
        parseConfig();
        setupLocale();
        setupInputs();
        setupDates();
        setupHelperFunctions();
        if (!self2.isMobile)
          build();
        bindEvents();
        if (self2.selectedDates.length || self2.config.noCalendar) {
          if (self2.config.enableTime) {
            setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
          }
          updateValue(false);
        }
        setCalendarWidth();
        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        if (!self2.isMobile && isSafari) {
          positionCalendar();
        }
        triggerEvent("onReady");
      }
      function getClosestActiveElement() {
        var _a;
        return ((_a = self2.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
      }
      function bindToInstance(fn2) {
        return fn2.bind(self2);
      }
      function setCalendarWidth() {
        var config2 = self2.config;
        if (config2.weekNumbers === false && config2.showMonths === 1) {
          return;
        } else if (config2.noCalendar !== true) {
          window.requestAnimationFrame(function() {
            if (self2.calendarContainer !== void 0) {
              self2.calendarContainer.style.visibility = "hidden";
              self2.calendarContainer.style.display = "block";
            }
            if (self2.daysContainer !== void 0) {
              var daysWidth = (self2.days.offsetWidth + 1) * config2.showMonths;
              self2.daysContainer.style.width = daysWidth + "px";
              self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
              self2.calendarContainer.style.removeProperty("visibility");
              self2.calendarContainer.style.removeProperty("display");
            }
          });
        }
      }
      function updateTime(e2) {
        if (self2.selectedDates.length === 0) {
          var defaultDate = self2.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
          var defaults2 = getDefaultHours(self2.config);
          defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
          self2.selectedDates = [defaultDate];
          self2.latestSelectedDateObj = defaultDate;
        }
        if (e2 !== void 0 && e2.type !== "blur") {
          timeWrapper(e2);
        }
        var prevValue = self2._input.value;
        setHoursFromInputs();
        updateValue();
        if (self2._input.value !== prevValue) {
          self2._debouncedChange();
        }
      }
      function ampm2military(hour, amPM) {
        return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
      }
      function military2ampm(hour) {
        switch (hour % 24) {
          case 0:
          case 12:
            return 12;
          default:
            return hour % 12;
        }
      }
      function setHoursFromInputs() {
        if (self2.hourElement === void 0 || self2.minuteElement === void 0)
          return;
        var hours2 = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes2 = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds2 = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
        if (self2.amPM !== void 0) {
          hours2 = ampm2military(hours2, self2.amPM.textContent);
        }
        var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
        var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
        if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
          var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
          var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
          var currentTime = calculateSecondsSinceMidnight(hours2, minutes2, seconds2);
          if (currentTime > maxBound && currentTime < minBound) {
            var result = parseSeconds(minBound);
            hours2 = result[0];
            minutes2 = result[1];
            seconds2 = result[2];
          }
        } else {
          if (limitMaxHours) {
            var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
            hours2 = Math.min(hours2, maxTime.getHours());
            if (hours2 === maxTime.getHours())
              minutes2 = Math.min(minutes2, maxTime.getMinutes());
            if (minutes2 === maxTime.getMinutes())
              seconds2 = Math.min(seconds2, maxTime.getSeconds());
          }
          if (limitMinHours) {
            var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
            hours2 = Math.max(hours2, minTime.getHours());
            if (hours2 === minTime.getHours() && minutes2 < minTime.getMinutes())
              minutes2 = minTime.getMinutes();
            if (minutes2 === minTime.getMinutes())
              seconds2 = Math.max(seconds2, minTime.getSeconds());
          }
        }
        setHours(hours2, minutes2, seconds2);
      }
      function setHoursFromDate(dateObj) {
        var date2 = dateObj || self2.latestSelectedDateObj;
        if (date2 && date2 instanceof Date) {
          setHours(date2.getHours(), date2.getMinutes(), date2.getSeconds());
        }
      }
      function setHours(hours2, minutes2, seconds2) {
        if (self2.latestSelectedDateObj !== void 0) {
          self2.latestSelectedDateObj.setHours(hours2 % 24, minutes2, seconds2 || 0, 0);
        }
        if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
          return;
        self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours2) % 12 + 12 * int(hours2 % 12 === 0) : hours2);
        self2.minuteElement.value = pad(minutes2);
        if (self2.amPM !== void 0)
          self2.amPM.textContent = self2.l10n.amPM[int(hours2 >= 12)];
        if (self2.secondElement !== void 0)
          self2.secondElement.value = pad(seconds2);
      }
      function onYearInput(event) {
        var eventTarget = getEventTarget(event);
        var year = parseInt(eventTarget.value) + (event.delta || 0);
        if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
          changeYear(year);
        }
      }
      function bind2(element2, event, handler, options) {
        if (event instanceof Array)
          return event.forEach(function(ev) {
            return bind2(element2, ev, handler, options);
          });
        if (element2 instanceof Array)
          return element2.forEach(function(el) {
            return bind2(el, event, handler, options);
          });
        element2.addEventListener(event, handler, options);
        self2._handlers.push({
          remove: function() {
            return element2.removeEventListener(event, handler, options);
          }
        });
      }
      function triggerChange() {
        triggerEvent("onChange");
      }
      function bindEvents() {
        if (self2.config.wrap) {
          ["open", "close", "toggle", "clear"].forEach(function(evt) {
            Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
              return bind2(el, "click", self2[evt]);
            });
          });
        }
        if (self2.isMobile) {
          setupMobile();
          return;
        }
        var debouncedResize = debounce$1(onResize, 50);
        self2._debouncedChange = debounce$1(triggerChange, DEBOUNCED_CHANGE_MS);
        if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
          bind2(self2.daysContainer, "mouseover", function(e2) {
            if (self2.config.mode === "range")
              onMouseOver(getEventTarget(e2));
          });
        bind2(self2._input, "keydown", onKeyDown);
        if (self2.calendarContainer !== void 0) {
          bind2(self2.calendarContainer, "keydown", onKeyDown);
        }
        if (!self2.config.inline && !self2.config.static)
          bind2(window, "resize", debouncedResize);
        if (window.ontouchstart !== void 0)
          bind2(window.document, "touchstart", documentClick);
        else
          bind2(window.document, "mousedown", documentClick);
        bind2(window.document, "focus", documentClick, { capture: true });
        if (self2.config.clickOpens === true) {
          bind2(self2._input, "focus", self2.open);
          bind2(self2._input, "click", self2.open);
        }
        if (self2.daysContainer !== void 0) {
          bind2(self2.monthNav, "click", onMonthNavClick);
          bind2(self2.monthNav, ["keyup", "increment"], onYearInput);
          bind2(self2.daysContainer, "click", selectDate);
        }
        if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
          var selText = function(e2) {
            return getEventTarget(e2).select();
          };
          bind2(self2.timeContainer, ["increment"], updateTime);
          bind2(self2.timeContainer, "blur", updateTime, { capture: true });
          bind2(self2.timeContainer, "click", timeIncrement);
          bind2([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
          if (self2.secondElement !== void 0)
            bind2(self2.secondElement, "focus", function() {
              return self2.secondElement && self2.secondElement.select();
            });
          if (self2.amPM !== void 0) {
            bind2(self2.amPM, "click", function(e2) {
              updateTime(e2);
            });
          }
        }
        if (self2.config.allowInput) {
          bind2(self2._input, "blur", onBlur);
        }
      }
      function jumpToDate(jumpDate, triggerChange2) {
        var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
        var oldYear = self2.currentYear;
        var oldMonth = self2.currentMonth;
        try {
          if (jumpTo !== void 0) {
            self2.currentYear = jumpTo.getFullYear();
            self2.currentMonth = jumpTo.getMonth();
          }
        } catch (e2) {
          e2.message = "Invalid date supplied: " + jumpTo;
          self2.config.errorHandler(e2);
        }
        if (triggerChange2 && self2.currentYear !== oldYear) {
          triggerEvent("onYearChange");
          buildMonthSwitch();
        }
        if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
          triggerEvent("onMonthChange");
        }
        self2.redraw();
      }
      function timeIncrement(e2) {
        var eventTarget = getEventTarget(e2);
        if (~eventTarget.className.indexOf("arrow"))
          incrementNumInput(e2, eventTarget.classList.contains("arrowUp") ? 1 : -1);
      }
      function incrementNumInput(e2, delta, inputElem) {
        var target = e2 && getEventTarget(e2);
        var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
        var event = createEvent("increment");
        event.delta = delta;
        input && input.dispatchEvent(event);
      }
      function build() {
        var fragment = window.document.createDocumentFragment();
        self2.calendarContainer = createElement("div", "flatpickr-calendar");
        self2.calendarContainer.tabIndex = -1;
        if (!self2.config.noCalendar) {
          fragment.appendChild(buildMonthNav());
          self2.innerContainer = createElement("div", "flatpickr-innerContainer");
          if (self2.config.weekNumbers) {
            var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
            self2.innerContainer.appendChild(weekWrapper);
            self2.weekNumbers = weekNumbers;
            self2.weekWrapper = weekWrapper;
          }
          self2.rContainer = createElement("div", "flatpickr-rContainer");
          self2.rContainer.appendChild(buildWeekdays());
          if (!self2.daysContainer) {
            self2.daysContainer = createElement("div", "flatpickr-days");
            self2.daysContainer.tabIndex = -1;
          }
          buildDays();
          self2.rContainer.appendChild(self2.daysContainer);
          self2.innerContainer.appendChild(self2.rContainer);
          fragment.appendChild(self2.innerContainer);
        }
        if (self2.config.enableTime) {
          fragment.appendChild(buildTime());
        }
        toggleClass$1(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
        toggleClass$1(self2.calendarContainer, "animate", self2.config.animate === true);
        toggleClass$1(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
        self2.calendarContainer.appendChild(fragment);
        var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
        if (self2.config.inline || self2.config.static) {
          self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
          if (self2.config.inline) {
            if (!customAppend && self2.element.parentNode)
              self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
            else if (self2.config.appendTo !== void 0)
              self2.config.appendTo.appendChild(self2.calendarContainer);
          }
          if (self2.config.static) {
            var wrapper = createElement("div", "flatpickr-wrapper");
            if (self2.element.parentNode)
              self2.element.parentNode.insertBefore(wrapper, self2.element);
            wrapper.appendChild(self2.element);
            if (self2.altInput)
              wrapper.appendChild(self2.altInput);
            wrapper.appendChild(self2.calendarContainer);
          }
        }
        if (!self2.config.static && !self2.config.inline)
          (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
      }
      function createDay(className, date2, _dayNumber, i2) {
        var dateIsEnabled = isEnabled(date2, true), dayElement = createElement("span", className, date2.getDate().toString());
        dayElement.dateObj = date2;
        dayElement.$i = i2;
        dayElement.setAttribute("aria-label", self2.formatDate(date2, self2.config.ariaDateFormat));
        if (className.indexOf("hidden") === -1 && compareDates(date2, self2.now) === 0) {
          self2.todayDateElem = dayElement;
          dayElement.classList.add("today");
          dayElement.setAttribute("aria-current", "date");
        }
        if (dateIsEnabled) {
          dayElement.tabIndex = -1;
          if (isDateSelected(date2)) {
            dayElement.classList.add("selected");
            self2.selectedDateElem = dayElement;
            if (self2.config.mode === "range") {
              toggleClass$1(dayElement, "startRange", self2.selectedDates[0] && compareDates(date2, self2.selectedDates[0], true) === 0);
              toggleClass$1(dayElement, "endRange", self2.selectedDates[1] && compareDates(date2, self2.selectedDates[1], true) === 0);
              if (className === "nextMonthDay")
                dayElement.classList.add("inRange");
            }
          }
        } else {
          dayElement.classList.add("flatpickr-disabled");
        }
        if (self2.config.mode === "range") {
          if (isDateInRange(date2) && !isDateSelected(date2))
            dayElement.classList.add("inRange");
        }
        if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i2 % 7 === 6) {
          self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date2) + "</span>");
        }
        triggerEvent("onDayCreate", dayElement);
        return dayElement;
      }
      function focusOnDayElem(targetNode) {
        targetNode.focus();
        if (self2.config.mode === "range")
          onMouseOver(targetNode);
      }
      function getFirstAvailableDay(delta) {
        var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
        var endMonth = delta > 0 ? self2.config.showMonths : -1;
        for (var m2 = startMonth; m2 != endMonth; m2 += delta) {
          var month = self2.daysContainer.children[m2];
          var startIndex = delta > 0 ? 0 : month.children.length - 1;
          var endIndex = delta > 0 ? month.children.length : -1;
          for (var i2 = startIndex; i2 != endIndex; i2 += delta) {
            var c2 = month.children[i2];
            if (c2.className.indexOf("hidden") === -1 && isEnabled(c2.dateObj))
              return c2;
          }
        }
        return void 0;
      }
      function getNextAvailableDay(current, delta) {
        var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
        var endMonth = delta > 0 ? self2.config.showMonths : -1;
        var loopDelta = delta > 0 ? 1 : -1;
        for (var m2 = givenMonth - self2.currentMonth; m2 != endMonth; m2 += loopDelta) {
          var month = self2.daysContainer.children[m2];
          var startIndex = givenMonth - self2.currentMonth === m2 ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
          var numMonthDays = month.children.length;
          for (var i2 = startIndex; i2 >= 0 && i2 < numMonthDays && i2 != (delta > 0 ? numMonthDays : -1); i2 += loopDelta) {
            var c2 = month.children[i2];
            if (c2.className.indexOf("hidden") === -1 && isEnabled(c2.dateObj) && Math.abs(current.$i - i2) >= Math.abs(delta))
              return focusOnDayElem(c2);
          }
        }
        self2.changeMonth(loopDelta);
        focusOnDay(getFirstAvailableDay(loopDelta), 0);
        return void 0;
      }
      function focusOnDay(current, offset2) {
        var activeElement = getClosestActiveElement();
        var dayFocused = isInView(activeElement || document.body);
        var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset2 > 0 ? 1 : -1);
        if (startElem === void 0) {
          self2._input.focus();
        } else if (!dayFocused) {
          focusOnDayElem(startElem);
        } else {
          getNextAvailableDay(startElem, offset2);
        }
      }
      function buildMonthDays(year, month) {
        var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
        var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
        var daysInMonth2 = self2.utils.getDaysInMonth(month, year), days2 = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
        var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
        for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
          days2.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
        }
        for (dayNumber = 1; dayNumber <= daysInMonth2; dayNumber++, dayIndex++) {
          days2.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
        }
        for (var dayNum = daysInMonth2 + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
          days2.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth2), dayNum, dayIndex));
        }
        var dayContainer = createElement("div", "dayContainer");
        dayContainer.appendChild(days2);
        return dayContainer;
      }
      function buildDays() {
        if (self2.daysContainer === void 0) {
          return;
        }
        clearNode(self2.daysContainer);
        if (self2.weekNumbers)
          clearNode(self2.weekNumbers);
        var frag = document.createDocumentFragment();
        for (var i2 = 0; i2 < self2.config.showMonths; i2++) {
          var d2 = new Date(self2.currentYear, self2.currentMonth, 1);
          d2.setMonth(self2.currentMonth + i2);
          frag.appendChild(buildMonthDays(d2.getFullYear(), d2.getMonth()));
        }
        self2.daysContainer.appendChild(frag);
        self2.days = self2.daysContainer.firstChild;
        if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
          onMouseOver();
        }
      }
      function buildMonthSwitch() {
        if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
          return;
        var shouldBuildMonth = function(month2) {
          if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
            return false;
          }
          return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
        };
        self2.monthsDropdownContainer.tabIndex = -1;
        self2.monthsDropdownContainer.innerHTML = "";
        for (var i2 = 0; i2 < 12; i2++) {
          if (!shouldBuildMonth(i2))
            continue;
          var month = createElement("option", "flatpickr-monthDropdown-month");
          month.value = new Date(self2.currentYear, i2).getMonth().toString();
          month.textContent = monthToStr(i2, self2.config.shorthandCurrentMonth, self2.l10n);
          month.tabIndex = -1;
          if (self2.currentMonth === i2) {
            month.selected = true;
          }
          self2.monthsDropdownContainer.appendChild(month);
        }
      }
      function buildMonth() {
        var container = createElement("div", "flatpickr-month");
        var monthNavFragment = window.document.createDocumentFragment();
        var monthElement;
        if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
          monthElement = createElement("span", "cur-month");
        } else {
          self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
          self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
          bind2(self2.monthsDropdownContainer, "change", function(e2) {
            var target = getEventTarget(e2);
            var selectedMonth = parseInt(target.value, 10);
            self2.changeMonth(selectedMonth - self2.currentMonth);
            triggerEvent("onMonthChange");
          });
          buildMonthSwitch();
          monthElement = self2.monthsDropdownContainer;
        }
        var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
        var yearElement = yearInput.getElementsByTagName("input")[0];
        yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
        if (self2.config.minDate) {
          yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
        }
        if (self2.config.maxDate) {
          yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
          yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
        }
        var currentMonth = createElement("div", "flatpickr-current-month");
        currentMonth.appendChild(monthElement);
        currentMonth.appendChild(yearInput);
        monthNavFragment.appendChild(currentMonth);
        container.appendChild(monthNavFragment);
        return {
          container,
          yearElement,
          monthElement
        };
      }
      function buildMonths() {
        clearNode(self2.monthNav);
        self2.monthNav.appendChild(self2.prevMonthNav);
        if (self2.config.showMonths) {
          self2.yearElements = [];
          self2.monthElements = [];
        }
        for (var m2 = self2.config.showMonths; m2--; ) {
          var month = buildMonth();
          self2.yearElements.push(month.yearElement);
          self2.monthElements.push(month.monthElement);
          self2.monthNav.appendChild(month.container);
        }
        self2.monthNav.appendChild(self2.nextMonthNav);
      }
      function buildMonthNav() {
        self2.monthNav = createElement("div", "flatpickr-months");
        self2.yearElements = [];
        self2.monthElements = [];
        self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
        self2.prevMonthNav.innerHTML = self2.config.prevArrow;
        self2.nextMonthNav = createElement("span", "flatpickr-next-month");
        self2.nextMonthNav.innerHTML = self2.config.nextArrow;
        buildMonths();
        Object.defineProperty(self2, "_hidePrevMonthArrow", {
          get: function() {
            return self2.__hidePrevMonthArrow;
          },
          set: function(bool) {
            if (self2.__hidePrevMonthArrow !== bool) {
              toggleClass$1(self2.prevMonthNav, "flatpickr-disabled", bool);
              self2.__hidePrevMonthArrow = bool;
            }
          }
        });
        Object.defineProperty(self2, "_hideNextMonthArrow", {
          get: function() {
            return self2.__hideNextMonthArrow;
          },
          set: function(bool) {
            if (self2.__hideNextMonthArrow !== bool) {
              toggleClass$1(self2.nextMonthNav, "flatpickr-disabled", bool);
              self2.__hideNextMonthArrow = bool;
            }
          }
        });
        self2.currentYearElement = self2.yearElements[0];
        updateNavigationCurrentMonth();
        return self2.monthNav;
      }
      function buildTime() {
        self2.calendarContainer.classList.add("hasTime");
        if (self2.config.noCalendar)
          self2.calendarContainer.classList.add("noCalendar");
        var defaults2 = getDefaultHours(self2.config);
        self2.timeContainer = createElement("div", "flatpickr-time");
        self2.timeContainer.tabIndex = -1;
        var separator = createElement("span", "flatpickr-time-separator", ":");
        var hourInput = createNumberInput("flatpickr-hour", {
          "aria-label": self2.l10n.hourAriaLabel
        });
        self2.hourElement = hourInput.getElementsByTagName("input")[0];
        var minuteInput = createNumberInput("flatpickr-minute", {
          "aria-label": self2.l10n.minuteAriaLabel
        });
        self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
        self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
        self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
        self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults2.minutes);
        self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
        self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
        self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
        self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
        self2.hourElement.setAttribute("maxlength", "2");
        self2.minuteElement.setAttribute("min", "0");
        self2.minuteElement.setAttribute("max", "59");
        self2.minuteElement.setAttribute("maxlength", "2");
        self2.timeContainer.appendChild(hourInput);
        self2.timeContainer.appendChild(separator);
        self2.timeContainer.appendChild(minuteInput);
        if (self2.config.time_24hr)
          self2.timeContainer.classList.add("time24hr");
        if (self2.config.enableSeconds) {
          self2.timeContainer.classList.add("hasSeconds");
          var secondInput = createNumberInput("flatpickr-second");
          self2.secondElement = secondInput.getElementsByTagName("input")[0];
          self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults2.seconds);
          self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
          self2.secondElement.setAttribute("min", "0");
          self2.secondElement.setAttribute("max", "59");
          self2.secondElement.setAttribute("maxlength", "2");
          self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
          self2.timeContainer.appendChild(secondInput);
        }
        if (!self2.config.time_24hr) {
          self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
          self2.amPM.title = self2.l10n.toggleTitle;
          self2.amPM.tabIndex = -1;
          self2.timeContainer.appendChild(self2.amPM);
        }
        return self2.timeContainer;
      }
      function buildWeekdays() {
        if (!self2.weekdayContainer)
          self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
        else
          clearNode(self2.weekdayContainer);
        for (var i2 = self2.config.showMonths; i2--; ) {
          var container = createElement("div", "flatpickr-weekdaycontainer");
          self2.weekdayContainer.appendChild(container);
        }
        updateWeekdays();
        return self2.weekdayContainer;
      }
      function updateWeekdays() {
        if (!self2.weekdayContainer) {
          return;
        }
        var firstDayOfWeek = self2.l10n.firstDayOfWeek;
        var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
        if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
          weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
        }
        for (var i2 = self2.config.showMonths; i2--; ) {
          self2.weekdayContainer.children[i2].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
        }
      }
      function buildWeeks() {
        self2.calendarContainer.classList.add("hasWeeks");
        var weekWrapper = createElement("div", "flatpickr-weekwrapper");
        weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
        var weekNumbers = createElement("div", "flatpickr-weeks");
        weekWrapper.appendChild(weekNumbers);
        return {
          weekWrapper,
          weekNumbers
        };
      }
      function changeMonth(value, isOffset) {
        if (isOffset === void 0) {
          isOffset = true;
        }
        var delta = isOffset ? value : value - self2.currentMonth;
        if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
          return;
        self2.currentMonth += delta;
        if (self2.currentMonth < 0 || self2.currentMonth > 11) {
          self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
          self2.currentMonth = (self2.currentMonth + 12) % 12;
          triggerEvent("onYearChange");
          buildMonthSwitch();
        }
        buildDays();
        triggerEvent("onMonthChange");
        updateNavigationCurrentMonth();
      }
      function clear2(triggerChangeEvent, toInitial) {
        if (triggerChangeEvent === void 0) {
          triggerChangeEvent = true;
        }
        if (toInitial === void 0) {
          toInitial = true;
        }
        self2.input.value = "";
        if (self2.altInput !== void 0)
          self2.altInput.value = "";
        if (self2.mobileInput !== void 0)
          self2.mobileInput.value = "";
        self2.selectedDates = [];
        self2.latestSelectedDateObj = void 0;
        if (toInitial === true) {
          self2.currentYear = self2._initialDate.getFullYear();
          self2.currentMonth = self2._initialDate.getMonth();
        }
        if (self2.config.enableTime === true) {
          var _a = getDefaultHours(self2.config), hours2 = _a.hours, minutes2 = _a.minutes, seconds2 = _a.seconds;
          setHours(hours2, minutes2, seconds2);
        }
        self2.redraw();
        if (triggerChangeEvent)
          triggerEvent("onChange");
      }
      function close() {
        self2.isOpen = false;
        if (!self2.isMobile) {
          if (self2.calendarContainer !== void 0) {
            self2.calendarContainer.classList.remove("open");
          }
          if (self2._input !== void 0) {
            self2._input.classList.remove("active");
          }
        }
        triggerEvent("onClose");
      }
      function destroy() {
        if (self2.config !== void 0)
          triggerEvent("onDestroy");
        for (var i2 = self2._handlers.length; i2--; ) {
          self2._handlers[i2].remove();
        }
        self2._handlers = [];
        if (self2.mobileInput) {
          if (self2.mobileInput.parentNode)
            self2.mobileInput.parentNode.removeChild(self2.mobileInput);
          self2.mobileInput = void 0;
        } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
          if (self2.config.static && self2.calendarContainer.parentNode) {
            var wrapper = self2.calendarContainer.parentNode;
            wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
            if (wrapper.parentNode) {
              while (wrapper.firstChild)
                wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
              wrapper.parentNode.removeChild(wrapper);
            }
          } else
            self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
        }
        if (self2.altInput) {
          self2.input.type = "text";
          if (self2.altInput.parentNode)
            self2.altInput.parentNode.removeChild(self2.altInput);
          delete self2.altInput;
        }
        if (self2.input) {
          self2.input.type = self2.input._type;
          self2.input.classList.remove("flatpickr-input");
          self2.input.removeAttribute("readonly");
        }
        [
          "_showTimeInput",
          "latestSelectedDateObj",
          "_hideNextMonthArrow",
          "_hidePrevMonthArrow",
          "__hideNextMonthArrow",
          "__hidePrevMonthArrow",
          "isMobile",
          "isOpen",
          "selectedDateElem",
          "minDateHasTime",
          "maxDateHasTime",
          "days",
          "daysContainer",
          "_input",
          "_positionElement",
          "innerContainer",
          "rContainer",
          "monthNav",
          "todayDateElem",
          "calendarContainer",
          "weekdayContainer",
          "prevMonthNav",
          "nextMonthNav",
          "monthsDropdownContainer",
          "currentMonthElement",
          "currentYearElement",
          "navigationCurrentMonth",
          "selectedDateElem",
          "config"
        ].forEach(function(k2) {
          try {
            delete self2[k2];
          } catch (_2) {
          }
        });
      }
      function isCalendarElem(elem) {
        return self2.calendarContainer.contains(elem);
      }
      function documentClick(e2) {
        if (self2.isOpen && !self2.config.inline) {
          var eventTarget_1 = getEventTarget(e2);
          var isCalendarElement = isCalendarElem(eventTarget_1);
          var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e2.path && e2.path.indexOf && (~e2.path.indexOf(self2.input) || ~e2.path.indexOf(self2.altInput));
          var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e2.relatedTarget);
          var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
            return elem.contains(eventTarget_1);
          });
          if (lostFocus && isIgnored) {
            if (self2.config.allowInput) {
              self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
            }
            if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
              updateTime();
            }
            self2.close();
            if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
              self2.clear(false);
          }
        }
      }
      function changeYear(newYear) {
        if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
          return;
        var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
        self2.currentYear = newYearNum || self2.currentYear;
        if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
          self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
        } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
          self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
        }
        if (isNewYear) {
          self2.redraw();
          triggerEvent("onYearChange");
          buildMonthSwitch();
        }
      }
      function isEnabled(date2, timeless) {
        var _a;
        if (timeless === void 0) {
          timeless = true;
        }
        var dateToCheck = self2.parseDate(date2, void 0, timeless);
        if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
          return false;
        if (!self2.config.enable && self2.config.disable.length === 0)
          return true;
        if (dateToCheck === void 0)
          return false;
        var bool = !!self2.config.enable, array2 = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
        for (var i2 = 0, d2 = void 0; i2 < array2.length; i2++) {
          d2 = array2[i2];
          if (typeof d2 === "function" && d2(dateToCheck))
            return bool;
          else if (d2 instanceof Date && dateToCheck !== void 0 && d2.getTime() === dateToCheck.getTime())
            return bool;
          else if (typeof d2 === "string") {
            var parsed = self2.parseDate(d2, void 0, true);
            return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
          } else if (typeof d2 === "object" && dateToCheck !== void 0 && d2.from && d2.to && dateToCheck.getTime() >= d2.from.getTime() && dateToCheck.getTime() <= d2.to.getTime())
            return bool;
        }
        return !bool;
      }
      function isInView(elem) {
        if (self2.daysContainer !== void 0)
          return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
        return false;
      }
      function onBlur(e2) {
        var isInput = e2.target === self2._input;
        var valueChanged = self2._input.value.trimEnd() !== getDateStr();
        if (isInput && valueChanged && !(e2.relatedTarget && isCalendarElem(e2.relatedTarget))) {
          self2.setDate(self2._input.value, true, e2.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
        }
      }
      function onKeyDown(e2) {
        var eventTarget = getEventTarget(e2);
        var isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
        var allowInput = self2.config.allowInput;
        var allowKeydown = self2.isOpen && (!allowInput || !isInput);
        var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
        if (e2.keyCode === 13 && isInput) {
          if (allowInput) {
            self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
            self2.close();
            return eventTarget.blur();
          } else {
            self2.open();
          }
        } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
          var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
          switch (e2.keyCode) {
            case 13:
              if (isTimeObj) {
                e2.preventDefault();
                updateTime();
                focusAndClose();
              } else
                selectDate(e2);
              break;
            case 27:
              e2.preventDefault();
              focusAndClose();
              break;
            case 8:
            case 46:
              if (isInput && !self2.config.allowInput) {
                e2.preventDefault();
                self2.clear();
              }
              break;
            case 37:
            case 39:
              if (!isTimeObj && !isInput) {
                e2.preventDefault();
                var activeElement = getClosestActiveElement();
                if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
                  var delta_1 = e2.keyCode === 39 ? 1 : -1;
                  if (!e2.ctrlKey)
                    focusOnDay(void 0, delta_1);
                  else {
                    e2.stopPropagation();
                    changeMonth(delta_1);
                    focusOnDay(getFirstAvailableDay(1), 0);
                  }
                }
              } else if (self2.hourElement)
                self2.hourElement.focus();
              break;
            case 38:
            case 40:
              e2.preventDefault();
              var delta = e2.keyCode === 40 ? 1 : -1;
              if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
                if (e2.ctrlKey) {
                  e2.stopPropagation();
                  changeYear(self2.currentYear - delta);
                  focusOnDay(getFirstAvailableDay(1), 0);
                } else if (!isTimeObj)
                  focusOnDay(void 0, delta * 7);
              } else if (eventTarget === self2.currentYearElement) {
                changeYear(self2.currentYear - delta);
              } else if (self2.config.enableTime) {
                if (!isTimeObj && self2.hourElement)
                  self2.hourElement.focus();
                updateTime(e2);
                self2._debouncedChange();
              }
              break;
            case 9:
              if (isTimeObj) {
                var elems = [
                  self2.hourElement,
                  self2.minuteElement,
                  self2.secondElement,
                  self2.amPM
                ].concat(self2.pluginElements).filter(function(x2) {
                  return x2;
                });
                var i2 = elems.indexOf(eventTarget);
                if (i2 !== -1) {
                  var target = elems[i2 + (e2.shiftKey ? -1 : 1)];
                  e2.preventDefault();
                  (target || self2._input).focus();
                }
              } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e2.shiftKey) {
                e2.preventDefault();
                self2._input.focus();
              }
              break;
          }
        }
        if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
          switch (e2.key) {
            case self2.l10n.amPM[0].charAt(0):
            case self2.l10n.amPM[0].charAt(0).toLowerCase():
              self2.amPM.textContent = self2.l10n.amPM[0];
              setHoursFromInputs();
              updateValue();
              break;
            case self2.l10n.amPM[1].charAt(0):
            case self2.l10n.amPM[1].charAt(0).toLowerCase():
              self2.amPM.textContent = self2.l10n.amPM[1];
              setHoursFromInputs();
              updateValue();
              break;
          }
        }
        if (isInput || isCalendarElem(eventTarget)) {
          triggerEvent("onKeyDown", e2);
        }
      }
      function onMouseOver(elem, cellClass) {
        if (cellClass === void 0) {
          cellClass = "flatpickr-day";
        }
        if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
          return;
        var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
        var containsDisabled = false;
        var minRange = 0, maxRange = 0;
        for (var t2 = rangeStartDate; t2 < rangeEndDate; t2 += duration.DAY) {
          if (!isEnabled(new Date(t2), true)) {
            containsDisabled = containsDisabled || t2 > rangeStartDate && t2 < rangeEndDate;
            if (t2 < initialDate && (!minRange || t2 > minRange))
              minRange = t2;
            else if (t2 > initialDate && (!maxRange || t2 < maxRange))
              maxRange = t2;
          }
        }
        var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
        hoverableCells.forEach(function(dayElem) {
          var date2 = dayElem.dateObj;
          var timestamp = date2.getTime();
          var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
          if (outOfRange) {
            dayElem.classList.add("notAllowed");
            ["inRange", "startRange", "endRange"].forEach(function(c2) {
              dayElem.classList.remove(c2);
            });
            return;
          } else if (containsDisabled && !outOfRange)
            return;
          ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c2) {
            dayElem.classList.remove(c2);
          });
          if (elem !== void 0) {
            elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
            if (initialDate < hoverDate && timestamp === initialDate)
              dayElem.classList.add("startRange");
            else if (initialDate > hoverDate && timestamp === initialDate)
              dayElem.classList.add("endRange");
            if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
              dayElem.classList.add("inRange");
          }
        });
      }
      function onResize() {
        if (self2.isOpen && !self2.config.static && !self2.config.inline)
          positionCalendar();
      }
      function open(e2, positionElement) {
        if (positionElement === void 0) {
          positionElement = self2._positionElement;
        }
        if (self2.isMobile === true) {
          if (e2) {
            e2.preventDefault();
            var eventTarget = getEventTarget(e2);
            if (eventTarget) {
              eventTarget.blur();
            }
          }
          if (self2.mobileInput !== void 0) {
            self2.mobileInput.focus();
            self2.mobileInput.click();
          }
          triggerEvent("onOpen");
          return;
        } else if (self2._input.disabled || self2.config.inline) {
          return;
        }
        var wasOpen = self2.isOpen;
        self2.isOpen = true;
        if (!wasOpen) {
          self2.calendarContainer.classList.add("open");
          self2._input.classList.add("active");
          triggerEvent("onOpen");
          positionCalendar(positionElement);
        }
        if (self2.config.enableTime === true && self2.config.noCalendar === true) {
          if (self2.config.allowInput === false && (e2 === void 0 || !self2.timeContainer.contains(e2.relatedTarget))) {
            setTimeout(function() {
              return self2.hourElement.select();
            }, 50);
          }
        }
      }
      function minMaxDateSetter(type) {
        return function(date2) {
          var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date2, self2.config.dateFormat);
          var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
          if (dateObj !== void 0) {
            self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
          }
          if (self2.selectedDates) {
            self2.selectedDates = self2.selectedDates.filter(function(d2) {
              return isEnabled(d2);
            });
            if (!self2.selectedDates.length && type === "min")
              setHoursFromDate(dateObj);
            updateValue();
          }
          if (self2.daysContainer) {
            redraw();
            if (dateObj !== void 0)
              self2.currentYearElement[type] = dateObj.getFullYear().toString();
            else
              self2.currentYearElement.removeAttribute(type);
            self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
          }
        };
      }
      function parseConfig() {
        var boolOpts = [
          "wrap",
          "weekNumbers",
          "allowInput",
          "allowInvalidPreload",
          "clickOpens",
          "time_24hr",
          "enableTime",
          "noCalendar",
          "altInput",
          "shorthandCurrentMonth",
          "inline",
          "static",
          "enableSeconds",
          "disableMobile"
        ];
        var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
        var formats2 = {};
        self2.config.parseDate = userConfig.parseDate;
        self2.config.formatDate = userConfig.formatDate;
        Object.defineProperty(self2.config, "enable", {
          get: function() {
            return self2.config._enable;
          },
          set: function(dates2) {
            self2.config._enable = parseDateRules(dates2);
          }
        });
        Object.defineProperty(self2.config, "disable", {
          get: function() {
            return self2.config._disable;
          },
          set: function(dates2) {
            self2.config._disable = parseDateRules(dates2);
          }
        });
        var timeMode = userConfig.mode === "time";
        if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
          var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults$1.dateFormat;
          formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
        }
        if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
          var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults$1.altFormat;
          formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
        }
        Object.defineProperty(self2.config, "minDate", {
          get: function() {
            return self2.config._minDate;
          },
          set: minMaxDateSetter("min")
        });
        Object.defineProperty(self2.config, "maxDate", {
          get: function() {
            return self2.config._maxDate;
          },
          set: minMaxDateSetter("max")
        });
        var minMaxTimeSetter = function(type) {
          return function(val) {
            self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
          };
        };
        Object.defineProperty(self2.config, "minTime", {
          get: function() {
            return self2.config._minTime;
          },
          set: minMaxTimeSetter("min")
        });
        Object.defineProperty(self2.config, "maxTime", {
          get: function() {
            return self2.config._maxTime;
          },
          set: minMaxTimeSetter("max")
        });
        if (userConfig.mode === "time") {
          self2.config.noCalendar = true;
          self2.config.enableTime = true;
        }
        Object.assign(self2.config, formats2, userConfig);
        for (var i2 = 0; i2 < boolOpts.length; i2++)
          self2.config[boolOpts[i2]] = self2.config[boolOpts[i2]] === true || self2.config[boolOpts[i2]] === "true";
        HOOKS.filter(function(hook) {
          return self2.config[hook] !== void 0;
        }).forEach(function(hook) {
          self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
        });
        self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        for (var i2 = 0; i2 < self2.config.plugins.length; i2++) {
          var pluginConf = self2.config.plugins[i2](self2) || {};
          for (var key in pluginConf) {
            if (HOOKS.indexOf(key) > -1) {
              self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
            } else if (typeof userConfig[key] === "undefined")
              self2.config[key] = pluginConf[key];
          }
        }
        if (!userConfig.altInputClass) {
          self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
        }
        triggerEvent("onParseConfig");
      }
      function getInputElem() {
        return self2.config.wrap ? element.querySelector("[data-input]") : element;
      }
      function setupLocale() {
        if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
          self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
        self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
        tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
        tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
        tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
        tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
        tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
        var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
        if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
          self2.config.time_24hr = self2.l10n.time_24hr;
        }
        self2.formatDate = createDateFormatter(self2);
        self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
      }
      function positionCalendar(customPositionElement) {
        if (typeof self2.config.position === "function") {
          return void self2.config.position(self2, customPositionElement);
        }
        if (self2.calendarContainer === void 0)
          return;
        triggerEvent("onPreCalendarPosition");
        var positionElement = customPositionElement || self2._positionElement;
        var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
          return acc + child.offsetHeight;
        }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
        var top2 = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
        toggleClass$1(self2.calendarContainer, "arrowTop", !showOnTop);
        toggleClass$1(self2.calendarContainer, "arrowBottom", showOnTop);
        if (self2.config.inline)
          return;
        var left2 = window.pageXOffset + inputBounds.left;
        var isCenter = false;
        var isRight = false;
        if (configPosHorizontal === "center") {
          left2 -= (calendarWidth - inputBounds.width) / 2;
          isCenter = true;
        } else if (configPosHorizontal === "right") {
          left2 -= calendarWidth - inputBounds.width;
          isRight = true;
        }
        toggleClass$1(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
        toggleClass$1(self2.calendarContainer, "arrowCenter", isCenter);
        toggleClass$1(self2.calendarContainer, "arrowRight", isRight);
        var right2 = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
        var rightMost = left2 + calendarWidth > window.document.body.offsetWidth;
        var centerMost = right2 + calendarWidth > window.document.body.offsetWidth;
        toggleClass$1(self2.calendarContainer, "rightMost", rightMost);
        if (self2.config.static)
          return;
        self2.calendarContainer.style.top = top2 + "px";
        if (!rightMost) {
          self2.calendarContainer.style.left = left2 + "px";
          self2.calendarContainer.style.right = "auto";
        } else if (!centerMost) {
          self2.calendarContainer.style.left = "auto";
          self2.calendarContainer.style.right = right2 + "px";
        } else {
          var doc2 = getDocumentStyleSheet();
          if (doc2 === void 0)
            return;
          var bodyWidth = window.document.body.offsetWidth;
          var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
          var centerBefore = ".flatpickr-calendar.centerMost:before";
          var centerAfter = ".flatpickr-calendar.centerMost:after";
          var centerIndex = doc2.cssRules.length;
          var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
          toggleClass$1(self2.calendarContainer, "rightMost", false);
          toggleClass$1(self2.calendarContainer, "centerMost", true);
          doc2.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
          self2.calendarContainer.style.left = centerLeft + "px";
          self2.calendarContainer.style.right = "auto";
        }
      }
      function getDocumentStyleSheet() {
        var editableSheet = null;
        for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
          var sheet = document.styleSheets[i2];
          if (!sheet.cssRules)
            continue;
          try {
            sheet.cssRules;
          } catch (err) {
            continue;
          }
          editableSheet = sheet;
          break;
        }
        return editableSheet != null ? editableSheet : createStyleSheet();
      }
      function createStyleSheet() {
        var style = document.createElement("style");
        document.head.appendChild(style);
        return style.sheet;
      }
      function redraw() {
        if (self2.config.noCalendar || self2.isMobile)
          return;
        buildMonthSwitch();
        updateNavigationCurrentMonth();
        buildDays();
      }
      function focusAndClose() {
        self2._input.focus();
        if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
          setTimeout(self2.close, 0);
        } else {
          self2.close();
        }
      }
      function selectDate(e2) {
        e2.preventDefault();
        e2.stopPropagation();
        var isSelectable = function(day) {
          return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
        };
        var t2 = findParent(getEventTarget(e2), isSelectable);
        if (t2 === void 0)
          return;
        var target = t2;
        var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
        var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
        self2.selectedDateElem = target;
        if (self2.config.mode === "single")
          self2.selectedDates = [selectedDate];
        else if (self2.config.mode === "multiple") {
          var selectedIndex = isDateSelected(selectedDate);
          if (selectedIndex)
            self2.selectedDates.splice(parseInt(selectedIndex), 1);
          else
            self2.selectedDates.push(selectedDate);
        } else if (self2.config.mode === "range") {
          if (self2.selectedDates.length === 2) {
            self2.clear(false, false);
          }
          self2.latestSelectedDateObj = selectedDate;
          self2.selectedDates.push(selectedDate);
          if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
            self2.selectedDates.sort(function(a2, b2) {
              return a2.getTime() - b2.getTime();
            });
        }
        setHoursFromInputs();
        if (shouldChangeMonth) {
          var isNewYear = self2.currentYear !== selectedDate.getFullYear();
          self2.currentYear = selectedDate.getFullYear();
          self2.currentMonth = selectedDate.getMonth();
          if (isNewYear) {
            triggerEvent("onYearChange");
            buildMonthSwitch();
          }
          triggerEvent("onMonthChange");
        }
        updateNavigationCurrentMonth();
        buildDays();
        updateValue();
        if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
          focusOnDayElem(target);
        else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
          self2.selectedDateElem && self2.selectedDateElem.focus();
        }
        if (self2.hourElement !== void 0)
          self2.hourElement !== void 0 && self2.hourElement.focus();
        if (self2.config.closeOnSelect) {
          var single = self2.config.mode === "single" && !self2.config.enableTime;
          var range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
          if (single || range) {
            focusAndClose();
          }
        }
        triggerChange();
      }
      var CALLBACKS = {
        locale: [setupLocale, updateWeekdays],
        showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
        minDate: [jumpToDate],
        maxDate: [jumpToDate],
        positionElement: [updatePositionElement],
        clickOpens: [
          function() {
            if (self2.config.clickOpens === true) {
              bind2(self2._input, "focus", self2.open);
              bind2(self2._input, "click", self2.open);
            } else {
              self2._input.removeEventListener("focus", self2.open);
              self2._input.removeEventListener("click", self2.open);
            }
          }
        ]
      };
      function set2(option, value) {
        if (option !== null && typeof option === "object") {
          Object.assign(self2.config, option);
          for (var key in option) {
            if (CALLBACKS[key] !== void 0)
              CALLBACKS[key].forEach(function(x2) {
                return x2();
              });
          }
        } else {
          self2.config[option] = value;
          if (CALLBACKS[option] !== void 0)
            CALLBACKS[option].forEach(function(x2) {
              return x2();
            });
          else if (HOOKS.indexOf(option) > -1)
            self2.config[option] = arrayify(value);
        }
        self2.redraw();
        updateValue(true);
      }
      function setSelectedDate(inputDate, format2) {
        var dates2 = [];
        if (inputDate instanceof Array)
          dates2 = inputDate.map(function(d2) {
            return self2.parseDate(d2, format2);
          });
        else if (inputDate instanceof Date || typeof inputDate === "number")
          dates2 = [self2.parseDate(inputDate, format2)];
        else if (typeof inputDate === "string") {
          switch (self2.config.mode) {
            case "single":
            case "time":
              dates2 = [self2.parseDate(inputDate, format2)];
              break;
            case "multiple":
              dates2 = inputDate.split(self2.config.conjunction).map(function(date2) {
                return self2.parseDate(date2, format2);
              });
              break;
            case "range":
              dates2 = inputDate.split(self2.l10n.rangeSeparator).map(function(date2) {
                return self2.parseDate(date2, format2);
              });
              break;
          }
        } else
          self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
        self2.selectedDates = self2.config.allowInvalidPreload ? dates2 : dates2.filter(function(d2) {
          return d2 instanceof Date && isEnabled(d2, false);
        });
        if (self2.config.mode === "range")
          self2.selectedDates.sort(function(a2, b2) {
            return a2.getTime() - b2.getTime();
          });
      }
      function setDate(date2, triggerChange2, format2) {
        if (triggerChange2 === void 0) {
          triggerChange2 = false;
        }
        if (format2 === void 0) {
          format2 = self2.config.dateFormat;
        }
        if (date2 !== 0 && !date2 || date2 instanceof Array && date2.length === 0)
          return self2.clear(triggerChange2);
        setSelectedDate(date2, format2);
        self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
        self2.redraw();
        jumpToDate(void 0, triggerChange2);
        setHoursFromDate();
        if (self2.selectedDates.length === 0) {
          self2.clear(false);
        }
        updateValue(triggerChange2);
        if (triggerChange2)
          triggerEvent("onChange");
      }
      function parseDateRules(arr) {
        return arr.slice().map(function(rule) {
          if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
            return self2.parseDate(rule, void 0, true);
          } else if (rule && typeof rule === "object" && rule.from && rule.to)
            return {
              from: self2.parseDate(rule.from, void 0),
              to: self2.parseDate(rule.to, void 0)
            };
          return rule;
        }).filter(function(x2) {
          return x2;
        });
      }
      function setupDates() {
        self2.selectedDates = [];
        self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
        var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
        if (preloadedDate)
          setSelectedDate(preloadedDate, self2.config.dateFormat);
        self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
        self2.currentYear = self2._initialDate.getFullYear();
        self2.currentMonth = self2._initialDate.getMonth();
        if (self2.selectedDates.length > 0)
          self2.latestSelectedDateObj = self2.selectedDates[0];
        if (self2.config.minTime !== void 0)
          self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
        if (self2.config.maxTime !== void 0)
          self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
        self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
        self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
      }
      function setupInputs() {
        self2.input = getInputElem();
        if (!self2.input) {
          self2.config.errorHandler(new Error("Invalid input element specified"));
          return;
        }
        self2.input._type = self2.input.type;
        self2.input.type = "text";
        self2.input.classList.add("flatpickr-input");
        self2._input = self2.input;
        if (self2.config.altInput) {
          self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
          self2._input = self2.altInput;
          self2.altInput.placeholder = self2.input.placeholder;
          self2.altInput.disabled = self2.input.disabled;
          self2.altInput.required = self2.input.required;
          self2.altInput.tabIndex = self2.input.tabIndex;
          self2.altInput.type = "text";
          self2.input.setAttribute("type", "hidden");
          if (!self2.config.static && self2.input.parentNode)
            self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
        }
        if (!self2.config.allowInput)
          self2._input.setAttribute("readonly", "readonly");
        updatePositionElement();
      }
      function updatePositionElement() {
        self2._positionElement = self2.config.positionElement || self2._input;
      }
      function setupMobile() {
        var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
        self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
        self2.mobileInput.tabIndex = 1;
        self2.mobileInput.type = inputType;
        self2.mobileInput.disabled = self2.input.disabled;
        self2.mobileInput.required = self2.input.required;
        self2.mobileInput.placeholder = self2.input.placeholder;
        self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
        if (self2.selectedDates.length > 0) {
          self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
        }
        if (self2.config.minDate)
          self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
        if (self2.config.maxDate)
          self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
        if (self2.input.getAttribute("step"))
          self2.mobileInput.step = String(self2.input.getAttribute("step"));
        self2.input.type = "hidden";
        if (self2.altInput !== void 0)
          self2.altInput.type = "hidden";
        try {
          if (self2.input.parentNode)
            self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
        } catch (_a) {
        }
        bind2(self2.mobileInput, "change", function(e2) {
          self2.setDate(getEventTarget(e2).value, false, self2.mobileFormatStr);
          triggerEvent("onChange");
          triggerEvent("onClose");
        });
      }
      function toggle2(e2) {
        if (self2.isOpen === true)
          return self2.close();
        self2.open(e2);
      }
      function triggerEvent(event, data) {
        if (self2.config === void 0)
          return;
        var hooks2 = self2.config[event];
        if (hooks2 !== void 0 && hooks2.length > 0) {
          for (var i2 = 0; hooks2[i2] && i2 < hooks2.length; i2++)
            hooks2[i2](self2.selectedDates, self2.input.value, self2, data);
        }
        if (event === "onChange") {
          self2.input.dispatchEvent(createEvent("change"));
          self2.input.dispatchEvent(createEvent("input"));
        }
      }
      function createEvent(name2) {
        var e2 = document.createEvent("Event");
        e2.initEvent(name2, true, true);
        return e2;
      }
      function isDateSelected(date2) {
        for (var i2 = 0; i2 < self2.selectedDates.length; i2++) {
          var selectedDate = self2.selectedDates[i2];
          if (selectedDate instanceof Date && compareDates(selectedDate, date2) === 0)
            return "" + i2;
        }
        return false;
      }
      function isDateInRange(date2) {
        if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
          return false;
        return compareDates(date2, self2.selectedDates[0]) >= 0 && compareDates(date2, self2.selectedDates[1]) <= 0;
      }
      function updateNavigationCurrentMonth() {
        if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
          return;
        self2.yearElements.forEach(function(yearElement, i2) {
          var d2 = new Date(self2.currentYear, self2.currentMonth, 1);
          d2.setMonth(self2.currentMonth + i2);
          if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
            self2.monthElements[i2].textContent = monthToStr(d2.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
          } else {
            self2.monthsDropdownContainer.value = d2.getMonth().toString();
          }
          yearElement.value = d2.getFullYear().toString();
        });
        self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
        self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
      }
      function getDateStr(specificFormat) {
        var format2 = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
        return self2.selectedDates.map(function(dObj) {
          return self2.formatDate(dObj, format2);
        }).filter(function(d2, i2, arr) {
          return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d2) === i2;
        }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
      }
      function updateValue(triggerChange2) {
        if (triggerChange2 === void 0) {
          triggerChange2 = true;
        }
        if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
          self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
        }
        self2.input.value = getDateStr(self2.config.dateFormat);
        if (self2.altInput !== void 0) {
          self2.altInput.value = getDateStr(self2.config.altFormat);
        }
        if (triggerChange2 !== false)
          triggerEvent("onValueUpdate");
      }
      function onMonthNavClick(e2) {
        var eventTarget = getEventTarget(e2);
        var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
        var isNextMonth = self2.nextMonthNav.contains(eventTarget);
        if (isPrevMonth || isNextMonth) {
          changeMonth(isPrevMonth ? -1 : 1);
        } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
          eventTarget.select();
        } else if (eventTarget.classList.contains("arrowUp")) {
          self2.changeYear(self2.currentYear + 1);
        } else if (eventTarget.classList.contains("arrowDown")) {
          self2.changeYear(self2.currentYear - 1);
        }
      }
      function timeWrapper(e2) {
        e2.preventDefault();
        var isKeyDown = e2.type === "keydown", eventTarget = getEventTarget(e2), input = eventTarget;
        if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
          self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
        }
        var min2 = parseFloat(input.getAttribute("min")), max2 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e2.delta || (isKeyDown ? e2.which === 38 ? 1 : -1 : 0);
        var newValue = curValue + step * delta;
        if (typeof input.value !== "undefined" && input.value.length === 2) {
          var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
          if (newValue < min2) {
            newValue = max2 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
            if (isMinuteElem)
              incrementNumInput(void 0, -1, self2.hourElement);
          } else if (newValue > max2) {
            newValue = input === self2.hourElement ? newValue - max2 - int(!self2.amPM) : min2;
            if (isMinuteElem)
              incrementNumInput(void 0, 1, self2.hourElement);
          }
          if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
            self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
          }
          input.value = pad(newValue);
        }
      }
      init();
      return self2;
    }
    function _flatpickr(nodeList, config2) {
      var nodes = Array.prototype.slice.call(nodeList).filter(function(x2) {
        return x2 instanceof HTMLElement;
      });
      var instances = [];
      for (var i2 = 0; i2 < nodes.length; i2++) {
        var node = nodes[i2];
        try {
          if (node.getAttribute("data-fp-omit") !== null)
            continue;
          if (node._flatpickr !== void 0) {
            node._flatpickr.destroy();
            node._flatpickr = void 0;
          }
          node._flatpickr = FlatpickrInstance(node, config2 || {});
          instances.push(node._flatpickr);
        } catch (e2) {
          console.error(e2);
        }
      }
      return instances.length === 1 ? instances[0] : instances;
    }
    if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
      HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config2) {
        return _flatpickr(this, config2);
      };
      HTMLElement.prototype.flatpickr = function(config2) {
        return _flatpickr([this], config2);
      };
    }
    var flatpickr = function(selector, config2) {
      if (typeof selector === "string") {
        return _flatpickr(window.document.querySelectorAll(selector), config2);
      } else if (selector instanceof Node) {
        return _flatpickr([selector], config2);
      } else {
        return _flatpickr(selector, config2);
      }
    };
    flatpickr.defaultConfig = {};
    flatpickr.l10ns = {
      en: __assign({}, english),
      default: __assign({}, english)
    };
    flatpickr.localize = function(l10n) {
      flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
    };
    flatpickr.setDefaults = function(config2) {
      flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config2);
    };
    flatpickr.parseDate = createDateParser({});
    flatpickr.formatDate = createDateFormatter({});
    flatpickr.compareDates = compareDates;
    if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
      jQuery.fn.flatpickr = function(config2) {
        return _flatpickr(this, config2);
      };
    }
    Date.prototype.fp_incr = function(days2) {
      return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days2 === "string" ? parseInt(days2, 10) : days2));
    };
    if (typeof window !== "undefined") {
      window.flatpickr = flatpickr;
    }
    var DatepickerWrapper = {
      name: "DatepickerWrapper",
      emits: ["change"],
      props: {
        value: {
          required: true
        },
        options: {
          type: [Object],
          required: true
        },
        id: {
          type: [Number, String],
          required: true
        },
        placeholder: {
          type: [Number, String],
          required: false
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        }
      },
      setup(props, context) {
        var {
          id,
          options,
          value
        } = toRefs(props);
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var moment = form$.value.$vueform.services.moment;
        var $this = getCurrentInstance().proxy;
        var datepicker$ = ref(null);
        var input = ref(null);
        var available = computed(() => {
          return el$.value.available;
        });
        var locale2 = computed(() => {
          var _$this$$vueform$i18n$, _$this$$vueform$i18n$2;
          return ((_$this$$vueform$i18n$ = $this.$vueform.i18n.locales[form$.value.locale$]) === null || _$this$$vueform$i18n$ === void 0 || (_$this$$vueform$i18n$ = _$this$$vueform$i18n$.vueform) === null || _$this$$vueform$i18n$ === void 0 ? void 0 : _$this$$vueform$i18n$.datepicker) || ((_$this$$vueform$i18n$2 = $this.$vueform.i18n.locales[$this.$vueform.i18n.fallbackLocale]) === null || _$this$$vueform$i18n$2 === void 0 || (_$this$$vueform$i18n$2 = _$this$$vueform$i18n$2.vueform) === null || _$this$$vueform$i18n$2 === void 0 ? void 0 : _$this$$vueform$i18n$2.datepicker) || {};
        });
        var mode = computed(() => {
          return options.value.mode || "single";
        });
        var config2 = computed(() => {
          var config3 = {};
          each(options.value, (val, option) => {
            if (val !== null && val !== void 0) {
              config3[option] = val;
            }
          });
          config3.static = true;
          return config3;
        });
        var update = (val) => {
          context.emit("change", mode.value == "single" ? val[0] || null : val);
        };
        var setDatepickerId = () => {
          datepicker$.value.input.parentElement.id = "datepicker-" + id.value;
        };
        var init = /* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(function* () {
            if (!input.value) {
              yield nextTick();
            }
            datepicker$.value = flatpickr(input.value, Object.assign({}, config2.value, {
              onChange: (val) => {
                update(val);
              },
              onClose: (val) => {
                val = mode.value == "range" && val.length < 2 ? [] : val;
                update(val);
              },
              // creating a date object from a string date provided in displayFormat (to value)
              parseDate: (dateStr, format2) => {
                return moment(dateStr, format2, true).toDate();
              },
              // creating a date string according to displayFormat (to display)
              formatDate: (date2, format2) => {
                return moment(date2).format(format2);
              },
              ariaDateFormat: "MMMM D, YYYY",
              disableMobile: true,
              locale: locale2.value
            }));
            if (datepicker$.value.calendarContainer) {
              classes2.value.calendarContainer.forEach((c2) => {
                datepicker$.value.calendarContainer.classList.add(c2);
              });
            }
            setDatepickerId();
            if (value.value !== null) {
              datepicker$.value.setDate(value.value, false);
            }
          });
          return function init2() {
            return _ref.apply(this, arguments);
          };
        }();
        watch(value, (n2, o2) => {
          var _datepicker$$value;
          (_datepicker$$value = datepicker$.value) === null || _datepicker$$value === void 0 || _datepicker$$value.setDate(n2, false);
        });
        watch(id, (n2, o2) => {
          setDatepickerId();
        }, {
          immediate: false
        });
        watch(options, (n2, o2) => {
          if (isEqual_1(n2, o2)) {
            return;
          }
          init();
        }, {
          deep: true
        });
        watch([locale2, available], (n2, o2) => {
          init();
        }, {
          deep: true
        });
        onMounted(() => {
          init();
        });
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          theme,
          classes: classes2,
          Templates,
          template,
          datepicker$,
          input,
          config: config2,
          mode,
          locale: locale2,
          update,
          init
        };
      }
    };
    var EditorWrapper = {
      name: "EditorWrapper",
      emits: ["input", "alert", "error", "blur"],
      props: {
        value: {
          required: false,
          default: null
        },
        placeholder: {
          required: false,
          type: [String, Number],
          default: null
        },
        name: {
          required: false,
          type: [String, Number],
          default: null
        },
        id: {
          required: false,
          type: [String, Number],
          default: null
        },
        accept: {
          required: false,
          type: Array,
          default: () => []
        },
        acceptMimes: {
          required: false,
          type: Array,
          default: () => []
        },
        endpoint: {
          required: false,
          type: [String, Function, Promise],
          default: null
        },
        method: {
          required: false,
          type: String,
          default: "post"
        },
        disabled: {
          required: false,
          type: Boolean,
          default: false
        },
        hideTools: {
          required: false,
          type: [Array],
          default: () => []
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        }
      },
      setup(props, context) {
        var {
          value,
          disabled,
          acceptMimes,
          accept,
          endpoint,
          method,
          attrs,
          placeholder,
          id
        } = toRefs(props);
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var trix$ = ref(null);
        var editor$ = computed(() => {
          return trix$.value.$el || trix$.value;
        });
        var resolvedEndpoint = computed(() => {
          if (endpoint.value) {
            return typeof endpoint.value === "function" ? endpoint.value : form$.value.$vueform.config.endpoints[endpoint.value] || endpoint.value;
          }
          return typeof form$.value.$vueform.config.endpoints.attachment === "function" ? form$.value.$vueform.config.endpoints.attachment : form$.value.$vueform.config.endpoints.attachment.url;
        });
        var resolvedMethod = computed(() => {
          if (typeof resolvedEndpoint.value === "function") {
            return null;
          }
          if (endpoint.value && form$.value.$vueform.config.endpoints[endpoint.value]) {
            return form$.value.$vueform.config.endpoints[endpoint.value];
          }
          return method.value || form$.value.$vueform.config.endpoints.attachment.method;
        });
        var options = computed(() => {
          return _objectSpread2$1(_objectSpread2$1({}, attrs.value), {}, {
            placeholder: placeholder.value,
            disabled: disabled.value,
            id: id.value,
            input: "editor-input-".concat(id.value)
          });
        });
        var update = (val) => {
          if (typeof val == "number") {
            val = String(val);
          }
          if (val === null || val === void 0) {
            val = "";
          }
          if (editor$.value.editor) {
            editor$.value.editor.loadHTML(val);
          } else {
            setTimeout(() => {
              var _editor$$value$editor;
              (_editor$$value$editor = editor$.value.editor) === null || _editor$$value$editor === void 0 || _editor$$value$editor.loadHTML(val);
            }, 0);
          }
        };
        var setOption = (key, val) => {
          editor$.value[key] = val;
        };
        var handleChange = () => {
          if (editor$.value.value == value.value || !editor$.value.value && !value.value) {
            return;
          }
          context.emit("input", {
            target: {
              value: editor$.value.value
            }
          });
        };
        var handleFileAccept = (e2) => {
          if (disabled.value) {
            e2.preventDefault();
            return;
          }
          if (!e2.file) {
            e2.preventDefault();
            return;
          }
          if (acceptMimes.value && acceptMimes.value.length && acceptMimes.value.indexOf(e2.file.type) === -1) {
            e2.preventDefault();
            context.emit("alert", form$.value.__(form$.value.translations.vueform.editor.acceptedMimesError, {
              mimes: acceptMimes.value.join(", ")
            }));
          }
          var extension = e2.file.name.split(".").pop();
          if (accept.value && accept.value.length && accept.value.indexOf(extension) === -1) {
            e2.preventDefault();
            context.emit("alert", form$.value.__(form$.value.translations.vueform.editor.acceptedExtensionsError, {
              extensions: accept.value.join(", ")
            }));
          }
        };
        var handleAttachmentAdd = /* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(function* (e2) {
            if (!e2.attachment.file) {
              return;
            }
            var data = new FormData();
            data.append("Content-Type", e2.attachment.file.type);
            data.append("file", e2.attachment.file);
            var response;
            try {
              if (typeof resolvedEndpoint.value === "function") {
                response = yield resolvedEndpoint.value(e2.attachment, el$.value);
              } else {
                response = yield el$.value.$vueform.services.axios.request({
                  url: resolvedEndpoint.value,
                  method: resolvedMethod.value,
                  [resolvedMethod.value.toLowerCase() === "get" ? "params" : "data"]: data,
                  onUploadProgress: (progress) => {
                    e2.attachment.setUploadProgress(Math.round(progress.loaded * 100 / progress.total));
                  }
                });
                response = response.data;
              }
              e2.attachment.setAttributes({
                url: response.url,
                href: response.href
              });
            } catch (error) {
              context.emit("error", error);
            }
          });
          return function handleAttachmentAdd2(_x) {
            return _ref.apply(this, arguments);
          };
        }();
        var handleBlur = () => {
          context.emit("blur");
        };
        watch(disabled, (val) => {
          editor$.value.contentEditable = !val;
        });
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          resolvedEndpoint,
          options,
          theme,
          classes: classes2,
          Templates,
          template,
          trix$,
          editor$,
          update,
          setOption,
          handleChange,
          handleFileAccept,
          handleAttachmentAdd,
          handleBlur
        };
      }
    };
    var base$$ = function base2(props, context, dependencies2) {
      var {
        label
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var el$ = dependencies2.el$;
      var config$ = inject("config$");
      var hasLabel = computed(() => {
        var _el$$value$$slots, _el$$value$$scopedSlo;
        return !!(form$.value.options.forceLabels || label.value || el$.value.slots.label || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots.label || /* istanbul ignore next: vue2 */
        form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo.label);
      });
      var isLabelFunction = computed(() => {
        return typeof label.value === "function" && (!label.value.prototype || !label.value.prototype.constructor || label.value.prototype.constructor && label.value.prototype.constructor.name !== "VueComponent");
      });
      var isLabelComponent = computed(() => {
        return isVueComponent(label.value);
      });
      var Label = computed(() => {
        var Label2 = isLabelFunction.value ? label.value(el$.value) : label.value || null;
        if (!isLabelComponent.value) {
          Label2 = localize(Label2, config$.value, form$.value);
        }
        return Label2;
      });
      return {
        hasLabel,
        Label
      };
    };
    var base$_ = function base2(props, context, dependencies2) {
      var {
        columns: columns2,
        presets
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var theme = dependencies2.theme;
      var hasLabel = dependencies2.hasLabel;
      var Columns2 = ref(cloneDeep_1(columns2.value));
      var columnsClassesService = computed(() => {
        var config2 = form$.value.$vueform.config;
        return new form$.value.$vueform.services.columns({
          configPresetColumns: config2.usePresets,
          configColumns: config2.columns,
          formPresetColumns: form$.value.options.presets,
          formColumns: form$.value.options.columns,
          elementPresetColumns: presets.value,
          elementColumns: Columns2.value
        }, hasLabel.value, theme.value.columns, config2.presets);
      });
      var columnsClasses = computed(() => {
        return columnsClassesService.value.classes;
      });
      var cols = computed(() => {
        return columnsClassesService.value.cols;
      });
      var updateColumns = (v2) => {
        Columns2.value = cloneDeep_1(v2);
      };
      watch(columns2, (v2) => {
        Columns2.value = cloneDeep_1(v2);
      }, {
        immediate: false,
        deep: true
      });
      return {
        cols,
        columnsClassesService,
        columnsClasses,
        updateColumns
      };
    };
    var base$Z = function base2(props, context, dependencies2) {
      var {
        size: size2,
        view,
        views,
        presets
      } = toRefs(props);
      var componentName = context.name;
      var available = dependencies2.available;
      var active = dependencies2.active;
      var form$ = dependencies2.form$;
      var parent2 = dependencies2.parent;
      var hidden = ref(false);
      var visible = computed(() => {
        return available.value && !hidden.value && active.value;
      });
      var Size = computed(() => {
        var Size2;
        if (size2.value) {
          Size2 = size2.value;
        } else {
          each(presets.value, (presetName) => {
            var preset = form$.value.$vueform.config.presets[presetName];
            if (!preset || !preset.size) {
              return;
            }
            Size2 = preset.size;
          });
        }
        if (!Size2) {
          if (parent2.value) {
            Size2 = parent2.value.Size;
          } else {
            Size2 = form$.value.Size;
          }
        }
        return Size2;
      });
      var View = computed(() => {
        if (view.value) {
          return view.value;
        }
        return Views.value[componentName.value];
      });
      var Views = computed(() => {
        var Views2 = form$.value.Views;
        each(presets.value, (presetName) => {
          var preset = form$.value.$vueform.config.presets[presetName];
          if (!preset || !preset.views) {
            return;
          }
          Views2 = Object.assign({}, Views2, preset.views);
        });
        Views2 = Object.assign({}, Views2, views.value);
        return Views2;
      });
      var hide = () => {
        hidden.value = true;
      };
      var show = () => {
        hidden.value = false;
      };
      provide("Size", Size);
      provide("View", View);
      provide("Views", Views);
      return {
        hidden,
        visible,
        Size,
        View,
        Views,
        hide,
        show
      };
    };
    var captcha$1 = function captcha2(props, context, dependencies2) {
      var {
        hidden,
        visible: baseVisible,
        Size,
        View,
        Views,
        hide,
        show
      } = base$Z(props, context, dependencies2);
      var {
        shouldVerify
      } = dependencies2;
      var visible = computed(() => {
        return baseVisible.value && shouldVerify.value;
      });
      return {
        hidden,
        visible,
        Size,
        View,
        Views,
        hide,
        show
      };
    };
    var base$Y = function base2(props, context, dependencies2) {
      var {
        templates,
        presets
      } = toRefs(props);
      var componentName = context.name;
      var theme = dependencies2.theme;
      var View = dependencies2.View;
      var form$ = dependencies2.form$;
      var Templates = computed(() => {
        var presetTemplates = {};
        each(presets ? presets.value : [], (presetName) => {
          var preset = form$.value.$vueform.config.presets[presetName];
          if (!preset || !preset.templates) {
            return;
          }
          presetTemplates = Object.assign({}, presetTemplates, preset.templates);
        });
        return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, theme.value.templates), presetTemplates), templates ? templates.value : {});
      });
      var template = computed(() => {
        return View && View.value && Templates.value["".concat(componentName.value, "_").concat(View.value)] ? Templates.value["".concat(componentName.value, "_").concat(View.value)] : Templates.value[componentName.value];
      });
      return {
        Templates,
        template
      };
    };
    var base$X = function base2(props, context, dependencies2) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      toRefs(props);
      var el$ = dependencies2.el$;
      var defaultElementSlots = ["label", "info", "description", "before", "between", "after"];
      var defaultFieldSlots = ["checkbox", "radio", "option", "single-label", "multiple-label", "tag", "no-results", "no-options", "after-list", "before-list", "placeholder", "group-label", "caret", "clear", "spinner", "option", "default", "addon-before", "addon-after"];
      var elementSlots = computed(() => {
        var elementSlots2 = {};
        defaultElementSlots.filter((s2) => options.slots.indexOf(s2) !== -1).forEach((s2) => {
          var slot = el$.value.slots[s2] || el$.value.slots[camelCase_1(s2)];
          if (typeof slot === "object") {
            if (slot.props && (Array.isArray(slot.props) && slot.props.indexOf("el$") === -1 || !Array.isArray(slot.props) && Object.keys(slot.props).indexOf("el$") === -1)) {
              if (Array.isArray(slot.props)) {
                slot.props.push("el$");
              } else {
                slot.props.el$ = {
                  type: Object,
                  required: true
                };
              }
            } else if (!slot.props) {
              slot.props = ["el$"];
            }
          }
          elementSlots2[s2] = slot;
        });
        return elementSlots2;
      });
      var fieldSlots = computed(() => {
        var fieldSlots2 = {};
        defaultFieldSlots.filter((s2) => options.slots.indexOf(s2) !== -1).forEach((s2) => {
          var slot = el$.value.slots[s2] || el$.value.slots[camelCase_1(s2)];
          if (typeof slot === "object") {
            if (slot.props && (Array.isArray(slot.props) && slot.props.indexOf("el$") === -1 || !Array.isArray(slot.props) && Object.keys(slot.props).indexOf("el$") === -1)) {
              if (Array.isArray(slot.props)) {
                slot.props.push("el$");
              } else {
                slot.props.el$ = {
                  type: Object,
                  required: true
                };
              }
            } else if (!slot.props) {
              slot.props = ["el$"];
            }
          }
          fieldSlots2[s2] = slot;
        });
        return fieldSlots2;
      });
      return {
        elementSlots,
        fieldSlots
      };
    };
    var base$W = function base2(props, context, dependencies2) {
      var {
        buttonLabel,
        buttonType,
        href,
        target,
        loading,
        onClick,
        resets,
        submits
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var isDisabled = dependencies2.isDisabled;
      var fieldId = dependencies2.fieldId;
      var fire = dependencies2.fire;
      var el$ = dependencies2.el$;
      var isLoading = computed(() => {
        if (typeof loading.value === "function") {
          return loading.value(form$.value, el$.value);
        }
        if (submits.value && (form$.value.submitting || form$.value.preparing || form$.value.isLoading)) {
          return true;
        }
        return loading.value;
      });
      var isButtonLabelComponent = computed(() => {
        return buttonLabel.value !== null && typeof buttonLabel.value === "object";
      });
      var button2 = computed(() => {
        var button3 = {
          id: fieldId.value
        };
        switch (buttonType.value) {
          case "anchor":
            button3.href = href.value;
            button3.target = target.value;
            break;
          case "button":
            button3.disabled = isDisabled.value;
            break;
        }
        if (isLoading.value) {
          button3.tabindex = void 0;
        }
        return button3;
      });
      var resolvedButtonLabel = computed(() => {
        return typeof buttonLabel.value === "function" ? buttonLabel.value(el$.value) : buttonLabel.value;
      });
      var handleClick = (e2) => {
        if (buttonType.value === "anchor" && !href.value) {
          e2.preventDefault();
        }
        if (isDisabled.value || isLoading.value) {
          e2.preventDefault();
          return;
        }
        if (resets.value) {
          form$.value.reset();
        }
        if (submits.value) {
          form$.value.submit();
        }
        fire("click", form$.value, el$.value, e2);
      };
      return {
        isButtonLabelComponent,
        button: button2,
        resolvedButtonLabel,
        isLoading,
        handleClick
      };
    };
    var base$V = function base2(props, context, dependencies2) {
      var {
        layout,
        inline
      } = toRefs(props);
      var elementLayout = computed(() => {
        return inline.value || !layout.value ? "ElementLayoutInline" : layout.value;
      });
      return {
        elementLayout
      };
    };
    var base$U = function base2(props, context, dependencies2) {
      var {
        id,
        name: name2
      } = toRefs(props);
      var parent2 = dependencies2.parent;
      var fieldId = computed(() => {
        var _parent$value, _parent$value2;
        return id.value || ((_parent$value = parent2.value) !== null && _parent$value !== void 0 && _parent$value.fieldId ? "".concat((_parent$value2 = parent2.value) === null || _parent$value2 === void 0 ? void 0 : _parent$value2.fieldId, ".").concat(name2.value) : name2.value);
      });
      return {
        fieldId
      };
    };
    var base$T = function base2(props, context, dependencies2) {
      var {
        container
      } = dependencies2;
      var focus = () => {
        var _container$value, _el$querySelector;
        var el = ((_container$value = container.value) === null || _container$value === void 0 ? void 0 : _container$value.$el) || container.value;
        el === null || el === void 0 || (_el$querySelector = el.querySelector("a[href],area[href],input:not([disabled]),select:not([disabled]),textarea:not([disabled]),button:not([disabled]),iframe,[tabindex],[contentEditable=true],trix-editor")) === null || _el$querySelector === void 0 || _el$querySelector.focus();
      };
      return {
        focus
      };
    };
    var editor$1 = function editor2(props, context, dependencies2) {
      var {
        input
      } = dependencies2;
      var focus = () => {
        input.value.editor$.focus();
      };
      return {
        focus
      };
    };
    var baseClone = _baseClone;
    var CLONE_SYMBOLS_FLAG = 4;
    function clone$1(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    var clone_1 = clone$1;
    var base$S = function base2(props, context, dependencies2) {
      var {
        disabled
      } = toRefs(props);
      var localDisabled = ref(null);
      var isDisabled = computed(() => {
        return disabled.value && localDisabled.value !== false || localDisabled.value === true;
      });
      var disable = () => {
        localDisabled.value = true;
      };
      var enable = () => {
        localDisabled.value = false;
      };
      return {
        localDisabled,
        isDisabled,
        disable,
        enable
      };
    };
    var checkboxgroup$3 = function checkboxgroup2(props, context, dependencies2) {
      var {
        disables
      } = toRefs(props);
      var {
        localDisabled,
        isDisabled
      } = base$S(props);
      var disabledItems = ref([]);
      var disable = (values2) => {
        if (!isArray_1(values2)) {
          values2 = [values2];
        }
        var disablesList = clone_1(disabledItems.value);
        each(values2, (item) => {
          item = String(item);
          if (disablesList.indexOf(item) === -1) {
            disablesList.push(item);
          }
        });
        disabledItems.value = disablesList;
      };
      var enable = (values2) => {
        if (!isArray_1(values2)) {
          values2 = [values2];
        }
        var disablesList = clone_1(disabledItems.value);
        each(values2, (item) => {
          item = String(item);
          var index2 = disablesList.indexOf(item);
          if (index2 !== -1) {
            disablesList.splice(index2, 1);
          }
        });
        disabledItems.value = disablesList;
      };
      var disableAll = () => {
        localDisabled.value = true;
      };
      var enableAll = () => {
        localDisabled.value = false;
        disabledItems.value = [];
      };
      disabledItems.value = map_1(disables.value || /* istanbul ignore next: can't fall into this, because it is hardwired to be `[]` if undefined */
      [], (d2) => {
        return String(d2);
      });
      return {
        disabledItems,
        isDisabled,
        disableAll,
        enableAll,
        disable,
        enable
      };
    };
    var button$1 = function button2(props, context, dependencies2) {
      var {
        disabled,
        submits
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var el$ = dependencies2.el$;
      var isDisabled = computed(() => {
        if (typeof disabled.value === "function") {
          return disabled.value(el$.value, form$.value);
        }
        if (submits.value && (form$.value.invalid && form$.value.shouldValidateOnChange || form$.value.busy || form$.value.isDisabled)) {
          return true;
        }
        return disabled.value;
      });
      return {
        isDisabled
      };
    };
    var radiogroup$2 = checkboxgroup$3;
    var base$R = function base2(props, context, dependencies2) {
      var fieldId = dependencies2.fieldId;
      var invalid = dependencies2.invalid;
      var isDisabled = dependencies2.isDisabled;
      var busy = dependencies2.busy;
      var labelId = computed(() => {
        return "".concat(fieldId.value, "__label");
      });
      var descriptionId = computed(() => {
        return "".concat(fieldId.value, "__description");
      });
      var infoId = computed(() => {
        return "".concat(fieldId.value, "__info");
      });
      var errorId = computed(() => {
        return "".concat(fieldId.value, "__error");
      });
      var aria = computed(() => {
        return {
          "aria-labelledby": labelId.value,
          "aria-describedby": "".concat(descriptionId.value, " ").concat(infoId.value),
          "aria-invalid": invalid.value,
          "aria-errormessage": errorId.value,
          "aria-disabled": isDisabled === null || isDisabled === void 0 ? void 0 : isDisabled.value,
          "aria-busy": busy.value
        };
      });
      return {
        descriptionId,
        labelId,
        infoId,
        errorId,
        aria
      };
    };
    var checkbox$1 = function checkbox2(props, context, dependencies2) {
      var {
        text: text2
      } = toRefs(props);
      var {
        descriptionId,
        labelId,
        infoId,
        errorId
      } = base$R(props, context, dependencies2);
      var invalid = dependencies2.invalid;
      var isDisabled = dependencies2.isDisabled;
      var busy = dependencies2.busy;
      var aria = computed(() => {
        var aria2 = {
          "aria-label": text2.value,
          "aria-describedby": "".concat(labelId.value, " ").concat(descriptionId.value, " ").concat(infoId.value),
          "aria-invalid": invalid.value,
          "aria-errormessage": errorId.value,
          "aria-disabled": isDisabled.value,
          "aria-busy": busy.value
        };
        if (!aria2["aria-label"]) {
          aria2["aria-labelledby"] = labelId.value;
        }
        return aria2;
      });
      return {
        descriptionId,
        labelId,
        infoId,
        errorId,
        aria
      };
    };
    var checkboxgroup$2 = function checkboxgroup2(props, context, dependencies2) {
      var {
        descriptionId,
        labelId,
        infoId,
        errorId
      } = base$R(props, context, dependencies2);
      var invalid = dependencies2.invalid;
      var isDisabled = dependencies2.isDisabled;
      var busy = dependencies2.busy;
      var aria = computed(() => {
        return {
          "aria-describedby": "".concat(descriptionId.value, " ").concat(infoId.value),
          "aria-invalid": invalid.value,
          "aria-errormessage": errorId.value,
          "aria-disabled": isDisabled.value,
          "aria-busy": busy.value
        };
      });
      return {
        descriptionId,
        labelId,
        infoId,
        errorId,
        aria
      };
    };
    var button = function button2(props, context, dependencies2) {
      var {
        descriptionId,
        labelId,
        infoId,
        errorId
      } = base$R(props, context, dependencies2);
      var isDisabled = dependencies2.isDisabled;
      var aria = computed(() => {
        return {
          "aria-labelledby": labelId.value,
          "aria-describedby": "".concat(descriptionId.value, " ").concat(infoId.value),
          "aria-disabled": isDisabled.value
        };
      });
      return {
        descriptionId,
        labelId,
        infoId,
        errorId,
        aria
      };
    };
    var static_$3 = function static_2(props, context, dependencies2) {
      var {
        descriptionId,
        labelId,
        infoId,
        errorId
      } = base$R(props, context, dependencies2);
      var aria = computed(() => {
        return {
          "aria-labelledby": labelId.value,
          "aria-describedby": "".concat(descriptionId.value, " ").concat(infoId.value)
        };
      });
      return {
        descriptionId,
        labelId,
        infoId,
        errorId,
        aria
      };
    };
    var phone$2 = function phone2(props, context, dependencies2) {
      toRefs(props);
      var {
        descriptionId,
        labelId,
        infoId,
        errorId,
        aria
      } = base$R(props, context, dependencies2);
      var form$ = dependencies2.form$;
      var optionsAria = computed(() => {
        return {
          "aria-label": form$.value.translations.vueform.elements.phone.ariaLabel
        };
      });
      return {
        descriptionId,
        labelId,
        infoId,
        errorId,
        aria,
        optionsAria
      };
    };
    var radiogroup$1 = checkboxgroup$2;
    var radio = checkbox$1;
    var toggle$1 = checkbox$1;
    var file$4 = checkboxgroup$2;
    var createCaseFirst = _createCaseFirst;
    var lowerFirst = createCaseFirst("toLowerCase");
    var lowerFirst_1 = lowerFirst;
    var base$Q = function base2(props, context, dependencies2) {
      var {
        name: name2
      } = toRefs(props);
      var currentInstance2 = getCurrentInstance();
      var form$ = dependencies2.form$;
      var assignToParent = ($parent, assignToParent2) => {
        if ($parent.children$Array) {
          $parent.children$Array.push(currentInstance2.proxy);
        } else if ($parent.elements$) {
          form$.value.$set($parent.elements$, name2.value, currentInstance2.proxy);
        } else {
          assignToParent2($parent.$parent, assignToParent2);
        }
      };
      var removeFromParent = ($parent, removeFromParent2) => {
        if ($parent.children$Array) {
          $parent.children$Array.splice($parent.children$Array.map((e$) => normalize$1(e$.name)).indexOf(normalize$1(name2.value)), 1);
        } else if ($parent.elements$) {
          form$.value.$delete($parent.elements$, name2.value);
        } else {
          removeFromParent2($parent.$parent, removeFromParent2);
        }
      };
      return {
        assignToParent,
        removeFromParent
      };
    };
    var base$P = function base2(props, context, dependencies2) {
      var instantHooks = ["onBeforeCreate", "onCreated"];
      var hooks2 = {
        onBeforeMount,
        onMounted,
        onBeforeUpdate,
        onUpdated,
        onBeforeUnmount,
        onUnmounted
      };
      var currentInstance2 = getCurrentInstance();
      var form$ = dependencies2.form$;
      var fire = dependencies2.fire;
      var {
        assignToParent,
        removeFromParent
      } = base$Q(props, context, {
        form$
      });
      var container = ref(null);
      var mounted = ref(false);
      var active = ref(true);
      var isStatic = computed(() => {
        return false;
      });
      var isFileType = computed(() => {
        return false;
      });
      var isImageType = computed(() => {
        return false;
      });
      var isArrayType = computed(() => {
        return false;
      });
      var isObjectType = computed(() => {
        return false;
      });
      var isGroupType = computed(() => {
        return false;
      });
      var isListType = computed(() => {
        return false;
      });
      var isActive = computed(() => {
        return active.value;
      });
      var el$ = computed(() => {
        return currentInstance2.proxy;
      });
      var activate = () => {
        active.value = true;
      };
      var deactivate = () => {
        active.value = false;
      };
      provide("el$", el$);
      onBeforeMount(() => {
        assignToParent(currentInstance2.proxy.$parent, assignToParent);
      });
      onMounted(() => {
        mounted.value = true;
      });
      onBeforeUnmount(() => {
        removeFromParent(currentInstance2.proxy.$parent, removeFromParent);
      });
      Object.values(instantHooks).forEach((hook) => {
        fire(lowerFirst_1(hook.replace("on", "")), el$.value);
      });
      Object.keys(hooks2).forEach((hook) => {
        hooks2[hook](() => {
          fire(lowerFirst_1(hook.replace("on", "")), el$.value);
        });
      });
      return {
        el$,
        isStatic,
        isFileType,
        isArrayType,
        isImageType,
        isObjectType,
        isGroupType,
        isListType,
        isActive,
        active,
        mounted,
        container,
        activate,
        deactivate
      };
    };
    var list$4 = function list2(props, context, dependencies2) {
      var {
        el$,
        isStatic,
        isFileType,
        isImageType,
        isObjectType,
        isGroupType,
        isActive,
        active,
        mounted,
        container,
        activate,
        deactivate
      } = base$P(props, context, dependencies2);
      var isArrayType = computed(() => {
        return true;
      });
      var isListType = computed(() => {
        return true;
      });
      return {
        el$,
        isStatic,
        isFileType,
        isArrayType,
        isImageType,
        isObjectType,
        isGroupType,
        isListType,
        isActive,
        active,
        mounted,
        container,
        activate,
        deactivate
      };
    };
    var object$7 = function object2(props, context, dependencies2) {
      var {
        el$,
        isStatic,
        isFileType,
        isArrayType,
        isImageType,
        isGroupType,
        isListType,
        isActive,
        active,
        mounted,
        container,
        activate,
        deactivate
      } = base$P(props, context, dependencies2);
      var isObjectType = computed(() => {
        return true;
      });
      return {
        el$,
        isStatic,
        isFileType,
        isArrayType,
        isImageType,
        isObjectType,
        isGroupType,
        isListType,
        isActive,
        active,
        mounted,
        container,
        activate,
        deactivate
      };
    };
    var group$7 = function group2(props, context, dependencies2) {
      var {
        el$,
        isStatic,
        isFileType,
        isArrayType,
        isImageType,
        isObjectType,
        isListType,
        isActive,
        active,
        mounted,
        container,
        activate,
        deactivate
      } = base$P(props, context, dependencies2);
      var isGroupType = computed(() => {
        return true;
      });
      return {
        el$,
        isStatic,
        isFileType,
        isArrayType,
        isImageType,
        isObjectType,
        isGroupType,
        isListType,
        isActive,
        active,
        mounted,
        container,
        activate,
        deactivate
      };
    };
    var file$3 = function file2(props, context, dependencies2) {
      var {
        view
      } = toRefs(props);
      var {
        el$,
        isStatic,
        isArrayType,
        isObjectType,
        isGroupType,
        isListType,
        isActive,
        active,
        mounted,
        container,
        activate,
        deactivate
      } = base$P(props, context, dependencies2);
      var isFileType = computed(() => {
        return true;
      });
      var isImageType = computed(() => {
        return ["gallery", "image"].indexOf(view.value) !== -1;
      });
      return {
        el$,
        isStatic,
        isFileType,
        isArrayType,
        isImageType,
        isObjectType,
        isGroupType,
        isListType,
        isActive,
        active,
        mounted,
        container,
        activate,
        deactivate
      };
    };
    var static_$2 = function static_2(props, context, dependencies2) {
      var {
        el$,
        isArrayType,
        isFileType,
        isImageType,
        isObjectType,
        isGroupType,
        isListType,
        isActive,
        active,
        mounted,
        container,
        activate,
        deactivate
      } = base$P(props, context, dependencies2);
      var isStatic = computed(() => {
        return true;
      });
      return {
        el$,
        isStatic,
        isFileType,
        isArrayType,
        isImageType,
        isObjectType,
        isGroupType,
        isListType,
        isActive,
        active,
        mounted,
        container,
        activate,
        deactivate
      };
    };
    var checkboxgroup$1 = list$4;
    var dates$5 = list$4;
    var multiselect$5 = list$4;
    var tags$5 = list$4;
    var base$O = function base2(props, context, dependencies2) {
      var {
        name: name2
      } = toRefs(props);
      var currentInstance2 = getCurrentInstance();
      var {
        form$
      } = dependencies2;
      var parent2 = computed(() => {
        var getParent = (parent3, getParent2) => {
          if (parent3 && (form$.value.$vueform.vueVersion === 3 && parent3.$options.name && parent3.$options.name.match(/^[a-zA-Z\-]*Element$/) || form$.value.$vueform.vueVersion === 2 && parent3.hasOwnProperty("el$") && typeof parent3.el$ !== "function")) {
            return parent3.el$;
          } else if (parent3.$parent) {
            return getParent2(parent3.$parent, getParent2);
          } else {
            return null;
          }
        };
        return getParent(form$.value.$vueform.vueVersion === 3 ? currentInstance2.parent.proxy : currentInstance2.proxy.$parent, getParent);
      });
      var path = computed(() => {
        return parent2.value && parent2.value.path ? parent2.value.path + "." + name2.value : name2.value;
      });
      var dataPath = computed(() => {
        return parent2.value && parent2.value.dataPath ? parent2.value.dataPath + "." + name2.value : name2.value;
      });
      var flat = computed(() => {
        return false;
      });
      return {
        parent: parent2,
        path,
        dataPath,
        flat
      };
    };
    var group$6 = function group2(props, context, dependencies2) {
      var {
        path,
        parent: parent2
      } = base$O(props, context, dependencies2);
      var dataPath = computed(() => {
        return parent2.value && parent2.value.dataPath ? parent2.value.dataPath : null;
      });
      var flat = computed(() => {
        return true;
      });
      return {
        path,
        dataPath,
        flat,
        parent: parent2
      };
    };
    var static_$1 = function static_2(props, context, dependencies2) {
      var {
        path,
        parent: parent2,
        flat
      } = base$O(props, context, dependencies2);
      return {
        path,
        flat,
        parent: parent2
      };
    };
    function resolveDeps$1(props, context, options) {
      var deps = options.deps || {};
      options = _objectSpread2$1(_objectSpread2$1({}, options), {}, {
        events: context.emits,
        slots: context.slots
      });
      context.features.forEach((feature) => {
        each(feature(props, context, deps, options), (featureDep, key) => {
          deps[key] = featureDep;
        });
      });
      return deps;
    }
    var base$N = function base2(props, context) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var deps = resolveDeps$1(props, context, options);
      onMounted(() => {
        if (deps.initWatcher) {
          deps.initWatcher();
        }
        if (deps.initMessageBag) {
          deps.initMessageBag();
        }
        if (deps.initValidation) {
          deps.initValidation();
        }
      });
      return _objectSpread2$1({}, deps);
    };
    var static_ = function static_2(props, context) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var deps = resolveDeps$1(props, context, options);
      return _objectSpread2$1({}, deps);
    };
    var multilingual$8 = function multilingual2(props, context) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var deps = resolveDeps$1(props, context, options);
      onMounted(() => {
        deps.initWatcher();
        deps.initState();
        deps.initMessageBag();
        deps.initValidation();
      });
      return _objectSpread2$1({}, deps);
    };
    var location$3 = function location2(props, context) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var {
        displayKey
      } = toRefs(props);
      var deps = resolveDeps$1(props, context, options);
      onMounted(() => {
        if (deps.value.value[displayKey.value]) {
          deps.input.value.value = deps.value.value[displayKey.value];
        }
      });
      onMounted(() => {
        deps.initWatcher();
        deps.initMessageBag();
        deps.initValidation();
      });
      return _objectSpread2$1({}, deps);
    };
    var BaseElement = {
      props: {
        name: {
          required: true,
          type: [String, Number]
        },
        conditions: {
          required: false,
          type: [Array],
          default: () => []
        },
        onBeforeCreate: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onCreated: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onBeforeMount: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onMounted: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onBeforeUpdate: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onUpdated: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onBeforeUnmount: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onUnmounted: {
          required: false,
          type: [Function],
          default: null,
          private: true
        }
      }
    };
    var HasView = {
      props: {
        inline: {
          required: false,
          type: [Boolean],
          default: false
        },
        layout: {
          required: false,
          type: [String, Object, Boolean],
          default: "ElementLayout",
          private: true
        },
        addClass: {
          required: false,
          type: [Array, Object, String, Function],
          default: null
        },
        removeClass: {
          required: false,
          type: [Array, Object, Function],
          default: null
        },
        replaceClass: {
          required: false,
          type: [Object, Function],
          default: null
        },
        overrideClass: {
          required: false,
          type: [Array, Object, String, Function],
          default: null
        },
        addClasses: {
          required: false,
          type: [Object, Function],
          default: () => ({})
        },
        replaceClasses: {
          required: false,
          type: [Object, Function],
          default: () => ({})
        },
        removeClasses: {
          required: false,
          type: [Object, Function],
          default: () => ({})
        },
        overrideClasses: {
          required: false,
          type: [Object, Function],
          default: () => ({})
        },
        presets: {
          required: false,
          type: [Array],
          default: () => []
        },
        view: {
          required: false,
          type: [String],
          default: void 0
        },
        views: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        size: {
          required: false,
          type: [String],
          default: void 0
        },
        columns: {
          required: false,
          type: [Object, String, Number],
          default: null
        },
        templates: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        description: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        info: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        infoPosition: {
          required: false,
          type: [String],
          default: "right"
        },
        label: {
          required: false,
          type: [String, Object, Function],
          localized: true,
          default: null
        },
        before: {
          required: false,
          type: [Object, String, Number],
          localized: true,
          default: null
        },
        between: {
          required: false,
          type: [Object, String, Number],
          localized: true,
          default: null
        },
        after: {
          required: false,
          type: [Object, String, Number],
          localized: true,
          default: null
        },
        slots: {
          required: false,
          type: [Object],
          default: () => ({})
        }
      }
    };
    var ButtonElement = {
      name: "ButtonElement",
      mixins: [BaseElement, HasView],
      emits: ["click", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "button",
          private: true
        },
        buttonLabel: {
          required: false,
          type: [String, Object, Function],
          default: null
        },
        buttonType: {
          required: false,
          type: [String],
          default: "button"
          // button|anchor
        },
        buttonClass: {
          required: false,
          type: [String, Array, Object],
          default: null
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        disabled: {
          required: false,
          type: [Function, Boolean],
          default: false
        },
        loading: {
          required: false,
          type: [Function, Boolean],
          default: false
        },
        href: {
          required: false,
          type: [String],
          default: ""
        },
        target: {
          required: false,
          type: [String],
          default: null
        },
        onClick: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        resets: {
          required: false,
          type: [Boolean],
          default: false
        },
        submits: {
          required: false,
          type: [Boolean],
          default: false
        },
        secondary: {
          required: false,
          type: [Boolean],
          default: false
        },
        danger: {
          required: false,
          type: [Boolean],
          default: false
        },
        full: {
          required: false,
          type: [Boolean],
          default: false
        },
        align: {
          required: false,
          type: [String],
          default: void 0
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, static_$1, base$1c, static_$2, button$1, base$14, base$$, base$Z, base$Y, base$U, base$W, base$1a, base$_, base$X, button, base$T];
        context.slots = ["label", "info", "description", "before", "between", "after", "default"];
        return _objectSpread2$1({}, static_(props, context));
      }
    };
    var base$M = function base2(props, context, dependencies2) {
      var input = ref(null);
      return {
        input
      };
    };
    var select$4 = function select2(props, context, dependencies2) {
      var input = ref(null);
      return {
        input
      };
    };
    var multiselect$4 = select$4;
    var tags$4 = select$4;
    function checkDateFormat(format2, date2, moment) {
      if (!(date2 instanceof Date) && moment(date2, format2).format(format2) !== date2) {
        console.warn('Wrong formatted date. Expected format: "'.concat(format2, '", received: "').concat(date2, '"'));
      }
    }
    var base$L = function base2(props, context, dependencies2) {
      var _options$value, _options$value2;
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var {
        name: name2,
        type
      } = toRefs(props);
      var parent2 = dependencies2.parent;
      var defaultValue = dependencies2.defaultValue;
      var dataPath = dependencies2.dataPath;
      var form$ = dependencies2.form$;
      dependencies2.isObject;
      dependencies2.isGroup;
      dependencies2.isList;
      var initialValue = ref(void 0);
      if (form$.value.isSync) {
        initialValue.value = get_1(form$.value.model, dataPath.value);
      } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType || parent2.value.isListType)) {
        initialValue.value = parent2.value.value[name2.value];
      }
      var internalValue = ref(defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value));
      var value = computed({
        get: ((_options$value = options.value) === null || _options$value === void 0 ? void 0 : _options$value.get) || function() {
          var value2;
          if (form$.value.isSync) {
            value2 = get_1(form$.value.model, dataPath.value);
          } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType || parent2.value.isListType)) {
            value2 = parent2.value.value[name2.value];
          } else {
            value2 = internalValue.value;
          }
          return value2 !== void 0 ? value2 : (
            /* istanbul ignore next: value is never undefined if default is set */
            defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value)
          );
        },
        set: ((_options$value2 = options.value) === null || _options$value2 === void 0 ? void 0 : _options$value2.set) || function(val) {
          if (form$.value.isSync) {
            form$.value.updateModel(dataPath.value, val);
          } else if (parent2.value && parent2.value.isListType) {
            var newValue = parent2.value.value.map((v2, k2) => k2 == name2.value ? val : v2);
            parent2.value.update(newValue);
          } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
            parent2.value.value = Object.assign({}, parent2.value.value, {
              [name2.value]: val
            });
          } else {
            internalValue.value = val;
          }
        }
      });
      var model = computed({
        get() {
          return value.value;
        },
        set(val) {
          value.value = val;
        }
      });
      if (options.init === void 0 || options.init !== false) {
        if (initialValue.value === void 0) {
          value.value = defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value);
        }
      }
      var isDefault = computed(() => {
        return isEqual_1(value.value, defaultValue.value);
      });
      watch(type, () => {
        value.value = defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value);
      });
      return {
        initialValue,
        internalValue,
        value,
        model,
        isDefault
      };
    };
    var list$3 = function list2(props, context, dependencies2) {
      var {
        initialValue,
        internalValue,
        value,
        model,
        isDefault
      } = base$L(props, context, dependencies2, {
        init: false
      });
      return {
        initialValue,
        internalValue,
        value,
        model,
        isDefault
      };
    };
    var object$6 = function object2(props, context, dependencies2) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var {
        initialValue,
        internalValue,
        value,
        isDefault
      } = base$L(props, context, dependencies2, {
        init: false
      });
      var defaultValue = dependencies2.defaultValue;
      if (options.init === void 0 || /* istanbul ignore next: init will always be false */
      options.init !== false) {
        if (initialValue.value === void 0) {
          value.value = defaultValue.value;
        } else {
          value.value = Object.assign({}, defaultValue.value, value.value);
        }
      }
      return {
        internalValue,
        value,
        isDefault
      };
    };
    var group$5 = function group2(props, context, dependencies2) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var parent2 = dependencies2.parent;
      var dataPath = dependencies2.dataPath;
      var defaultValue = dependencies2.defaultValue;
      var children$Array = dependencies2.children$Array;
      var form$ = dependencies2.form$;
      dependencies2.isObject;
      dependencies2.isGroup;
      dependencies2.isList;
      var internalValue = ref(cloneDeep_1(defaultValue.value));
      var value = computed(options.value || {
        get() {
          var value2;
          if (form$.value.isSync) {
            value2 = dataPath.value ? get_1(form$.value.model, dataPath.value) || {} : form$.value.model;
          } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
            value2 = parent2.value.value;
          } else {
            value2 = internalValue.value;
          }
          var childKeys = children$Array.value.reduce((all, child$) => {
            if (!child$ || child$.isStatic) {
              return all;
            }
            var keys2 = [];
            if (!child$.flat) {
              keys2.push(child$.name);
            } else {
              var addGroupKeys = (children$Array2) => {
                children$Array2.forEach((child$2) => {
                  if (!child$2.isStatic && child$2.flat) {
                    addGroupKeys(child$2.children$Array);
                  } else if (!child$2.isStatic) {
                    keys2.push(child$2.name);
                  }
                });
              };
              addGroupKeys(child$.children$Array);
            }
            return all.concat(keys2);
          }, []);
          var tempValue = {};
          childKeys.forEach((key) => {
            if (value2[key] !== void 0) {
              tempValue[key] = value2[key];
            }
          });
          value2 = tempValue;
          return value2 !== void 0 ? value2 : (
            /* istanbul ignore next: will never reach, internalValue is assigned at the beginning */
            cloneDeep_1(defaultValue.value)
          );
        },
        set(val) {
          if (form$.value.isSync) {
            form$.value.updateModel(dataPath.value, val);
          } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
            parent2.value.value = Object.assign({}, parent2.value.value, val);
          } else {
            internalValue.value = val;
          }
        }
      });
      var isDefault = computed(() => {
        return isEqual_1(value.value, defaultValue.value);
      });
      return {
        value,
        isDefault
      };
    };
    var multilingual$7 = function multilingual2(props, context, dependencies2) {
      var {
        value,
        isDefault
      } = base$L(props, context, dependencies2);
      var language = dependencies2.language;
      var model = computed({
        get() {
          return value.value[language.value];
        },
        set(val) {
          value.value = Object.assign({}, value.value, {
            [language.value]: val
          });
        }
      });
      return {
        value,
        model,
        isDefault
      };
    };
    var date$3 = function date2(props, context, dependencies2) {
      var {
        name: name2
      } = toRefs(props);
      var parent2 = dependencies2.parent;
      var valueDateFormat = dependencies2.valueDateFormat;
      var defaultValue = dependencies2.defaultValue;
      var dataPath = dependencies2.dataPath;
      var form$ = dependencies2.form$;
      dependencies2.isObject;
      dependencies2.isGroup;
      dependencies2.isList;
      var moment = form$.value.$vueform.services.moment;
      var internalValue = ref(defaultValue.value instanceof File ? (
        /* istanbul ignore next: @todo:adam date type will never have file instance default value */
        defaultValue.value
      ) : cloneDeep_1(defaultValue.value));
      var {
        value,
        initialValue,
        isDefault
      } = base$L(props, context, dependencies2, {
        value: {
          get() {
            var value2;
            if (form$.value.isSync) {
              value2 = get_1(form$.value.model, dataPath.value);
            } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType || parent2.value.isListType)) {
              value2 = parent2.value.value[name2.value];
            } else {
              value2 = internalValue.value;
            }
            return value2 !== void 0 ? value2 : (
              /* istanbul ignore next: can not be undefined @todo:adam can not be file */
              defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value)
            );
          },
          set(val) {
            if (!isEmpty_1(val) && !(val instanceof Date) && valueDateFormat.value !== false) {
              checkDateFormat(valueDateFormat.value, val, moment);
            }
            val = val && val instanceof Date && valueDateFormat.value !== false ? moment(val).format(valueDateFormat.value) : val;
            if (form$.value.isSync) {
              form$.value.updateModel(dataPath.value, val);
            } else if (parent2.value && parent2.value.isListType) {
              var newValue = parent2.value.value.map((v2, k2) => k2 == name2.value ? val : v2);
              parent2.value.update(newValue);
            } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
              parent2.value.value = Object.assign({}, parent2.value.value, {
                [name2.value]: val
              });
            } else {
              internalValue.value = val;
            }
          }
        }
      });
      var model = computed(() => {
        return value.value instanceof Date || !value.value ? value.value : moment(value.value, valueDateFormat.value).toDate();
      });
      return {
        value,
        model,
        initialValue,
        internalValue,
        isDefault
      };
    };
    var dates$4 = function dates2(props, context, dependencies2) {
      var {
        name: name2
      } = toRefs(props);
      var parent2 = dependencies2.parent;
      var valueDateFormat = dependencies2.valueDateFormat;
      var defaultValue = dependencies2.defaultValue;
      var dataPath = dependencies2.dataPath;
      var form$ = dependencies2.form$;
      dependencies2.isObject;
      dependencies2.isGroup;
      dependencies2.isList;
      var moment = form$.value.$vueform.services.moment;
      var internalValue = ref(defaultValue.value instanceof File ? (
        /* istanbul ignore next: @todo:adam date type will never have file instance default value */
        defaultValue.value
      ) : cloneDeep_1(defaultValue.value));
      var {
        value,
        initialValue,
        isDefault
      } = base$L(props, context, dependencies2, {
        value: {
          get() {
            var value2;
            if (form$.value.isSync) {
              value2 = get_1(form$.value.model, dataPath.value);
            } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType || parent2.value.isListType)) {
              value2 = parent2.value.value[name2.value];
            } else {
              value2 = internalValue.value;
            }
            return value2 !== void 0 ? value2 : (
              /* istanbul ignore next: can not be undefined @todo:adam can not be file */
              defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value)
            );
          },
          set(val) {
            if (!Array.isArray(val)) {
              val = [val];
            }
            val = val.map((v2) => {
              if (!isEmpty_1(v2) && !(v2 instanceof Date) && valueDateFormat.value !== false) {
                checkDateFormat(valueDateFormat.value, v2, moment);
              }
              return v2 && v2 instanceof Date && valueDateFormat.value !== false ? moment(v2).format(valueDateFormat.value) : v2;
            });
            if (form$.value.isSync) {
              form$.value.updateModel(dataPath.value, val);
            } else if (parent2.value && parent2.value.isListType) {
              var newValue = parent2.value.value.map((v2, k2) => k2 == name2.value ? val : v2);
              parent2.value.update(newValue);
            } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
              parent2.value.value = Object.assign({}, parent2.value.value, {
                [name2.value]: val
              });
            } else {
              internalValue.value = val;
            }
          }
        }
      });
      var model = computed(() => {
        return value.value.map((v2) => {
          return v2 instanceof Date || !v2 ? v2 : moment(v2, valueDateFormat.value).toDate();
        });
      });
      return {
        value,
        model,
        initialValue,
        internalValue,
        isDefault
      };
    };
    var base$K = function base2(props, context, dependencies2) {
      var nullValue = computed(() => {
        return null;
      });
      return {
        nullValue
      };
    };
    var array$1 = function array2(props, context, dependencies2) {
      var nullValue = computed(() => {
        return [];
      });
      return {
        nullValue
      };
    };
    var boolean = function boolean2(props, context, dependencies2) {
      var {
        falseValue
      } = toRefs(props);
      var nullValue = computed(() => {
        return falseValue.value;
      });
      return {
        nullValue
      };
    };
    var min$2 = function min2(props, context, dependencies2) {
      var {
        min: min3,
        default: default_
      } = toRefs(props);
      var nullValue = computed(() => {
        return default_.value !== void 0 && isArray_1(default_.value) ? default_.value.map((v2) => min3.value) : min3.value;
      });
      return {
        nullValue
      };
    };
    var object$5 = function object2(props, context, dependencies2) {
      var nullValue = computed(() => {
        return {};
      });
      return {
        nullValue
      };
    };
    var location$2 = function location2(props, context, dependencies2) {
      var nullValue = computed(() => {
        return {
          country: null,
          country_code: null,
          state: null,
          state_code: null,
          city: null,
          zip: null,
          address: null,
          formatted_address: null,
          lat: null,
          lng: null
        };
      });
      return {
        nullValue
      };
    };
    var multilingual$6 = function multilingual2(props, context, dependencies2) {
      var languages = dependencies2.languages;
      var nullValue = computed(() => {
        var value = {};
        each(languages.value, (code) => {
          value[code] = null;
        });
        return value;
      });
      return {
        nullValue
      };
    };
    var generic = function generic2(props, context, dependencies2) {
      var nullValue = computed(() => {
        return context.nullValue !== void 0 ? context.nullValue : null;
      });
      return {
        nullValue
      };
    };
    var base$J = function base2(props, context, dependencies2) {
      var {
        name: name2,
        floating,
        placeholder,
        label,
        fieldName
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var Label = dependencies2.Label;
      var config$ = inject("config$");
      var genericName = computed(() => {
        if (fieldName && fieldName.value) {
          return localize(fieldName.value, config$.value, form$.value);
        } else if (label && label.value) {
          return Label.value;
        } else if (floating && floating.value) {
          return localize(floating.value, config$.value, form$.value);
        } else if (placeholder && placeholder.value && form$.value.options.floatPlaceholders) {
          return localize(placeholder.value, config$.value, form$.value);
        } else {
          return upperFirst_1(name2.value).replace(/_|-/g, " ");
        }
      });
      return {
        genericName
      };
    };
    var file$2 = function file2(props, context, dependencies2) {
      var {
        name: name2,
        embed,
        label,
        fieldName
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var Label = dependencies2.Label;
      var filename = dependencies2.filename || /* istanbul ignore next: failsafe only */
      ref(null);
      var config$ = inject("config$");
      var genericName = computed(() => {
        if (embed.value && filename.value) {
          return filename.value;
        } else if (fieldName && fieldName.value) {
          return localize(fieldName.value, config$.value, form$.value);
        } else if (label.value) {
          return Label.value;
        } else {
          return /^\d+$/.test(name2.value) ? form$.value.translations.vueform.elements.file.defaultName : upperFirst_1(name2.value).replace(/_|-/g, " ");
        }
      });
      return {
        genericName
      };
    };
    var base$I = function base2(props, context, dependencies2) {
      var value = dependencies2.value;
      var nullValue = dependencies2.nullValue;
      var empty = computed(() => {
        return isEqual_1(value.value, nullValue.value) || [void 0, null, ""].indexOf(value.value) !== -1;
      });
      return {
        empty
      };
    };
    var multilingual$5 = function multilingual2(props, context, dependencies2) {
      var value = dependencies2.value;
      var nullValue = dependencies2.nullValue;
      var language = dependencies2.language;
      var empty = computed(() => {
        return value.value[language.value] == nullValue.value[language.value] || value.value[language.value] === "";
      });
      return {
        empty
      };
    };
    var array = function array2(props, context, dependencies2) {
      var value = dependencies2.value;
      var nullValue = dependencies2.nullValue;
      var empty = computed(() => {
        return isEqual_1(value.value, nullValue.value) || [void 0, null, ""].indexOf(value.value) !== -1 || value.value.length == 0;
      });
      return {
        empty
      };
    };
    var base$H = function base2(props, context, dependencies2) {
      var {
        loading
      } = toRefs(props);
      var pending = dependencies2.pending;
      var isLoading = computed(() => {
        return pending.value || loading.value;
      });
      return {
        isLoading
      };
    };
    var base$G = function base2(props, context, dependencies2) {
      var {
        floating,
        placeholder
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var hasFloating = computed(() => {
        return !!(!!floating.value || placeholder.value && form$.value.options.floatPlaceholders) && floating.value !== false;
      });
      return {
        hasFloating
      };
    };
    var base$F = function base2(props, context, dependencies2) {
      var form$ = dependencies2.form$;
      var el$ = dependencies2.el$;
      var fire = dependencies2.fire;
      var dirt = dependencies2.dirt;
      var validate = dependencies2.validate;
      var value = dependencies2.value;
      var initWatcher = () => {
        watch(value, (n2, o2) => {
          if (dataEquals(n2, o2)) {
            return;
          }
          fire("change", n2, o2, el$.value);
          if (dirt) {
            dirt();
          }
          if (validate && form$.value.shouldValidateOnChange) {
            validate();
          }
        }, {
          immediate: false,
          deep: true
        });
      };
      return {
        initWatcher
      };
    };
    var multilingual$4 = function multilingual2(props, context, dependencies2) {
      var form$ = dependencies2.form$;
      var el$ = dependencies2.el$;
      var fire = dependencies2.fire;
      var dirt = dependencies2.dirt;
      var value = dependencies2.value;
      var language = dependencies2.language;
      var validateLanguage = dependencies2.validateLanguage;
      var initWatcher = () => {
        watch(value, (n2, o2) => {
          if (dataEquals(n2, o2)) {
            return;
          }
          fire("change", n2, o2, el$.value);
          if (dirt) {
            dirt();
          }
          if (form$.value.shouldValidateOnChange) {
            validateLanguage(language.value);
          }
        }, {
          immediate: false,
          deep: true
        });
      };
      return {
        initWatcher
      };
    };
    var list$2 = function list2(props, context, dependencies2) {
      var form$ = dependencies2.form$;
      var el$ = dependencies2.el$;
      var fire = dependencies2.fire;
      var dirt = dependencies2.dirt;
      var validateValidators = dependencies2.validateValidators;
      var value = dependencies2.value;
      var initWatcher = () => {
        watch(value, (n2, o2) => {
          if (dataEquals(n2, o2)) {
            return;
          }
          fire("change", n2, o2, el$.value);
          if (dirt) {
            dirt();
          }
          if (validateValidators && form$.value.shouldValidateOnChange) {
            validateValidators();
          }
        }, {
          immediate: false,
          deep: true
        });
      };
      return {
        initWatcher
      };
    };
    var object$4 = function object2(props, context, dependencies2) {
      var form$ = dependencies2.form$;
      var fire = dependencies2.fire;
      var value = dependencies2.value;
      var el$ = dependencies2.el$;
      var dirt = dependencies2.dirt;
      var validateValidators = dependencies2.validateValidators;
      var initWatcher = () => {
        watch(value, (n2, o2) => {
          if (dataEquals(n2, o2)) {
            return;
          }
          fire("change", n2, o2, el$.value);
          if (dirt) {
            dirt();
          }
          if (validateValidators && form$.value.shouldValidateOnChange) {
            validateValidators();
          }
        }, {
          immediate: false,
          deep: true
        });
      };
      return {
        initWatcher
      };
    };
    var location$1 = function location2(props, context, dependencies2) {
      var {
        displayKey
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var el$ = dependencies2.el$;
      var fire = dependencies2.fire;
      var dirt = dependencies2.dirt;
      var validate = dependencies2.validate;
      var value = dependencies2.value;
      var input = dependencies2.input;
      var initWatcher = () => {
        watch(value, (n2, o2) => {
          if (dataEquals(n2, o2)) {
            return;
          }
          fire("change", n2, o2, el$.value);
          dirt();
          input.value.value = input.value && value.value && value.value[displayKey.value] !== void 0 ? value.value[displayKey.value] : "";
          if (validate && form$.value.shouldValidateOnChange) {
            validate();
          }
        }, {
          immediate: false,
          deep: true
        });
      };
      return {
        initWatcher
      };
    };
    var multifile$5 = list$2;
    var group$4 = object$4;
    var base$E = function base2(props, context, dependencies2) {
      var {
        provider: elementProvider,
        options,
        readonly: readonly2
      } = toRefs(props);
      var {
        form$,
        input,
        model,
        nullValue,
        messageBag: messageBag2,
        validate,
        el$,
        invalid,
        isDisabled,
        resetValidators,
        resetting,
        initValidation
      } = dependencies2;
      var Provider = ref(null);
      var shouldVerify = computed(() => {
        return !isDisabled.value && !readonly2.value;
      });
      var provider = computed(() => {
        return elementProvider.value || form$.value.options.useProviders.captcha;
      });
      var captchaOptions = computed(() => {
        return _objectSpread2$1(_objectSpread2$1({}, form$.value.options.providerOptions[provider.value]), options.value);
      });
      var initCaptcha = () => {
        model.value = nullValue.value;
        Provider.value = new form$.value.options.providers.captcha[provider.value](input.value, captchaOptions.value, el$.value);
      };
      var destroyCaptcha = () => {
        resetValidators();
        Provider.value.reset();
        model.value = nullValue.value;
        Provider.value = null;
      };
      onMounted(() => {
        if (shouldVerify.value) {
          initCaptcha();
        }
      });
      watch(shouldVerify, /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator(function* (n2, o2) {
          if (!n2) {
            destroyCaptcha();
          } else if (n2) {
            yield nextTick();
            initCaptcha();
            initValidation();
          }
        });
        return function(_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }());
      return {
        Provider,
        captchaOptions,
        shouldVerify,
        initCaptcha,
        destroyCaptcha
      };
    };
    var base$D = function base2(props, context, dependencies2) {
      var {
        rules: rules2
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var path = dependencies2.path;
      var state = ref({
        dirty: false,
        validated: true
      });
      var Validators = ref([]);
      var messageBag2 = ref({});
      var validatorFactory = reactive({});
      var resetting = ref(false);
      var validationRules = computed(() => {
        return rules2.value;
      });
      var dirty = computed(() => {
        return state.value.dirty;
      });
      var validated = computed(() => {
        return state.value.validated;
      });
      var invalid = computed(() => {
        return some_1(Validators.value, {
          invalid: true
        });
      });
      var pending = computed(() => {
        return some_1(Validators.value, {
          pending: true
        });
      });
      var busy = computed(() => {
        return pending.value;
      });
      var validatorErrors = computed(() => {
        var errs = [];
        each(Validators.value, (Validator2) => {
          if (Validator2.failing) {
            errs.push(Validator2.message);
          }
        });
        return errs;
      });
      var errors = computed(() => {
        return messageBag2.value.errors;
      });
      var error = computed(() => {
        return messageBag2.value.error || null;
      });
      var isDanger = computed(() => {
        return error.value !== null;
      });
      var isSuccess = computed(() => {
        return validationRules.value && validationRules.value.length > 0 && state.value.validated && !invalid.value || (!validationRules.value || !validationRules.value.length) && dirty.value;
      });
      var validate = /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator(function* () {
          if (!validationRules.value) {
            return;
          }
          if (form$.value.validation === false) {
            return;
          }
          if (resetting.value) {
            resetting.value = false;
            return;
          }
          yield asyncForEach(Validators.value, /* @__PURE__ */ function() {
            var _ref2 = _asyncToGenerator(function* (Validator2) {
              yield Validator2.validate();
            });
            return function(_x) {
              return _ref2.apply(this, arguments);
            };
          }());
          state.value.validated = true;
        });
        return function validate2() {
          return _ref.apply(this, arguments);
        };
      }();
      var resetValidators = () => {
        each(Validators.value, (Validator2) => {
          Validator2.reset();
        });
        state.value.validated = !validationRules.value;
      };
      var dirt = () => {
        state.value.dirty = true;
      };
      var clean = () => {
        state.value.dirty = false;
      };
      var clearMessages = () => {
        if (messageBag2.value) {
          messageBag2.value.clear();
        }
      };
      var initMessageBag = () => {
        messageBag2.value = new form$.value.$vueform.services.messageBag(validatorErrors);
      };
      var initValidation = () => {
        if (!validationRules.value) {
          return;
        }
        state.value.validated = false;
        validatorFactory.value = new form$.value.$vueform.services.validation.factory(path.value, form$.value);
        Validators.value = [];
        each(validatorFactory.value.makeAll(validationRules.value), (Validator2) => {
          Validators.value.push(Validator2);
        });
      };
      var reinitValidation = () => {
        initValidation();
      };
      return {
        state,
        Validators,
        messageBag: messageBag2,
        resetting,
        dirty,
        validated,
        invalid,
        pending,
        busy,
        errors,
        error,
        validationRules,
        isDanger,
        isSuccess,
        validate,
        dirt,
        clean,
        clearMessages,
        resetValidators,
        initMessageBag,
        initValidation,
        reinitValidation
      };
    };
    var text$2 = function text2(props, context, dependencies2) {
      var {
        state,
        Validators,
        messageBag: messageBag2,
        resetting,
        dirty,
        validated,
        invalid,
        pending,
        errors,
        error,
        validationRules,
        isDanger,
        isSuccess,
        validate,
        dirt,
        clean,
        clearMessages,
        resetValidators,
        initMessageBag,
        initValidation,
        reinitValidation
      } = base$D(props, context, dependencies2);
      var debouncing = computed(() => {
        return some_1(Validators.value, {
          debouncing: true
        });
      });
      var busy = computed(() => {
        return pending.value || debouncing.value;
      });
      return {
        state,
        Validators,
        messageBag: messageBag2,
        resetting,
        dirty,
        validated,
        invalid,
        pending,
        debouncing,
        busy,
        errors,
        error,
        validationRules,
        isDanger,
        isSuccess,
        validate,
        dirt,
        clean,
        clearMessages,
        resetValidators,
        initMessageBag,
        initValidation,
        reinitValidation
      };
    };
    var list$1 = function list2(props, context, dependencies2) {
      var {
        state,
        Validators,
        messageBag: messageBag2,
        validationRules,
        dirt,
        initValidation,
        resetting
      } = base$D(props, context, dependencies2);
      var form$ = dependencies2.form$;
      var children$ = dependencies2.children$;
      var dirty = computed(() => {
        return some_1(children$.value, {
          available: true,
          dirty: true
        }) || state.value.dirty;
      });
      var validated = computed(() => {
        return !some_1(children$.value, {
          available: true,
          validated: false
        }) && state.value.validated;
      });
      var invalid = computed(() => {
        return some_1(children$.value, {
          available: true,
          invalid: true
        }) || some_1(Validators.value, {
          invalid: true
        });
      });
      var pending = computed(() => {
        return some_1(children$.value, {
          available: true,
          pending: true
        }) || some_1(Validators.value, {
          pending: true
        });
      });
      var debouncing = computed(() => {
        return some_1(children$.value, {
          available: true,
          debouncing: true
        }) || some_1(Validators.value, {
          debouncing: true
        });
      });
      var busy = computed(() => {
        return some_1(children$.value, {
          available: true,
          busy: true
        }) || pending.value || debouncing.value;
      });
      var validatorErrors = computed(() => {
        var validatorErrors2 = [];
        each(Validators.value, (Validator2) => {
          if (Validator2.failing) {
            validatorErrors2.push(Validator2.message);
          }
        });
        return validatorErrors2;
      });
      var childrenErrors = computed(() => {
        var childrenErrors2 = [];
        each(children$.value, (element$) => {
          if (!element$.available || element$.isStatic) {
            return;
          }
          each(element$.errors, (error2) => {
            childrenErrors2.push(error2);
          });
        });
        return childrenErrors2;
      });
      var baseErrors = computed(() => {
        return validatorErrors.value.concat(childrenErrors.value);
      });
      var errors = computed(() => {
        return messageBag2.value.errors;
      });
      var error = computed(() => {
        return head_1(validatorErrors.value);
      });
      var validate = /* @__PURE__ */ function() {
        var _ref3 = _asyncToGenerator(function* () {
          if (resetting.value) {
            resetting.value = false;
            return;
          }
          yield validateValidators();
          yield validateChildren();
        });
        return function validate2() {
          return _ref3.apply(this, arguments);
        };
      }();
      var validateValidators = /* @__PURE__ */ function() {
        var _ref4 = _asyncToGenerator(function* () {
          if (resetting.value) {
            resetting.value = false;
            return;
          }
          if (form$.value.validation === false) {
            return;
          }
          yield asyncForEach(Validators.value, /* @__PURE__ */ function() {
            var _ref5 = _asyncToGenerator(function* (Validator2) {
              yield Validator2.validate();
            });
            return function(_x2) {
              return _ref5.apply(this, arguments);
            };
          }());
          state.value.validated = true;
        });
        return function validateValidators2() {
          return _ref4.apply(this, arguments);
        };
      }();
      var validateChildren = /* @__PURE__ */ function() {
        var _ref6 = _asyncToGenerator(function* () {
          if (form$.value.validation === false) {
            return;
          }
          yield asyncForEach(children$.value, /* @__PURE__ */ function() {
            var _ref7 = _asyncToGenerator(function* (element$) {
              if (!element$.isStatic) {
                yield element$.validate();
              }
            });
            return function(_x3) {
              return _ref7.apply(this, arguments);
            };
          }());
        });
        return function validateChildren2() {
          return _ref6.apply(this, arguments);
        };
      }();
      var clean = () => {
        each(children$.value, (element$) => {
          if (element$.isStatic) {
            return;
          }
          element$.clean();
        });
        state.value.dirty = false;
      };
      var clearMessages = () => {
        if (messageBag2.value) {
          messageBag2.value.clear();
        }
        each(children$.value, (element$) => {
          if (element$.isStatic) {
            return;
          }
          element$.clearMessages();
        });
      };
      var resetValidators = () => {
        each(children$.value, (element$) => {
          if (element$.isStatic) {
            return;
          }
          element$.resetValidators();
        });
        each(Validators.value, (Validator2) => {
          Validator2.reset();
        });
        state.value.validated = !validationRules.value;
      };
      var initMessageBag = () => {
        messageBag2.value = new form$.value.$vueform.services.messageBag(baseErrors);
      };
      var reinitValidation = () => {
        initValidation();
        each(children$.value, (element$) => {
          if (element$.isStatic) {
            return;
          }
          element$.reinitValidation();
        });
      };
      return {
        state,
        Validators,
        messageBag: messageBag2,
        resetting,
        dirty,
        validated,
        invalid,
        pending,
        debouncing,
        busy,
        validatorErrors,
        childrenErrors,
        errors,
        error,
        validationRules,
        validate,
        validateValidators,
        validateChildren,
        dirt,
        clean,
        clearMessages,
        resetValidators,
        initMessageBag,
        initValidation,
        reinitValidation
      };
    };
    var multilingual$3 = function multilingual2(props, context, dependencies2) {
      var {
        rules: rules2
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var path = dependencies2.path;
      var languages = dependencies2.languages;
      var language = dependencies2.language;
      var value = dependencies2.value;
      var {
        messageBag: messageBag2,
        clearMessages,
        resetting
      } = text$2(props, context, dependencies2);
      var state = ref({
        dirty: {},
        validated: {}
      });
      var Validators = ref({});
      var validationRules = computed(() => {
        var ruleList = {};
        if (!rules2.value) {
          return ruleList;
        }
        each(languages.value, (lang2) => {
          ruleList[lang2] = isPlainObject_1(rules2.value) ? rules2.value[lang2] || null : rules2.value;
        });
        return ruleList;
      });
      var dirty = computed(() => {
        return some_1(state.value.dirty, (val) => {
          return val === true;
        });
      });
      var validated = computed(() => {
        return !some_1(state.value.validated, (val) => {
          return val === false;
        });
      });
      var invalid = computed(() => {
        var invalid2 = false;
        each(Validators.value, (Validators2) => {
          if (some_1(Validators2, {
            invalid: true
          })) {
            invalid2 = true;
          }
        });
        return invalid2;
      });
      var pending = computed(() => {
        var pending2 = false;
        each(Validators.value, (Validators2) => {
          if (some_1(Validators2, {
            pending: true
          })) {
            pending2 = true;
          }
        });
        return pending2;
      });
      var debouncing = computed(() => {
        var debouncing2 = false;
        each(Validators.value, (Validators2) => {
          if (some_1(Validators2, {
            debouncing: true
          })) {
            debouncing2 = true;
          }
        });
        return debouncing2;
      });
      var busy = computed(() => {
        return pending.value || debouncing.value;
      });
      var validatorErrors = computed(() => {
        var errors2 = [];
        each(Validators.value, (Validators2, language2) => {
          each(Validators2, (Validator2) => {
            if (Validator2.failing) {
              errors2.push(Validator2.message + " (" + language2 + ")");
            }
          });
        });
        return errors2;
      });
      var errors = computed(() => {
        return messageBag2.value.errors;
      });
      var error = computed(() => {
        var error2 = null;
        each(Validators.value[language.value], (Validator2) => {
          if (error2 !== null) {
            return false;
          }
          if (Validator2.failing) {
            error2 = Validator2.message;
          }
        });
        var errors2 = messageBag2.value.prepends ? messageBag2.value.prepends.errors : [];
        if (error2 !== null) {
          errors2 = concat_1(errors2, [error2]);
        }
        errors2 = concat_1(errors2, messageBag2.value.appends ? messageBag2.value.appends.errors : []);
        return head_1(errors2);
      });
      var isDanger = computed(() => {
        return error.value !== null && error.value !== void 0;
      });
      var isSuccess = computed(() => {
        return validationRules.value[language.value] && validationRules.value[language.value].length > 0 && state.value.validated[language.value] && !some_1(Validators.value[language.value], {
          invalid: true
        }) || (!validationRules.value[language.value] || !validationRules.value[language.value].length) && state.value.dirty[language.value];
      });
      var validate = /* @__PURE__ */ function() {
        var _ref8 = _asyncToGenerator(function* () {
          if (resetting.value) {
            resetting.value = false;
            return;
          }
          yield asyncForEach(languages.value, /* @__PURE__ */ function() {
            var _ref9 = _asyncToGenerator(function* (lang2) {
              yield validateLanguage(lang2);
            });
            return function(_x4) {
              return _ref9.apply(this, arguments);
            };
          }());
        });
        return function validate2() {
          return _ref8.apply(this, arguments);
        };
      }();
      var validateLanguage = /* @__PURE__ */ function() {
        var _ref10 = _asyncToGenerator(function* () {
          var lang2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : language.value;
          if (form$.value.validation === false) {
            return;
          }
          if (!Validators.value[lang2]) {
            return;
          }
          yield asyncForEach(Validators.value[lang2], /* @__PURE__ */ function() {
            var _ref11 = _asyncToGenerator(function* (Validator2) {
              yield Validator2.validate(value.value[lang2]);
            });
            return function(_x5) {
              return _ref11.apply(this, arguments);
            };
          }());
          state.value.validated[lang2] = true;
        });
        return function validateLanguage2() {
          return _ref10.apply(this, arguments);
        };
      }();
      var resetValidators = () => {
        each(languages.value, (lang2) => {
          each(Validators.value[lang2], (Validator2) => {
            Validator2.reset();
          });
          each(validationRules.value, (r2, lang3) => {
            state.value.validated[lang3] = r2.length > 0 ? false : true;
          });
        });
      };
      var dirt = () => {
        state.value.dirty[language.value] = true;
      };
      var clean = () => {
        state.value.dirty[language.value] = false;
      };
      var initState = () => {
        var dirty2 = {};
        var validated2 = {};
        each(languages.value, (lang2) => {
          dirty2[lang2] = false;
        });
        each(languages.value, (lang2) => {
          validated2[lang2] = true;
        });
        state.value = {
          dirty: dirty2,
          validated: validated2
        };
      };
      var initMessageBag = () => {
        messageBag2.value = new form$.value.$vueform.services.messageBag(validatorErrors);
      };
      var initValidation = () => {
        if (!validationRules.value) {
          return;
        }
        each(validationRules.value, (r2, lang2) => {
          state.value.validated[lang2] = r2 !== null && r2.length > 0 ? false : true;
        });
        var factory = new form$.value.$vueform.services.validation.factory(path.value, form$.value);
        Validators.value = {};
        each(validationRules.value, (languageRules, lang2) => {
          if (languageRules === null) {
            return;
          }
          if (!Validators.value[lang2]) {
            Validators.value = Object.assign({}, Validators.value, {
              [lang2]: []
            });
          }
          each(factory.makeAll(languageRules), (Validator2) => {
            Validators.value[lang2].push(Validator2);
          });
        });
      };
      var reinitValidation = () => {
        initValidation();
      };
      return {
        state,
        Validators,
        messageBag: messageBag2,
        resetting,
        dirty,
        validated,
        invalid,
        pending,
        debouncing,
        busy,
        errors,
        error,
        validationRules,
        isDanger,
        isSuccess,
        validate,
        validateLanguage,
        dirt,
        clean,
        clearMessages,
        resetValidators,
        initState,
        initMessageBag,
        initValidation,
        reinitValidation
      };
    };
    var slider$1 = function slider2(props, context, dependencies2) {
      var value = dependencies2.value;
      var {
        state,
        Validators,
        messageBag: messageBag2,
        resetting,
        dirty,
        validated,
        invalid,
        pending,
        busy,
        errors,
        error,
        validationRules,
        dirt,
        clean,
        clearMessages,
        resetValidators,
        initMessageBag,
        initValidation,
        reinitValidation
      } = base$D(props, context, dependencies2);
      var validate = /* @__PURE__ */ function() {
        var _ref12 = _asyncToGenerator(function* () {
          if (!validationRules.value) {
            return;
          }
          if (resetting.value) {
            resetting.value = false;
            return;
          }
          if (isArray_1(value.value)) {
            yield asyncForEach(value.value, /* @__PURE__ */ function() {
              var _ref13 = _asyncToGenerator(function* (val) {
                yield asyncForEach(Validators.value, /* @__PURE__ */ function() {
                  var _ref14 = _asyncToGenerator(function* (Validator2) {
                    yield Validator2.validate(val);
                  });
                  return function(_x7) {
                    return _ref14.apply(this, arguments);
                  };
                }());
                if (invalid.value) {
                  return false;
                }
              });
              return function(_x6) {
                return _ref13.apply(this, arguments);
              };
            }());
          } else {
            yield asyncForEach(Validators.value, /* @__PURE__ */ function() {
              var _ref15 = _asyncToGenerator(function* (Validator2) {
                yield Validator2.validate(value.value);
              });
              return function(_x8) {
                return _ref15.apply(this, arguments);
              };
            }());
          }
          state.value.validated = true;
        });
        return function validate2() {
          return _ref12.apply(this, arguments);
        };
      }();
      return {
        state,
        Validators,
        messageBag: messageBag2,
        resetting,
        dirty,
        validated,
        invalid,
        pending,
        busy,
        errors,
        error,
        validationRules,
        validate,
        dirt,
        clean,
        clearMessages,
        resetValidators,
        initMessageBag,
        initValidation,
        reinitValidation
      };
    };
    var file$1 = function file2(props, context, dependencies2) {
      var form$ = dependencies2.form$;
      var value = dependencies2.value;
      var uploading = dependencies2.uploading;
      var removing = dependencies2.removing;
      var {
        state,
        Validators,
        messageBag: messageBag2,
        resetting,
        dirty,
        validated,
        invalid,
        pending,
        errors,
        error,
        validationRules,
        dirt,
        clean,
        clearMessages,
        resetValidators,
        initMessageBag,
        initValidation,
        reinitValidation
      } = base$D(props, context, dependencies2);
      var busy = computed(() => {
        return pending.value || uploading.value || removing.value;
      });
      var validate = /* @__PURE__ */ function() {
        var _ref16 = _asyncToGenerator(function* () {
          if (!validationRules.value) {
            return;
          }
          if (form$.value.validation === false) {
            return;
          }
          if (resetting.value) {
            resetting.value = false;
            return;
          }
          var restricted = ["min", "max", "between", "size", "mimetypes", "mimes", "dimensions", "file", "image", "gt", "gte", "lt", "lte"];
          yield asyncForEach(Validators.value, /* @__PURE__ */ function() {
            var _ref17 = _asyncToGenerator(function* (Validator2) {
              if (!(value.value instanceof File) && !!value.value && restricted.indexOf(Validator2.name) !== -1) {
                return;
              }
              yield Validator2.validate();
            });
            return function(_x9) {
              return _ref17.apply(this, arguments);
            };
          }());
          state.value.validated = true;
        });
        return function validate2() {
          return _ref16.apply(this, arguments);
        };
      }();
      return {
        state,
        Validators,
        messageBag: messageBag2,
        resetting,
        dirty,
        validated,
        invalid,
        pending,
        busy,
        errors,
        error,
        validationRules,
        validate,
        dirt,
        clean,
        clearMessages,
        resetValidators,
        initMessageBag,
        initValidation,
        reinitValidation
      };
    };
    var location = function location2(props, context, dependencies2) {
      var {
        displayKey
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var value = dependencies2.value;
      var {
        state,
        Validators,
        messageBag: messageBag2,
        resetting,
        dirty,
        validated,
        invalid,
        pending,
        debouncing,
        busy,
        errors,
        error,
        validationRules,
        isSuccess,
        isDanger,
        dirt,
        clean,
        clearMessages,
        resetValidators,
        initMessageBag,
        initValidation,
        reinitValidation
      } = text$2(props, context, dependencies2);
      var validate = /* @__PURE__ */ function() {
        var _ref18 = _asyncToGenerator(function* () {
          if (!validationRules.value) {
            return;
          }
          if (form$.value.validation === false) {
            return;
          }
          if (resetting.value) {
            resetting.value = false;
            return;
          }
          yield asyncForEach(Validators.value, /* @__PURE__ */ function() {
            var _ref19 = _asyncToGenerator(function* (Validator2) {
              yield Validator2.validate(value.value[displayKey.value]);
            });
            return function(_x10) {
              return _ref19.apply(this, arguments);
            };
          }());
          state.value.validated = true;
        });
        return function validate2() {
          return _ref18.apply(this, arguments);
        };
      }();
      return {
        state,
        Validators,
        messageBag: messageBag2,
        resetting,
        dirty,
        validated,
        invalid,
        pending,
        debouncing,
        busy,
        errors,
        error,
        validationRules,
        isSuccess,
        isDanger,
        validate,
        dirt,
        clean,
        clearMessages,
        resetValidators,
        initMessageBag,
        initValidation,
        reinitValidation
      };
    };
    var group$3 = list$1;
    var object$3 = list$1;
    var base$C = function base2(props, context, dependencies2) {
      var {
        default: default_,
        name: name2
      } = toRefs(props);
      var nullValue = dependencies2.nullValue;
      var form$ = dependencies2.form$;
      var parent2 = dependencies2.parent;
      var defaultValue = computed(() => {
        var parentDefaultValue;
        if (parent2 && parent2.value && !parent2.value.mounted) {
          parentDefaultValue = parent2.value.defaultValue[name2.value];
        } else if (!form$.value.mounted && form$.value.options.default[name2.value] !== void 0) {
          parentDefaultValue = form$.value.options.default[name2.value];
        }
        if (parentDefaultValue !== void 0) {
          return parentDefaultValue instanceof File ? new File([parentDefaultValue], parentDefaultValue.name, parentDefaultValue) : cloneDeep_1(parentDefaultValue);
        }
        if (default_.value !== void 0) {
          return default_.value instanceof File ? new File([default_.value], default_.value.name, default_.value) : cloneDeep_1(default_.value);
        }
        return cloneDeep_1(nullValue.value);
      });
      return {
        defaultValue
      };
    };
    var text$1 = function text2(props, context, dependencies2) {
      var {
        default: default_,
        name: name2
      } = toRefs(props);
      var nullValue = dependencies2.nullValue;
      var form$ = dependencies2.form$;
      var parent2 = dependencies2.parent;
      var config$ = inject("config$");
      var defaultValue = computed(() => {
        var parentDefaultValue;
        if (parent2 && parent2.value && !parent2.value.mounted) {
          parentDefaultValue = parent2.value.defaultValue[name2.value];
        } else if (!form$.value.mounted && typeof form$.value.options.default[name2.value] !== void 0) {
          parentDefaultValue = form$.value.options.default[name2.value];
        }
        if (parentDefaultValue !== void 0) {
          return parentDefaultValue instanceof File ? new File([parentDefaultValue], parentDefaultValue.name, parentDefaultValue) : isPlainObject_1(parentDefaultValue) ? localize(cloneDeep_1(parentDefaultValue), config$.value, form$.value) : cloneDeep_1(parentDefaultValue);
        }
        if (default_.value !== void 0) {
          return default_.value instanceof File ? new File([default_.value], default_.value.name, default_.value) : isPlainObject_1(default_.value) ? localize(cloneDeep_1(default_.value), config$.value, form$.value) : cloneDeep_1(default_.value);
        }
        return cloneDeep_1(nullValue.value);
      });
      return {
        defaultValue
      };
    };
    var object$2 = function object2(props, context, dependencies2) {
      var {
        default: default_,
        name: name2
      } = toRefs(props);
      var nullValue = dependencies2.nullValue;
      var form$ = dependencies2.form$;
      var parent2 = dependencies2.parent;
      var defaultValue = computed(() => {
        var parentDefaultValue;
        if (parent2 && parent2.value && !parent2.value.mounted) {
          parentDefaultValue = parent2.value.defaultValue[name2.value];
        } else if (!form$.value.mounted && form$.value.options.default[name2.value]) {
          parentDefaultValue = form$.value.options.default[name2.value];
        }
        if (parentDefaultValue !== void 0) {
          return cloneDeep_1(merge_1({}, default_.value || /* istanbul ignore next: `default_.value` will never be undefined, because it is a hardwired `{}` */
          nullValue.value, parentDefaultValue));
        }
        if (Object.keys(default_.value).length > 0) {
          return cloneDeep_1(default_.value);
        }
        return cloneDeep_1(nullValue.value);
      });
      return {
        defaultValue
      };
    };
    var group$2 = function group2(props, context, dependencies2) {
      var {
        default: default_
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var parent2 = dependencies2.parent;
      var defaultValue = computed(() => {
        var parentDefaultValue = {};
        if (parent2 && parent2.value && !parent2.value.mounted) {
          parentDefaultValue = parent2.value.defaultValue;
        } else if (!form$.value.mounted && form$.value.options.default) {
          parentDefaultValue = form$.value.options.default;
        }
        return cloneDeep_1(merge_1({}, default_.value, parentDefaultValue));
      });
      return {
        defaultValue
      };
    };
    var multilingual$2 = function multilingual2(props, context, dependencies2) {
      var {
        default: default_,
        name: name2
      } = toRefs(props);
      var nullValue = dependencies2.nullValue;
      var form$ = dependencies2.form$;
      var parent2 = dependencies2.parent;
      var defaultValue = computed(() => {
        var parentDefaultValue;
        if (parent2 && parent2.value && !parent2.value.mounted) {
          parentDefaultValue = parent2.value.defaultValue[name2.value];
        } else if (!form$.value.mounted && form$.value.options.default[name2.value]) {
          parentDefaultValue = form$.value.options.default[name2.value];
        }
        if (parentDefaultValue !== void 0) {
          return cloneDeep_1(Object.assign({}, clone_1(nullValue.value), parentDefaultValue));
        }
        if (default_.value === void 0) {
          return clone_1(nullValue.value);
        }
        var def2 = clone_1(default_.value);
        if (!isPlainObject_1(def2)) {
          var tempDefault = {};
          each(nullValue.value, (v2, language) => {
            tempDefault[language] = def2;
          });
          def2 = tempDefault;
        }
        return Object.assign({}, clone_1(nullValue.value), def2);
      });
      return {
        defaultValue
      };
    };
    function baseSortBy$1(array2, comparer) {
      var length = array2.length;
      array2.sort(comparer);
      while (length--) {
        array2[length] = array2[length].value;
      }
      return array2;
    }
    var _baseSortBy = baseSortBy$1;
    var isSymbol = isSymbol_1;
    function compareAscending$1(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    var _compareAscending = compareAscending$1;
    var compareAscending = _compareAscending;
    function compareMultiple$1(object2, other, orders) {
      var index2 = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index2 < length) {
        var result = compareAscending(objCriteria[index2], othCriteria[index2]);
        if (result) {
          if (index2 >= ordersLength) {
            return result;
          }
          var order2 = orders[index2];
          return result * (order2 == "desc" ? -1 : 1);
        }
      }
      return object2.index - other.index;
    }
    var _compareMultiple = compareMultiple$1;
    var arrayMap = _arrayMap, baseGet = _baseGet, baseIteratee = _baseIteratee, baseMap = _baseMap, baseSortBy = _baseSortBy, baseUnary = _baseUnary, compareMultiple = _compareMultiple, identity = identity_1, isArray = isArray_1;
    function baseOrderBy$1(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index2 = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index2, "value": value };
      });
      return baseSortBy(result, function(object2, other) {
        return compareMultiple(object2, other, orders);
      });
    }
    var _baseOrderBy = baseOrderBy$1;
    var baseFlatten = _baseFlatten, baseOrderBy = _baseOrderBy, baseRest = _baseRest, isIterateeCall = _isIterateeCall;
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    var sortBy_1 = sortBy;
    var base$B = function base2(props, context, dependencies2) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var {
        submit,
        formatData,
        formatLoad,
        name: name2
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var available = dependencies2.available;
      var value = dependencies2.value;
      var resetValidators = dependencies2.resetValidators;
      var defaultValue = dependencies2.defaultValue;
      var nullValue = dependencies2.nullValue;
      var resetting = dependencies2.resetting;
      var isDefault = dependencies2.isDefault;
      var setValue = (val) => {
        if (options.setValue) {
          return options.setValue(val);
        }
        value.value = val;
      };
      var data = computed(() => {
        return {
          [name2.value]: value.value
        };
      });
      var requestData = computed(() => {
        if (!available.value || !submit.value) {
          return {};
        }
        return formatData.value ? formatData.value(name2.value, value.value, form$.value) : {
          [name2.value]: value.value
        };
      });
      var load = function load2(val) {
        var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        setValue(format2 && formatLoad.value ? formatLoad.value(val, form$.value) : val);
      };
      var update = (val) => {
        setValue(val);
      };
      var clear2 = () => {
        setValue(cloneDeep_1(nullValue.value));
      };
      var reset = () => {
        if (!isDefault.value) {
          resetting.value = true;
        }
        setValue(cloneDeep_1(defaultValue.value));
        resetValidators();
      };
      var prepare = /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator(function* () {
        });
        return function prepare2() {
          return _ref.apply(this, arguments);
        };
      }();
      return {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      };
    };
    var text = function text2(props, context, dependencies2) {
      var {
        submit,
        formatData,
        name: name2,
        forceNumbers
      } = toRefs(props);
      var {
        load,
        update,
        clear: clear2,
        reset,
        prepare
      } = base$B(props, context, dependencies2);
      var form$ = dependencies2.form$;
      var available = dependencies2.available;
      var value = dependencies2.value;
      var config$ = inject("config$");
      var data = computed(() => {
        var v2 = value.value;
        if (shouldForceNumbers()) {
          v2 = stringToNumber(value.value);
        }
        return {
          [name2.value]: v2
        };
      });
      var requestData = computed(() => {
        if (!available.value || !submit.value) {
          return {};
        }
        var v2 = value.value;
        if (shouldForceNumbers()) {
          v2 = stringToNumber(value.value);
        }
        return formatData.value ? formatData.value(name2.value, v2, form$.value) : {
          [name2.value]: v2
        };
      });
      var shouldForceNumbers = () => {
        return forceNumbers.value || config$.value.config.forceNumbers && form$.value.options.forceNumbers !== false && forceNumbers.value !== false || form$.value.options.forceNumbers && forceNumbers.value !== false;
      };
      var stringToNumber = (str) => {
        var v2 = str;
        if (typeof str === "string") {
          if (/^[-]?\d+([\.,]\d+)?$/.test(str)) {
            v2 = parseFloat(str.replace(",", "."));
          } else if (/^[-]?\d+$/.test(str)) {
            v2 = parseInt(str, 10);
          }
        }
        return v2;
      };
      return {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      };
    };
    var select$3 = function select2(props, context, dependencies2) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var {
        resolveOnLoad,
        items
      } = toRefs(props);
      var {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        prepare
      } = base$B(props, context, dependencies2);
      var value = dependencies2.value;
      var resetValidators = dependencies2.resetValidators;
      var defaultValue = dependencies2.defaultValue;
      var updateItems = dependencies2.updateItems;
      var resetting = dependencies2.resetting;
      var isDefault = dependencies2.isDefault;
      var setValue = (val) => {
        if (options.setValue) {
          return options.setValue(val);
        }
        value.value = val;
      };
      var reset = () => {
        if (!isDefault.value) {
          resetting.value = true;
        }
        setValue(cloneDeep_1(defaultValue.value));
        resetValidators();
        if (typeof items.value === "string" && resolveOnLoad.value !== false) {
          updateItems();
        }
      };
      return {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      };
    };
    var captcha = function captcha2(props, context, dependencies2) {
      var {
        data,
        requestData,
        load,
        update,
        clear: clearBase,
        reset: resetBase,
        prepare
      } = base$B(props, context, dependencies2);
      var {
        Provider
      } = dependencies2;
      var clear2 = () => {
        clearBase();
        if (!Provider.value) {
          return;
        }
        Provider.value.reset();
      };
      var reset = () => {
        resetBase();
        if (!Provider.value) {
          return;
        }
        Provider.value.reset();
      };
      return {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      };
    };
    var object$1 = function object2(props, context, dependencies2) {
      var {
        name: name2,
        formatLoad,
        formatData,
        submit
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var available = dependencies2.available;
      var children$ = dependencies2.children$;
      var children$Array = dependencies2.children$Array;
      var resetting = dependencies2.resetting;
      var isDefault = dependencies2.isDefault;
      var data = computed(() => {
        var data2 = {};
        each(children$.value, (element$) => {
          if (element$.isStatic) {
            return;
          }
          data2 = Object.assign({}, data2, element$.data);
        });
        return {
          [name2.value]: data2
        };
      });
      var requestData = computed(() => {
        if (!available.value || !submit.value) {
          return {};
        }
        var requestData2 = {};
        each(children$.value, (element$) => {
          if (element$.isStatic) {
            return;
          }
          requestData2 = Object.assign({}, requestData2, element$.requestData);
        });
        return formatData.value ? formatData.value(name2.value, requestData2, form$.value) : {
          [name2.value]: requestData2
        };
      });
      var load = function load2(val) {
        var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var formatted = format2 && formatLoad.value ? formatLoad.value(val, form$.value) : val;
        each(children$.value, (element$) => {
          if (element$.isStatic) {
            return;
          }
          if (!element$.flat && formatted[element$.name] === void 0) {
            element$.clear();
            return;
          }
          element$.load(element$.flat ? formatted : formatted[element$.name], format2);
        });
      };
      var update = (val) => {
        each(children$.value, (element$) => {
          if (element$.isStatic) {
            return;
          }
          if (val[element$.name] === void 0 && !element$.flat) {
            return;
          }
          element$.update(element$.flat ? val : val[element$.name]);
        });
      };
      var clear2 = () => {
        each(children$.value, (element$) => {
          if (element$.isStatic) {
            return;
          }
          element$.clear();
        });
      };
      var reset = () => {
        if (!isDefault.value) {
          resetting.value = true;
        }
        each(children$.value, (element$) => {
          if (element$.isStatic) {
            return;
          }
          element$.reset();
        });
      };
      var prepare = /* @__PURE__ */ function() {
        var _ref2 = _asyncToGenerator(function* () {
          yield asyncForEach(children$Array.value, /* @__PURE__ */ function() {
            var _ref3 = _asyncToGenerator(function* (e$) {
              if (e$.prepare) {
                yield e$.prepare();
              }
            });
            return function(_x) {
              return _ref3.apply(this, arguments);
            };
          }());
        });
        return function prepare2() {
          return _ref2.apply(this, arguments);
        };
      }();
      return {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      };
    };
    var group$1 = function group2(props, context, dependencies2) {
      var {
        name: name2,
        formatData,
        submit
      } = toRefs(props);
      var {
        load,
        update,
        clear: clear2,
        reset,
        prepare
      } = object$1(props, context, dependencies2);
      var form$ = dependencies2.form$;
      var children$ = dependencies2.children$;
      var available = dependencies2.available;
      dependencies2.value;
      var data = computed(() => {
        var data2 = {};
        each(children$.value, (element$) => {
          if (element$.isStatic) {
            return;
          }
          data2 = Object.assign({}, data2, element$.data);
        });
        return data2;
      });
      var requestData = computed(() => {
        if (!available.value || !submit.value) {
          return {};
        }
        var requestData2 = {};
        each(children$.value, (element$) => {
          if (element$.isStatic) {
            return;
          }
          requestData2 = Object.assign({}, requestData2, element$.requestData);
        });
        return formatData.value ? formatData.value(name2.value, requestData2, form$.value) : requestData2;
      });
      return {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      };
    };
    var list = function list2(props, context, dependencies2, options) {
      var {
        name: name2,
        storeOrder,
        formatLoad,
        formatData,
        order: order2,
        submit,
        initial,
        default: default_
      } = toRefs(props);
      var {
        update,
        clear: clear2,
        data
      } = base$B(props, context, dependencies2);
      var form$ = dependencies2.form$;
      var children$ = dependencies2.children$;
      var children$Array = dependencies2.children$Array;
      var available = dependencies2.available;
      var isDisabled = dependencies2.isDisabled;
      var value = dependencies2.value;
      var orderByName = dependencies2.orderByName;
      var refreshOrderStore = dependencies2.refreshOrderStore;
      var dataPath = dependencies2.dataPath;
      var parent2 = dependencies2.parent;
      var nullValue = dependencies2.nullValue;
      var defaultValue = dependencies2.defaultValue;
      var fire = dependencies2.fire;
      var resetValidators = dependencies2.resetValidators;
      var resetting = dependencies2.resetting;
      var isDefault = dependencies2.isDefault;
      var initialValue = ref(get_1(form$.value.model, dataPath.value));
      var parentDefaultValue = computed(() => {
        return parent2 && parent2.value ? parent2.value.defaultValue[name2.value] : form$.value.options.default[name2.value];
      });
      var requestData = computed(() => {
        if (!available.value || !submit.value) {
          return {};
        }
        var requestData2 = [];
        each(children$.value, (element$) => {
          var val = element$.requestData[element$.name];
          if (val !== void 0) {
            requestData2.push(val);
          }
        });
        return formatData.value ? formatData.value(name2.value, requestData2, form$.value) : {
          [name2.value]: requestData2
        };
      });
      var length = computed(() => {
        return Object.keys(value.value || /* istanbul ignore next: failsafe only */
        {}).length;
      });
      var add2 = function add3() {
        var val = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        var focus = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var newValue = storeOrder.value ? Object.assign({}, val || {}, {
          [storeOrder.value]: val ? val[storeOrder.value] : void 0
        }) : val;
        value.value = refreshOrderStore(value.value.concat([newValue]));
        var index2 = value.value.length - 1;
        fire("add", index2, newValue, value.value);
        if (focus) {
          nextTick(() => {
            children$Array.value[children$Array.value.length - 1].focus();
          });
        }
        return index2;
      };
      var remove2 = (index2) => {
        value.value = value.value.filter((v2, i3) => i3 !== index2);
        refreshOrderStore(value.value);
        fire("remove", index2, value.value);
      };
      var load = /* @__PURE__ */ function() {
        var _ref4 = _asyncToGenerator(function* (val) {
          var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var values2 = sortValue(format2 && formatLoad.value ? formatLoad.value(val, form$.value) : val);
          clear2();
          yield nextTick();
          for (var i3 = 0; i3 < values2.length; i3++) {
            add2();
          }
          yield nextTick();
          each(children$.value, (child$, i4) => {
            child$.load(values2[i4], format2);
          });
        });
        return function load2(_x2) {
          return _ref4.apply(this, arguments);
        };
      }();
      var reset = () => {
        if (!isDefault.value) {
          resetting.value = true;
        }
        value.value = cloneDeep_1(defaultValue.value);
        resetValidators();
        if (!value.value.length && initial.value > 0) {
          for (var i3 = 0; i3 < initial.value; i3++) {
            add2();
          }
          children$Array.value.forEach((child$) => {
            child$.reset();
          });
        }
        nextTick(() => {
          refreshOrderStore(value.value);
        });
      };
      var prepare = /* @__PURE__ */ function() {
        var _ref5 = _asyncToGenerator(function* () {
          yield asyncForEach(children$Array.value, /* @__PURE__ */ function() {
            var _ref6 = _asyncToGenerator(function* (e$) {
              if (e$.prepare) {
                yield e$.prepare();
              }
            });
            return function(_x3) {
              return _ref6.apply(this, arguments);
            };
          }());
        });
        return function prepare2() {
          return _ref5.apply(this, arguments);
        };
      }();
      var sortValue = (val) => {
        if (!order2.value && !orderByName.value || !val) {
          return val;
        }
        var desc = order2.value && typeof order2.value === "string" && order2.value.toUpperCase() == "DESC";
        if (orderByName.value) {
          val = desc ? sortBy_1(val, orderByName.value).reverse() : sortBy_1(val, orderByName.value);
        } else if (order2.value) {
          val = desc ? val.sort().reverse() : val.sort();
        }
        return val;
      };
      var handleAdd = () => {
        if (isDisabled.value) {
          return;
        }
        add2(void 0, true);
      };
      var handleRemove = (index2) => {
        if (isDisabled.value) {
          return;
        }
        remove2(index2);
      };
      if (initialValue.value === void 0 && parentDefaultValue.value === void 0 && default_.value === void 0) {
        if (initial.value > 0) {
          for (var i2 = 0; i2 < initial.value; i2++) {
            add2();
          }
        } else {
          value.value = nullValue.value;
        }
      } else if (initialValue.value === void 0) {
        value.value = defaultValue.value;
      }
      return {
        requestData,
        data,
        length,
        add: add2,
        remove: remove2,
        load,
        update,
        clear: clear2,
        reset,
        handleAdd,
        handleRemove,
        prepare
      };
    };
    var date$2 = function date2(props, context, dependencies2) {
      var {
        formatLoad
      } = toRefs(props);
      var {
        data,
        requestData,
        update,
        clear: clear2,
        reset,
        prepare
      } = base$B(props, context, dependencies2);
      var form$ = dependencies2.form$;
      var value = dependencies2.value;
      var loadDateFormat = dependencies2.loadDateFormat;
      var moment = form$.value.$vueform.services.moment;
      var load = function load2(val) {
        var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var formatted = format2 && formatLoad.value ? formatLoad.value(val, form$.value) : val;
        checkDateFormat(loadDateFormat.value, formatted, moment);
        value.value = formatted instanceof Date || !formatted ? formatted : moment(formatted, loadDateFormat.value).toDate();
      };
      return {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      };
    };
    var dates$3 = function dates2(props, context, dependencies2) {
      var {
        formatLoad
      } = toRefs(props);
      var {
        data,
        requestData,
        update,
        clear: clear2,
        reset,
        prepare
      } = base$B(props, context, dependencies2);
      var form$ = dependencies2.form$;
      var value = dependencies2.value;
      var loadDateFormat = dependencies2.loadDateFormat;
      var moment = form$.value.$vueform.services.moment;
      var load = function load2(val) {
        var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var formatted = format2 && formatLoad.value ? formatLoad.value(val, form$.value) : val;
        value.value = map_1(formatted, (v2) => {
          checkDateFormat(loadDateFormat.value, v2, moment);
          return v2 instanceof Date ? v2 : moment(v2, loadDateFormat.value).toDate();
        });
      };
      return {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      };
    };
    var multilingual$1 = function multilingual2(props, context, dependencies2) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var {
        formatLoad
      } = toRefs(props);
      var {
        data,
        requestData,
        clear: clear2,
        reset,
        prepare
      } = base$B(props, context, dependencies2, options);
      var form$ = dependencies2.form$;
      var value = dependencies2.value;
      var language = dependencies2.language;
      var nullValue = dependencies2.nullValue;
      var setValue = (val) => {
        if (options.setValue) {
          return options.setValue(val);
        }
        value.value = val;
      };
      var load = function load2(val) {
        var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var formatted = format2 && formatLoad.value ? formatLoad.value(val, form$.value) : val;
        if (!isPlainObject_1(formatted)) {
          throw new Error("Multilingual element requires an object to load");
        }
        setValue(Object.assign({}, clone_1(nullValue.value), formatted));
      };
      var update = (val) => {
        var updateValue = val;
        if (!isPlainObject_1(updateValue)) {
          updateValue = {
            [language.value]: val
          };
        }
        setValue(Object.assign({}, value.value, updateValue));
      };
      return {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      };
    };
    var editor = function editor2(props, context, dependencies2) {
      var {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      } = base$B(props, context, dependencies2, {
        setValue: (val) => {
          value.value = val;
          nextTick(() => {
            var _input$value;
            (_input$value = input.value) === null || _input$value === void 0 || _input$value.update(val);
          });
        }
      });
      var input = dependencies2.input;
      var value = dependencies2.value;
      return {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      };
    };
    var teditor = function teditor2(props, context, dependencies2) {
      var {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      } = multilingual$1(props, context, dependencies2, {
        setValue: (val) => {
          value.value = val;
          nextTick(() => {
            input.value.update(val[language.value]);
          });
        }
      });
      var input = dependencies2.input;
      var model = dependencies2.model;
      var value = dependencies2.value;
      var language = dependencies2.language;
      watch(language, () => {
        input.value.update(model.value);
      });
      return {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      };
    };
    var file = function file2(props, context, dependencies2) {
      var {
        load,
        update,
        clear: clear2,
        reset,
        prepare
      } = base$B(props, context, dependencies2);
      var {
        submit,
        formatData,
        name: name2
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var available = dependencies2.available;
      var value = dependencies2.value;
      var data = computed(() => {
        var _v;
        var v2 = value.value;
        if (typeof v2 === "object" && (_v = v2) !== null && _v !== void 0 && _v.__file__) {
          v2 = v2 instanceof File ? v2 : _objectSpread2$1({}, v2);
          delete v2.__file__;
        }
        return {
          [name2.value]: v2
        };
      });
      var requestData = computed(() => {
        var _v2;
        if (!available.value || !submit.value) {
          return {};
        }
        var v2 = value.value;
        if (typeof v2 === "object" && (_v2 = v2) !== null && _v2 !== void 0 && _v2.__file__) {
          v2 = v2 instanceof File ? v2 : _objectSpread2$1({}, v2);
          delete v2.__file__;
        }
        return formatData.value ? formatData.value(name2.value, v2, form$.value) : {
          [name2.value]: v2
        };
      });
      return {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      };
    };
    var multifile$4 = function multifile2(props, context, dependencies2) {
      var {
        length,
        add: add2,
        remove: remove2,
        load,
        update,
        clear: clear2,
        reset,
        handleAdd,
        handleRemove,
        prepare
      } = list(props, context, dependencies2);
      var {
        submit,
        formatData,
        name: name2
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var available = dependencies2.available;
      var value = dependencies2.value;
      var children$ = dependencies2.children$;
      var data = computed(() => {
        var val = value.value;
        val = val.map((file2) => {
          if (typeof file2 === "object" && file2 !== null && file2 !== void 0 && file2.__file__) {
            var v2 = file2 instanceof File ? file2 : _objectSpread2$1({}, file2);
            delete v2.__file__;
            return v2;
          }
          return file2;
        });
        return {
          [name2.value]: val
        };
      });
      var requestData = computed(() => {
        if (!available.value || !submit.value) {
          return {};
        }
        var requestData2 = [];
        each(children$.value, (element$) => {
          var val = element$.requestData[element$.name];
          if (val !== void 0) {
            var _val;
            if (typeof val === "object" && (_val = val) !== null && _val !== void 0 && _val.__file__) {
              var v2 = file instanceof File ? file : _objectSpread2$1({}, file);
              delete v2.__file__;
              val = v2;
            }
            requestData2.push(val);
          }
        });
        return formatData.value ? formatData.value(name2.value, requestData2, form$.value) : {
          [name2.value]: requestData2
        };
      });
      return {
        requestData,
        data,
        length,
        add: add2,
        remove: remove2,
        load,
        update,
        clear: clear2,
        reset,
        handleAdd,
        handleRemove,
        prepare
      };
    };
    var signature = function signature2(props, context, dependencies2) {
      var {
        data,
        requestData,
        load,
        update,
        clear: clearBase,
        reset: resetBase
      } = base$B(props, context, dependencies2);
      var {
        mode,
        clearSignature,
        typingToImage,
        drawingToImage,
        uploaded,
        setDefaultMode,
        setDefaultFont,
        setDefaultColor
      } = dependencies2;
      var clear2 = () => {
        clearBase();
        clearSignature();
      };
      var reset = () => {
        clearSignature();
        setDefaultMode(true);
        setDefaultFont(true);
        setDefaultColor();
        resetBase();
      };
      var prepare = /* @__PURE__ */ function() {
        var _ref7 = _asyncToGenerator(function* () {
          if (uploaded.value) {
            return;
          }
          if (mode.value === "type") {
            yield typingToImage();
          }
          if (mode.value === "draw") {
            yield drawingToImage();
          }
        });
        return function prepare2() {
          return _ref7.apply(this, arguments);
        };
      }();
      return {
        data,
        requestData,
        load,
        update,
        clear: clear2,
        reset,
        prepare
      };
    };
    var multiselect$3 = select$3;
    var tags$3 = select$3;
    var HasChange = {
      props: {
        onChange: {
          required: false,
          type: [Function],
          default: null,
          private: true
        }
      }
    };
    var HasData = {
      props: {
        formatData: {
          required: false,
          type: [Function],
          default: null
        },
        formatLoad: {
          required: false,
          type: [Function],
          default: null
        },
        submit: {
          required: false,
          type: [Boolean],
          default: true
        }
      }
    };
    var HasValidation = {
      props: {
        rules: {
          required: false,
          type: [Array, String, Object],
          default: null
        },
        messages: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        fieldName: {
          required: false,
          type: [String],
          "@default": "name|label"
        }
      }
    };
    var CaptchaElement = {
      name: "CaptchaElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "captcha",
          private: true
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        default: {
          required: false,
          type: [String],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        readonly: {
          required: false,
          type: [Boolean],
          default: false
        },
        rules: {
          required: false,
          type: [Array, String, Object],
          default: ["captcha"]
        },
        size: {
          required: false,
          type: [String],
          default: void 0,
          private: true
        },
        fieldName: {
          required: false,
          type: [String],
          "@default": "name|label",
          private: true
        },
        provider: {
          required: false,
          type: [String],
          default: null,
          "@default": "config.useProviders.captcha"
        },
        options: {
          required: false,
          type: [Object],
          default: () => ({})
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$G, base$1c, base$P, base$C, base$14, base$D, base$H, base$L, base$E, base$I, captcha, base$$, base$J, captcha$1, base$Y, base$1a, base$_, base$X, base$F, base$T];
        context.slots = ["label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$A = function base2(props, context, dependencies2) {
      var {
        text: text2
      } = toRefs(props);
      var config$ = inject("config$");
      var form$ = inject("form$");
      var Text2 = computed(() => {
        return localize(text2.value, config$.value, form$.value) || "";
      });
      return {
        Text: Text2
      };
    };
    var base$z = function base2(props, context, dependencies2) {
      var {
        trueValue,
        falseValue
      } = toRefs(props);
      var update = dependencies2.update;
      var check2 = () => {
        update(trueValue.value);
      };
      var uncheck = () => {
        update(falseValue.value);
      };
      return {
        check: check2,
        uncheck
      };
    };
    var checkbox = function checkbox2(props, context, dependencies2) {
      var {
        trueValue,
        falseValue
      } = toRefs(props);
      var update = dependencies2.update;
      var check2 = () => {
        update(trueValue.value);
      };
      var uncheck = () => {
        update(falseValue.value);
      };
      return {
        check: check2,
        uncheck
      };
    };
    var CheckboxElement = {
      name: "CheckboxElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "checkbox",
          private: true
        },
        default: {
          required: false,
          type: [String, Boolean, Number],
          default: void 0
          // falseValue
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        text: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        trueValue: {
          required: false,
          type: [Boolean, String, Number],
          default: true
        },
        falseValue: {
          required: false,
          type: [Boolean, String, Number],
          default: false
        },
        align: {
          required: false,
          type: [String],
          default: void 0
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, boolean, base$U, base$1c, base$P, base$C, base$14, base$D, base$L, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, checkbox, checkbox$1, base$F, base$T, base$A];
        context.slots = ["default", "label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$y = function base2(props, context, dependencies2) {
      var value = dependencies2.value;
      var resolvedOptions = dependencies2.resolvedOptions;
      var toggle2 = (val) => {
        if (value.value.indexOf(String(val)) === -1 && value.value.indexOf(Number(val)) === -1) {
          check2(val);
        } else {
          uncheck(val);
        }
      };
      var check2 = (values2) => {
        if (!isArray_1(values2)) {
          values2 = [values2];
        }
        var items = clone_1(value.value);
        each(values2, (item) => {
          if (items.indexOf(String(item)) === -1 && items.indexOf(Number(item)) === -1) {
            items.push(item);
          }
        });
        value.value = items;
      };
      var uncheck = (values2) => {
        if (!isArray_1(values2)) {
          values2 = [values2];
        }
        var items = clone_1(value.value);
        each(values2, (item) => {
          var index2 = items.indexOf(String(item));
          if (index2 === -1) {
            index2 = items.indexOf(Number(item));
          }
          if (index2 !== -1) {
            items.splice(index2, 1);
          }
        });
        value.value = items;
      };
      var checkAll = () => {
        check2(resolvedOptions.value.map((o2) => o2.value));
      };
      var uncheckAll = () => {
        uncheck(resolvedOptions.value.map((o2) => o2.value));
      };
      return {
        toggle: toggle2,
        check: check2,
        uncheck,
        checkAll,
        uncheckAll
      };
    };
    var base$x = function base2(props, context, dependencies2) {
      var {
        items,
        valueProp,
        labelProp,
        dataKey,
        searchParam,
        clearOnRefetch,
        object: object2
      } = toRefs(props);
      var isNative = dependencies2.isNative;
      var disable = dependencies2.disable;
      var enable = dependencies2.enable;
      var input = dependencies2.input;
      var value = dependencies2.value;
      var nullValue = dependencies2.nullValue;
      var path = dependencies2.path;
      var el$ = dependencies2.el$;
      var form$ = dependencies2.form$;
      var config$ = inject("config$");
      var options = ref(null);
      var watchers = ref([]);
      var resolvedOptions = computed(() => {
        if (!isNative.value) {
          return options.value;
        }
        var nativeItems = [];
        each(options.value, (item, key) => {
          if ([null, void 0].indexOf(item) !== -1) {
            return;
          }
          if (Array.isArray(options.value) && typeof item === "object") {
            if (item[valueProp.value] === void 0) {
              console.warn("You must define `value` property for each option when using an array of objects options for select element");
            }
            nativeItems.push({
              value: item[valueProp.value],
              label: item[labelProp.value]
            });
          } else if (Array.isArray(options.value)) {
            nativeItems.push({
              value: item,
              label: item
            });
          } else {
            nativeItems.push({
              value: key,
              label: item
            });
          }
        });
        return nativeItems.map((o2) => {
          return _objectSpread2$1(_objectSpread2$1({}, o2), {}, {
            label: localize(o2.label, config$.value, form$.value)
          });
        });
      });
      var updateItems = /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator(function* () {
          var shouldDisable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          if (!isNative.value) {
            var _input$value;
            if (typeof items.value === "string") {
              options.value = createAsyncOptionsFromUrl();
            }
            yield (_input$value = input.value) === null || _input$value === void 0 ? void 0 : _input$value.resolveOptions();
            return;
          }
          if (shouldDisable) {
            disable();
          }
          if (typeof items.value === "string") {
            yield resolveOptionsFromUrl();
          } else if (typeof items.value === "function") {
            yield resolveOptionsFromFunction();
          } else {
            options.value = items.value;
          }
          if (shouldDisable) {
            enable();
          }
        });
        return function updateItems2() {
          return _ref.apply(this, arguments);
        };
      }();
      var resolveOptionsFromUrl = /* @__PURE__ */ function() {
        var _ref2 = _asyncToGenerator(function* () {
          try {
            var _yield$form$$value$$v;
            var url2 = yield resolveUrlAndSetWatchers(items.value, updateItems);
            var optionList = ((_yield$form$$value$$v = yield form$.value.$vueform.services.axios.get(url2)) === null || _yield$form$$value$$v === void 0 ? void 0 : _yield$form$$value$$v.data) || [];
            if (dataKey && dataKey.value && Object.keys(optionList).length) {
              optionList = get_1(optionList, dataKey.value) || [];
            }
            options.value = optionList;
          } catch (e2) {
            options.value = [];
            console.warn("Couldn't resolve items from ".concat(items.value), e2);
          } finally {
            var _resolvedOptions$valu;
            cleanupValue(((_resolvedOptions$valu = resolvedOptions.value) === null || _resolvedOptions$valu === void 0 ? void 0 : _resolvedOptions$valu.map((o2) => o2.value)) || []);
          }
        });
        return function resolveOptionsFromUrl2() {
          return _ref2.apply(this, arguments);
        };
      }();
      var createAsyncOptionsFromUrl = () => {
        return /* @__PURE__ */ function() {
          var _ref3 = _asyncToGenerator(function* (query) {
            var url2 = yield resolveUrlAndSetWatchers(items.value, updateItems);
            var optionList;
            try {
              var _yield$form$$value$$v2;
              optionList = ((_yield$form$$value$$v2 = yield form$.value.$vueform.services.axios.get("".concat(url2).concat(url2.match(/\?/) ? "&" : "?").concat(searchParam.value, "=").concat(query || ""))) === null || _yield$form$$value$$v2 === void 0 ? void 0 : _yield$form$$value$$v2.data) || [];
              if (dataKey && dataKey.value && Object.keys(optionList).length) {
                optionList = get_1(optionList, dataKey.value) || [];
              }
            } catch (e2) {
              console.error(e2);
            } finally {
              setTimeout(() => {
                var _input$value2;
                cleanupValue(((_input$value2 = input.value) === null || _input$value2 === void 0 || (_input$value2 = _input$value2.eo) === null || _input$value2 === void 0 ? void 0 : _input$value2.map((o2) => o2[valueProp.value])) || []);
              }, 0);
            }
            return optionList;
          });
          return function(_x) {
            return _ref3.apply(this, arguments);
          };
        }();
      };
      var resolveOptionsFromFunction = /* @__PURE__ */ function() {
        var _ref4 = _asyncToGenerator(function* () {
          try {
            options.value = (yield items.value(el$.value)) || [];
          } catch (e2) {
            options.value = [];
            console.warn("Couldn't resolve items from async function", e2);
          }
        });
        return function resolveOptionsFromFunction2() {
          return _ref4.apply(this, arguments);
        };
      }();
      var resolveOptions = /* @__PURE__ */ function() {
        var _ref5 = _asyncToGenerator(function* (n2, o2) {
          if (typeof items.value === "function" && isNative.value) {
            yield resolveOptionsFromFunction();
          } else if (!isEqual_1(n2, o2) || n2 === void 0 && o2 === void 0) {
            if (typeof items.value === "string" && isNative.value) {
              yield resolveOptionsFromUrl();
            } else if (typeof items.value === "string" && !isNative.value) {
              options.value = createAsyncOptionsFromUrl();
            } else {
              options.value = items.value;
            }
          }
        });
        return function resolveOptions2(_x2, _x3) {
          return _ref5.apply(this, arguments);
        };
      }();
      var cleanupValue = (values2) => {
        if (clearOnRefetch.value) {
          value.value = cloneDeep_1(nullValue.value);
          return;
        }
        if (!Array.isArray(nullValue.value) && value.value && values2.indexOf(object2.value ? value.value[valueProp.value] : value.value) === -1) {
          value.value = cloneDeep_1(nullValue.value);
        } else if (Array.isArray(nullValue.value) && value.value.length) {
          value.value = value.value.filter((v2) => {
            return values2.indexOf(v2) !== -1;
          });
        }
      };
      var resolveUrlAndSetWatchers = /* @__PURE__ */ function() {
        var _ref6 = _asyncToGenerator(function* (url2, updateItems2) {
          var regex2 = /{([^}]+)}/g;
          var resolvedUrl = url2;
          if (url2.match(regex2)) {
            yield nextTick();
            watchers.value.forEach((unwatch) => unwatch());
            var match;
            var _loop = function* _loop2() {
              var _match$1$match;
              var defaultValue = ((_match$1$match = match[1].match(/\|'([^']+)/)) === null || _match$1$match === void 0 ? void 0 : _match$1$match[1]) || "";
              var elPath = replaceWildcards(match[1].match(/^([^|]+)/)[1], path.value);
              var el$2 = form$.value.el$(elPath);
              var elValue = typeof (el$2 === null || el$2 === void 0 ? void 0 : el$2.value) !== "undefined" && el$2.value !== null && typeof el$2.value === "object" ? JSON.stringify(el$2.value) : typeof (el$2 === null || el$2 === void 0 ? void 0 : el$2.value) !== "undefined" && el$2.value !== null ? el$2.value : defaultValue;
              resolvedUrl = resolvedUrl.replace(match[0], encodeURIComponent(elValue));
              watchers.value.push(watch(computed(() => el$2 === null || el$2 === void 0 ? void 0 : el$2.value), () => {
                updateItems2();
              }));
            };
            while ((match = regex2.exec(url2)) !== null) {
              yield* _loop();
            }
          }
          return resolvedUrl;
        });
        return function resolveUrlAndSetWatchers2(_x4, _x5) {
          return _ref6.apply(this, arguments);
        };
      }();
      return {
        resolveOptions,
        resolvedOptions,
        updateItems,
        watchers,
        cleanupValue,
        resolveUrlAndSetWatchers
      };
    };
    var select$2 = function select2(props, context, dependencies2) {
      var {
        items
      } = toRefs(props);
      var {
        resolveOptions,
        resolvedOptions,
        updateItems,
        watchers,
        cleanupValue,
        resolveUrlAndSetWatchers
      } = base$x(props, context, dependencies2);
      resolveOptions();
      watch(items, resolveOptions);
      return {
        resolveOptions,
        resolvedOptions,
        updateItems,
        watchers,
        cleanupValue,
        resolveUrlAndSetWatchers
      };
    };
    var checkboxgroup = function checkboxgroup2(props, context, dependencies2) {
      var {
        items
      } = toRefs(props);
      var {
        watchers,
        cleanupValue,
        resolveUrlAndSetWatchers
      } = base$x(props, context, dependencies2);
      var disableAll = dependencies2.disableAll;
      var enableAll = dependencies2.enableAll;
      var el$ = dependencies2.el$;
      var form$ = dependencies2.form$;
      var config$ = inject("config$");
      var options = ref(null);
      var resolvedOptions = computed(() => {
        var resolvedOptions2 = [];
        each(options.value, (item, key) => {
          if ([null, void 0].indexOf(item) !== -1) {
            return;
          }
          if (Array.isArray(options.value) && typeof item === "object") {
            if (item.value === void 0) {
              console.warn("You must define `value` property for each item when using an array of objects options");
            }
            resolvedOptions2.push(item);
          } else if (Array.isArray(options.value)) {
            resolvedOptions2.push({
              value: item,
              label: item
            });
          } else if (typeof item === "object") {
            resolvedOptions2.push(_objectSpread2$1(_objectSpread2$1({}, item), {}, {
              value: key
            }));
          } else {
            resolvedOptions2.push({
              label: item,
              value: key
            });
          }
        });
        return resolvedOptions2.map((o2) => {
          return _objectSpread2$1(_objectSpread2$1({}, o2), {}, {
            label: localize(o2.label, config$.value, form$.value)
          });
        });
      });
      var updateItems = /* @__PURE__ */ function() {
        var _ref7 = _asyncToGenerator(function* () {
          var shouldDisable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          if (shouldDisable) {
            disableAll();
          }
          if (typeof items.value === "string") {
            yield resolveOptionsFromUrl();
          } else {
            yield resolveOptionsFromFunction();
          }
          if (shouldDisable) {
            enableAll();
          }
        });
        return function updateItems2() {
          return _ref7.apply(this, arguments);
        };
      }();
      var resolveOptionsFromUrl = /* @__PURE__ */ function() {
        var _ref8 = _asyncToGenerator(function* () {
          try {
            var _yield$form$$value$$v3, _resolvedOptions$valu2;
            var url2 = yield resolveUrlAndSetWatchers(items.value, updateItems);
            options.value = ((_yield$form$$value$$v3 = yield form$.value.$vueform.services.axios.get(url2)) === null || _yield$form$$value$$v3 === void 0 ? void 0 : _yield$form$$value$$v3.data) || [];
            cleanupValue(((_resolvedOptions$valu2 = resolvedOptions.value) === null || _resolvedOptions$valu2 === void 0 ? void 0 : _resolvedOptions$valu2.map((o2) => o2.value)) || []);
          } catch (e2) {
            options.value = [];
            console.warn("Couldn't resolve items from ".concat(items.value), e2);
          }
        });
        return function resolveOptionsFromUrl2() {
          return _ref8.apply(this, arguments);
        };
      }();
      var resolveOptionsFromFunction = /* @__PURE__ */ function() {
        var _ref9 = _asyncToGenerator(function* () {
          try {
            options.value = (yield items.value(el$.value)) || [];
          } catch (e2) {
            options.value = [];
            console.warn("Couldn't resolve items from async function", e2);
          }
        });
        return function resolveOptionsFromFunction2() {
          return _ref9.apply(this, arguments);
        };
      }();
      var resolveOptions = /* @__PURE__ */ function() {
        var _ref10 = _asyncToGenerator(function* () {
          if (typeof items.value === "function") {
            yield resolveOptionsFromFunction();
          } else if (typeof items.value === "string") {
            yield resolveOptionsFromUrl();
          } else {
            options.value = items.value;
          }
        });
        return function resolveOptions2() {
          return _ref10.apply(this, arguments);
        };
      }();
      resolveOptions();
      watch(items, resolveOptions);
      return {
        resolveOptions,
        resolvedOptions,
        updateItems,
        watchers,
        cleanupValue,
        resolveUrlAndSetWatchers
      };
    };
    var radiogroup = checkboxgroup;
    var multiselect$2 = select$2;
    var tags$2 = select$2;
    var CheckboxgroupElement = {
      name: "CheckboxgroupElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "checkboxgroup",
          private: true
        },
        default: {
          required: false,
          type: [Array],
          default: () => []
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        items: {
          required: false,
          type: [Object, Array, Function, String],
          localized: true,
          default: () => ({})
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        disables: {
          required: false,
          type: [Array],
          default: () => []
        },
        clearOnRefetch: {
          type: [Boolean],
          required: false,
          default: true
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$O, array$1, base$U, base$1c, checkboxgroup$1, checkboxgroup$3, base$C, base$L, checkboxgroup, base$14, base$D, base$y, base$B, base$$, base$J, base$_, base$Z, base$Y, base$1a, base$X, checkboxgroup$2, base$F, base$T];
        context.slots = ["checkbox", "label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$w = function base2(props, context, dependencies2) {
      var {
        addons,
        slots
      } = toRefs(props);
      var el$ = dependencies2.el$;
      var form$ = dependencies2.form$;
      var hasAddonBefore = computed(() => {
        var _el$$value$$slots, _el$$value$$scopedSlo;
        return !!(addons.value.before || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots["addon-before"] || /* istanbul ignore next */
        form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo["addon-before"] || slots.value["addon-before"]);
      });
      var hasAddonAfter = computed(() => {
        var _el$$value$$slots2, _el$$value$$scopedSlo2;
        return !!(addons.value.after || (_el$$value$$slots2 = el$.value.$slots) !== null && _el$$value$$slots2 !== void 0 && _el$$value$$slots2["addon-after"] || /* istanbul ignore next */
        form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo2 = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo2 !== void 0 && _el$$value$$scopedSlo2["addon-after"] || slots.value["addon-after"]);
      });
      return {
        hasAddonBefore,
        hasAddonAfter
      };
    };
    var base$v = function base2(props, context, dependencies2) {
      var {
        displayFormat,
        valueFormat,
        loadFormat,
        date: date2,
        time,
        seconds: seconds2,
        hour24
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var defaultFormat = computed(() => {
        var format2;
        if (date2.value && time.value && seconds2.value && hour24.value) {
          format2 = "datetimeSeconds24";
        } else if (date2.value && time.value && seconds2.value && !hour24.value) {
          format2 = "datetimeSeconds12";
        } else if (date2.value && time.value && !seconds2.value && hour24.value) {
          format2 = "datetime24";
        } else if (date2.value && time.value && !seconds2.value && !hour24.value) {
          format2 = "datetime12";
        } else if (!date2.value && time.value && seconds2.value && hour24.value) {
          format2 = "timeSeconds24";
        } else if (!date2.value && time.value && seconds2.value && !hour24.value) {
          format2 = "timeSeconds12";
        } else if (!date2.value && time.value && !seconds2.value && hour24.value) {
          format2 = "time24";
        } else if (!date2.value && time.value && !seconds2.value && !hour24.value) {
          format2 = "time12";
        } else {
          format2 = "date";
        }
        return format2;
      });
      var defaultDisplayFormat = computed(() => {
        return form$.value.translations.vueform.dateFormats[defaultFormat.value];
      });
      var defaultDataFormat = computed(() => {
        var dataDateFormats = {
          datetimeSeconds24: "YYYY-MM-DD HH:mm:ss",
          datetimeSeconds12: "YYYY-MM-DD hh:mm:ss a",
          datetime24: "YYYY-MM-DD HH:mm",
          datetime12: "YYYY-MM-DD hh:mm a",
          timeSeconds24: "HH:mm:ss",
          timeSeconds12: "hh:mm:ss a",
          time24: "HH:mm",
          time12: "hh:mm a",
          date: "YYYY-MM-DD"
        };
        return dataDateFormats[defaultFormat.value];
      });
      var displayDateFormat = computed(() => {
        return displayFormat.value !== null ? displayFormat.value : defaultDisplayFormat.value;
      });
      var valueDateFormat = computed(() => {
        return valueFormat.value !== null || valueFormat.value === false ? valueFormat.value : defaultDataFormat.value;
      });
      var loadDateFormat = computed(() => {
        return loadFormat.value !== null ? loadFormat.value : defaultDataFormat.value;
      });
      return {
        displayDateFormat,
        valueDateFormat,
        loadDateFormat
      };
    };
    var dates$2 = function dates2(props, context, dependencies2) {
      var {
        displayFormat,
        valueFormat,
        loadFormat
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var defaultFormat = computed(() => {
        return form$.value.translations.vueform.dateFormats.date;
      });
      var displayDateFormat = computed(() => {
        return displayFormat.value !== null ? displayFormat.value : defaultFormat.value;
      });
      var valueDateFormat = computed(() => {
        return valueFormat.value !== null || valueFormat.value === false ? valueFormat.value : defaultFormat.value;
      });
      var loadDateFormat = computed(() => {
        return loadFormat.value !== null ? loadFormat.value : defaultFormat.value;
      });
      return {
        displayDateFormat,
        valueDateFormat,
        loadDateFormat
      };
    };
    var base$u = function base2(props, context, dependencies2) {
      var value = dependencies2.value;
      var handleChange = (val) => {
        value.value = val;
      };
      return {
        handleChange
      };
    };
    var base$t = function base2(props, context, dependencies2) {
      var {
        placeholder
      } = toRefs(props);
      var config$ = inject("config$");
      var form$ = inject("form$");
      var Placeholder = computed(() => {
        return localize(placeholder.value, config$.value, form$.value);
      });
      return {
        Placeholder
      };
    };
    var date$1 = function date2(props, context, dependencies2) {
      var {
        disables,
        min: min2,
        max: max2,
        extendOptions,
        readonly: readonly2,
        hour24,
        seconds: seconds2,
        date: date3,
        time
      } = toRefs(props);
      var isDisabled = dependencies2.isDisabled;
      var displayDateFormat = dependencies2.displayDateFormat;
      var valueDateFormat = dependencies2.valueDateFormat;
      var form$ = dependencies2.form$;
      var moment = form$.value.$vueform.services.moment;
      var disabledDates = computed(() => {
        if (disables.value === void 0) {
          return [];
        }
        return map_1(disables.value, (disabledDate) => {
          checkDateFormat(valueDateFormat.value, disabledDate, moment);
          return disabledDate instanceof Date ? disabledDate : moment(disabledDate, valueDateFormat.value, true).toDate();
        });
      });
      var minDate = computed(() => {
        if (!min2.value) {
          return null;
        }
        checkDateFormat(valueDateFormat.value, min2.value, moment);
        return min2.value instanceof Date ? min2.value : moment(min2.value, valueDateFormat.value, true).toDate();
      });
      var maxDate = computed(() => {
        if (!max2.value) {
          return null;
        }
        checkDateFormat(valueDateFormat.value, max2.value, moment);
        return max2.value instanceof Date ? max2.value : moment(max2.value, valueDateFormat.value, true).toDate();
      });
      var defaultOptions = computed(() => {
        return {
          dateFormat: displayDateFormat.value,
          minDate: minDate.value,
          maxDate: maxDate.value,
          disable: disabledDates.value,
          clickOpens: !isDisabled.value && !readonly2.value,
          time_24hr: hour24.value,
          enableTime: time.value,
          enableSeconds: seconds2.value,
          noCalendar: !date3.value
        };
      });
      var fieldOptions = computed(() => {
        return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
        {});
      });
      var hasDate = computed(() => {
        return true;
      });
      var hasTime = computed(() => {
        return false;
      });
      return {
        minDate,
        maxDate,
        disabledDates,
        fieldOptions,
        hasDate,
        hasTime
      };
    };
    var dates$1 = function dates2(props, context, dependencies2) {
      var {
        mode,
        extendOptions,
        readonly: readonly2
      } = toRefs(props);
      var {
        minDate,
        maxDate,
        disabledDates
      } = date$1(props, context, dependencies2);
      var isDisabled = dependencies2.isDisabled;
      var displayDateFormat = dependencies2.displayDateFormat;
      var defaultOptions = computed(() => {
        return {
          mode: mode.value,
          dateFormat: displayDateFormat.value,
          minDate: minDate.value,
          maxDate: maxDate.value,
          disable: disabledDates.value,
          clickOpens: !isDisabled.value && !readonly2.value
        };
      });
      var fieldOptions = computed(() => {
        return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
        {});
      });
      var hasDate = computed(() => {
        return true;
      });
      var hasTime = computed(() => {
        return false;
      });
      return {
        minDate,
        maxDate,
        disabledDates,
        fieldOptions,
        hasDate,
        hasTime
      };
    };
    var select$1 = function select2(props, context, dependencies2) {
      var {
        native,
        extendOptions,
        labelProp,
        trackBy,
        valueProp,
        search,
        limit: limit2,
        noOptionsText,
        noResultsText,
        caret,
        object: object2,
        delay,
        minChars,
        resolveOnLoad,
        filterResults,
        clearOnSearch,
        canDeselect,
        canClear,
        openDirection,
        strict,
        closeOnSelect,
        closeOnDeselect,
        autocomplete,
        groups,
        groupLabel,
        groupOptions,
        groupHideEmpty,
        inputType,
        create,
        appendNewOption,
        addOptionOn,
        appendTo,
        appendToBody,
        allowAbsent
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var isLoading = dependencies2.isLoading;
      var config$ = inject("config$");
      var isNative = computed(() => {
        return native.value && !search.value;
      });
      var defaultOptions = computed(() => {
        return {
          mode: "single",
          searchable: search.value || create.value,
          noOptionsText: noOptionsText.value || form$.value.translations.vueform.multiselect.noOptions,
          noResultsText: noResultsText.value || form$.value.translations.vueform.multiselect.noResults,
          locale: Object.keys(config$.value.i18n.locales).length > 1 ? config$.value.i18n.locale : null,
          //@todo:adam can not be localized on form level
          fallbackLocale: config$.value.i18n.fallbackLocale,
          label: labelProp.value,
          trackBy: trackBy.value,
          valueProp: valueProp.value,
          limit: limit2.value,
          caret: caret.value,
          loading: isLoading.value,
          object: object2.value,
          delay: delay.value,
          minChars: minChars.value,
          resolveOnLoad: resolveOnLoad.value,
          filterResults: filterResults.value,
          clearOnSearch: clearOnSearch.value,
          canDeselect: canDeselect.value,
          canClear: canClear.value,
          openDirection: openDirection.value,
          strict: strict.value,
          closeOnSelect: closeOnSelect.value,
          closeOnDeselect: closeOnDeselect.value,
          autocomplete: autocomplete.value,
          groups: groups.value,
          groupLabel: groupLabel.value,
          groupOptions: groupOptions.value,
          groupHideEmpty: groupHideEmpty.value,
          inputType: inputType.value,
          createOption: create.value,
          appendNewOption: appendNewOption.value,
          addOptionOn: addOptionOn.value,
          appendTo: appendTo.value,
          appendToBody: appendToBody.value,
          allowAbsent: allowAbsent.value
        };
      });
      var fieldOptions = computed(() => {
        return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
        {});
      });
      return {
        fieldOptions,
        isNative
      };
    };
    var multiselect$1 = function multiselect2(props, context, dependencies2) {
      var {
        native,
        extendOptions,
        labelProp,
        trackBy,
        valueProp,
        search,
        limit: limit2,
        noOptionsText,
        noResultsText,
        caret,
        object: object2,
        delay,
        minChars,
        resolveOnLoad,
        filterResults,
        clearOnSearch,
        clearOnSelect,
        canClear,
        max: max2,
        openDirection,
        strict,
        closeOnSelect,
        closeOnDeselect,
        autocomplete,
        groups,
        groupLabel,
        groupOptions,
        groupHideEmpty,
        groupSelect,
        inputType,
        hideSelected,
        multipleLabel,
        multipleLabelMultiple,
        multipleLabelSingle,
        create,
        appendNewOption,
        addOptionOn,
        appendTo,
        appendToBody,
        allowAbsent
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var isLoading = dependencies2.isLoading;
      var config$ = inject("config$");
      var isNative = computed(() => {
        return native.value && !search.value;
      });
      var defaultOptions = computed(() => {
        return {
          mode: "multiple",
          searchable: search.value || create.value,
          noOptionsText: noOptionsText.value || form$.value.translations.vueform.multiselect.noOptions,
          noResultsText: noResultsText.value || form$.value.translations.vueform.multiselect.noResults,
          multipleLabel: multipleLabel.value || ((val, select$) => {
            return val && val.length > 1 ? multipleLabelMultiple.value ? multipleLabelMultiple.value.replace(":x:", val.length) : form$.value.__(form$.value.translations.vueform.multiselect.multipleLabelMore, {
              options: val.length
            }) : multipleLabelSingle.value || form$.value.translations.vueform.multiselect.multipleLabelOne;
          }),
          locale: Object.keys(config$.value.i18n.locales).length > 1 ? config$.value.i18n.locale : null,
          //@todo:adam can not be localized on form level
          fallbackLocale: config$.value.i18n.fallbackLocale,
          label: labelProp.value,
          trackBy: trackBy.value,
          valueProp: valueProp.value,
          limit: limit2.value,
          caret: caret.value,
          loading: isLoading.value,
          object: object2.value,
          delay: delay.value,
          minChars: minChars.value,
          resolveOnLoad: resolveOnLoad.value,
          filterResults: filterResults.value,
          clearOnSearch: clearOnSearch.value,
          clearOnSelect: clearOnSelect.value,
          canClear: canClear.value,
          max: max2.value,
          openDirection: openDirection.value,
          strict: strict.value,
          closeOnSelect: closeOnSelect.value,
          closeOnDeselect: closeOnDeselect.value,
          autocomplete: autocomplete.value,
          groups: groups.value,
          groupLabel: groupLabel.value,
          groupOptions: groupOptions.value,
          groupHideEmpty: groupHideEmpty.value,
          groupSelect: groupSelect.value,
          inputType: inputType.value,
          hideSelected: hideSelected.value,
          createOption: create.value,
          appendNewOption: appendNewOption.value,
          addOptionOn: addOptionOn.value,
          appendTo: appendTo.value,
          appendToBody: appendToBody.value,
          allowAbsent: allowAbsent.value
        };
      });
      var fieldOptions = computed(() => {
        return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
        {});
      });
      return {
        fieldOptions,
        isNative
      };
    };
    var tags$1 = function tags2(props, context, dependencies2) {
      var {
        extendOptions,
        labelProp,
        trackBy,
        valueProp,
        search,
        limit: limit2,
        noOptionsText,
        noResultsText,
        caret,
        object: object2,
        delay,
        minChars,
        resolveOnLoad,
        filterResults,
        clearOnSearch,
        clearOnSelect,
        canClear,
        max: max2,
        showOptions,
        openDirection,
        strict,
        closeOnSelect,
        closeOnDeselect,
        autocomplete,
        groups,
        groupLabel,
        groupOptions,
        groupHideEmpty,
        groupSelect,
        inputType,
        hideSelected,
        create,
        appendNewOption,
        addOptionOn,
        breakTags,
        appendTo,
        appendToBody,
        allowAbsent
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var isLoading = dependencies2.isLoading;
      var config$ = inject("config$");
      var native = ref(false);
      var isNative = computed(() => {
        return false;
      });
      var defaultOptions = computed(() => {
        return {
          mode: "tags",
          searchable: search.value || create.value,
          noOptionsText: noOptionsText.value || form$.value.translations.vueform.multiselect.noOptions,
          noResultsText: noResultsText.value || form$.value.translations.vueform.multiselect.noResults,
          locale: Object.keys(config$.value.i18n.locales).length > 1 ? config$.value.i18n.locale : null,
          //@todo:adam can not be localized on form level
          fallbackLocale: config$.value.i18n.fallbackLocale,
          label: labelProp.value,
          trackBy: trackBy.value,
          valueProp: valueProp.value,
          limit: limit2.value,
          caret: caret.value,
          loading: isLoading.value,
          object: object2.value,
          delay: delay.value,
          minChars: minChars.value,
          resolveOnLoad: resolveOnLoad.value,
          filterResults: filterResults.value,
          clearOnSearch: clearOnSearch.value,
          clearOnSelect: clearOnSelect.value,
          canClear: canClear.value,
          max: max2.value,
          showOptions: showOptions.value,
          openDirection: openDirection.value,
          strict: strict.value,
          closeOnSelect: closeOnSelect.value,
          closeOnDeselect: closeOnDeselect.value,
          autocomplete: autocomplete.value,
          groups: groups.value,
          groupLabel: groupLabel.value,
          groupOptions: groupOptions.value,
          groupHideEmpty: groupHideEmpty.value,
          groupSelect: groupSelect.value,
          inputType: inputType.value,
          hideSelected: hideSelected.value,
          createOption: create.value,
          appendNewOption: appendNewOption.value,
          addOptionOn: addOptionOn.value,
          breakTags: breakTags.value,
          appendTo: appendTo.value,
          appendToBody: appendToBody.value,
          allowAbsent: allowAbsent.value
        };
      });
      var fieldOptions = computed(() => {
        return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
        {});
      });
      return {
        native,
        fieldOptions,
        isNative
      };
    };
    var slider = function slider2(props, context, dependencies2) {
      var {
        min: min2,
        max: max2,
        step,
        tooltips,
        merge: merge2,
        format: format2,
        orientation,
        direction,
        extendOptions,
        showTooltip,
        tooltipPosition,
        lazy
      } = toRefs(props);
      var isDisabled = dependencies2.isDisabled;
      dependencies2.labelId;
      var defaultOptions = computed(() => {
        return {
          min: min2.value,
          max: max2.value,
          step: step.value,
          tooltips: tooltips.value,
          merge: merge2.value,
          format: format2.value,
          orientation: orientation.value,
          direction: direction.value,
          disabled: isDisabled.value,
          showTooltip: showTooltip.value,
          tooltipPosition: tooltipPosition.value,
          lazy: lazy.value
        };
      });
      var fieldOptions = computed(() => {
        return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
        {});
      });
      return {
        fieldOptions
      };
    };
    var toggle = function toggle2(props, context, dependencies2) {
      var {
        labels,
        extendOptions,
        trueValue,
        falseValue
      } = toRefs(props);
      var isDisabled = dependencies2.isDisabled;
      var form$ = dependencies2.form$;
      var config$ = inject("config$");
      var defaultOptions = computed(() => {
        return {
          disabled: isDisabled.value,
          offLabel: labels.value ? localize(labels.value.off, config$.value, form$.value) || "" : (
            /* istanbul ignore next: default is hardcoded {}, will never fall there */
            ""
          ),
          onLabel: labels.value ? localize(labels.value.on, config$.value, form$.value) || "" : (
            /* istanbul ignore next: default is hardcoded {}, will never fall there */
            ""
          ),
          trueValue: trueValue.value,
          falseValue: falseValue.value
        };
      });
      var fieldOptions = computed(() => {
        return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
        {});
      });
      return {
        fieldOptions
      };
    };
    var base$s = function base2(props, context, dependencies2) {
      var input = dependencies2.input;
      var focused = ref(false);
      onMounted(() => {
        if (input && input.value && input.value.addEventListener) {
          input.value.addEventListener("focus", () => {
            focused.value = true;
          });
          input.value.addEventListener("blur", () => {
            focused.value = false;
          });
        }
      });
      return {
        focused
      };
    };
    var date = function date2(props, context, dependencies2) {
      var input = dependencies2.input;
      var focused = ref(false);
      onMounted(() => {
        input.value.input.addEventListener("focus", () => {
          focused.value = true;
        });
        input.value.input.addEventListener("blur", () => {
          focused.value = false;
        });
      });
      return {
        focused
      };
    };
    var select = function select2(props, context, dependencies2) {
      var input = dependencies2.input;
      var isNative = dependencies2.isNative;
      var focused = ref(false);
      onMounted(() => {
        if (isNative.value) {
          input.value.addEventListener("focus", () => {
            focused.value = true;
          });
          input.value.addEventListener("blur", () => {
            focused.value = false;
          });
        } else {
          watch(computed(() => {
            var _input$value;
            return (_input$value = input.value) === null || _input$value === void 0 ? void 0 : _input$value.isActive;
          }), (active) => {
            focused.value = active;
          });
        }
      });
      return {
        focused
      };
    };
    var dates = date;
    var multiselect = select;
    var tags = select;
    var DateElement = {
      name: "DateElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "date",
          private: true
        },
        default: {
          required: false,
          type: [String, Date],
          default: null
        },
        addons: {
          required: false,
          type: [Object],
          localized: true,
          default: () => ({})
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        floating: {
          required: false,
          type: [String, Boolean, Object],
          localized: true,
          default: null
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        displayFormat: {
          required: false,
          type: [String],
          default: null,
          "@default": "locale.vueform.dateFormats.*"
        },
        valueFormat: {
          required: false,
          type: [String, Boolean],
          default: null,
          "@default": "locale.vueform.dateFormats.*"
        },
        loadFormat: {
          required: false,
          type: [String],
          default: null,
          "@default": "locale.vueform.dateFormats.*"
        },
        date: {
          required: false,
          type: [Boolean],
          default: true
        },
        time: {
          required: false,
          type: [Boolean],
          default: false
        },
        seconds: {
          required: false,
          type: [Boolean],
          default: false
        },
        hour24: {
          required: false,
          type: [Boolean],
          default: true
        },
        min: {
          required: false,
          type: [String, Date],
          default: null
        },
        max: {
          required: false,
          type: [String, Date],
          default: null
        },
        disables: {
          required: false,
          type: [Array],
          default: () => []
        },
        extendOptions: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        placeholder: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        readonly: {
          required: false,
          type: [Boolean],
          default: false
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$G, base$1c, base$P, base$w, base$v, date$1, base$C, base$14, base$D, date$3, base$I, date$2, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$u, date, base$R, base$F, base$T, base$t];
        context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var DatesElement = {
      name: "DatesElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "dates",
          private: true
        },
        default: {
          required: false,
          type: [Array],
          default: () => []
        },
        addons: {
          required: false,
          type: [Object],
          localized: true,
          default: () => ({})
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        floating: {
          required: false,
          type: [String, Boolean, Object],
          localized: true,
          default: null
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        displayFormat: {
          required: false,
          type: [String],
          default: null
        },
        valueFormat: {
          required: false,
          type: [String, Boolean],
          default: null
        },
        loadFormat: {
          required: false,
          type: [String, Boolean],
          default: null
        },
        mode: {
          required: false,
          type: [String],
          default: "multiple"
        },
        min: {
          required: false,
          type: [String, Date],
          default: null
        },
        max: {
          required: false,
          type: [String, Date],
          default: null
        },
        disables: {
          required: false,
          type: [Array],
          default: () => []
        },
        extendOptions: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        placeholder: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        readonly: {
          required: false,
          type: [Boolean],
          default: false
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, array$1, base$U, base$G, base$1c, dates$5, base$w, dates$2, dates$1, base$C, dates$4, base$14, base$D, base$I, dates$3, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$u, dates, base$R, base$F, base$T, base$t];
        context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$r = function base2(props, context, dependencies2) {
      var {
        embed,
        auto: auto2,
        methods,
        urls,
        uploadTempEndpoint,
        removeTempEndpoint,
        removeEndpoint,
        url: url2,
        previewUrl,
        params,
        softRemove,
        view
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var value = dependencies2.value;
      var isDisabled = dependencies2.isDisabled;
      var validate = dependencies2.validate;
      var invalid = dependencies2.invalid;
      var path = dependencies2.path;
      var axios2 = dependencies2.axios;
      var request = dependencies2.request;
      var uploading = dependencies2.uploading;
      var input = dependencies2.input;
      var update = dependencies2.update;
      var fire = dependencies2.fire;
      dependencies2.isImageType;
      var removing = dependencies2.removing;
      var handleError2 = dependencies2.handleError;
      var el$ = dependencies2.el$;
      var hasUploadError = ref(false);
      var progress = ref(0);
      var preparing = ref(false);
      var endpoints = computed(() => {
        var configEndpoints = form$.value.$vueform.config.endpoints;
        var propEndpoints = {
          uploadTempFile: uploadTempEndpoint.value,
          removeTempFile: removeTempEndpoint.value,
          removeFile: removeEndpoint.value
        };
        var endpoints2 = {};
        Object.keys(propEndpoints).forEach((name2) => {
          var endpoint = configEndpoints[name2];
          if (urls.value[name2]) {
            endpoint = {
              url: urls.value[name2],
              method: "POST"
            };
          }
          if (methods.value[name2] && typeof endpoint === "object") {
            endpoint.method = methods.value[name2];
          }
          if (typeof propEndpoints[name2] === "string") {
            if (configEndpoints[propEndpoints[name2]] !== void 0) {
              endpoint = configEndpoints[propEndpoints[name2]];
            } else {
              endpoint.url = propEndpoints[name2];
            }
          }
          if (propEndpoints[name2] === false) {
            endpoint = (f2) => f2;
          }
          if (typeof propEndpoints[name2] === "function") {
            endpoint = propEndpoints[name2];
          }
          if (typeof propEndpoints[name2] === "object") {
            endpoint = {
              url: propEndpoints[name2].url || propEndpoints[name2].endpoint || configEndpoints[name2].url,
              method: propEndpoints[name2].method || configEndpoints[name2].method
            };
          }
          endpoints2[name2] = endpoint;
        });
        return endpoints2;
      });
      var fileUrl = computed(() => {
        if (url2.value === void 0) {
          return "/";
        }
        if (url2.value === false) {
          return "";
        }
        var fileUrl2 = url2.value;
        if (!fileUrl2.match(/\/$/)) {
          fileUrl2 += "/";
        }
        if (!fileUrl2.match(/^(http|file)/) && !fileUrl2.match(/^\//)) {
          fileUrl2 = "/" + fileUrl2;
        }
        return fileUrl2;
      });
      var filePreviewUrl = computed(() => {
        if (previewUrl.value === void 0) {
          return fileUrl.value;
        }
        var filePreviewUrl2 = previewUrl.value;
        if (!filePreviewUrl2.match(/\/$/)) {
          filePreviewUrl2 += "/";
        }
        if (!filePreviewUrl2.match(/^http/) && !filePreviewUrl2.match(/^\//)) {
          filePreviewUrl2 = "/" + filePreviewUrl2;
        }
        return filePreviewUrl2;
      });
      var stage = computed(() => {
        if (value.value === null) {
          return 0;
        }
        if (value.value instanceof File) {
          return 1;
        }
        if (isObject_1(value.value) && value.value.tmp !== void 0) {
          return 2;
        }
        if (isString_1(value.value)) {
          return 3;
        }
        return -1;
      });
      var filename = computed(() => {
        switch (stage.value) {
          case 1:
            return value.value.name;
          case 2:
            return value.value.originalName;
          case 3:
            return value.value;
          default:
            return null;
        }
      });
      var link = computed(() => {
        if (!uploaded.value) {
          return;
        }
        return fileUrl.value + filename.value;
      });
      var previewLink = computed(() => {
        if (!uploaded.value) {
          return;
        }
        return filePreviewUrl.value + filename.value;
      });
      var preview = computed(() => {
        var _value$value;
        if (view.value === "file") {
          return null;
        }
        return uploaded.value ? previewLink.value : value.value instanceof File ? URL.createObjectURL(value.value) : ((_value$value = value.value) === null || _value$value === void 0 ? void 0 : _value$value.__file__) instanceof File ? URL.createObjectURL(value.value.__file__) : null;
      });
      var uploaded = computed(() => {
        return stage.value === 3;
      });
      var canRemove = computed(() => {
        return stage.value > 0 && !uploading.value && !isDisabled.value && !preparing.value && !removing.value;
      });
      var canUploadTemp = computed(() => {
        return stage.value === 1 && !auto2.value && !uploading.value && !isDisabled.value;
      });
      var canSelect = computed(() => {
        return !embed.value && stage.value == 0;
      });
      var uploadTemp = /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator(function* () {
          if (stage.value !== 1) {
            throw new Error("No file is selected");
          }
          yield validate();
          if (invalid.value) {
            return;
          }
          request.value = axios2.value.CancelToken.source();
          try {
            var data = _getFormData(Object.assign({}, params.value, {
              file: value.value,
              formKey: form$.value.options.formKey,
              path: path.value
            }));
            hasUploadError.value = false;
            var response;
            if (typeof endpoints.value.uploadTempFile === "function") {
              response = yield endpoints.value.uploadTempFile(value.value, el$.value);
            } else {
              var method = endpoints.value.uploadTempFile.method.toLowerCase();
              response = yield axios2.value.request({
                url: endpoints.value.uploadTempFile.url,
                method,
                [method === "get" ? "params" : "data"]: data,
                onUploadProgress: (e2) => {
                  progress.value = Math.round(e2.loaded * 100 / e2.total);
                },
                cancelToken: request.value.token
              });
              response = response.data;
            }
            if (response && typeof response === "object") {
              response.__file__ = value.value;
            }
            update(response);
          } catch (error) {
            progress.value = 0;
            if (!axios2.value.isCancel(error)) {
              hasUploadError.value = true;
              handleError2(error);
            }
            throw new Error(error);
          } finally {
            request.value = null;
          }
        });
        return function uploadTemp2() {
          return _ref.apply(this, arguments);
        };
      }();
      var remove2 = /* @__PURE__ */ function() {
        var _ref2 = _asyncToGenerator(function* () {
          removing.value = true;
          hasUploadError.value = false;
          try {
            if (stage.value === 3 && !softRemove.value) {
              if (!confirm(form$.value.translations.vueform.elements.file.removeConfirm)) {
                return false;
              }
              if (typeof endpoints.value.removeFile === "function") {
                yield endpoints.value.removeFile(value.value, el$.value);
              } else {
                var method = endpoints.value.removeFile.method.toLowerCase();
                yield axios2.value.request({
                  method,
                  url: endpoints.value.removeFile.url,
                  [method === "get" ? "params" : "data"]: Object.assign({}, params.value, {
                    file: value.value,
                    formKey: form$.value.options.formKey,
                    path: path.value
                  })
                });
              }
            } else if (stage.value === 2 && !softRemove.value) {
              if (typeof endpoints.value.removeTempFile === "function") {
                yield endpoints.value.removeTempFile(value.value, el$.value);
              } else {
                var _method = endpoints.value.removeTempFile.method.toLowerCase();
                yield axios2.value.request({
                  method: _method,
                  url: endpoints.value.removeTempFile.url,
                  [_method === "get" ? "params" : "data"]: Object.assign({}, params.value, {
                    file: value.value.tmp,
                    formKey: form$.value.options.formKey,
                    path: path.value
                  })
                });
              }
            }
          } catch (error) {
            handleError2(error);
            return;
          } finally {
            removing.value = false;
          }
          update(null);
          progress.value = 0;
          fire("remove");
        });
        return function remove3() {
          return _ref2.apply(this, arguments);
        };
      }();
      var prepare = /* @__PURE__ */ function() {
        var _ref3 = _asyncToGenerator(function* () {
          if (stage.value === 1) {
            preparing.value = true;
            try {
              yield uploadTemp();
            } finally {
              preparing.value = false;
            }
          }
        });
        return function prepare2() {
          return _ref3.apply(this, arguments);
        };
      }();
      var handleChange = /* @__PURE__ */ function() {
        var _ref4 = _asyncToGenerator(function* (e2) {
          var file2 = e2.target.files[0];
          input.value.value = "";
          update(file2 || null);
          if (auto2.value) {
            yield uploadTemp();
          }
          if (form$.value.shouldValidateOnChange) {
            validate();
          }
        });
        return function handleChange2(_x) {
          return _ref4.apply(this, arguments);
        };
      }();
      var handleClick = () => {
        if (isDisabled.value) {
          return;
        }
        input.value.click();
      };
      var handleUploadTemp = () => {
        uploadTemp();
      };
      var handleRemove = () => {
        remove2();
      };
      var handleAbort = () => {
        if (request.value === null) {
          return;
        }
        request.value.cancel();
      };
      if (value.value instanceof File && auto2.value) {
        nextTick(() => {
          uploadTemp();
        });
      }
      return {
        hasUploadError,
        progress,
        preparing,
        endpoints,
        fileUrl,
        stage,
        filename,
        link,
        preview,
        uploaded,
        canRemove,
        canUploadTemp,
        canSelect,
        uploadTemp,
        remove: remove2,
        prepare,
        handleChange,
        handleClick,
        handleUploadTemp,
        handleRemove,
        handleAbort
      };
    };
    var base$q = function base2(props, context, dependencies2) {
      var form$ = dependencies2.form$;
      var request = ref(null);
      var axios2 = ref(null);
      var uploading = computed(() => {
        return request.value !== null;
      });
      onMounted(() => {
        axios2.value = form$.value.$vueform.services.axios;
      });
      return {
        request,
        axios: axios2,
        uploading
      };
    };
    function checkFileType(file2, accept) {
      if (!accept) {
        return true;
      }
      if (!isArray_1(accept)) {
        accept = accept.split(",");
        each(accept, (one, i2) => {
          accept[i2] = one.trim();
        });
      }
      return some_1(accept, (a2) => {
        var universal = a2.match(/^([^\/]+)\/\*$/);
        if (universal) {
          return !!new RegExp("^".concat(universal[1], "/")).exec(file2.type);
        } else if (a2 == file2.type) {
          return true;
        } else if (a2 == ".".concat(file2.name.split(".").pop())) {
          return true;
        }
        return false;
      });
    }
    var base$p = function base2(props, context, dependencies2) {
      var {
        accept,
        auto: auto2
      } = toRefs(props);
      var update = dependencies2.update;
      var isDisabled = dependencies2.isDisabled;
      var uploadTemp = dependencies2.uploadTemp;
      var canDrop = computed(() => {
        var div = document.createElement("div");
        return ("draggable" in div || /* istanbul ignore next: failsafe only, can not influence div from outside */
        "ondragstart" in div && "ondrop" in div) && "FormData" in window && "FileReader" in window;
      });
      var handleDrop = (e2) => {
        if (isDisabled.value) {
          return;
        }
        var file2 = e2.dataTransfer.files[0];
        if (!checkFileType(file2, accept.value)) {
          return;
        }
        update(file2 || /* istanbul ignore next: failsafe only */
        null);
        if (auto2.value) {
          uploadTemp();
        }
        file2.value = null;
      };
      return {
        canDrop,
        handleDrop
      };
    };
    var multifile$3 = function multifile2(props, context, dependencies2) {
      var {
        accept
      } = toRefs(props);
      var {
        canDrop
      } = base$p(props, context, dependencies2);
      var add2 = dependencies2.add;
      var isDisabled = dependencies2.isDisabled;
      var isObject2 = dependencies2.isObject;
      var storeFileName = dependencies2.storeFileName;
      var handleDrop = (e2) => {
        if (!e2.dataTransfer || !e2.dataTransfer.files || e2.dataTransfer.files.length == 0 || isDisabled.value) {
          return;
        }
        each(e2.dataTransfer.files, (file2) => {
          if (!checkFileType(file2, accept.value)) {
            return;
          }
          add2(isObject2.value ? {
            [storeFileName.value]: file2
          } : file2);
        });
      };
      return {
        canDrop,
        handleDrop
      };
    };
    var base$o = function base2(props, context, dependencies2) {
      var removing = ref(false);
      return {
        removing
      };
    };
    var base$n = function base2(props, context, dependencies2) {
      var fire = dependencies2.fire;
      dependencies2.listeners;
      var handleError2 = (error) => {
        fire("error", error);
      };
      return {
        handleError: handleError2
      };
    };
    var FileElement = {
      name: "FileElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "remove", "error", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "file",
          private: true
        },
        default: {
          required: false,
          type: [String, Object],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        onRemove: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onError: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        view: {
          type: [String],
          required: false,
          default: "file"
        },
        drop: {
          required: false,
          type: [Boolean],
          default: false
        },
        accept: {
          required: false,
          type: [String, Array],
          default: null
        },
        clickable: {
          required: false,
          type: [Boolean],
          default: true
        },
        url: {
          required: false,
          type: [String, Boolean],
          default: "/"
        },
        previewUrl: {
          required: false,
          type: [String],
          default: void 0
        },
        auto: {
          required: false,
          type: [Boolean],
          default: true
        },
        urls: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        methods: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        uploadTempEndpoint: {
          required: false,
          type: [Object, String, Function, Boolean, Promise],
          default: void 0,
          "@default": "config.endpoints.uploadTempFile"
        },
        removeTempEndpoint: {
          required: false,
          type: [Object, String, Function, Boolean, Promise],
          default: void 0,
          "@default": "config.endpoints.removeTempFile"
        },
        removeEndpoint: {
          required: false,
          type: [Object, String, Function, Boolean, Promise],
          default: void 0,
          "@default": "config.endpoints.removeFile"
        },
        params: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        softRemove: {
          required: false,
          type: [Boolean],
          default: false
        },
        embed: {
          type: [Boolean],
          required: false,
          default: false,
          private: true
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$o, base$U, base$1c, file$3, base$q, base$C, base$14, base$L, file$1, base$I, file, base$n, base$r, base$p, base$$, file$2, base$Z, base$Y, base$1a, base$_, base$X, file$4, base$F, base$T];
        context.slots = ["label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$m = function base2(props, context, dependencies2) {
      var model = dependencies2.model;
      var handleInput = (e2) => {
        model.value = e2.target.value;
      };
      return {
        handleInput
      };
    };
    var phone$1 = function phone2(props, context, dependencies2) {
      var {
        model,
        input,
        el$
      } = dependencies2;
      var handleInput = (e2) => {
        if (el$.value.maskPluginInstalled) {
          model.value = e2.target.value;
          return;
        }
        var startsWithPlus = e2.target.value.startsWith("+");
        var value = e2.target.value.substr(startsWithPlus ? 1 : 0);
        var numbers = value.match(/\d+/g) || [];
        if (numbers.length || startsWithPlus) {
          value = "+";
        }
        value += numbers.join("");
        input.value.value = value;
        model.value = value;
      };
      return {
        handleInput
      };
    };
    var GenericElement = {
      register: false,
      name: "GenericElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "",
          private: true
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        default: {
          required: false,
          type: [String, Number, Object],
          default: void 0
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, generic, base$U, base$1c, base$P, text$1, base$14, text$2, base$L, base$I, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$m, base$s, base$R, base$F, base$T];
        context.slots = ["label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$l = function base2(props, context, dependencies2) {
      var children$Array = ref([]);
      var children$ = computed(() => {
        var children$2 = {};
        children$Array.value.forEach((e$) => {
          children$2[e$.name] = e$;
        });
        return children$2;
      });
      return {
        children$Array,
        children$
      };
    };
    var object = function object2(props, context, dependencies2) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var schemaName = options.schemaName || "schema";
      var {
        [schemaName]: schema
      } = toRefs(props);
      var {
        children$Array,
        children$
      } = base$l();
      var children = computed(() => {
        return schema.value;
      });
      if (schema) {
        watch(schema, (newValue) => {
          var newChildren$Array = [];
          each(newValue, (child, name2) => {
            newChildren$Array.push(children$Array.value[children$Array.value.map((e$) => normalize$1(e$.name)).indexOf(normalize$1(name2))]);
          });
          children$Array.value = newChildren$Array;
        }, {
          flush: "post",
          deep: true
        });
      }
      return {
        children,
        children$Array,
        children$
      };
    };
    var group = object;
    var GroupElement = {
      name: "GroupElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "group",
          private: true
        },
        default: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        schema: {
          required: false,
          type: [Object],
          default: () => ({})
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, group$6, base$U, object$5, base$1c, group$7, group, group$2, base$$, group$3, group$5, base$12, group$8, base$Z, base$Y, base$1a, base$_, base$X, group$1, base$R, group$4, base$T];
        context.slots = ["label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var HiddenElement = {
      name: "HiddenElement",
      mixins: [BaseElement, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "hidden",
          private: true
        },
        default: {
          required: false,
          type: [String, Number, Object],
          default: null
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        meta: {
          required: false,
          type: [Boolean],
          default: false
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$M, base$O, base$K, base$J, base$U, base$Y, base$1c, base$P, base$C, base$14, base$D, base$L, base$I, base$B, base$F, base$T];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    /**!
     * Sortable 1.15.2
     * @author	RubaXa   <trash@rubaxa.org>
     * @author	owenm    <owen23355@gmail.com>
     * @license MIT
     */
    function ownKeys(object2, enumerableOnly) {
      var keys2 = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread2(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        if (i2 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i2;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
          key = sourceSymbolKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    var version = "1.15.2";
    function userAgent(pattern) {
      if (typeof window !== "undefined" && window.navigator) {
        return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
      }
    }
    var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
    var Edge = userAgent(/Edge/i);
    var FireFox = userAgent(/firefox/i);
    var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
    var IOS = userAgent(/iP(ad|od|hone)/i);
    var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
    var captureMode = {
      capture: false,
      passive: false
    };
    function on$1(el, event, fn2) {
      el.addEventListener(event, fn2, !IE11OrLess && captureMode);
    }
    function off(el, event, fn2) {
      el.removeEventListener(event, fn2, !IE11OrLess && captureMode);
    }
    function matches(el, selector) {
      if (!selector)
        return;
      selector[0] === ">" && (selector = selector.substring(1));
      if (el) {
        try {
          if (el.matches) {
            return el.matches(selector);
          } else if (el.msMatchesSelector) {
            return el.msMatchesSelector(selector);
          } else if (el.webkitMatchesSelector) {
            return el.webkitMatchesSelector(selector);
          }
        } catch (_2) {
          return false;
        }
      }
      return false;
    }
    function getParentOrHost(el) {
      return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
    }
    function closest$1(el, selector, ctx, includeCTX) {
      if (el) {
        ctx = ctx || document;
        do {
          if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
            return el;
          }
          if (el === ctx)
            break;
        } while (el = getParentOrHost(el));
      }
      return null;
    }
    var R_SPACE = /\s+/g;
    function toggleClass(el, name2, state) {
      if (el && name2) {
        if (el.classList) {
          el.classList[state ? "add" : "remove"](name2);
        } else {
          var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name2 + " ", " ");
          el.className = (className + (state ? " " + name2 : "")).replace(R_SPACE, " ");
        }
      }
    }
    function css(el, prop, val) {
      var style = el && el.style;
      if (style) {
        if (val === void 0) {
          if (document.defaultView && document.defaultView.getComputedStyle) {
            val = document.defaultView.getComputedStyle(el, "");
          } else if (el.currentStyle) {
            val = el.currentStyle;
          }
          return prop === void 0 ? val : val[prop];
        } else {
          if (!(prop in style) && prop.indexOf("webkit") === -1) {
            prop = "-webkit-" + prop;
          }
          style[prop] = val + (typeof val === "string" ? "" : "px");
        }
      }
    }
    function matrix(el, selfOnly) {
      var appliedTransforms = "";
      if (typeof el === "string") {
        appliedTransforms = el;
      } else {
        do {
          var transform = css(el, "transform");
          if (transform && transform !== "none") {
            appliedTransforms = transform + " " + appliedTransforms;
          }
        } while (!selfOnly && (el = el.parentNode));
      }
      var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
      return matrixFn && new matrixFn(appliedTransforms);
    }
    function find(ctx, tagName, iterator) {
      if (ctx) {
        var list2 = ctx.getElementsByTagName(tagName), i2 = 0, n2 = list2.length;
        if (iterator) {
          for (; i2 < n2; i2++) {
            iterator(list2[i2], i2);
          }
        }
        return list2;
      }
      return [];
    }
    function getWindowScrollingElement() {
      var scrollingElement = document.scrollingElement;
      if (scrollingElement) {
        return scrollingElement;
      } else {
        return document.documentElement;
      }
    }
    function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
      if (!el.getBoundingClientRect && el !== window)
        return;
      var elRect, top2, left2, bottom2, right2, height, width;
      if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
        elRect = el.getBoundingClientRect();
        top2 = elRect.top;
        left2 = elRect.left;
        bottom2 = elRect.bottom;
        right2 = elRect.right;
        height = elRect.height;
        width = elRect.width;
      } else {
        top2 = 0;
        left2 = 0;
        bottom2 = window.innerHeight;
        right2 = window.innerWidth;
        height = window.innerHeight;
        width = window.innerWidth;
      }
      if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
        container = container || el.parentNode;
        if (!IE11OrLess) {
          do {
            if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
              var containerRect = container.getBoundingClientRect();
              top2 -= containerRect.top + parseInt(css(container, "border-top-width"));
              left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
              bottom2 = top2 + elRect.height;
              right2 = left2 + elRect.width;
              break;
            }
          } while (container = container.parentNode);
        }
      }
      if (undoScale && el !== window) {
        var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
        if (elMatrix) {
          top2 /= scaleY;
          left2 /= scaleX;
          width /= scaleX;
          height /= scaleY;
          bottom2 = top2 + height;
          right2 = left2 + width;
        }
      }
      return {
        top: top2,
        left: left2,
        bottom: bottom2,
        right: right2,
        width,
        height
      };
    }
    function isScrolledPast(el, elSide, parentSide) {
      var parent2 = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
      while (parent2) {
        var parentSideVal = getRect(parent2)[parentSide], visible = void 0;
        if (parentSide === "top" || parentSide === "left") {
          visible = elSideVal >= parentSideVal;
        } else {
          visible = elSideVal <= parentSideVal;
        }
        if (!visible)
          return parent2;
        if (parent2 === getWindowScrollingElement())
          break;
        parent2 = getParentAutoScrollElement(parent2, false);
      }
      return false;
    }
    function getChild(el, childNum, options, includeDragEl) {
      var currentChild = 0, i2 = 0, children = el.children;
      while (i2 < children.length) {
        if (children[i2].style.display !== "none" && children[i2] !== Sortable.ghost && (includeDragEl || children[i2] !== Sortable.dragged) && closest$1(children[i2], options.draggable, el, false)) {
          if (currentChild === childNum) {
            return children[i2];
          }
          currentChild++;
        }
        i2++;
      }
      return null;
    }
    function lastChild(el, selector) {
      var last2 = el.lastElementChild;
      while (last2 && (last2 === Sortable.ghost || css(last2, "display") === "none" || selector && !matches(last2, selector))) {
        last2 = last2.previousElementSibling;
      }
      return last2 || null;
    }
    function index$1(el, selector) {
      var index2 = 0;
      if (!el || !el.parentNode) {
        return -1;
      }
      while (el = el.previousElementSibling) {
        if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
          index2++;
        }
      }
      return index2;
    }
    function getRelativeScrollOffset(el) {
      var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
      if (el) {
        do {
          var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
          offsetLeft += el.scrollLeft * scaleX;
          offsetTop += el.scrollTop * scaleY;
        } while (el !== winScroller && (el = el.parentNode));
      }
      return [offsetLeft, offsetTop];
    }
    function indexOfObject(arr, obj) {
      for (var i2 in arr) {
        if (!arr.hasOwnProperty(i2))
          continue;
        for (var key in obj) {
          if (obj.hasOwnProperty(key) && obj[key] === arr[i2][key])
            return Number(i2);
        }
      }
      return -1;
    }
    function getParentAutoScrollElement(el, includeSelf) {
      if (!el || !el.getBoundingClientRect)
        return getWindowScrollingElement();
      var elem = el;
      var gotSelf = false;
      do {
        if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
          var elemCSS = css(elem);
          if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
            if (!elem.getBoundingClientRect || elem === document.body)
              return getWindowScrollingElement();
            if (gotSelf || includeSelf)
              return elem;
            gotSelf = true;
          }
        }
      } while (elem = elem.parentNode);
      return getWindowScrollingElement();
    }
    function extend(dst, src) {
      if (dst && src) {
        for (var key in src) {
          if (src.hasOwnProperty(key)) {
            dst[key] = src[key];
          }
        }
      }
      return dst;
    }
    function isRectEqual(rect1, rect2) {
      return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
    }
    var _throttleTimeout;
    function throttle$1(callback, ms) {
      return function() {
        if (!_throttleTimeout) {
          var args = arguments, _this = this;
          if (args.length === 1) {
            callback.call(_this, args[0]);
          } else {
            callback.apply(_this, args);
          }
          _throttleTimeout = setTimeout(function() {
            _throttleTimeout = void 0;
          }, ms);
        }
      };
    }
    function cancelThrottle() {
      clearTimeout(_throttleTimeout);
      _throttleTimeout = void 0;
    }
    function scrollBy(el, x2, y2) {
      el.scrollLeft += x2;
      el.scrollTop += y2;
    }
    function clone(el) {
      var Polymer = window.Polymer;
      var $2 = window.jQuery || window.Zepto;
      if (Polymer && Polymer.dom) {
        return Polymer.dom(el).cloneNode(true);
      } else if ($2) {
        return $2(el).clone(true)[0];
      } else {
        return el.cloneNode(true);
      }
    }
    function getChildContainingRectFromElement(container, options, ghostEl2) {
      var rect = {};
      Array.from(container.children).forEach(function(child) {
        var _rect$left, _rect$top, _rect$right, _rect$bottom;
        if (!closest$1(child, options.draggable, container, false) || child.animated || child === ghostEl2)
          return;
        var childRect = getRect(child);
        rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
        rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
        rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
        rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
      });
      rect.width = rect.right - rect.left;
      rect.height = rect.bottom - rect.top;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
    function AnimationStateManager() {
      var animationStates = [], animationCallbackId;
      return {
        captureAnimationState: function captureAnimationState() {
          animationStates = [];
          if (!this.options.animation)
            return;
          var children = [].slice.call(this.el.children);
          children.forEach(function(child) {
            if (css(child, "display") === "none" || child === Sortable.ghost)
              return;
            animationStates.push({
              target: child,
              rect: getRect(child)
            });
            var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
            if (child.thisAnimationDuration) {
              var childMatrix = matrix(child, true);
              if (childMatrix) {
                fromRect.top -= childMatrix.f;
                fromRect.left -= childMatrix.e;
              }
            }
            child.fromRect = fromRect;
          });
        },
        addAnimationState: function addAnimationState(state) {
          animationStates.push(state);
        },
        removeAnimationState: function removeAnimationState(target) {
          animationStates.splice(indexOfObject(animationStates, {
            target
          }), 1);
        },
        animateAll: function animateAll(callback) {
          var _this = this;
          if (!this.options.animation) {
            clearTimeout(animationCallbackId);
            if (typeof callback === "function")
              callback();
            return;
          }
          var animating = false, animationTime = 0;
          animationStates.forEach(function(state) {
            var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
            if (targetMatrix) {
              toRect.top -= targetMatrix.f;
              toRect.left -= targetMatrix.e;
            }
            target.toRect = toRect;
            if (target.thisAnimationDuration) {
              if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
              (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
                time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
              }
            }
            if (!isRectEqual(toRect, fromRect)) {
              target.prevFromRect = fromRect;
              target.prevToRect = toRect;
              if (!time) {
                time = _this.options.animation;
              }
              _this.animate(target, animatingRect, toRect, time);
            }
            if (time) {
              animating = true;
              animationTime = Math.max(animationTime, time);
              clearTimeout(target.animationResetTimer);
              target.animationResetTimer = setTimeout(function() {
                target.animationTime = 0;
                target.prevFromRect = null;
                target.fromRect = null;
                target.prevToRect = null;
                target.thisAnimationDuration = null;
              }, time);
              target.thisAnimationDuration = time;
            }
          });
          clearTimeout(animationCallbackId);
          if (!animating) {
            if (typeof callback === "function")
              callback();
          } else {
            animationCallbackId = setTimeout(function() {
              if (typeof callback === "function")
                callback();
            }, animationTime);
          }
          animationStates = [];
        },
        animate: function animate(target, currentRect, toRect, duration2) {
          if (duration2) {
            css(target, "transition", "");
            css(target, "transform", "");
            var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
            target.animatingX = !!translateX;
            target.animatingY = !!translateY;
            css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
            this.forRepaintDummy = repaint(target);
            css(target, "transition", "transform " + duration2 + "ms" + (this.options.easing ? " " + this.options.easing : ""));
            css(target, "transform", "translate3d(0,0,0)");
            typeof target.animated === "number" && clearTimeout(target.animated);
            target.animated = setTimeout(function() {
              css(target, "transition", "");
              css(target, "transform", "");
              target.animated = false;
              target.animatingX = false;
              target.animatingY = false;
            }, duration2);
          }
        }
      };
    }
    function repaint(target) {
      return target.offsetWidth;
    }
    function calculateRealTime(animatingRect, fromRect, toRect, options) {
      return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
    }
    var plugins = [];
    var defaults = {
      initializeByDefault: true
    };
    var PluginManager = {
      mount: function mount(plugin) {
        for (var option in defaults) {
          if (defaults.hasOwnProperty(option) && !(option in plugin)) {
            plugin[option] = defaults[option];
          }
        }
        plugins.forEach(function(p2) {
          if (p2.pluginName === plugin.pluginName) {
            throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
          }
        });
        plugins.push(plugin);
      },
      pluginEvent: function pluginEvent2(eventName, sortable, evt) {
        var _this = this;
        this.eventCanceled = false;
        evt.cancel = function() {
          _this.eventCanceled = true;
        };
        var eventNameGlobal = eventName + "Global";
        plugins.forEach(function(plugin) {
          if (!sortable[plugin.pluginName])
            return;
          if (sortable[plugin.pluginName][eventNameGlobal]) {
            sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
              sortable
            }, evt));
          }
          if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
            sortable[plugin.pluginName][eventName](_objectSpread2({
              sortable
            }, evt));
          }
        });
      },
      initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
        plugins.forEach(function(plugin) {
          var pluginName = plugin.pluginName;
          if (!sortable.options[pluginName] && !plugin.initializeByDefault)
            return;
          var initialized = new plugin(sortable, el, sortable.options);
          initialized.sortable = sortable;
          initialized.options = sortable.options;
          sortable[pluginName] = initialized;
          _extends(defaults2, initialized.defaults);
        });
        for (var option in sortable.options) {
          if (!sortable.options.hasOwnProperty(option))
            continue;
          var modified = this.modifyOption(sortable, option, sortable.options[option]);
          if (typeof modified !== "undefined") {
            sortable.options[option] = modified;
          }
        }
      },
      getEventProperties: function getEventProperties(name2, sortable) {
        var eventProperties = {};
        plugins.forEach(function(plugin) {
          if (typeof plugin.eventProperties !== "function")
            return;
          _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name2));
        });
        return eventProperties;
      },
      modifyOption: function modifyOption(sortable, name2, value) {
        var modifiedValue;
        plugins.forEach(function(plugin) {
          if (!sortable[plugin.pluginName])
            return;
          if (plugin.optionListeners && typeof plugin.optionListeners[name2] === "function") {
            modifiedValue = plugin.optionListeners[name2].call(sortable[plugin.pluginName], value);
          }
        });
        return modifiedValue;
      }
    };
    function dispatchEvent(_ref) {
      var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name2 = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
      sortable = sortable || rootEl2 && rootEl2[expando];
      if (!sortable)
        return;
      var evt, options = sortable.options, onName = "on" + name2.charAt(0).toUpperCase() + name2.substr(1);
      if (window.CustomEvent && !IE11OrLess && !Edge) {
        evt = new CustomEvent(name2, {
          bubbles: true,
          cancelable: true
        });
      } else {
        evt = document.createEvent("Event");
        evt.initEvent(name2, true, true);
      }
      evt.to = toEl || rootEl2;
      evt.from = fromEl || rootEl2;
      evt.item = targetEl || rootEl2;
      evt.clone = cloneEl2;
      evt.oldIndex = oldIndex2;
      evt.newIndex = newIndex2;
      evt.oldDraggableIndex = oldDraggableIndex2;
      evt.newDraggableIndex = newDraggableIndex2;
      evt.originalEvent = originalEvent;
      evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
      var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name2, sortable));
      for (var option in allEventProperties) {
        evt[option] = allEventProperties[option];
      }
      if (rootEl2) {
        rootEl2.dispatchEvent(evt);
      }
      if (options[onName]) {
        options[onName].call(sortable, evt);
      }
    }
    var _excluded = ["evt"];
    var pluginEvent = function pluginEvent2(eventName, sortable) {
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
      PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
        dragEl,
        parentEl,
        ghostEl,
        rootEl,
        nextEl,
        lastDownEl,
        cloneEl,
        cloneHidden,
        dragStarted: moved,
        putSortable,
        activeSortable: Sortable.active,
        originalEvent,
        oldIndex,
        oldDraggableIndex,
        newIndex,
        newDraggableIndex,
        hideGhostForTarget: _hideGhostForTarget,
        unhideGhostForTarget: _unhideGhostForTarget,
        cloneNowHidden: function cloneNowHidden() {
          cloneHidden = true;
        },
        cloneNowShown: function cloneNowShown() {
          cloneHidden = false;
        },
        dispatchSortableEvent: function dispatchSortableEvent(name2) {
          _dispatchEvent({
            sortable,
            name: name2,
            originalEvent
          });
        }
      }, data));
    };
    function _dispatchEvent(info) {
      dispatchEvent(_objectSpread2({
        putSortable,
        cloneEl,
        targetEl: dragEl,
        rootEl,
        oldIndex,
        oldDraggableIndex,
        newIndex,
        newDraggableIndex
      }, info));
    }
    var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
    var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
      if (!documentExists)
        return;
      if (IE11OrLess) {
        return false;
      }
      var el = document.createElement("x");
      el.style.cssText = "pointer-events:auto";
      return el.style.pointerEvents === "auto";
    }(), _detectDirection = function _detectDirection2(el, options) {
      var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
      if (elCSS.display === "flex") {
        return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
      }
      if (elCSS.display === "grid") {
        return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
      }
      if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
        var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
        return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
      }
      return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
    }, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
      var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
      return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
    }, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x2, y2) {
      var ret;
      sortables.some(function(sortable) {
        var threshold = sortable[expando].options.emptyInsertThreshold;
        if (!threshold || lastChild(sortable))
          return;
        var rect = getRect(sortable), insideHorizontally = x2 >= rect.left - threshold && x2 <= rect.right + threshold, insideVertically = y2 >= rect.top - threshold && y2 <= rect.bottom + threshold;
        if (insideHorizontally && insideVertically) {
          return ret = sortable;
        }
      });
      return ret;
    }, _prepareGroup = function _prepareGroup2(options) {
      function toFn(value, pull) {
        return function(to2, from2, dragEl2, evt) {
          var sameGroup = to2.options.group.name && from2.options.group.name && to2.options.group.name === from2.options.group.name;
          if (value == null && (pull || sameGroup)) {
            return true;
          } else if (value == null || value === false) {
            return false;
          } else if (pull && value === "clone") {
            return value;
          } else if (typeof value === "function") {
            return toFn(value(to2, from2, dragEl2, evt), pull)(to2, from2, dragEl2, evt);
          } else {
            var otherGroup = (pull ? to2 : from2).options.group.name;
            return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
          }
        };
      }
      var group2 = {};
      var originalGroup = options.group;
      if (!originalGroup || _typeof(originalGroup) != "object") {
        originalGroup = {
          name: originalGroup
        };
      }
      group2.name = originalGroup.name;
      group2.checkPull = toFn(originalGroup.pull, true);
      group2.checkPut = toFn(originalGroup.put);
      group2.revertClone = originalGroup.revertClone;
      options.group = group2;
    }, _hideGhostForTarget = function _hideGhostForTarget2() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, "display", "none");
      }
    }, _unhideGhostForTarget = function _unhideGhostForTarget2() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, "display", "");
      }
    };
    if (documentExists && !ChromeForAndroid) {
      document.addEventListener("click", function(evt) {
        if (ignoreNextClick) {
          evt.preventDefault();
          evt.stopPropagation && evt.stopPropagation();
          evt.stopImmediatePropagation && evt.stopImmediatePropagation();
          ignoreNextClick = false;
          return false;
        }
      }, true);
    }
    var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
      if (dragEl) {
        evt = evt.touches ? evt.touches[0] : evt;
        var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
        if (nearest) {
          var event = {};
          for (var i2 in evt) {
            if (evt.hasOwnProperty(i2)) {
              event[i2] = evt[i2];
            }
          }
          event.target = event.rootEl = nearest;
          event.preventDefault = void 0;
          event.stopPropagation = void 0;
          nearest[expando]._onDragOver(event);
        }
      }
    };
    var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
      if (dragEl) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
      }
    };
    function Sortable(el, options) {
      if (!(el && el.nodeType && el.nodeType === 1)) {
        throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
      }
      this.el = el;
      this.options = options = _extends({}, options);
      el[expando] = this;
      var defaults2 = {
        group: null,
        sort: true,
        disabled: false,
        store: null,
        handle: null,
        draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
        swapThreshold: 1,
        // percentage; 0 <= x <= 1
        invertSwap: false,
        // invert always
        invertedSwapThreshold: null,
        // will be set to same as swapThreshold if default
        removeCloneOnHide: true,
        direction: function direction() {
          return _detectDirection(el, this.options);
        },
        ghostClass: "sortable-ghost",
        chosenClass: "sortable-chosen",
        dragClass: "sortable-drag",
        ignore: "a, img",
        filter: null,
        preventOnFilter: true,
        animation: 0,
        easing: null,
        setData: function setData(dataTransfer, dragEl2) {
          dataTransfer.setData("Text", dragEl2.textContent);
        },
        dropBubble: false,
        dragoverBubble: false,
        dataIdAttr: "data-id",
        delay: 0,
        delayOnTouchOnly: false,
        touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
        forceFallback: false,
        fallbackClass: "sortable-fallback",
        fallbackOnBody: false,
        fallbackTolerance: 0,
        fallbackOffset: {
          x: 0,
          y: 0
        },
        supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
        emptyInsertThreshold: 5
      };
      PluginManager.initializePlugins(this, el, defaults2);
      for (var name2 in defaults2) {
        !(name2 in options) && (options[name2] = defaults2[name2]);
      }
      _prepareGroup(options);
      for (var fn2 in this) {
        if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
          this[fn2] = this[fn2].bind(this);
        }
      }
      this.nativeDraggable = options.forceFallback ? false : supportDraggable;
      if (this.nativeDraggable) {
        this.options.touchStartThreshold = 1;
      }
      if (options.supportPointer) {
        on$1(el, "pointerdown", this._onTapStart);
      } else {
        on$1(el, "mousedown", this._onTapStart);
        on$1(el, "touchstart", this._onTapStart);
      }
      if (this.nativeDraggable) {
        on$1(el, "dragover", this);
        on$1(el, "dragenter", this);
      }
      sortables.push(this.el);
      options.store && options.store.get && this.sort(options.store.get(this) || []);
      _extends(this, AnimationStateManager());
    }
    Sortable.prototype = /** @lends Sortable.prototype */
    {
      constructor: Sortable,
      _isOutsideThisEl: function _isOutsideThisEl(target) {
        if (!this.el.contains(target) && target !== this.el) {
          lastTarget = null;
        }
      },
      _getDirection: function _getDirection(evt, target) {
        return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
      },
      _onTapStart: function _onTapStart(evt) {
        if (!evt.cancelable)
          return;
        var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter2 = options.filter;
        _saveInputCheckedState(el);
        if (dragEl) {
          return;
        }
        if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
          return;
        }
        if (originalTarget.isContentEditable) {
          return;
        }
        if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
          return;
        }
        target = closest$1(target, options.draggable, el, false);
        if (target && target.animated) {
          return;
        }
        if (lastDownEl === target) {
          return;
        }
        oldIndex = index$1(target);
        oldDraggableIndex = index$1(target, options.draggable);
        if (typeof filter2 === "function") {
          if (filter2.call(this, evt, target, this)) {
            _dispatchEvent({
              sortable: _this,
              rootEl: originalTarget,
              name: "filter",
              targetEl: target,
              toEl: el,
              fromEl: el
            });
            pluginEvent("filter", _this, {
              evt
            });
            preventOnFilter && evt.cancelable && evt.preventDefault();
            return;
          }
        } else if (filter2) {
          filter2 = filter2.split(",").some(function(criteria) {
            criteria = closest$1(originalTarget, criteria.trim(), el, false);
            if (criteria) {
              _dispatchEvent({
                sortable: _this,
                rootEl: criteria,
                name: "filter",
                targetEl: target,
                fromEl: el,
                toEl: el
              });
              pluginEvent("filter", _this, {
                evt
              });
              return true;
            }
          });
          if (filter2) {
            preventOnFilter && evt.cancelable && evt.preventDefault();
            return;
          }
        }
        if (options.handle && !closest$1(originalTarget, options.handle, el, false)) {
          return;
        }
        this._prepareDragStart(evt, touch, target);
      },
      _prepareDragStart: function _prepareDragStart(evt, touch, target) {
        var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
        if (target && !dragEl && target.parentNode === el) {
          var dragRect = getRect(target);
          rootEl = el;
          dragEl = target;
          parentEl = dragEl.parentNode;
          nextEl = dragEl.nextSibling;
          lastDownEl = target;
          activeGroup = options.group;
          Sortable.dragged = dragEl;
          tapEvt = {
            target: dragEl,
            clientX: (touch || evt).clientX,
            clientY: (touch || evt).clientY
          };
          tapDistanceLeft = tapEvt.clientX - dragRect.left;
          tapDistanceTop = tapEvt.clientY - dragRect.top;
          this._lastX = (touch || evt).clientX;
          this._lastY = (touch || evt).clientY;
          dragEl.style["will-change"] = "all";
          dragStartFn = function dragStartFn2() {
            pluginEvent("delayEnded", _this, {
              evt
            });
            if (Sortable.eventCanceled) {
              _this._onDrop();
              return;
            }
            _this._disableDelayedDragEvents();
            if (!FireFox && _this.nativeDraggable) {
              dragEl.draggable = true;
            }
            _this._triggerDragStart(evt, touch);
            _dispatchEvent({
              sortable: _this,
              name: "choose",
              originalEvent: evt
            });
            toggleClass(dragEl, options.chosenClass, true);
          };
          options.ignore.split(",").forEach(function(criteria) {
            find(dragEl, criteria.trim(), _disableDraggable);
          });
          on$1(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
          on$1(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
          on$1(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
          on$1(ownerDocument, "mouseup", _this._onDrop);
          on$1(ownerDocument, "touchend", _this._onDrop);
          on$1(ownerDocument, "touchcancel", _this._onDrop);
          if (FireFox && this.nativeDraggable) {
            this.options.touchStartThreshold = 4;
            dragEl.draggable = true;
          }
          pluginEvent("delayStart", this, {
            evt
          });
          if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
            if (Sortable.eventCanceled) {
              this._onDrop();
              return;
            }
            on$1(ownerDocument, "mouseup", _this._disableDelayedDrag);
            on$1(ownerDocument, "touchend", _this._disableDelayedDrag);
            on$1(ownerDocument, "touchcancel", _this._disableDelayedDrag);
            on$1(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
            on$1(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
            options.supportPointer && on$1(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
            _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
          } else {
            dragStartFn();
          }
        }
      },
      _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e2) {
        var touch = e2.touches ? e2.touches[0] : e2;
        if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
          this._disableDelayedDrag();
        }
      },
      _disableDelayedDrag: function _disableDelayedDrag() {
        dragEl && _disableDraggable(dragEl);
        clearTimeout(this._dragStartTimer);
        this._disableDelayedDragEvents();
      },
      _disableDelayedDragEvents: function _disableDelayedDragEvents() {
        var ownerDocument = this.el.ownerDocument;
        off(ownerDocument, "mouseup", this._disableDelayedDrag);
        off(ownerDocument, "touchend", this._disableDelayedDrag);
        off(ownerDocument, "touchcancel", this._disableDelayedDrag);
        off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
        off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
        off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
      },
      _triggerDragStart: function _triggerDragStart(evt, touch) {
        touch = touch || evt.pointerType == "touch" && evt;
        if (!this.nativeDraggable || touch) {
          if (this.options.supportPointer) {
            on$1(document, "pointermove", this._onTouchMove);
          } else if (touch) {
            on$1(document, "touchmove", this._onTouchMove);
          } else {
            on$1(document, "mousemove", this._onTouchMove);
          }
        } else {
          on$1(dragEl, "dragend", this);
          on$1(rootEl, "dragstart", this._onDragStart);
        }
        try {
          if (document.selection) {
            _nextTick(function() {
              document.selection.empty();
            });
          } else {
            window.getSelection().removeAllRanges();
          }
        } catch (err) {
        }
      },
      _dragStarted: function _dragStarted(fallback, evt) {
        awaitingDragStarted = false;
        if (rootEl && dragEl) {
          pluginEvent("dragStarted", this, {
            evt
          });
          if (this.nativeDraggable) {
            on$1(document, "dragover", _checkOutsideTargetEl);
          }
          var options = this.options;
          !fallback && toggleClass(dragEl, options.dragClass, false);
          toggleClass(dragEl, options.ghostClass, true);
          Sortable.active = this;
          fallback && this._appendGhost();
          _dispatchEvent({
            sortable: this,
            name: "start",
            originalEvent: evt
          });
        } else {
          this._nulling();
        }
      },
      _emulateDragOver: function _emulateDragOver() {
        if (touchEvt) {
          this._lastX = touchEvt.clientX;
          this._lastY = touchEvt.clientY;
          _hideGhostForTarget();
          var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          var parent2 = target;
          while (target && target.shadowRoot) {
            target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
            if (target === parent2)
              break;
            parent2 = target;
          }
          dragEl.parentNode[expando]._isOutsideThisEl(target);
          if (parent2) {
            do {
              if (parent2[expando]) {
                var inserted = void 0;
                inserted = parent2[expando]._onDragOver({
                  clientX: touchEvt.clientX,
                  clientY: touchEvt.clientY,
                  target,
                  rootEl: parent2
                });
                if (inserted && !this.options.dragoverBubble) {
                  break;
                }
              }
              target = parent2;
            } while (parent2 = parent2.parentNode);
          }
          _unhideGhostForTarget();
        }
      },
      _onTouchMove: function _onTouchMove(evt) {
        if (tapEvt) {
          var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
          if (!Sortable.active && !awaitingDragStarted) {
            if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
              return;
            }
            this._onDragStart(evt, true);
          }
          if (ghostEl) {
            if (ghostMatrix) {
              ghostMatrix.e += dx - (lastDx || 0);
              ghostMatrix.f += dy - (lastDy || 0);
            } else {
              ghostMatrix = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                e: dx,
                f: dy
              };
            }
            var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
            css(ghostEl, "webkitTransform", cssMatrix);
            css(ghostEl, "mozTransform", cssMatrix);
            css(ghostEl, "msTransform", cssMatrix);
            css(ghostEl, "transform", cssMatrix);
            lastDx = dx;
            lastDy = dy;
            touchEvt = touch;
          }
          evt.cancelable && evt.preventDefault();
        }
      },
      _appendGhost: function _appendGhost() {
        if (!ghostEl) {
          var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
          if (PositionGhostAbsolutely) {
            ghostRelativeParent = container;
            while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
              ghostRelativeParent = ghostRelativeParent.parentNode;
            }
            if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
              if (ghostRelativeParent === document)
                ghostRelativeParent = getWindowScrollingElement();
              rect.top += ghostRelativeParent.scrollTop;
              rect.left += ghostRelativeParent.scrollLeft;
            } else {
              ghostRelativeParent = getWindowScrollingElement();
            }
            ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
          }
          ghostEl = dragEl.cloneNode(true);
          toggleClass(ghostEl, options.ghostClass, false);
          toggleClass(ghostEl, options.fallbackClass, true);
          toggleClass(ghostEl, options.dragClass, true);
          css(ghostEl, "transition", "");
          css(ghostEl, "transform", "");
          css(ghostEl, "box-sizing", "border-box");
          css(ghostEl, "margin", 0);
          css(ghostEl, "top", rect.top);
          css(ghostEl, "left", rect.left);
          css(ghostEl, "width", rect.width);
          css(ghostEl, "height", rect.height);
          css(ghostEl, "opacity", "0.8");
          css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
          css(ghostEl, "zIndex", "100000");
          css(ghostEl, "pointerEvents", "none");
          Sortable.ghost = ghostEl;
          container.appendChild(ghostEl);
          css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
        }
      },
      _onDragStart: function _onDragStart(evt, fallback) {
        var _this = this;
        var dataTransfer = evt.dataTransfer;
        var options = _this.options;
        pluginEvent("dragStart", this, {
          evt
        });
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        pluginEvent("setupClone", this);
        if (!Sortable.eventCanceled) {
          cloneEl = clone(dragEl);
          cloneEl.removeAttribute("id");
          cloneEl.draggable = false;
          cloneEl.style["will-change"] = "";
          this._hideClone();
          toggleClass(cloneEl, this.options.chosenClass, false);
          Sortable.clone = cloneEl;
        }
        _this.cloneId = _nextTick(function() {
          pluginEvent("clone", _this);
          if (Sortable.eventCanceled)
            return;
          if (!_this.options.removeCloneOnHide) {
            rootEl.insertBefore(cloneEl, dragEl);
          }
          _this._hideClone();
          _dispatchEvent({
            sortable: _this,
            name: "clone"
          });
        });
        !fallback && toggleClass(dragEl, options.dragClass, true);
        if (fallback) {
          ignoreNextClick = true;
          _this._loopId = setInterval(_this._emulateDragOver, 50);
        } else {
          off(document, "mouseup", _this._onDrop);
          off(document, "touchend", _this._onDrop);
          off(document, "touchcancel", _this._onDrop);
          if (dataTransfer) {
            dataTransfer.effectAllowed = "move";
            options.setData && options.setData.call(_this, dataTransfer, dragEl);
          }
          on$1(document, "drop", _this);
          css(dragEl, "transform", "translateZ(0)");
        }
        awaitingDragStarted = true;
        _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
        on$1(document, "selectstart", _this);
        moved = true;
        if (Safari) {
          css(document.body, "user-select", "none");
        }
      },
      // Returns true - if no further action is needed (either inserted or another condition)
      _onDragOver: function _onDragOver(evt) {
        var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group2 = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group2, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
        if (_silent)
          return;
        function dragOverEvent(name2, extra) {
          pluginEvent(name2, _this, _objectSpread2({
            evt,
            isOwner,
            axis: vertical ? "vertical" : "horizontal",
            revert,
            dragRect,
            targetRect,
            canSort,
            fromSortable,
            target,
            completed: completed2,
            onMove: function onMove(target2, after3) {
              return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after3);
            },
            changed
          }, extra));
        }
        function capture() {
          dragOverEvent("dragOverAnimationCapture");
          _this.captureAnimationState();
          if (_this !== fromSortable) {
            fromSortable.captureAnimationState();
          }
        }
        function completed2(insertion) {
          dragOverEvent("dragOverCompleted", {
            insertion
          });
          if (insertion) {
            if (isOwner) {
              activeSortable._hideClone();
            } else {
              activeSortable._showClone(_this);
            }
            if (_this !== fromSortable) {
              toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
              toggleClass(dragEl, options.ghostClass, true);
            }
            if (putSortable !== _this && _this !== Sortable.active) {
              putSortable = _this;
            } else if (_this === Sortable.active && putSortable) {
              putSortable = null;
            }
            if (fromSortable === _this) {
              _this._ignoreWhileAnimating = target;
            }
            _this.animateAll(function() {
              dragOverEvent("dragOverAnimationComplete");
              _this._ignoreWhileAnimating = null;
            });
            if (_this !== fromSortable) {
              fromSortable.animateAll();
              fromSortable._ignoreWhileAnimating = null;
            }
          }
          if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
            lastTarget = null;
          }
          if (!options.dragoverBubble && !evt.rootEl && target !== document) {
            dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
            !insertion && nearestEmptyInsertDetectEvent(evt);
          }
          !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
          return completedFired = true;
        }
        function changed() {
          newIndex = index$1(dragEl);
          newDraggableIndex = index$1(dragEl, options.draggable);
          _dispatchEvent({
            sortable: _this,
            name: "change",
            toEl: el,
            newIndex,
            newDraggableIndex,
            originalEvent: evt
          });
        }
        if (evt.preventDefault !== void 0) {
          evt.cancelable && evt.preventDefault();
        }
        target = closest$1(target, options.draggable, el, true);
        dragOverEvent("dragOver");
        if (Sortable.eventCanceled)
          return completedFired;
        if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
          return completed2(false);
        }
        ignoreNextClick = false;
        if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group2.checkPut(this, activeSortable, dragEl, evt))) {
          vertical = this._getDirection(evt, target) === "vertical";
          dragRect = getRect(dragEl);
          dragOverEvent("dragOverValid");
          if (Sortable.eventCanceled)
            return completedFired;
          if (revert) {
            parentEl = rootEl;
            capture();
            this._hideClone();
            dragOverEvent("revert");
            if (!Sortable.eventCanceled) {
              if (nextEl) {
                rootEl.insertBefore(dragEl, nextEl);
              } else {
                rootEl.appendChild(dragEl);
              }
            }
            return completed2(true);
          }
          var elLastChild = lastChild(el, options.draggable);
          if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
            if (elLastChild === dragEl) {
              return completed2(false);
            }
            if (elLastChild && el === evt.target) {
              target = elLastChild;
            }
            if (target) {
              targetRect = getRect(target);
            }
            if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
              capture();
              if (elLastChild && elLastChild.nextSibling) {
                el.insertBefore(dragEl, elLastChild.nextSibling);
              } else {
                el.appendChild(dragEl);
              }
              parentEl = el;
              changed();
              return completed2(true);
            }
          } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
            var firstChild = getChild(el, 0, options, true);
            if (firstChild === dragEl) {
              return completed2(false);
            }
            target = firstChild;
            targetRect = getRect(target);
            if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
              capture();
              el.insertBefore(dragEl, firstChild);
              parentEl = el;
              changed();
              return completed2(true);
            }
          } else if (target.parentNode === el) {
            targetRect = getRect(target);
            var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
            if (lastTarget !== target) {
              targetBeforeFirstSwap = targetRect[side1];
              pastFirstInvertThresh = false;
              isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
            }
            direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
            var sibling;
            if (direction !== 0) {
              var dragIndex = index$1(dragEl);
              do {
                dragIndex -= direction;
                sibling = parentEl.children[dragIndex];
              } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
            }
            if (direction === 0 || sibling === target) {
              return completed2(false);
            }
            lastTarget = target;
            lastDirection = direction;
            var nextSibling = target.nextElementSibling, after2 = false;
            after2 = direction === 1;
            var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after2);
            if (moveVector !== false) {
              if (moveVector === 1 || moveVector === -1) {
                after2 = moveVector === 1;
              }
              _silent = true;
              setTimeout(_unsilent, 30);
              capture();
              if (after2 && !nextSibling) {
                el.appendChild(dragEl);
              } else {
                target.parentNode.insertBefore(dragEl, after2 ? nextSibling : target);
              }
              if (scrolledPastTop) {
                scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
              }
              parentEl = dragEl.parentNode;
              if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
                targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
              }
              changed();
              return completed2(true);
            }
          }
          if (el.contains(dragEl)) {
            return completed2(false);
          }
        }
        return false;
      },
      _ignoreWhileAnimating: null,
      _offMoveEvents: function _offMoveEvents() {
        off(document, "mousemove", this._onTouchMove);
        off(document, "touchmove", this._onTouchMove);
        off(document, "pointermove", this._onTouchMove);
        off(document, "dragover", nearestEmptyInsertDetectEvent);
        off(document, "mousemove", nearestEmptyInsertDetectEvent);
        off(document, "touchmove", nearestEmptyInsertDetectEvent);
      },
      _offUpEvents: function _offUpEvents() {
        var ownerDocument = this.el.ownerDocument;
        off(ownerDocument, "mouseup", this._onDrop);
        off(ownerDocument, "touchend", this._onDrop);
        off(ownerDocument, "pointerup", this._onDrop);
        off(ownerDocument, "touchcancel", this._onDrop);
        off(document, "selectstart", this);
      },
      _onDrop: function _onDrop(evt) {
        var el = this.el, options = this.options;
        newIndex = index$1(dragEl);
        newDraggableIndex = index$1(dragEl, options.draggable);
        pluginEvent("drop", this, {
          evt
        });
        parentEl = dragEl && dragEl.parentNode;
        newIndex = index$1(dragEl);
        newDraggableIndex = index$1(dragEl, options.draggable);
        if (Sortable.eventCanceled) {
          this._nulling();
          return;
        }
        awaitingDragStarted = false;
        isCircumstantialInvert = false;
        pastFirstInvertThresh = false;
        clearInterval(this._loopId);
        clearTimeout(this._dragStartTimer);
        _cancelNextTick(this.cloneId);
        _cancelNextTick(this._dragStartId);
        if (this.nativeDraggable) {
          off(document, "drop", this);
          off(el, "dragstart", this._onDragStart);
        }
        this._offMoveEvents();
        this._offUpEvents();
        if (Safari) {
          css(document.body, "user-select", "");
        }
        css(dragEl, "transform", "");
        if (evt) {
          if (moved) {
            evt.cancelable && evt.preventDefault();
            !options.dropBubble && evt.stopPropagation();
          }
          ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
          if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
            cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
          }
          if (dragEl) {
            if (this.nativeDraggable) {
              off(dragEl, "dragend", this);
            }
            _disableDraggable(dragEl);
            dragEl.style["will-change"] = "";
            if (moved && !awaitingDragStarted) {
              toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
            }
            toggleClass(dragEl, this.options.chosenClass, false);
            _dispatchEvent({
              sortable: this,
              name: "unchoose",
              toEl: parentEl,
              newIndex: null,
              newDraggableIndex: null,
              originalEvent: evt
            });
            if (rootEl !== parentEl) {
              if (newIndex >= 0) {
                _dispatchEvent({
                  rootEl: parentEl,
                  name: "add",
                  toEl: parentEl,
                  fromEl: rootEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "remove",
                  toEl: parentEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  rootEl: parentEl,
                  name: "sort",
                  toEl: parentEl,
                  fromEl: rootEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "sort",
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
              putSortable && putSortable.save();
            } else {
              if (newIndex !== oldIndex) {
                if (newIndex >= 0) {
                  _dispatchEvent({
                    sortable: this,
                    name: "update",
                    toEl: parentEl,
                    originalEvent: evt
                  });
                  _dispatchEvent({
                    sortable: this,
                    name: "sort",
                    toEl: parentEl,
                    originalEvent: evt
                  });
                }
              }
            }
            if (Sortable.active) {
              if (newIndex == null || newIndex === -1) {
                newIndex = oldIndex;
                newDraggableIndex = oldDraggableIndex;
              }
              _dispatchEvent({
                sortable: this,
                name: "end",
                toEl: parentEl,
                originalEvent: evt
              });
              this.save();
            }
          }
        }
        this._nulling();
      },
      _nulling: function _nulling() {
        pluginEvent("nulling", this);
        rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
        savedInputChecked.forEach(function(el) {
          el.checked = true;
        });
        savedInputChecked.length = lastDx = lastDy = 0;
      },
      handleEvent: function handleEvent(evt) {
        switch (evt.type) {
          case "drop":
          case "dragend":
            this._onDrop(evt);
            break;
          case "dragenter":
          case "dragover":
            if (dragEl) {
              this._onDragOver(evt);
              _globalDragOver(evt);
            }
            break;
          case "selectstart":
            evt.preventDefault();
            break;
        }
      },
      /**
       * Serializes the item into an array of string.
       * @returns {String[]}
       */
      toArray: function toArray2() {
        var order2 = [], el, children = this.el.children, i2 = 0, n2 = children.length, options = this.options;
        for (; i2 < n2; i2++) {
          el = children[i2];
          if (closest$1(el, options.draggable, this.el, false)) {
            order2.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
          }
        }
        return order2;
      },
      /**
       * Sorts the elements according to the array.
       * @param  {String[]}  order  order of the items
       */
      sort: function sort(order2, useAnimation) {
        var items = {}, rootEl2 = this.el;
        this.toArray().forEach(function(id, i2) {
          var el = rootEl2.children[i2];
          if (closest$1(el, this.options.draggable, rootEl2, false)) {
            items[id] = el;
          }
        }, this);
        useAnimation && this.captureAnimationState();
        order2.forEach(function(id) {
          if (items[id]) {
            rootEl2.removeChild(items[id]);
            rootEl2.appendChild(items[id]);
          }
        });
        useAnimation && this.animateAll();
      },
      /**
       * Save the current sorting
       */
      save: function save() {
        var store = this.options.store;
        store && store.set && store.set(this);
      },
      /**
       * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
       * @param   {HTMLElement}  el
       * @param   {String}       [selector]  default: `options.draggable`
       * @returns {HTMLElement|null}
       */
      closest: function closest$1$1(el, selector) {
        return closest$1(el, selector || this.options.draggable, this.el, false);
      },
      /**
       * Set/get option
       * @param   {string} name
       * @param   {*}      [value]
       * @returns {*}
       */
      option: function option(name2, value) {
        var options = this.options;
        if (value === void 0) {
          return options[name2];
        } else {
          var modifiedValue = PluginManager.modifyOption(this, name2, value);
          if (typeof modifiedValue !== "undefined") {
            options[name2] = modifiedValue;
          } else {
            options[name2] = value;
          }
          if (name2 === "group") {
            _prepareGroup(options);
          }
        }
      },
      /**
       * Destroy
       */
      destroy: function destroy() {
        pluginEvent("destroy", this);
        var el = this.el;
        el[expando] = null;
        off(el, "mousedown", this._onTapStart);
        off(el, "touchstart", this._onTapStart);
        off(el, "pointerdown", this._onTapStart);
        if (this.nativeDraggable) {
          off(el, "dragover", this);
          off(el, "dragenter", this);
        }
        Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
          el2.removeAttribute("draggable");
        });
        this._onDrop();
        this._disableDelayedDragEvents();
        sortables.splice(sortables.indexOf(this.el), 1);
        this.el = el = null;
      },
      _hideClone: function _hideClone() {
        if (!cloneHidden) {
          pluginEvent("hideClone", this);
          if (Sortable.eventCanceled)
            return;
          css(cloneEl, "display", "none");
          if (this.options.removeCloneOnHide && cloneEl.parentNode) {
            cloneEl.parentNode.removeChild(cloneEl);
          }
          cloneHidden = true;
        }
      },
      _showClone: function _showClone(putSortable2) {
        if (putSortable2.lastPutMode !== "clone") {
          this._hideClone();
          return;
        }
        if (cloneHidden) {
          pluginEvent("showClone", this);
          if (Sortable.eventCanceled)
            return;
          if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
            rootEl.insertBefore(cloneEl, dragEl);
          } else if (nextEl) {
            rootEl.insertBefore(cloneEl, nextEl);
          } else {
            rootEl.appendChild(cloneEl);
          }
          if (this.options.group.revertClone) {
            this.animate(dragEl, cloneEl);
          }
          css(cloneEl, "display", "");
          cloneHidden = false;
        }
      }
    };
    function _globalDragOver(evt) {
      if (evt.dataTransfer) {
        evt.dataTransfer.dropEffect = "move";
      }
      evt.cancelable && evt.preventDefault();
    }
    function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
      var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
      if (window.CustomEvent && !IE11OrLess && !Edge) {
        evt = new CustomEvent("move", {
          bubbles: true,
          cancelable: true
        });
      } else {
        evt = document.createEvent("Event");
        evt.initEvent("move", true, true);
      }
      evt.to = toEl;
      evt.from = fromEl;
      evt.dragged = dragEl2;
      evt.draggedRect = dragRect;
      evt.related = targetEl || toEl;
      evt.relatedRect = targetRect || getRect(toEl);
      evt.willInsertAfter = willInsertAfter;
      evt.originalEvent = originalEvent;
      fromEl.dispatchEvent(evt);
      if (onMoveFn) {
        retVal = onMoveFn.call(sortable, evt, originalEvent);
      }
      return retVal;
    }
    function _disableDraggable(el) {
      el.draggable = false;
    }
    function _unsilent() {
      _silent = false;
    }
    function _ghostIsFirst(evt, vertical, sortable) {
      var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
      var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
      var spacer = 10;
      return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
    }
    function _ghostIsLast(evt, vertical, sortable) {
      var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
      var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
      var spacer = 10;
      return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
    }
    function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
      var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
      if (!invertSwap) {
        if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
          if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
            pastFirstInvertThresh = true;
          }
          if (!pastFirstInvertThresh) {
            if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
              return -lastDirection;
            }
          } else {
            invert = true;
          }
        } else {
          if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
            return _getInsertDirection(target);
          }
        }
      }
      invert = invert || invertSwap;
      if (invert) {
        if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
          return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
        }
      }
      return 0;
    }
    function _getInsertDirection(target) {
      if (index$1(dragEl) < index$1(target)) {
        return 1;
      } else {
        return -1;
      }
    }
    function _generateId(el) {
      var str = el.tagName + el.className + el.src + el.href + el.textContent, i2 = str.length, sum = 0;
      while (i2--) {
        sum += str.charCodeAt(i2);
      }
      return sum.toString(36);
    }
    function _saveInputCheckedState(root2) {
      savedInputChecked.length = 0;
      var inputs = root2.getElementsByTagName("input");
      var idx = inputs.length;
      while (idx--) {
        var el = inputs[idx];
        el.checked && savedInputChecked.push(el);
      }
    }
    function _nextTick(fn2) {
      return setTimeout(fn2, 0);
    }
    function _cancelNextTick(id) {
      return clearTimeout(id);
    }
    if (documentExists) {
      on$1(document, "touchmove", function(evt) {
        if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
          evt.preventDefault();
        }
      });
    }
    Sortable.utils = {
      on: on$1,
      off,
      css,
      find,
      is: function is(el, selector) {
        return !!closest$1(el, selector, el, false);
      },
      extend,
      throttle: throttle$1,
      closest: closest$1,
      toggleClass,
      clone,
      index: index$1,
      nextTick: _nextTick,
      cancelNextTick: _cancelNextTick,
      detectDirection: _detectDirection,
      getChild
    };
    Sortable.get = function(element) {
      return element[expando];
    };
    Sortable.mount = function() {
      for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
        plugins2[_key] = arguments[_key];
      }
      if (plugins2[0].constructor === Array)
        plugins2 = plugins2[0];
      plugins2.forEach(function(plugin) {
        if (!plugin.prototype || !plugin.prototype.constructor) {
          throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
        }
        if (plugin.utils)
          Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
        PluginManager.mount(plugin);
      });
    };
    Sortable.create = function(el, options) {
      return new Sortable(el, options);
    };
    Sortable.version = version;
    var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
    function AutoScrollPlugin() {
      function AutoScroll() {
        this.defaults = {
          scroll: true,
          forceAutoScrollFallback: false,
          scrollSensitivity: 30,
          scrollSpeed: 10,
          bubbleScroll: true
        };
        for (var fn2 in this) {
          if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
            this[fn2] = this[fn2].bind(this);
          }
        }
      }
      AutoScroll.prototype = {
        dragStarted: function dragStarted(_ref) {
          var originalEvent = _ref.originalEvent;
          if (this.sortable.nativeDraggable) {
            on$1(document, "dragover", this._handleAutoScroll);
          } else {
            if (this.options.supportPointer) {
              on$1(document, "pointermove", this._handleFallbackAutoScroll);
            } else if (originalEvent.touches) {
              on$1(document, "touchmove", this._handleFallbackAutoScroll);
            } else {
              on$1(document, "mousemove", this._handleFallbackAutoScroll);
            }
          }
        },
        dragOverCompleted: function dragOverCompleted(_ref2) {
          var originalEvent = _ref2.originalEvent;
          if (!this.options.dragOverBubble && !originalEvent.rootEl) {
            this._handleAutoScroll(originalEvent);
          }
        },
        drop: function drop2() {
          if (this.sortable.nativeDraggable) {
            off(document, "dragover", this._handleAutoScroll);
          } else {
            off(document, "pointermove", this._handleFallbackAutoScroll);
            off(document, "touchmove", this._handleFallbackAutoScroll);
            off(document, "mousemove", this._handleFallbackAutoScroll);
          }
          clearPointerElemChangedInterval();
          clearAutoScrolls();
          cancelThrottle();
        },
        nulling: function nulling() {
          touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
          autoScrolls.length = 0;
        },
        _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
          this._handleAutoScroll(evt, true);
        },
        _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
          var _this = this;
          var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x2, y2);
          touchEvt$1 = evt;
          if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
            autoScroll(evt, this.options, elem, fallback);
            var ogElemScroller = getParentAutoScrollElement(elem, true);
            if (scrolling && (!pointerElemChangedInterval || x2 !== lastAutoScrollX || y2 !== lastAutoScrollY)) {
              pointerElemChangedInterval && clearPointerElemChangedInterval();
              pointerElemChangedInterval = setInterval(function() {
                var newElem = getParentAutoScrollElement(document.elementFromPoint(x2, y2), true);
                if (newElem !== ogElemScroller) {
                  ogElemScroller = newElem;
                  clearAutoScrolls();
                }
                autoScroll(evt, _this.options, newElem, fallback);
              }, 10);
              lastAutoScrollX = x2;
              lastAutoScrollY = y2;
            }
          } else {
            if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
              clearAutoScrolls();
              return;
            }
            autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
          }
        }
      };
      return _extends(AutoScroll, {
        pluginName: "scroll",
        initializeByDefault: true
      });
    }
    function clearAutoScrolls() {
      autoScrolls.forEach(function(autoScroll2) {
        clearInterval(autoScroll2.pid);
      });
      autoScrolls = [];
    }
    function clearPointerElemChangedInterval() {
      clearInterval(pointerElemChangedInterval);
    }
    var autoScroll = throttle$1(function(evt, options, rootEl2, isFallback) {
      if (!options.scroll)
        return;
      var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
      var scrollThisInstance = false, scrollCustomFn;
      if (scrollRootEl !== rootEl2) {
        scrollRootEl = rootEl2;
        clearAutoScrolls();
        scrollEl = options.scroll;
        scrollCustomFn = options.scrollFn;
        if (scrollEl === true) {
          scrollEl = getParentAutoScrollElement(rootEl2, true);
        }
      }
      var layersOut = 0;
      var currentParent = scrollEl;
      do {
        var el = currentParent, rect = getRect(el), top2 = rect.top, bottom2 = rect.bottom, left2 = rect.left, right2 = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
        if (el === winScroller) {
          canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
          canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
        } else {
          canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
          canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
        }
        var vx = canScrollX && (Math.abs(right2 - x2) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left2 - x2) <= sens && !!scrollPosX);
        var vy = canScrollY && (Math.abs(bottom2 - y2) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top2 - y2) <= sens && !!scrollPosY);
        if (!autoScrolls[layersOut]) {
          for (var i2 = 0; i2 <= layersOut; i2++) {
            if (!autoScrolls[i2]) {
              autoScrolls[i2] = {};
            }
          }
        }
        if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
          autoScrolls[layersOut].el = el;
          autoScrolls[layersOut].vx = vx;
          autoScrolls[layersOut].vy = vy;
          clearInterval(autoScrolls[layersOut].pid);
          if (vx != 0 || vy != 0) {
            scrollThisInstance = true;
            autoScrolls[layersOut].pid = setInterval((function() {
              if (isFallback && this.layer === 0) {
                Sortable.active._onTouchMove(touchEvt$1);
              }
              var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
              var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
              if (typeof scrollCustomFn === "function") {
                if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
                  return;
                }
              }
              scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
            }).bind({
              layer: layersOut
            }), 24);
          }
        }
        layersOut++;
      } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
      scrolling = scrollThisInstance;
    }, 30);
    var drop = function drop2(_ref) {
      var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
      if (!originalEvent)
        return;
      var toSortable = putSortable2 || activeSortable;
      hideGhostForTarget();
      var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
      var target = document.elementFromPoint(touch.clientX, touch.clientY);
      unhideGhostForTarget();
      if (toSortable && !toSortable.el.contains(target)) {
        dispatchSortableEvent("spill");
        this.onSpill({
          dragEl: dragEl2,
          putSortable: putSortable2
        });
      }
    };
    function Revert() {
    }
    Revert.prototype = {
      startIndex: null,
      dragStart: function dragStart(_ref2) {
        var oldDraggableIndex2 = _ref2.oldDraggableIndex;
        this.startIndex = oldDraggableIndex2;
      },
      onSpill: function onSpill(_ref3) {
        var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
        this.sortable.captureAnimationState();
        if (putSortable2) {
          putSortable2.captureAnimationState();
        }
        var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
        if (nextSibling) {
          this.sortable.el.insertBefore(dragEl2, nextSibling);
        } else {
          this.sortable.el.appendChild(dragEl2);
        }
        this.sortable.animateAll();
        if (putSortable2) {
          putSortable2.animateAll();
        }
      },
      drop
    };
    _extends(Revert, {
      pluginName: "revertOnSpill"
    });
    function Remove() {
    }
    Remove.prototype = {
      onSpill: function onSpill(_ref4) {
        var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
        var parentSortable = putSortable2 || this.sortable;
        parentSortable.captureAnimationState();
        dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
        parentSortable.animateAll();
      },
      drop
    };
    _extends(Remove, {
      pluginName: "removeOnSpill"
    });
    Sortable.mount(new AutoScrollPlugin());
    Sortable.mount(Remove, Revert);
    var base$k = function base2(props, context, dependencies2, options) {
      var {
        sort
      } = toRefs(props);
      var isDisabled = dependencies2.isDisabled;
      var fire = dependencies2.fire;
      var refreshOrderStore = dependencies2.refreshOrderStore;
      var value = dependencies2.value;
      var sorting = dependencies2.sorting;
      var length = dependencies2.length;
      var path = dependencies2.path;
      var children$Array = dependencies2.children$Array;
      var list2 = ref(null);
      var sortable = ref(null);
      var isSortable = computed(() => {
        return sort.value && !isDisabled.value && length.value && value.value[0] !== void 0;
      });
      var initSortable = () => {
        sortable.value = new Sortable(list2.value, {
          handle: "[data-handle]",
          onStart: (
            /* istanbul ignore next: can not imitate dragging */
            () => {
              sorting.value = true;
            }
          ),
          onEnd: handleSort
        });
      };
      var destroySortable = () => {
        var _sortable$value;
        (_sortable$value = sortable.value) === null || _sortable$value === void 0 || _sortable$value.destroy();
        sortable.value = null;
      };
      var handleSort = (_ref) => {
        var {
          oldIndex: oldIndex2,
          newIndex: newIndex2,
          item
        } = _ref;
        sorting.value = false;
        if (oldIndex2 === newIndex2 || isDisabled.value) {
          return;
        }
        list2.value.children[newIndex2].remove();
        list2.value.insertBefore(item, list2.value.children[oldIndex2]);
        var valueClone = cloneDeep_1(value.value);
        valueClone.splice(newIndex2, 0, valueClone.splice(oldIndex2, 1)[0]);
        value.value = valueClone;
        refreshOrderStore(value.value);
        fire("sort", value.value, oldIndex2, newIndex2, children$Array.value[newIndex2]);
      };
      watch(isSortable, (n2, o2) => {
        if (n2 === true && o2 === false) {
          initSortable();
        } else if (n2 === false && o2 === true) {
          destroySortable();
        }
      }, {
        immediate: false,
        flush: "post"
      });
      onMounted(() => {
        if (isSortable.value) {
          initSortable();
        }
      });
      watch(length, (n2) => {
        var _sortable$value2;
        if (!isSortable.value) {
          return;
        }
        destroySortable();
        initSortable();
        (_sortable$value2 = sortable.value) === null || _sortable$value2 === void 0 || _sortable$value2.sort(Array.from(Array(n2).keys()).reduce((a2, b2, i2) => {
          a2.push("".concat(path.value, "-").concat(i2));
          return a2;
        }, []));
      }, {
        flush: "post"
      });
      return {
        list: list2,
        sortable,
        isSortable,
        handleSort,
        initSortable,
        destroySortable
      };
    };
    var base$j = function base2(props, context, dependencies2) {
      var sorting = ref(false);
      return {
        sorting
      };
    };
    var base$i = function base2(props, context, dependencies2, options) {
      var {
        storeOrder,
        orderBy,
        order: order2
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var value = dependencies2.value;
      var orderFrom = ref(form$.value.$vueform.config.orderFrom);
      var refreshOrderStore = (value2) => {
        if (storeOrder.value) {
          each(value2, (val, index2) => {
            val[storeOrder.value] = order2.value && order2.value.toUpperCase() === "DESC" ? value2.length - index2 - (orderFrom.value == 0 ? 1 : 0) : parseInt(index2) + orderFrom.value;
          });
        }
        return value2;
      };
      var orderByName = computed(() => {
        return orderBy.value || storeOrder.value;
      });
      watch(storeOrder, (n2, o2) => {
        if (n2) {
          refreshOrderStore(value.value);
        } else {
          each(value.value, (val, index2) => {
            val[o2] = null;
          });
        }
      }, {
        immediate: false
      });
      return {
        refreshOrderStore,
        orderByName
      };
    };
    var multifile$2 = function multifile2(props, context, dependencies2, options) {
      var {
        storeOrder,
        orderBy
      } = toRefs(props);
      var {
        refreshOrderStore
      } = base$i(props, context, dependencies2);
      var orderByName = computed(() => {
        return orderBy.value || storeOrder.value;
      });
      return {
        refreshOrderStore,
        orderByName
      };
    };
    var base$h = function base2(props, context, dependencies2) {
      var {
        object: object2,
        element
      } = toRefs(props);
      var prototype2 = computed(() => {
        return isObject2.value ? Object.assign({}, object2.value, {
          type: "object"
        }) : element.value || {};
      });
      var isObject2 = computed(() => {
        return !!object2.value;
      });
      return {
        prototype: prototype2,
        isObject: isObject2
      };
    };
    var multifile$1 = function multifile2(props, context, dependencies2) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var {
        auto: auto2,
        object: object2,
        file: file2,
        fields,
        storeFile,
        storeOrder,
        view,
        clickable,
        url: url2,
        previewUrl,
        uploadTempEndpoint,
        removeTempEndpoint,
        removeEndpoint,
        params,
        softRemove
      } = toRefs(props);
      var isDisabled = dependencies2.isDisabled;
      var type = computed(() => {
        return options.type || "file";
      });
      var storeFileName = computed(() => {
        if (storeFile.value) {
          return storeFile.value;
        }
        return object2.value || keys_1(fields.value).length || storeOrder.value ? "file" : null;
      });
      var isObject2 = computed(() => {
        return !!object2.value || !!storeOrder.value || !!keys_1(fields.value).length;
      });
      var prototype2 = computed(() => {
        var fileSchema = {
          type: type.value,
          auto: auto2.value,
          view: view.value,
          layout: view.value === "gallery" ? "ElementLayoutInline" : "ElementLayout",
          disabled: isDisabled.value,
          clickable: clickable.value,
          url: url2.value,
          previewUrl: previewUrl.value,
          uploadTempEndpoint: uploadTempEndpoint.value,
          removeTempEndpoint: removeTempEndpoint.value,
          removeEndpoint: removeEndpoint.value,
          params: params.value,
          softRemove: softRemove.value
        };
        if (!isObject2.value) {
          return Object.assign({}, fileSchema, file2.value);
        }
        return {
          type: "object",
          schema: Object.assign(
            {},
            // File
            {
              [storeFileName.value]: Object.assign({}, fileSchema, {
                embed: true
              }, file2.value)
            },
            // Order
            storeOrder.value ? {
              [storeOrder.value]: {
                type: "hidden",
                meta: true
              }
            } : {},
            // Other fields
            fields.value
          )
        };
      });
      return {
        storeFileName,
        isObject: isObject2,
        prototype: prototype2
      };
    };
    var base$g = function base2(props, context, dependencies2) {
      var {
        controls,
        sort,
        min: min2,
        max: max2,
        addText
      } = toRefs(props);
      var isDisabled = dependencies2.isDisabled;
      var value = dependencies2.value;
      var form$ = dependencies2.form$;
      var hasAdd = computed(() => {
        return !isDisabled.value && (controls.value.add || controls.value.add === void 0) && (max2.value === -1 || max2.value > value.value.length);
      });
      var hasRemove = computed(() => {
        return !isDisabled.value && (controls.value.remove || controls.value.remove === void 0) && (min2.value === -1 || min2.value < value.value.length);
      });
      var hasSort = computed(() => {
        return !isDisabled.value && (controls.value.sort || controls.value.sort === void 0) && sort.value;
      });
      var addLabel = computed(() => {
        return addText.value || form$.value.translations.vueform.elements.list.add;
      });
      return {
        hasAdd,
        hasRemove,
        hasSort,
        addLabel
      };
    };
    var multifile = function multifile2(props, context, dependencies2) {
      var {
        controls,
        sort
      } = toRefs(props);
      var isDisabled = dependencies2.isDisabled;
      var hasUploading = dependencies2.hasUploading;
      var hasAdd = computed(() => {
        return controls.value.add || controls.value.add === void 0;
      });
      var hasRemove = computed(() => {
        return !isDisabled.value && (controls.value.remove || controls.value.remove === void 0) && !hasUploading.value;
      });
      var hasSort = computed(() => {
        return !isDisabled.value && (controls.value.sort || controls.value.sort === void 0) && sort.value && !hasUploading.value;
      });
      return {
        hasAdd,
        hasRemove,
        hasSort
      };
    };
    var ListElement = {
      name: "ListElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "add", "remove", "sort", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "list",
          private: true
        },
        default: {
          required: false,
          type: [Array],
          default: void 0
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        onAdd: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onRemove: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onSort: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        element: {
          required: false,
          type: [Object],
          default: null
        },
        object: {
          required: false,
          type: [Object],
          default: null
        },
        initial: {
          required: false,
          type: [Number],
          default: 1
        },
        min: {
          required: false,
          type: [Number],
          default: -1
        },
        max: {
          required: false,
          type: [Number],
          default: -1
        },
        addText: {
          required: false,
          type: [String],
          default: null,
          "@default": "locale.elements.list.add"
        },
        sort: {
          required: false,
          type: [Boolean],
          default: false
        },
        controls: {
          required: false,
          type: [Object],
          default: () => ({
            add: true,
            remove: true,
            sort: true
          })
        },
        storeOrder: {
          required: false,
          type: [String],
          default: null
        },
        order: {
          required: false,
          type: [String],
          default: null
        },
        orderBy: {
          required: false,
          type: [String],
          default: null
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$O, base$U, base$S, array$1, base$h, base$l, base$j, base$i, base$1c, list$4, base$C, base$$, base$J, base$12, list$5, list$1, list$3, base$g, array, base$_, base$Z, base$Y, base$1a, base$X, list, base$k, base$R, list$2, base$T];
        context.slots = ["label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$f = function base2(props, context, dependencies2) {
      var options_ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var {
        provider,
        extendOptions
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var value = dependencies2.value;
      var clear2 = dependencies2.clear;
      var input = dependencies2.input;
      var inputElement = () => {
        return options_.input ? options_.input.value : input.value;
      };
      var locationService = ref(null);
      var location2 = ref({});
      var locationProvider = computed(() => {
        return provider.value || form$.value.$vueform.config.locationProvider;
      });
      var defaultOptions = computed(() => {
        var providers = {
          google: {
            fields: ["geometry", "formatted_address", "address_components"]
          },
          algolia: {
            type: "address",
            appId: form$.value.$vueform.config.services.algolia.app_id,
            apiKey: form$.value.$vueform.config.services.algolia.api_key,
            templates: options_.templates || {}
          }
        };
        return providers[locationProvider.value];
      });
      var providerOptions = computed(() => {
        return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next: failsafe only */
        {});
      });
      var handleAddressChange = (data, raw) => {
        if (options_.handleAddressChange) {
          options_.handleAddressChange(data, raw);
          return;
        }
        location2.value = raw;
        value.value = data;
      };
      var handleLocationBlur = () => {
        if (inputElement().value.length) {
          inputElement().value = value.value.formatted_address;
        } else {
          clear2();
        }
      };
      var initLocationService = () => {
        if (locationService.value) {
          locationService.value.destroy();
        }
        locationService.value = new form$.value.$vueform.services.location[locationProvider.value]();
        locationService.value.init(inputElement(), handleAddressChange, providerOptions.value);
      };
      watch([locationProvider, providerOptions], () => {
        initLocationService();
      }, {
        deep: true,
        immediate: false
      });
      onMounted(() => {
        initLocationService();
      });
      return {
        locationService,
        location: location2,
        defaultOptions,
        providerOptions,
        handleAddressChange,
        handleLocationBlur,
        initLocationService
      };
    };
    var LocationElement = {
      name: "LocationElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "location",
          private: true
        },
        default: {
          required: false,
          type: [Object],
          default: () => ({
            country: null,
            country_code: null,
            state: null,
            state_code: null,
            city: null,
            zip: null,
            address: null,
            formatted_address: null,
            lat: null,
            lng: null
          })
        },
        debounce: {
          required: false,
          type: [Number],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        floating: {
          required: false,
          type: [String, Boolean, Object],
          localized: true,
          default: null
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        placeholder: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        readonly: {
          required: false,
          type: [Boolean],
          default: false
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        addons: {
          required: false,
          type: [Object],
          localized: true,
          default: () => ({})
        },
        provider: {
          required: false,
          type: [String],
          default: "google"
        },
        displayKey: {
          required: false,
          type: [String],
          default: "formatted_address"
        },
        extendOptions: {
          required: false,
          type: [Object],
          default: () => ({})
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, location$2, base$U, base$G, base$1c, base$P, base$w, base$C, base$L, location, base$14, base$I, base$B, base$f, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$s, base$R, location$1, base$T, base$t];
        context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
        return _objectSpread2$1({}, location$3(props, context));
      }
    };
    var base$e = function base2(props, context, dependencies2) {
      var isDisabled = dependencies2.isDisabled;
      var add2 = dependencies2.add;
      var input = dependencies2.input;
      var isObject2 = dependencies2.isObject;
      var storeFileName = dependencies2.storeFileName;
      var children$ = dependencies2.children$;
      var preparing = computed(() => {
        return some_1(children$.value, {
          available: true,
          preparing: true
        });
      });
      var hasUploading = computed(() => {
        return some_1(children$.value, {
          uploading: true
        });
      });
      var handleChange = (e2) => {
        if (!e2.target || !e2.target.files || e2.target.files.length == 0 || isDisabled.value) {
          return;
        }
        each(e2.target.files, (file2) => {
          add2(isObject2.value ? {
            [storeFileName.value]: file2
          } : file2);
        });
        input.value.value = "";
      };
      var handleClick = () => {
        if (isDisabled.value) {
          return;
        }
        input.value.click();
      };
      return {
        preparing,
        hasUploading,
        handleChange,
        handleClick
      };
    };
    var MultifileElement = {
      name: "MultifileElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "add", "remove", "sort", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "multifile",
          private: true
        },
        default: {
          required: false,
          type: [Array],
          default: () => []
        },
        initial: {
          required: false,
          type: [Number],
          default: 0,
          private: true
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        onAdd: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onRemove: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onSort: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        view: {
          type: [String],
          required: false,
          default: "file"
        },
        drop: {
          required: false,
          type: [Boolean],
          default: false
        },
        sort: {
          required: false,
          type: [Boolean],
          default: false
        },
        controls: {
          required: false,
          type: [Object],
          default: () => ({
            add: true,
            remove: true,
            sort: true
          })
        },
        object: {
          required: false,
          type: [Boolean],
          default: null
        },
        storeFile: {
          required: false,
          type: [String],
          default: "file"
        },
        fields: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        storeOrder: {
          required: false,
          type: [String],
          default: null
        },
        order: {
          required: false,
          type: [String],
          default: null
        },
        orderBy: {
          required: false,
          type: [String],
          default: null
        },
        file: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        accept: {
          required: false,
          type: [String, Array],
          default: null
        },
        clickable: {
          required: false,
          type: [Boolean],
          default: true
        },
        url: {
          required: false,
          type: [String, Boolean],
          default: "/"
        },
        previewUrl: {
          required: false,
          type: [String],
          default: void 0
        },
        auto: {
          required: false,
          type: [Boolean],
          default: true
        },
        uploadTempEndpoint: {
          required: false,
          type: [Object, String, Function, Boolean, Promise],
          default: void 0,
          "@default": "config.endpoints.uploadTempFile"
        },
        removeTempEndpoint: {
          required: false,
          type: [Object, String, Function, Boolean, Promise],
          default: void 0,
          "@default": "config.endpoints.removeTempFile"
        },
        removeEndpoint: {
          required: false,
          type: [Object, String, Function, Boolean, Promise],
          default: void 0,
          "@default": "config.endpoints.removeFile"
        },
        params: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        softRemove: {
          required: false,
          type: [Boolean],
          default: false
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$O, base$S, array$1, base$l, base$M, base$j, multifile$1, base$U, base$1c, list$4, base$C, base$$, base$J, list$1, base$L, array, base$12, base$14, base$_, base$Z, base$Y, base$X, multifile$2, multifile$4, base$e, multifile, multifile$3, base$1a, base$k, base$R, multifile$5, base$T];
        context.slots = ["label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$d = function base2(props, context, dependencies2) {
      var fire = dependencies2.fire;
      var el$ = dependencies2.el$;
      var handleSelect = (option) => {
        fire("select", option, el$.value);
      };
      var handleDeselect = (option) => {
        fire("deselect", option, el$.value);
      };
      var handleSearchChange = (searchQuery) => {
        fire("search-change", searchQuery, el$.value);
      };
      var handleOpen = () => {
        fire("open", el$.value);
      };
      var handleClose = () => {
        fire("close", el$.value);
      };
      var handleClear = () => {
        fire("clear", el$.value);
      };
      var handlePaste = (e2) => {
        fire("paste", e2, el$.value);
      };
      var handleTag = (searchQuery) => {
      };
      return {
        handleSelect,
        handleDeselect,
        handleSearchChange,
        handleOpen,
        handleClose,
        handleClear,
        handlePaste,
        handleTag
      };
    };
    function spliceMultiple(array2, indexes) {
      indexes.sort();
      for (var i2 = indexes.length - 1; i2 >= 0; i2--) {
        array2.splice(indexes[i2], 1);
      }
      return array2;
    }
    var base$c = function base2(props, context, dependencies2) {
      var value = dependencies2.value;
      var inValue = (option) => {
        return value.value.indexOf(option) !== -1;
      };
      var select2 = (options) => {
        if (!isArray_1(options)) {
          options = [options];
        }
        var val = clone_1(value.value);
        each(options, (option) => {
          if (inValue(normalize$1(option))) {
            return;
          }
          val.push(option);
        });
        value.value = val;
      };
      var deselect = (options) => {
        if (!isArray_1(options)) {
          options = [options];
        }
        var val = clone_1(value.value);
        var indexes = [];
        each(options, (option) => {
          var i2 = value.value.indexOf(option);
          if (i2 === -1 || indexes.indexOf(i2) !== -1) {
            return;
          }
          indexes.push(i2);
        });
        value.value = spliceMultiple(val, indexes);
      };
      return {
        select: select2,
        deselect
      };
    };
    var MultiselectElement = {
      name: "MultiselectElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "select", "deselect", "search-change", "open", "close", "clear", "paste", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "multiselect",
          private: true
        },
        default: {
          required: false,
          type: [Array],
          default: () => []
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        floating: {
          required: false,
          type: [String, Boolean, Object],
          localized: true,
          default: null
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        placeholder: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null,
          native: false
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        onSelect: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onDeselect: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onSearchChange: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onOpen: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onClose: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onClear: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onPaste: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        native: {
          required: false,
          type: [Boolean],
          default: true
        },
        items: {
          required: false,
          type: [Object, Array, Function, String],
          localized: true,
          default: () => ({})
        },
        labelProp: {
          type: [String],
          required: false,
          default: "label",
          native: false
        },
        valueProp: {
          type: [String],
          required: false,
          default: "value",
          native: false
        },
        dataKey: {
          type: [String],
          required: false,
          default: void 0
        },
        searchParam: {
          type: [String],
          required: false,
          default: "query"
        },
        search: {
          required: false,
          type: [Boolean],
          default: false,
          native: false
        },
        trackBy: {
          type: [String, Array],
          required: false,
          default: "label",
          native: false
        },
        strict: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        multipleLabel: {
          type: [Function],
          required: false,
          native: false
        },
        multipleLabelSingle: {
          type: [String],
          required: false,
          native: false,
          "@default": "locale.vueform.multiselect.multipleLabelOne"
        },
        multipleLabelMultiple: {
          type: [String],
          required: false,
          native: false,
          "@default": "locale.vueform.multiselect.multipleLabelMore"
        },
        create: {
          required: false,
          type: [Boolean],
          default: false,
          native: false
        },
        appendNewOption: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        addOptionOn: {
          type: [Array],
          required: false,
          default: () => ["enter"],
          native: false
        },
        allowAbsent: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        object: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        limit: {
          type: [Number],
          required: false,
          default: -1,
          native: false
        },
        max: {
          type: [Number],
          required: false,
          default: -1,
          native: false
        },
        groups: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        groupLabel: {
          type: [String],
          required: false,
          default: "label",
          native: false
        },
        groupOptions: {
          type: [String],
          required: false,
          default: "items",
          native: false
        },
        groupHideEmpty: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        groupSelect: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        openDirection: {
          type: [String],
          required: false,
          default: "bottom",
          native: false
        },
        appendToBody: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        appendTo: {
          type: [String],
          required: false,
          default: void 0,
          native: false
        },
        canClear: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        clearOnSelect: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        closeOnSelect: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        closeOnDeselect: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        clearOnRefetch: {
          type: [Boolean],
          required: false,
          default: true
        },
        delay: {
          type: [Number],
          required: false,
          default: -1,
          native: false
        },
        minChars: {
          type: [Number],
          required: false,
          default: 0,
          native: false
        },
        resolveOnLoad: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        filterResults: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        clearOnSearch: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        hideSelected: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        caret: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        loading: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        noOptionsText: {
          type: [String, Object],
          required: false,
          default: void 0,
          "@default": "locale.multiselect.noOptions",
          localized: true,
          native: false
        },
        noResultsText: {
          type: [String, Object],
          required: false,
          default: void 0,
          "@default": "locale.multiselect.noResults",
          localized: true,
          native: false
        },
        autocomplete: {
          type: [String],
          required: false,
          native: false
        },
        inputType: {
          type: [String],
          required: false,
          default: "text",
          native: false
        },
        extendOptions: {
          required: false,
          type: [Object],
          default: () => ({})
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, multiselect$4, base$O, base$S, array$1, base$U, base$G, base$1c, multiselect$5, base$C, base$D, base$H, multiselect$1, base$L, multiselect$2, base$14, array, multiselect$3, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$d, base$c, multiselect, base$R, base$F, base$T, base$t];
        context.slots = ["option", "multiple-label", "placeholder", "group-label", "before-list", "after-list", "no-results", "no-options", "caret", "spinner", "clear", "label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var ObjectElement = {
      name: "ObjectElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "remove", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "object",
          private: true
        },
        default: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        schema: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        embed: {
          required: false,
          type: [Boolean],
          default: false
        },
        onRemove: {
          required: false,
          type: [Function],
          default: null,
          private: true
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$O, base$U, object$5, base$1c, object$7, object$2, object$6, base$$, object, base$12, object$8, object$3, base$Z, base$Y, base$1a, base$_, base$X, object$1, base$R, object$4, base$T];
        context.slots = ["label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$b = function base2(props, context, dependencies2) {
      var fire = dependencies2.fire;
      var el$ = dependencies2.el$;
      var handleBlur = () => {
        fire("blur", el$.value);
      };
      var handleFocus = () => {
        fire("focus", el$.value);
      };
      return {
        handleBlur,
        handleFocus
      };
    };
    const us = "{+}0 (000) 000-0000";
    var countryPhones = [
      {
        // "country": "Afghanistan",
        "c": "AF",
        "n": "+93",
        "p": 0,
        "m": [
          ["93", "{+}00 00 000 0000"]
        ]
      },
      {
        // "country": "Albania",
        "c": "AL",
        "n": "+355",
        "p": 1,
        "m": [
          ["3554", "{+}000 0 000 0000"],
          ["355", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Algeria",
        "c": "DZ",
        "n": "+213",
        "p": 2,
        "m": [
          ["2131", "{+}000 0 000 0000"],
          ["2132", "{+}000 0 000 0000"],
          ["2133", "{+}000 0 000 0000"],
          ["2134", "{+}000 0 000 0000"],
          ["213", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "American Samoa",
        "c": "AS",
        "n": "+1",
        "p": 3,
        "m": [
          ["1684", us]
        ]
      },
      {
        // "country": "Andorra",
        "c": "AD",
        "n": "+376",
        "p": 4,
        "m": [
          ["376", "{+}000 000 000"]
        ]
      },
      {
        // "country": "Angola",
        "c": "AO",
        "n": "+244",
        "p": 5,
        "m": [
          ["2449", "{+}000 000 000 0000"],
          ["244", "{+}000 000 000 000"]
        ]
      },
      {
        // "country": "Anguilla",
        "c": "AI",
        "n": "+1",
        "p": 6,
        "m": [
          ["1264", us]
        ]
      },
      {
        // "country": "Antigua & Barbuda",
        "c": "AG",
        "n": "+1",
        "p": 7,
        "m": [
          ["1268", us]
        ]
      },
      {
        // "country": "Argentina",
        "c": "AR",
        "n": "+54",
        "p": 8,
        "m": [
          ["549", "{+}00 0 000 000 0000"],
          ["54", "{+}00 000 000 0000"]
        ]
      },
      {
        // "country": "Armenia",
        "c": "AM",
        "n": "+374",
        "p": 9,
        "m": [
          ["37493", "{+}000 00 000 000"],
          ["37494", "{+}000 00 000 000"],
          ["37498", "{+}000 00 000 000"],
          ["37477", "{+}000 00 000 000"],
          ["37491", "{+}000 00 000 000"],
          ["37496", "{+}000 00 000 000"],
          ["37499", "{+}000 00 000 000"],
          ["37455", "{+}000 00 000 000"],
          ["37495", "{+}000 00 000 000"],
          ["37441", "{+}000 00 000 000"],
          ["374", "{+}000 000 000 000"]
        ]
      },
      {
        // "country": "Aruba",
        "c": "AW",
        "n": "+297",
        "p": 10,
        "m": [
          ["297", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Ascension Island",
        "c": "AC",
        "n": "+247",
        "p": 11,
        "m": [
          ["247", "{+}000 0000"]
        ]
      },
      {
        // "country": "Australia",
        "c": "AU",
        "n": "+61",
        "p": 12,
        "m": [
          ["61", "{+}00 0 0000 0000"],
          ["614", "{+}00 000 000 000"]
        ]
      },
      {
        // "country": "Austria",
        "c": "AT",
        "n": "+43",
        "p": 13,
        "m": [
          ["43", "{+}00 0000000[0000]"]
        ]
      },
      {
        // "country": "Azerbaijan",
        "c": "AZ",
        "n": "+994",
        "p": 14,
        "m": [
          ["9944", "{+}000 00 000 000"],
          ["9945", "{+}000 00 000 000"],
          ["9946", "{+}000 00 000 000"],
          ["9947", "{+}000 00 000 000"],
          ["994", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Bahamas",
        "c": "BS",
        "n": "+1",
        "p": 15,
        "m": [
          ["1242", us]
        ]
      },
      {
        // "country": "Bahrain",
        "c": "BH",
        "n": "+973",
        "p": 16,
        "m": [
          ["973", "{+}000 0000 0000"]
        ]
      },
      {
        // "country": "Bangladesh",
        "c": "BD",
        "n": "+880",
        "p": 17,
        "m": [
          ["8801", "{+}000 00 0000 0000"],
          ["880", "{+}000 00 0000 0000[00]"]
        ]
      },
      {
        // "country": "Barbados",
        "c": "BB",
        "n": "+1",
        "p": 18,
        "m": [
          ["1246", us]
        ]
      },
      {
        // "country": "Belarus",
        "c": "BY",
        "n": "+375",
        "p": 19,
        "m": [
          ["375", "{+}000 000000000[0]"]
        ]
      },
      {
        // "country": "Belgium",
        "c": "BE",
        "n": "+32",
        "p": 20,
        "m": [
          ["324", "{+}00 000 00 00 00"],
          ["32", "{+}00 0 000 00 00"]
        ]
      },
      {
        // "country": "Belize",
        "c": "BZ",
        "n": "+501",
        "p": 21,
        "m": [
          ["501", "{+}000 000-0000"]
        ]
      },
      {
        // "country": "Benin",
        "c": "BJ",
        "n": "+229",
        "p": 22,
        "m": [
          ["229", "{+}000 00 00 00 00"]
        ]
      },
      {
        // "country": "Bermuda",
        "c": "BM",
        "n": "+1",
        "p": 23,
        "m": [
          ["1441", us]
        ]
      },
      {
        // "country": "Bhutan",
        "c": "BT",
        "n": "+975",
        "p": 24,
        "m": [
          ["97517", "{+}000 00 000000"],
          ["975", "{+}000 0 00000[0]"]
        ]
      },
      {
        // "country": "Bolivia",
        "c": "BO",
        "n": "+591",
        "p": 25,
        "m": [
          ["5916", "{+}000 000 000 0000"],
          ["5917", "{+}000 000 000 0000"],
          ["591", "{+}000 0 000 0000[0]"]
        ]
      },
      {
        // "country": "Bosnia & Herzegovina",
        "c": "BA",
        "n": "+387",
        "p": 26,
        "m": [
          ["3876", "{+}000 00 000 000"],
          ["387", "{+}000 00 000 000[0]"]
        ]
      },
      {
        // "country": "Botswana",
        "c": "BW",
        "n": "+267",
        "p": 27,
        "m": [
          ["2677", "{+}000 00 000 0000"],
          ["267", "{+}000 000 000000"]
        ]
      },
      {
        // "country": "Brazil",
        "c": "BR",
        "n": "+55",
        "p": 28,
        "m": [
          ["55", "{+}00 00 0000 0000[0]"]
        ]
      },
      {
        // "country": "British Indian Ocean Territory",
        "c": "IO",
        "n": "+246",
        "p": 29,
        "m": [
          ["246", "{+}000 0000"]
        ]
      },
      {
        // "country": "British Virgin Islands",
        "c": "VG",
        "n": "+1",
        "p": 30,
        "m": [
          ["1284", us]
        ]
      },
      {
        // "country": "Brunei",
        "c": "BN",
        "n": "+673",
        "p": 31,
        "m": [
          ["673", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Bulgaria",
        "c": "BG",
        "n": "+359",
        "p": 32,
        "m": [
          ["3598", "{+}000 00 000 0000"],
          ["3599", "{+}000 00 000 0000"],
          ["359", "{+}000 0000000[000]"]
        ]
      },
      {
        // "country": "Burkina Faso",
        "c": "BF",
        "n": "+226",
        "p": 33,
        "m": [
          ["226", "{+}000 00 00 00 00"]
        ]
      },
      {
        // "country": "Burundi",
        "c": "BI",
        "n": "+257",
        "p": 34,
        "m": [
          ["257", "{+}000 00 00 00 00"]
        ]
      },
      {
        // "country": "Cambodia",
        "c": "KH",
        "n": "+855",
        "p": 35,
        "m": [
          ["855", "{+}000 000000000"]
        ]
      },
      {
        // "country": "Cameroon",
        "c": "CM",
        "n": "+237",
        "p": 36,
        "m": [
          ["237", "{+}000 0000 0000"]
        ]
      },
      {
        // "country": "Canada",
        "c": "CA",
        "n": "+1",
        "p": 37,
        "m": [
          ["1204", us],
          ["1226", us],
          ["1236", us],
          ["1249", us],
          ["1250", us],
          ["1263", us],
          ["1289", us],
          ["1306", us],
          ["1343", us],
          ["1354", us],
          ["1365", us],
          ["1367", us],
          ["1368", us],
          ["1403", us],
          ["1416", us],
          ["1418", us],
          ["1431", us],
          ["1437", us],
          ["1438", us],
          ["1450", us],
          ["1468", us],
          ["1474", us],
          ["1506", us],
          ["1514", us],
          ["1519", us],
          ["1548", us],
          ["1579", us],
          ["1581", us],
          ["1584", us],
          ["1587", us],
          ["1604", us],
          ["1613", us],
          ["1639", us],
          ["1647", us],
          ["1672", us],
          ["1683", us],
          ["1705", us],
          ["1709", us],
          ["1742", us],
          ["1753", us],
          ["1778", us],
          ["1780", us],
          ["1782", us],
          ["1807", us],
          ["1819", us],
          ["1825", us],
          ["1867", us],
          ["1873", us],
          ["1902", us],
          ["1905", us]
        ]
      },
      {
        // "country": "Cape Verde",
        "c": "CV",
        "n": "+238",
        "p": 38,
        "m": [
          ["238", "{+}000 0000 000"]
        ]
      },
      {
        // "country": "Caribbean Netherlands",
        "c": "BQ",
        "n": "+599",
        "p": 39,
        "m": [
          ["599", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Cayman Islands",
        "c": "KY",
        "n": "+1",
        "p": 40,
        "m": [
          ["1345", us]
        ]
      },
      {
        // "country": "Central African Republic",
        "c": "CF",
        "n": "+236",
        "p": 41,
        "m": [
          ["236", "{+}000 00 00 00 00"]
        ]
      },
      {
        // "country": "Chad",
        "c": "TD",
        "n": "+235",
        "p": 42,
        "m": [
          ["235", "{+}000 00 00 00 00"]
        ]
      },
      {
        // "country": "Chile",
        "c": "CL",
        "n": "+56",
        "p": 43,
        "m": [
          ["562", "{+}00 0 0000 0000"],
          ["569", "{+}00 0 0000 0000"],
          ["56", "{+}00 00 0000 000[0]"]
        ]
      },
      {
        // "country": "China",
        "c": "CN",
        "n": "+86",
        "p": 44,
        "m": [
          ["8613", "{+}00 000 0000 0000"],
          ["8615", "{+}00 000 0000 0000"],
          ["8618", "{+}00 000 0000 0000"],
          ["86", "{+}00 00 0000 0000"]
        ]
      },
      {
        // "country": "Colombia",
        "c": "CO",
        "n": "+57",
        "p": 45,
        "m": [
          ["573", "{+}00 000 000 0000"],
          ["57", "{+}00 0 000 0000"]
        ]
      },
      {
        // "country": "Comoros",
        "c": "KM",
        "n": "+269",
        "p": 46,
        "m": [
          ["269", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Congo - Brazzaville",
        "c": "CG",
        "n": "+242",
        "p": 47,
        "m": [
          ["242", "{+}000 00 000 000[0]"]
        ]
      },
      {
        // "country": "Congo - Kinshasa",
        "c": "CD",
        "n": "+243",
        "p": 48,
        "m": [
          ["243", "{+}000 00 000 000[0]"]
        ]
      },
      {
        // "country": "Cook Islands",
        "c": "CK",
        "n": "+682",
        "p": 49,
        "m": [
          ["682", "{+}000 00 000"]
        ]
      },
      {
        // "country": "Costa Rica",
        "c": "CR",
        "n": "+506",
        "p": 50,
        "m": [
          ["506", "{+}000 0000 0000"]
        ]
      },
      {
        // "country": "Côte d’Ivoire",
        "c": "CI",
        "n": "+225",
        "p": 51,
        "m": [
          ["225", "{+}000 00 00 00 00"]
        ]
      },
      {
        // "country": "Croatia",
        "c": "HR",
        "n": "+385",
        "p": 52,
        "m": [
          ["385", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Cuba",
        "c": "CU",
        "n": "+53",
        "p": 53,
        "m": [
          ["535", "{+}00 0 000 0000"],
          ["53", "{+}00 000000[0000]"]
        ]
      },
      {
        // "country": "Curaçao",
        "c": "CW",
        "n": "+599",
        "p": 54,
        "m": [
          ["5999", "{+}000 0 000 0000"]
        ]
      },
      {
        // "country": "Cyprus",
        "c": "CY",
        "n": "+357",
        "p": 55,
        "m": [
          ["357", "{+}000 00 000 000"]
        ]
      },
      {
        // "country": "Czechia",
        "c": "CZ",
        "n": "+420",
        "p": 56,
        "m": [
          ["4206", "{+}000 000 000 000"],
          ["4207", "{+}000 000 000 000"],
          ["420", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Denmark",
        "c": "DK",
        "n": "+45",
        "p": 57,
        "m": [
          ["45", "{+}00 00 00 00 00"]
        ]
      },
      {
        // "country": "Djibouti",
        "c": "DJ",
        "n": "+253",
        "p": 58,
        "m": [
          ["253", "{+}000 00 00 00 00"]
        ]
      },
      {
        // "country": "Dominica",
        "c": "DM",
        "n": "+1",
        "p": 59,
        "m": [
          ["1767", us]
        ]
      },
      {
        // "country": "Dominican Republic",
        "c": "DO",
        "n": "+1",
        "p": 60,
        "m": [
          ["1809", us],
          ["1829", us],
          ["1849", us]
        ]
      },
      {
        // "country": "Ecuador",
        "c": "EC",
        "n": "+593",
        "p": 61,
        "m": [
          ["593", "{+}000 00 0000 000"]
        ]
      },
      {
        // "country": "Egypt",
        "c": "EG",
        "n": "+20",
        "p": 62,
        "m": [
          ["2010", "{+}00 000 0000 000"],
          ["2011", "{+}00 000 0000 000"],
          ["2012", "{+}00 000 0000 000"],
          ["2014", "{+}00 000 0000 000"],
          ["2016", "{+}00 000 0000 000"],
          ["202", "{+}00 0 0000 0000"],
          ["203", "{+}00 0 0000 0000"],
          ["20", "{+}00 000 0000 000"]
        ]
      },
      {
        // "country": "El Salvador",
        "c": "SV",
        "n": "+503",
        "p": 63,
        "m": [
          ["503", "{+}000 0000 0000"]
        ]
      },
      {
        // "country": "Equatorial Guinea",
        "c": "GQ",
        "n": "+240",
        "p": 64,
        "m": [
          ["240", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Eritrea",
        "c": "ER",
        "n": "+291",
        "p": 65,
        "m": [
          ["291", "{+}000 0 000 000"]
        ]
      },
      {
        // "country": "Estonia",
        "c": "EE",
        "n": "+372",
        "p": 66,
        "m": [
          ["372", "{+}000 0000 000[0]"]
        ]
      },
      {
        // "country": "Eswatini",
        "c": "SZ",
        "n": "+268",
        "p": 67,
        "m": [
          ["268", "{+}000 00 00 0000"]
        ]
      },
      {
        // "country": "Ethiopia",
        "c": "ET",
        "n": "+251",
        "p": 68,
        "m": [
          ["2519", "{+}000 000 000 000"],
          ["251", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Falkland Islands (Islas Malvinas)",
        "c": "FK",
        "n": "+500",
        "p": 69,
        "m": [
          ["500", "{+}000 00000"]
        ]
      },
      {
        // "country": "Faroe Islands",
        "c": "FO",
        "n": "+298",
        "p": 70,
        "m": [
          ["298", "{+}000 000 000"]
        ]
      },
      {
        // "country": "Fiji",
        "c": "FJ",
        "n": "+679",
        "p": 71,
        "m": [
          ["679", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Finland",
        "c": "FI",
        "n": "+358",
        "p": 72,
        "m": [
          ["358", "{+}000 0000[0000000]"]
        ]
      },
      {
        // "country": "France",
        "c": "FR",
        "n": "+33",
        "p": 73,
        "m": [
          ["33", "{+}00 000 000 000"]
        ]
      },
      {
        // "country": "French Guiana",
        "c": "GF",
        "n": "+594",
        "p": 74,
        "m": [
          ["594", "{+}000 000 00 00 00"]
        ]
      },
      {
        // "country": "French Polynesia",
        "c": "PF",
        "n": "+689",
        "p": 75,
        "m": [
          ["689", "{+}000 00 00 00 00"]
        ]
      },
      {
        // "country": "Gabon",
        "c": "GA",
        "n": "+241",
        "p": 76,
        "m": [
          ["24106", "{+}000 000 00 00 00"],
          ["24107", "{+}000 000 00 00 00"],
          ["241", "{+}000 00 00 00 00"]
        ]
      },
      {
        // "country": "Gambia",
        "c": "GM",
        "n": "+220",
        "p": 77,
        "m": [
          ["220", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Georgia",
        "c": "GE",
        "n": "+995",
        "p": 78,
        "m": [
          ["99532", "{+}000 00 000 0000"],
          ["995", "{+}000 000 000 000[0]"]
        ]
      },
      {
        // "country": "Germany",
        "c": "DE",
        "n": "+49",
        "p": 79,
        "m": [
          ["4930", "{+}00 00 0000 0000"],
          ["4989", "{+}00 00 0000 0000"],
          ["49", "{+}00 000 0000 000[0]"]
        ]
      },
      {
        // "country": "Ghana",
        "c": "GH",
        "n": "+233",
        "p": 80,
        "m": [
          ["233", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Gibraltar",
        "c": "GI",
        "n": "+350",
        "p": 81,
        "m": [
          ["350", "{+}000 0000 0000"]
        ]
      },
      {
        // "country": "Greece",
        "c": "GR",
        "n": "+30",
        "p": 82,
        "m": [
          ["3069", "{+}00 000 0000 000"],
          ["30", "{+}00 000 0000 000[0]"]
        ]
      },
      {
        // "country": "Greenland",
        "c": "GL",
        "n": "+299",
        "p": 83,
        "m": [
          ["299", "{+}000 00 00 00"]
        ]
      },
      {
        // "country": "Grenada",
        "c": "GD",
        "n": "+1",
        "p": 84,
        "m": [
          ["1473", us]
        ]
      },
      {
        // "country": "Guadeloupe",
        "c": "GP",
        "n": "+590",
        "p": 85,
        "m": [
          ["590", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Guam",
        "c": "GU",
        "n": "+1",
        "p": 86,
        "m": [
          ["1671", us]
        ]
      },
      {
        // "country": "Guatemala",
        "c": "GT",
        "n": "+502",
        "p": 87,
        "m": [
          ["502", "{+}000 000 00000"]
        ]
      },
      {
        // "country": "Guinea",
        "c": "GN",
        "n": "+224",
        "p": 88,
        "m": [
          ["224", "{+}000 0000 000[0]"]
        ]
      },
      {
        // "country": "Guinea-Bissau",
        "c": "GW",
        "n": "+245",
        "p": 89,
        "m": [
          ["245", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Guyana",
        "c": "GY",
        "n": "+592",
        "p": 90,
        "m": [
          ["592", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Haiti",
        "c": "HT",
        "n": "+509",
        "p": 91,
        "m": [
          ["509", "{+}000 00 00 0000"]
        ]
      },
      {
        // "country": "Honduras",
        "c": "HN",
        "n": "+504",
        "p": 92,
        "m": [
          ["504", "{+}000 0000 0000"]
        ]
      },
      {
        // "country": "Hong Kong",
        "c": "HK",
        "n": "+852",
        "p": 93,
        "m": [
          ["852", "{+}000 0000 0000"]
        ]
      },
      {
        // "country": "Hungary",
        "c": "HU",
        "n": "+36",
        "p": 94,
        "m": [
          ["361", "{+}00 0 000 0000"],
          ["3620", "{+}00 00 000 0000"],
          ["3630", "{+}00 00 000 0000"],
          ["3670", "{+}00 00 000 0000"],
          ["36", "{+}00 00 000 000[0]"]
        ]
      },
      {
        // "country": "Iceland",
        "c": "IS",
        "n": "+354",
        "p": 95,
        "m": [
          ["354", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "India",
        "c": "IN",
        "n": "+91",
        "p": 96,
        "m": [
          ["916", "{+}00 000 000 0000"],
          ["917", "{+}00 000 000 0000"],
          ["918", "{+}00 000 000 0000"],
          ["919", "{+}00 000 000 0000"],
          ["91", "{+}00 00 0000 0000"]
        ]
      },
      {
        // "country": "Indonesia",
        "c": "ID",
        "n": "+62",
        "p": 97,
        "m": [
          ["62361", "{+}00 000 000 000"],
          ["6221", "{+}00 00 0000 0000"],
          ["628", "{+}00 000 0000 0000"],
          ["62", "{+}00 00000[000000]"]
        ]
      },
      {
        // "country": "Iran",
        "c": "IR",
        "n": "+98",
        "p": 98,
        "m": [
          ["98921", "{+}00 00 000 0000"],
          ["98951", "{+}00 00 000 0000"],
          ["989", "{+}00 000 000 0000"],
          ["98", "{+}00 00000000[00]"]
        ]
      },
      {
        // "country": "Iraq",
        "c": "IQ",
        "n": "+964",
        "p": 99,
        "m": [
          ["9641", "{+}000 0 000 0000[0]"],
          ["9647", "{+}000 000 000 0000"],
          ["964", "{+}000 000000[0000]"]
        ]
      },
      {
        // "country": "Ireland",
        "c": "IE",
        "n": "+353",
        "p": 100,
        "m": [
          ["3531", "{+}000 0 000 0000"],
          ["353", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Israel",
        "c": "IL",
        "n": "+972",
        "p": 101,
        "m": [
          ["9725", "{+}000 00 000 0000"],
          ["9727", "{+}000 00 000 0000"],
          ["972", "{+}000 0 000 0000"]
        ]
      },
      {
        // "country": "Italy",
        "c": "IT",
        "n": "+39",
        "p": 102,
        "m": [
          ["393", "{+}00 000 000 0000"],
          ["39", "{+}00 00 0000 0000"]
        ]
      },
      {
        // "country": "Jamaica",
        "c": "JM",
        "n": "+1",
        "p": 103,
        "m": [
          ["1876", us]
        ]
      },
      {
        // "country": "Japan",
        "c": "JP",
        "n": "+81",
        "p": 104,
        "m": [
          ["8170", "{+}00 00 0000 0000"],
          ["8180", "{+}00 00 0000 0000"],
          ["8190", "{+}00 00 0000 0000"],
          ["81", "{+}00 0 0000 0000"]
        ]
      },
      {
        // "country": "Jordan",
        "c": "JO",
        "n": "+962",
        "p": 105,
        "m": [
          ["9627", "{+}000 000 000 000"],
          ["962", "{+}000 0 000 0000"]
        ]
      },
      {
        // "country": "Kazakhstan",
        "c": "KZ",
        "n": "+7",
        "p": 106,
        "m": [
          ["77", "{+}0 000 000 0000"]
        ]
      },
      {
        // "country": "Kenya",
        "c": "KE",
        "n": "+254",
        "p": 107,
        "m": [
          ["2541", "{+}000 000 000 000"],
          ["2547", "{+}000 000 000 000"],
          ["254", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Kiribati",
        "c": "KI",
        "n": "+686",
        "p": 108,
        "m": [
          ["686", "{+}000 00 000"]
        ]
      },
      {
        // "country": "Kosovo",
        "c": "XK",
        "n": "+383",
        "p": 109,
        "m": [
          ["383", "{+}000 00 000 000"]
        ]
      },
      {
        // "country": "Kuwait",
        "c": "KW",
        "n": "+965",
        "p": 110,
        "m": [
          ["9655", "{+}000 000 00000"],
          ["9656", "{+}000 000 00000"],
          ["9659", "{+}000 000 00000"],
          ["965", "{+}000 0000 0000"]
        ]
      },
      {
        // "country": "Kyrgyzstan",
        "c": "KG",
        "n": "+996",
        "p": 111,
        "m": [
          ["996", "{+}000 000 000 000"]
        ]
      },
      {
        // "country": "Laos",
        "c": "LA",
        "n": "+856",
        "p": 112,
        "m": [
          ["85620", "{+}000 00 0000 0000"],
          ["85630", "{+}000 00 0000 0000"],
          ["856", "{+}000 00 000 000"]
        ]
      },
      {
        // "country": "Latvia",
        "c": "LV",
        "n": "+371",
        "p": 113,
        "m": [
          ["3715", "{+}000 0 00 00000"],
          ["3716", "{+}000 0 00 00000"],
          ["3717", "{+}000 0 00 00000"],
          ["371", "{+}000 000 00 000"]
        ]
      },
      {
        // "country": "Lebanon",
        "c": "LB",
        "n": "+961",
        "p": 114,
        "m": [
          ["96170", "{+}000 00 000 000"],
          ["96171", "{+}000 00 000 000"],
          ["96180", "{+}000 00 000 000"],
          ["96181", "{+}000 00 000 000"],
          ["96190", "{+}000 00 000 000"],
          ["96191", "{+}000 00 000 000"],
          ["961", "{+}000 0 000 000[0]"]
        ]
      },
      {
        // "country": "Lesotho",
        "c": "LS",
        "n": "+266",
        "p": 115,
        "m": [
          ["266", "{+}000 000 000 000"]
        ]
      },
      {
        // "country": "Liberia",
        "c": "LR",
        "n": "+231",
        "p": 116,
        "m": [
          ["231", "{+}000 000000[0000]"]
        ]
      },
      {
        // "country": "Libya",
        "c": "LY",
        "n": "+218",
        "p": 117,
        "m": [
          ["218", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Liechtenstein",
        "c": "LI",
        "n": "+423",
        "p": 118,
        "m": [
          ["42323", "{+}000 00 00000"],
          ["42375", "{+}000 00 00000"],
          ["423", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Lithuania",
        "c": "LT",
        "n": "+370",
        "p": 119,
        "m": [
          ["370", "{+}000 000 000 000"]
        ]
      },
      {
        // "country": "Luxembourg",
        "c": "LU",
        "n": "+352",
        "p": 120,
        "m": [
          ["352", "{+}000 000 000 000"]
        ]
      },
      {
        // "country": "Macao",
        "c": "MO",
        "n": "+853",
        "p": 121,
        "m": [
          ["8536", "{+}000 000 0000[0]"],
          ["853", "{+}000 0000 000[0]"]
        ]
      },
      {
        // "country": "Madagascar",
        "c": "MG",
        "n": "+261",
        "p": 122,
        "m": [
          ["261", "{+}000 00 00 00000"]
        ]
      },
      {
        // "country": "Malawi",
        "c": "MW",
        "n": "+265",
        "p": 123,
        "m": [
          ["265", "{+}000 000 000 000"]
        ]
      },
      {
        // "country": "Malaysia",
        "c": "MY",
        "n": "+60",
        "p": 124,
        "m": [
          ["60", "{+}00 0000000[000]"]
        ]
      },
      {
        // "country": "Maldives",
        "c": "MV",
        "n": "+960",
        "p": 125,
        "m": [
          ["960", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Mali",
        "c": "ML",
        "n": "+223",
        "p": 126,
        "m": [
          ["223", "{+}000 00 00 0000"]
        ]
      },
      {
        // "country": "Malta",
        "c": "MT",
        "n": "+356",
        "p": 127,
        "m": [
          ["356", "{+}000 0000 000[0]"]
        ]
      },
      {
        // "country": "Marshall Islands",
        "c": "MH",
        "n": "+692",
        "p": 128,
        "m": [
          ["692", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Martinique",
        "c": "MQ",
        "n": "+596",
        "p": 129,
        "m": [
          ["596", "{+}000 000 000 000"]
        ]
      },
      {
        // "country": "Mauritania",
        "c": "MR",
        "n": "+222",
        "p": 130,
        "m": [
          ["222", "{+}000 00 000 000"]
        ]
      },
      {
        // "country": "Mauritius",
        "c": "MU",
        "n": "+230",
        "p": 131,
        "m": [
          ["230", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Mexico",
        "c": "MX",
        "n": "+52",
        "p": 132,
        "m": [
          ["52", "{+}00 000 000 0000"]
        ]
      },
      {
        // "country": "Micronesia",
        "c": "FM",
        "n": "+691",
        "p": 133,
        "m": [
          ["691", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Moldova",
        "c": "MD",
        "n": "+373",
        "p": 134,
        "m": [
          ["373", "{+}000 000 00 000"]
        ]
      },
      {
        // "country": "Monaco",
        "c": "MC",
        "n": "+377",
        "p": 135,
        "m": [
          ["377", "{+}000 00 00 00 00"]
        ]
      },
      {
        // "country": "Mongolia",
        "c": "MN",
        "n": "+976",
        "p": 136,
        "m": [
          ["976", "{+}000 00 00 0000"]
        ]
      },
      {
        // "country": "Montenegro",
        "c": "ME",
        "n": "+382",
        "p": 137,
        "m": [
          ["382", "{+}000 00 000 000"]
        ]
      },
      {
        // "country": "Montserrat",
        "c": "MS",
        "n": "+1",
        "p": 138,
        "m": [
          ["1664", us]
        ]
      },
      {
        // "country": "Morocco",
        "c": "MA",
        "n": "+212",
        "p": 139,
        "m": [
          ["212", "{+}000 00 000 0000[0]"]
        ]
      },
      {
        // "country": "Mozambique",
        "c": "MZ",
        "n": "+258",
        "p": 140,
        "m": [
          ["258", "{+}000 00 000 000"]
        ]
      },
      {
        // "country": "Myanmar (Burma)",
        "c": "MM",
        "n": "+95",
        "p": 141,
        "m": [
          ["95", "{+}00 0000000[0000]"]
        ]
      },
      {
        // "country": "Namibia",
        "c": "NA",
        "n": "+264",
        "p": 142,
        "m": [
          ["264", "{+}000 000000[000000]"]
        ]
      },
      {
        // "country": "Nauru",
        "c": "NR",
        "n": "+674",
        "p": 143,
        "m": [
          ["674", "{+}000 000000[000000]"]
        ]
      },
      {
        // "country": "Nepal",
        "c": "NP",
        "n": "+977",
        "p": 144,
        "m": [
          ["977", "{+}000 000000[000000]"]
        ]
      },
      {
        // "country": "Netherlands",
        "c": "NL",
        "n": "+31",
        "p": 145,
        "m": [
          ["31", "{+}00 00 000 0000"]
        ]
      },
      {
        // "country": "New Caledonia",
        "c": "NC",
        "n": "+687",
        "p": 146,
        "m": [
          ["687", "{+}000 000000[000000]"]
        ]
      },
      {
        // "country": "New Zealand",
        "c": "NZ",
        "n": "+64",
        "p": 147,
        "m": [
          ["642", "{+}00 000 000 000"],
          ["64", "{+}00 0 000 0000"]
        ]
      },
      {
        // "country": "Nicaragua",
        "c": "NI",
        "n": "+505",
        "p": 148,
        "m": [
          ["505", "{+}000 000000[000000]"]
        ]
      },
      {
        // "country": "Niger",
        "c": "NE",
        "n": "+227",
        "p": 149,
        "m": [
          ["227", "{+}000 00000000[000]"]
        ]
      },
      {
        // "country": "Nigeria",
        "c": "NG",
        "n": "+234",
        "p": 150,
        "m": [
          ["234", "{+}000 000000[000000]"]
        ]
      },
      {
        // "country": "Niue",
        "c": "NU",
        "n": "+683",
        "p": 151,
        "m": [
          ["683", "{+}000 000000[000000]"]
        ]
      },
      {
        // "country": "Norfolk Island",
        "c": "NF",
        "n": "+672",
        "p": 152,
        "m": [
          ["672", "{+}000 000000[000000]"]
        ]
      },
      {
        // "country": "North Korea",
        "c": "KP",
        "n": "+850",
        "p": 153,
        "m": [
          ["850", "{+}000 000000[0000000]"]
        ]
      },
      {
        // "country": "North Macedonia",
        "c": "MK",
        "n": "+389",
        "p": 154,
        "m": [
          ["389", "{+}000 00 000 000"]
        ]
      },
      {
        // "country": "Northern Mariana Islands",
        "c": "MP",
        "n": "+1",
        "p": 155,
        "m": [
          ["1670", us]
        ]
      },
      {
        // "country": "Norway",
        "c": "NO",
        "n": "+47",
        "p": 156,
        "m": [
          ["47", "{+}00 00 00 00 00"]
        ]
      },
      {
        // "country": "Oman",
        "c": "OM",
        "n": "+968",
        "p": 157,
        "m": [
          ["968", "{+}000 0000 0000"]
        ]
      },
      {
        // "country": "Pakistan",
        "c": "PK",
        "n": "+92",
        "p": 158,
        "m": [
          ["923", "{+}00 000 0000 000"],
          ["92", "{+}00 00 0000 0000"]
        ]
      },
      {
        // "country": "Palau",
        "c": "PW",
        "n": "+680",
        "p": 159,
        "m": [
          ["680", "{+}000 000000[000000]"]
        ]
      },
      {
        // "country": "Palestine",
        "c": "PS",
        "n": "+970",
        "p": 160,
        "m": [
          ["970", "{+}000 000000[000000]"]
        ]
      },
      {
        // "country": "Panama",
        "c": "PA",
        "n": "+507",
        "p": 161,
        "m": [
          ["507", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Papua New Guinea",
        "c": "PG",
        "n": "+675",
        "p": 162,
        "m": [
          ["675", "{+}000 00 000 000"]
        ]
      },
      {
        // "country": "Paraguay",
        "c": "PY",
        "n": "+595",
        "p": 163,
        "m": [
          ["595", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Peru",
        "c": "PE",
        "n": "+51",
        "p": 164,
        "m": [
          ["51", "{+}00 00 000 000"]
        ]
      },
      {
        // "country": "Philippines",
        "c": "PH",
        "n": "+63",
        "p": 165,
        "m": [
          ["639", "{+}00 000 000 0000"],
          ["63", "{+}00 00 000 0000"]
        ]
      },
      {
        // "country": "Poland",
        "c": "PL",
        "n": "+48",
        "p": 166,
        "m": [
          ["485", "{+}00 000 000 000"],
          ["48", "{+}00 00 000 0000"]
        ]
      },
      {
        // "country": "Portugal",
        "c": "PT",
        "n": "+351",
        "p": 167,
        "m": [
          ["351", "{+}000 000 000 000"]
        ]
      },
      {
        // "country": "Puerto Rico",
        "c": "PR",
        "n": "+1",
        "p": 168,
        "m": [
          ["1787", us],
          ["1939", us]
        ]
      },
      {
        // "country": "Qatar",
        "c": "QA",
        "n": "+974",
        "p": 169,
        "m": [
          ["974", "{+}000 0000 0000"]
        ]
      },
      {
        // "country": "Réunion",
        "c": "RE",
        "n": "+262",
        "p": 170,
        "m": [
          ["262", "{+}000 00000 0000"]
        ]
      },
      {
        // "country": "Romania",
        "c": "RO",
        "n": "+40",
        "p": 171,
        "m": [
          ["407", "{+}00 000 000 000"],
          ["40", "{+}00 00 000 0000"]
        ]
      },
      {
        // "country": "Russia",
        "c": "RU",
        "n": "+7",
        "p": 172,
        "m": [
          ["7", "{+}0 000 000 00 00"]
        ]
      },
      {
        // "country": "Rwanda",
        "c": "RW",
        "n": "+250",
        "p": 173,
        "m": [
          ["250", "{+}000 00 000 000"]
        ]
      },
      {
        // "country": "Samoa",
        "c": "WS",
        "n": "+685",
        "p": 174,
        "m": [
          ["685", "{+}000 00 0000"]
        ]
      },
      {
        // "country": "San Marino",
        "c": "SM",
        "n": "+378",
        "p": 175,
        "m": [
          ["378", "{+}000 0000 000000"]
        ]
      },
      {
        // "country": "São Tomé & Príncipe",
        "c": "ST",
        "n": "+239",
        "p": 176,
        "m": [
          ["239", "{+}000 00 00 00"]
        ]
      },
      {
        // "country": "Saudi Arabia",
        "c": "SA",
        "n": "+966",
        "p": 177,
        "m": [
          ["96657", "{+}000 000 00 0000"],
          ["966", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Senegal",
        "c": "SN",
        "n": "+221",
        "p": 178,
        "m": [
          ["221", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Serbia",
        "c": "RS",
        "n": "+381",
        "p": 179,
        "m": [
          ["3816", "{+}000 000 000 000"],
          ["3817", "{+}000 000 000 000"],
          ["381", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Seychelles",
        "c": "SC",
        "n": "+248",
        "p": 180,
        "m": [
          ["248", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Sierra Leone",
        "c": "SL",
        "n": "+232",
        "p": 181,
        "m": [
          ["232", "{+}000 00 000 000"]
        ]
      },
      {
        // "country": "Singapore",
        "c": "SG",
        "n": "+65",
        "p": 182,
        "m": [
          ["65", "{+}00 0000 0000"]
        ]
      },
      {
        // "country": "Sint Maarten",
        "c": "SX",
        "n": "+1",
        "p": 183,
        "m": [
          ["1721", us]
        ]
      },
      {
        // "country": "Slovakia",
        "c": "SK",
        "n": "+421",
        "p": 184,
        "m": [
          ["4219", "{+}000 000 000 0000"],
          ["421", "{+}000 00000000[00]"]
        ]
      },
      {
        // "country": "Slovenia",
        "c": "SI",
        "n": "+386",
        "p": 185,
        "m": [
          ["3863", "{+}000 00 000 000"],
          ["386", "{+}000 0000000[00]"]
        ]
      },
      {
        // "country": "Solomon Islands",
        "c": "SB",
        "n": "+677",
        "p": 186,
        "m": [
          ["677", "{+}000 00000"]
        ]
      },
      {
        // "country": "Somalia",
        "c": "SO",
        "n": "+252",
        "p": 187,
        "m": [
          ["252", "{+}000 0 000 000"]
        ]
      },
      {
        // "country": "South Africa",
        "c": "ZA",
        "n": "+27",
        "p": 188,
        "m": [
          ["276", "{+}00 000 000 000"],
          ["277", "{+}00 000 000 000"],
          ["278", "{+}00 000 000 000"],
          ["27", "{+}00 00 000 0000"]
        ]
      },
      {
        // "country": "South Korea",
        "c": "KR",
        "n": "+82",
        "p": 189,
        "m": [
          ["82", "{+}00 00000000[00]"]
        ]
      },
      {
        // "country": "South Sudan",
        "c": "SS",
        "n": "+211",
        "p": 190,
        "m": [
          ["211", "{+}000 0000000[00]"]
        ]
      },
      {
        // "country": "Spain",
        "c": "ES",
        "n": "+34",
        "p": 191,
        "m": [
          ["346", "{+}00 000 000 000"],
          ["347", "{+}00 000 000 000"],
          ["34", "{+}00 00 000 000"]
        ]
      },
      {
        // "country": "Sri Lanka",
        "c": "LK",
        "n": "+94",
        "p": 192,
        "m": [
          ["947", "{+}00 000 000 0000"],
          ["948", "{+}00 000 000 0000"],
          ["949", "{+}00 000 000 0000"],
          ["94", "{+}00 00 000 0000"]
        ]
      },
      {
        // "country": "St. Barthélemy",
        "c": "BL",
        "n": "+590",
        "p": 193,
        "m": [
          ["590", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "St. Helena",
        "c": "SH",
        "n": "+290",
        "p": 194,
        "m": [
          ["290", "{+}000 0000"]
        ]
      },
      {
        // "country": "St. Kitts & Nevis",
        "c": "KN",
        "n": "+1",
        "p": 195,
        "m": [
          ["1869", us]
        ]
      },
      {
        // "country": "St. Lucia",
        "c": "LC",
        "n": "+1",
        "p": 196,
        "m": [
          ["1758", us]
        ]
      },
      {
        // "country": "St. Martin",
        "c": "MF",
        "n": "+590",
        "p": 197,
        "m": [
          ["590", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "St. Pierre & Miquelon",
        "c": "PM",
        "n": "+508",
        "p": 198,
        "m": [
          ["508", "{+}000 00 00 00"]
        ]
      },
      {
        // "country": "St. Vincent & Grenadines",
        "c": "VC",
        "n": "+1",
        "p": 199,
        "m": [
          ["1784", us]
        ]
      },
      {
        // "country": "Sudan",
        "c": "SD",
        "n": "+249",
        "p": 200,
        "m": [
          ["249", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Suriname",
        "c": "SR",
        "n": "+597",
        "p": 201,
        "m": [
          ["597", "{+}000 000 000"]
        ]
      },
      {
        // "country": "Sweden",
        "c": "SE",
        "n": "+46",
        "p": 202,
        "m": [
          ["4613", "{+}00 00 00 00 00"],
          ["4618", "{+}00 00 00 00 00"],
          ["467", "{+}00 00 000 00 00"],
          ["468", "{+}00 00 000 00 00"],
          ["46", "{+}00 0000000[0000]"]
        ]
      },
      {
        // "country": "Switzerland",
        "c": "CH",
        "n": "+41",
        "p": 203,
        "m": [
          ["417", "{+}00 000 000 000"],
          ["41", "{+}00 00 000 0000"]
        ]
      },
      {
        // "country": "Syria",
        "c": "SY",
        "n": "+963",
        "p": 204,
        "m": [
          ["9639", "{+}000 000 000 000"],
          ["963", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Taiwan",
        "c": "TW",
        "n": "+886",
        "p": 205,
        "m": [
          ["8869", "{+}000 000 000 000"],
          ["886", "{+}000 0 0000 0000"]
        ]
      },
      {
        // "country": "Tajikistan",
        "c": "TJ",
        "n": "+992",
        "p": 206,
        "m": [
          ["992", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Tanzania",
        "c": "TZ",
        "n": "+255",
        "p": 207,
        "m": [
          ["255", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Thailand",
        "c": "TH",
        "n": "+66",
        "p": 208,
        "m": [
          ["6653", "{+}00 00 000 000"],
          ["6676", "{+}00 00 000 000"],
          ["662", "{+}00 0 000 0000"],
          ["666", "{+}00 000 000 000"],
          ["668", "{+}00 000 000 000"],
          ["669", "{+}00 000 000 000"],
          ["66", "{+}00 00 000 000"]
        ]
      },
      {
        // "country": "Timor-Leste",
        "c": "TL",
        "n": "+670",
        "p": 209,
        "m": [
          ["670", "{+}000 000 0000"]
        ]
      },
      {
        // "country": "Togo",
        "c": "TG",
        "n": "+228",
        "p": 210,
        "m": [
          ["228", "{+}000 00 000 000"]
        ]
      },
      {
        // "country": "Tokelau",
        "c": "TK",
        "n": "+690",
        "p": 211,
        "m": [
          ["690", "{+}000 0000"]
        ]
      },
      {
        // "country": "Tonga",
        "c": "TO",
        "n": "+676",
        "p": 212,
        "m": [
          ["676", "{+}000 00 000"]
        ]
      },
      {
        // "country": "Trinidad & Tobago",
        "c": "TT",
        "n": "+1",
        "p": 213,
        "m": [
          ["1868", us]
        ]
      },
      {
        // "country": "Tunisia",
        "c": "TN",
        "n": "+216",
        "p": 214,
        "m": [
          ["216", "{+}000 00 000 000"]
        ]
      },
      {
        // "country": "Türkiye",
        "c": "TR",
        "n": "+90",
        "p": 215,
        "m": [
          ["90", "{+}00 000 000 0000"]
        ]
      },
      {
        // "country": "Turkmenistan",
        "c": "TM",
        "n": "+993",
        "p": 216,
        "m": [
          ["993", "{+}000 0 000 000"]
        ]
      },
      {
        // "country": "Turks & Caicos Islands",
        "c": "TC",
        "n": "+1",
        "p": 217,
        "m": [
          ["1649", us]
        ]
      },
      {
        // "country": "Tuvalu",
        "c": "TV",
        "n": "+688",
        "p": 218,
        "m": [
          ["688", "{+}000 00 000"]
        ]
      },
      {
        // "country": "U.S. Virgin Islands",
        "c": "VI",
        "n": "+1",
        "p": 219,
        "m": [
          ["1340", us]
        ]
      },
      {
        // "country": "Uganda",
        "c": "UG",
        "n": "+256",
        "p": 220,
        "m": [
          ["2567", "{+}000 000 000 000"],
          ["256", "{+}000 00 000 000[0]"]
        ]
      },
      {
        // "country": "Ukraine",
        "c": "UA",
        "n": "+380",
        "p": 221,
        "m": [
          ["380", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "United Arab Emirates",
        "c": "AE",
        "n": "+971",
        "p": 222,
        "m": [
          ["9715", "{+}000 00 000 0000"],
          ["971", "{+}000 0 000 0000"]
        ]
      },
      {
        // "country": "United Kingdom",
        "c": "GB",
        "n": "+44",
        "p": 223,
        "m": [
          ["4420", "{+}00 00 0000 0000"],
          ["447", "{+}00 0000 000 000"],
          ["44", "{+}00 000 000 0000"]
        ]
      },
      {
        // "country": "United States",
        "c": "US",
        "n": "+1",
        "p": 224,
        "m": [
          ["1", us]
        ]
      },
      {
        // "country": "Uruguay",
        "c": "UY",
        "n": "+598",
        "p": 225,
        "m": [
          ["598", "{+}000 0 000 00 00"]
        ]
      },
      {
        // "country": "Uzbekistan",
        "c": "UZ",
        "n": "+998",
        "p": 226,
        "m": [
          ["998", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Vanuatu",
        "c": "VU",
        "n": "+678",
        "p": 227,
        "m": [
          ["678", "{+}000 00 0000"]
        ]
      },
      {
        // "country": "Vatican City",
        "c": "VA",
        "n": "+39",
        "p": 228,
        "m": [
          ["3906698", "{+}00 00 000 00000"],
          ["379", "{+}000 00 0000 0000"]
        ]
      },
      {
        // "country": "Venezuela",
        "c": "VE",
        "n": "+58",
        "p": 229,
        "m": [
          ["58", "{+}00 000 000 0000"]
        ]
      },
      {
        // "country": "Vietnam",
        "c": "VN",
        "n": "+84",
        "p": 230,
        "m": [
          ["843", "{+}00 000 000 000"],
          ["845", "{+}00 000 000 000"],
          ["847", "{+}00 000 000 000"],
          ["849", "{+}00 000 000 000"],
          ["84", "{+}00 00 0000 0000"]
        ]
      },
      {
        // "country": "Wallis & Futuna",
        "c": "WF",
        "n": "+681",
        "p": 231,
        "m": [
          ["681", "{+}000 00 0000"]
        ]
      },
      {
        // "country": "Yemen",
        "c": "YE",
        "n": "+967",
        "p": 232,
        "m": [
          ["9677", "{+}000 000 000 000"],
          ["967", "{+}000 0 000 000"]
        ]
      },
      {
        // "country": "Zambia",
        "c": "ZM",
        "n": "+260",
        "p": 233,
        "m": [
          ["2609", "{+}000 000 000 000"],
          ["260", "{+}000 00 000 0000"]
        ]
      },
      {
        // "country": "Zimbabwe",
        "c": "ZW",
        "n": "+263",
        "p": 234,
        "m": [
          ["263", "{+}000 00 000 00[00]"]
        ]
      }
    ];
    var base$a = function base2(props, context, dependencies2) {
      var {
        include,
        exclude,
        mask: maskProp
      } = toRefs(props);
      var {
        update,
        focus,
        value,
        input,
        form$,
        el$,
        classes: classes2
      } = dependencies2;
      var options$ = ref(null);
      var addonPlaceholder = ref(markRaw({
        props: ["option", "el$"],
        render() {
          return h$1("div", {
            class: classes2.value.placeholder,
            style: {
              backgroundPosition: "0 -".concat(this.option.p * 20 + 20, "px")
            }
          });
        }
      }));
      var addonOptions = computed(() => {
        return countryPhones.filter((c2) => {
          if (!include.value.length && !exclude.value.length) {
            return true;
          }
          if (include.value.length) {
            return include.value.map((c3) => c3.toUpperCase()).indexOf(c2.c) !== -1;
          }
          return exclude.value.map((c3) => c3.toUpperCase()).indexOf(c2.c) === -1;
        }).map((c2) => {
          return _objectSpread2$1(_objectSpread2$1({}, c2), {}, {
            value: c2.c,
            label: form$.value.translations.vueform.countries[c2.c],
            display: markRaw({
              props: ["option", "index", "selected", "pointed", "el$"],
              render() {
                return h$1("div", {
                  class: classes2.value.option(this.selected || this.pointed)
                }, [h$1("div", {
                  class: classes2.value.optionWrapper
                }, [h$1("div", {
                  class: classes2.value.flag,
                  style: {
                    backgroundPosition: "0 -".concat(this.option.p * 20 + 20, "px")
                  }
                }), h$1("div", {
                  class: classes2.value.country
                }, [this.option.label, h$1("span", {
                  class: classes2.value.number
                }, [this.option.n])])])]);
              }
            }),
            valueDisplay: markRaw({
              props: ["option", "el$"],
              render() {
                return h$1("div", {
                  class: classes2.value.flag,
                  style: {
                    backgroundPosition: "0 -".concat(this.option.p * 20 + 20, "px")
                  }
                });
              }
            })
          });
        }).sort((a2, b2) => a2.label.localeCompare(b2.label)).map((c2, i2) => _objectSpread2$1(_objectSpread2$1({}, c2), {}, {
          index: i2
        }));
      });
      var mask = computed(() => {
        if (!maskPluginInstalled.value) {
          return;
        }
        var masks2 = {};
        var maskLengths = [];
        addonOptions.value.forEach((c2) => c2.m.forEach((m2) => {
          if (masks2[m2[1]] === void 0) {
            masks2[m2[1]] = [];
          }
          var length = m2[0].toString().length;
          if (masks2[m2[1]][length] === void 0) {
            masks2[m2[1]][length] = [];
          }
          masks2[m2[1]][length].push(parseInt(m2[0]));
          if (maskLengths.indexOf(length) === -1) {
            maskLengths.push(length);
          }
        }));
        maskLengths.sort().reverse();
        var mask2 = [];
        maskLengths.forEach((length) => {
          Object.keys(masks2).forEach((m2) => {
            if (masks2[m2][length]) {
              mask2.push({
                mask: m2,
                startsWith: masks2[m2][length],
                placeholder: true
              });
            }
          });
        });
        mask2.push({
          mask: "{+}0000000[0000000]",
          startsWith: ""
        });
        return {
          mask: mask2
        };
      });
      var masks = computed(() => {
        return addonOptions.value.reduce((prev, curr) => {
          return curr.m.reduce((p2, c2) => {
            return _objectSpread2$1(_objectSpread2$1({}, p2), {}, {
              [c2[0]]: curr.c
            });
          }, _objectSpread2$1({}, prev));
        }, {});
      });
      var maskPluginInstalled = computed(() => {
        return !!maskProp;
      });
      var inputType = computed(() => {
        return maskPluginInstalled.value ? "text" : "tel";
      });
      var setFlag = () => {
        var _options$$value$selec;
        if (!value.value) {
          if (Object.keys(options$.value.selected).length) {
            options$.value.reset();
          }
          return;
        }
        if (value.value && !value.value.toString().startsWith("+") || value.value === ((_options$$value$selec = options$.value.selected) === null || _options$$value$selec === void 0 ? void 0 : _options$$value$selec.n)) {
          return;
        }
        var number = value.value.replace("+", "");
        var lengths = [7, 5, 4, 3, 2, 1].filter((l2) => number.length >= l2);
        var country;
        lengths.forEach((l2) => {
          if (country) {
            return;
          }
          country = masks.value[number.slice(0, l2)] || void 0;
        });
        if (!country) {
          if (Object.keys(options$.value.selected).length) {
            options$.value.reset();
          }
          return;
        }
        if (country === "MF") {
          country = "GP";
        }
        var option = addonOptions.value.find((c2) => c2.c === country);
        if (options$.value.selected.index !== option.index) {
          options$.value.selectOption(option);
        }
      };
      var handleOptionSelect = (option) => {
        if (document.activeElement === input.value) {
          context.emit("select", option, el$.value);
          return;
        }
        if (option.n === void 0) {
          el$.value.clear();
        } else if (maskPluginInstalled.value) {
          var valueMatchesMask = value.value ? option.m.map((m2) => "+".concat(m2[0])).find((m2) => {
            return value.value.startsWith(m2);
          }) : false;
          if (!valueMatchesMask) {
            el$.value.update(option.m.length === 1 ? "+".concat(option.m[0][0]) : option.n);
          }
          if (document.activeElement.closest("[data-dropdown-for]")) {
            focus();
          }
        }
        context.emit("select", option, el$.value);
      };
      var handleOpen = () => {
        context.emit("open", el$);
      };
      var handleClose = () => {
        context.emit("close", el$);
      };
      onMounted(() => {
        setFlag();
      });
      watch(value, (n2) => {
        setFlag();
      });
      return {
        options$,
        addonOptions,
        handleOptionSelect,
        addonPlaceholder,
        maskPluginInstalled,
        inputType,
        mask,
        handleOpen,
        handleClose
      };
    };
    var base$9 = function base2(props, context, dependencies2) {
      var {
        fire,
        el$
      } = dependencies2;
      var handleKeydown = (e2) => {
        fire("keydown", e2, el$.value);
      };
      var handleKeyup = (e2) => {
        fire("keyup", e2, el$.value);
      };
      var handleKeypress = (e2) => {
        fire("keypress", e2, el$.value);
      };
      return {
        handleKeydown,
        handleKeyup,
        handleKeypress
      };
    };
    var phone = function phone2(props, context, dependencies2) {
      var {
        fire,
        model,
        input,
        el$
      } = dependencies2;
      var handleKeydown = (e2) => {
        if (el$.value.maskPluginInstalled) {
          return;
        }
        if (["Backspace", "Delete", "Tab", "Escape", "Enter", "ArrowLeft", "ArrowRight"].indexOf(e2.key) !== -1 || e2.ctrlKey || e2.metaKey) {
          return;
        }
        if (/[0-9]/.test(e2.key) && (!model.value || model.value.length < 16)) {
          return;
        }
        if (e2.key === "+" && (!model.value || input.value.selectionStart === 0) && (!model.value || model.value.length < 16)) {
          return;
        }
        e2.preventDefault();
      };
      return {
        handleKeydown
      };
    };
    var PhoneElement = {
      name: "PhoneElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "select", "open", "close", "blur", "focus", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "text",
          private: true
        },
        default: {
          required: false,
          type: [String, Number, Object],
          localized: true,
          default: null
        },
        debounce: {
          required: false,
          type: [Number],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        floating: {
          required: false,
          type: [String, Boolean, Object],
          localized: true,
          default: null
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        placeholder: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        readonly: {
          required: false,
          type: [Boolean],
          default: false
        },
        include: {
          required: false,
          type: [Array],
          default: () => []
        },
        exclude: {
          required: false,
          type: [Array],
          default: () => []
        },
        unmask: {
          require: false,
          type: [Boolean],
          default: false
        },
        allowIncomplete: {
          require: false,
          type: [Boolean],
          default: false
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        autocomplete: {
          required: false,
          type: [String, Number],
          default: null
        },
        loading: {
          type: [Boolean],
          required: false,
          default: false
        },
        onBlur: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onSelect: {
          required: false,
          type: [Function],
          default: null,
          private: true
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$G, base$1c, base$P, text$1, base$14, text$2, base$H, base$L, base$I, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, phone$1, base$s, base$b, phone$2, base$F, base$T, phone, base$t, base$a];
        context.slots = ["label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$8 = function base2(props, context, dependencies2) {
      var {
        radioName,
        radioValue
      } = toRefs(props);
      var update = dependencies2.update;
      var nullValue = dependencies2.nullValue;
      var fieldId = dependencies2.fieldId;
      var path = dependencies2.path;
      var form$ = dependencies2.form$;
      var listeners = ref([]);
      var inputName = computed(() => {
        return radioName.value || path.value;
      });
      var check2 = () => {
        update(radioValue.value);
      };
      var uncheck = () => {
        update(nullValue.value);
      };
      var watchChange = (value, old) => {
        if (old) {
          form$.value.$el.querySelectorAll('input[name="'.concat(old, '"')).forEach((element, i2) => {
            if (listeners.value[i2]) {
              element.removeEventListener("change", listeners.value[i2]);
            }
          });
        }
        form$.value.$el.querySelectorAll('input[name="'.concat(value, '"')).forEach((element) => {
          var listener = () => {
            if (element.id != fieldId.value) {
              update(nullValue.value);
            }
          };
          listeners.value.push(listener);
          element.addEventListener("change", listener);
        });
      };
      onMounted(() => {
        watchChange(inputName.value);
      });
      watch(inputName, watchChange);
      return {
        inputName,
        check: check2,
        uncheck
      };
    };
    var RadioElement = {
      name: "RadioElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "radio",
          private: true
        },
        default: {
          required: false,
          type: [String, Number],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        radioName: {
          required: false,
          type: [String],
          default: null
        },
        radioValue: {
          required: false,
          type: [Boolean, String, Number],
          default: 1
        },
        text: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        align: {
          required: false,
          type: [String],
          default: void 0
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$U, base$1c, base$P, base$K, base$C, base$14, base$D, base$L, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$8, radio, base$F, base$T, base$A];
        context.slots = ["default", "label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var RadiogroupElement = {
      name: "RadiogroupElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "radiogroup",
          private: true
        },
        default: {
          required: false,
          type: [String, Number],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        items: {
          required: false,
          type: [Object, Array, Function, String],
          localized: true,
          default: () => ({})
        },
        disables: {
          required: false,
          type: [Array],
          default: () => []
        },
        clearOnRefetch: {
          type: [Boolean],
          required: false,
          default: true
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$O, base$K, base$U, base$1c, base$P, radiogroup$2, base$C, base$L, radiogroup, base$14, base$D, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, radiogroup$1, base$F, base$T];
        context.slots = ["radio", "label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var SelectElement = {
      name: "SelectElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "select", "deselect", "search-change", "open", "close", "clear", "paste", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "select",
          private: true
        },
        default: {
          required: false,
          type: [String, Number, Object],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        floating: {
          required: false,
          type: [String, Boolean, Object],
          localized: true,
          default: null
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        placeholder: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        onSelect: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onDeselect: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onSearchChange: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onOpen: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onClose: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onClear: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onPaste: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        native: {
          required: false,
          type: [Boolean],
          default: true
        },
        items: {
          required: false,
          type: [Object, Array, Function, String],
          localized: true,
          default: () => ({})
        },
        labelProp: {
          type: [String],
          required: false,
          default: "label"
        },
        valueProp: {
          type: [String],
          required: false,
          default: "value"
        },
        dataKey: {
          type: [String],
          required: false,
          default: void 0
        },
        searchParam: {
          type: [String],
          required: false,
          default: "query"
        },
        search: {
          required: false,
          type: [Boolean],
          default: false,
          native: false
        },
        trackBy: {
          type: [String, Array],
          required: false,
          default: void 0,
          native: false
        },
        strict: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        create: {
          required: false,
          type: [Boolean],
          default: false,
          native: false
        },
        appendNewOption: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        addOptionOn: {
          type: [Array],
          required: false,
          default: () => ["enter"],
          native: false
        },
        allowAbsent: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        object: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        limit: {
          type: [Number],
          required: false,
          default: -1,
          native: false
        },
        groups: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        groupLabel: {
          type: [String],
          required: false,
          default: "label",
          native: false
        },
        groupOptions: {
          type: [String],
          required: false,
          default: "items",
          native: false
        },
        groupHideEmpty: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        openDirection: {
          type: [String],
          required: false,
          default: "bottom",
          native: false
        },
        appendToBody: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        appendTo: {
          type: [String],
          required: false,
          default: void 0,
          native: false
        },
        canDeselect: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        canClear: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        closeOnSelect: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        closeOnDeselect: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        clearOnRefetch: {
          type: [Boolean],
          required: false,
          default: false
        },
        delay: {
          type: [Number],
          required: false,
          default: -1,
          native: false
        },
        minChars: {
          type: [Number],
          required: false,
          default: 0,
          native: false
        },
        resolveOnLoad: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        filterResults: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        clearOnSearch: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        caret: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        truncate: {
          type: [Boolean],
          required: false,
          default: true,
          native: false
        },
        loading: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        noOptionsText: {
          type: [String, Object],
          required: false,
          default: void 0,
          "@default": "locale.multiselect.noOptions",
          localized: true,
          native: false
        },
        noResultsText: {
          type: [String, Object],
          required: false,
          default: void 0,
          "@default": "locale.multiselect.noResults",
          localized: true,
          native: false
        },
        autocomplete: {
          type: [String],
          required: false,
          native: false
        },
        inputType: {
          type: [String],
          required: false,
          default: "text",
          native: false
        },
        extendOptions: {
          required: false,
          type: [Object],
          default: () => ({})
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, select$4, base$O, base$S, base$K, base$U, base$G, base$1c, base$P, base$C, base$D, base$H, select$1, base$L, select$2, base$14, base$I, select$3, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$d, select, base$R, base$F, base$T, base$t];
        context.slots = ["option", "single-label", "placeholder", "group-label", "before-list", "after-list", "no-results", "no-options", "caret", "spinner", "clear", "label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    /*!
     * Signature Pad v5.0.2 | https://github.com/szimek/signature_pad
     * (c) 2024 Szymon Nowak | Released under the MIT license
     */
    class Point {
      constructor(x2, y2, pressure, time) {
        if (isNaN(x2) || isNaN(y2)) {
          throw new Error(`Point is invalid: (${x2}, ${y2})`);
        }
        this.x = +x2;
        this.y = +y2;
        this.pressure = pressure || 0;
        this.time = time || Date.now();
      }
      distanceTo(start2) {
        return Math.sqrt(Math.pow(this.x - start2.x, 2) + Math.pow(this.y - start2.y, 2));
      }
      equals(other) {
        return this.x === other.x && this.y === other.y && this.pressure === other.pressure && this.time === other.time;
      }
      velocityFrom(start2) {
        return this.time !== start2.time ? this.distanceTo(start2) / (this.time - start2.time) : 0;
      }
    }
    class Bezier {
      static fromPoints(points, widths) {
        const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;
        const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;
        return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);
      }
      static calculateControlPoints(s1, s2, s3) {
        const dx1 = s1.x - s2.x;
        const dy1 = s1.y - s2.y;
        const dx2 = s2.x - s3.x;
        const dy2 = s2.y - s3.y;
        const m1 = { x: (s1.x + s2.x) / 2, y: (s1.y + s2.y) / 2 };
        const m2 = { x: (s2.x + s3.x) / 2, y: (s2.y + s3.y) / 2 };
        const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
        const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
        const dxm = m1.x - m2.x;
        const dym = m1.y - m2.y;
        const k2 = l2 / (l1 + l2);
        const cm = { x: m2.x + dxm * k2, y: m2.y + dym * k2 };
        const tx = s2.x - cm.x;
        const ty = s2.y - cm.y;
        return {
          c1: new Point(m1.x + tx, m1.y + ty),
          c2: new Point(m2.x + tx, m2.y + ty)
        };
      }
      constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {
        this.startPoint = startPoint;
        this.control2 = control2;
        this.control1 = control1;
        this.endPoint = endPoint;
        this.startWidth = startWidth;
        this.endWidth = endWidth;
      }
      length() {
        const steps = 10;
        let length = 0;
        let px;
        let py;
        for (let i2 = 0; i2 <= steps; i2 += 1) {
          const t2 = i2 / steps;
          const cx = this.point(t2, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
          const cy = this.point(t2, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
          if (i2 > 0) {
            const xdiff = cx - px;
            const ydiff = cy - py;
            length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
          }
          px = cx;
          py = cy;
        }
        return length;
      }
      point(t2, start2, c1, c2, end2) {
        return start2 * (1 - t2) * (1 - t2) * (1 - t2) + 3 * c1 * (1 - t2) * (1 - t2) * t2 + 3 * c2 * (1 - t2) * t2 * t2 + end2 * t2 * t2 * t2;
      }
    }
    class SignatureEventTarget {
      constructor() {
        try {
          this._et = new EventTarget();
        } catch (error) {
          this._et = document;
        }
      }
      addEventListener(type, listener, options) {
        this._et.addEventListener(type, listener, options);
      }
      dispatchEvent(event) {
        return this._et.dispatchEvent(event);
      }
      removeEventListener(type, callback, options) {
        this._et.removeEventListener(type, callback, options);
      }
    }
    function throttle(fn2, wait = 250) {
      let previous = 0;
      let timeout = null;
      let result;
      let storedContext;
      let storedArgs;
      const later = () => {
        previous = Date.now();
        timeout = null;
        result = fn2.apply(storedContext, storedArgs);
        if (!timeout) {
          storedContext = null;
          storedArgs = [];
        }
      };
      return function wrapper(...args) {
        const now2 = Date.now();
        const remaining = wait - (now2 - previous);
        storedContext = this;
        storedArgs = args;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = now2;
          result = fn2.apply(storedContext, storedArgs);
          if (!timeout) {
            storedContext = null;
            storedArgs = [];
          }
        } else if (!timeout) {
          timeout = window.setTimeout(later, remaining);
        }
        return result;
      };
    }
    class SignaturePad extends SignatureEventTarget {
      constructor(canvas, options = {}) {
        var _a, _b, _c;
        super();
        this.canvas = canvas;
        this._drawingStroke = false;
        this._isEmpty = true;
        this._lastPoints = [];
        this._data = [];
        this._lastVelocity = 0;
        this._lastWidth = 0;
        this._handleMouseDown = (event) => {
          if (!this._isLeftButtonPressed(event, true) || this._drawingStroke) {
            return;
          }
          this._strokeBegin(this._pointerEventToSignatureEvent(event));
        };
        this._handleMouseMove = (event) => {
          if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {
            this._strokeEnd(this._pointerEventToSignatureEvent(event), false);
            return;
          }
          this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));
        };
        this._handleMouseUp = (event) => {
          if (this._isLeftButtonPressed(event)) {
            return;
          }
          this._strokeEnd(this._pointerEventToSignatureEvent(event));
        };
        this._handleTouchStart = (event) => {
          if (event.targetTouches.length !== 1 || this._drawingStroke) {
            return;
          }
          if (event.cancelable) {
            event.preventDefault();
          }
          this._strokeBegin(this._touchEventToSignatureEvent(event));
        };
        this._handleTouchMove = (event) => {
          if (event.targetTouches.length !== 1) {
            return;
          }
          if (event.cancelable) {
            event.preventDefault();
          }
          if (!this._drawingStroke) {
            this._strokeEnd(this._touchEventToSignatureEvent(event), false);
            return;
          }
          this._strokeMoveUpdate(this._touchEventToSignatureEvent(event));
        };
        this._handleTouchEnd = (event) => {
          if (event.targetTouches.length !== 0) {
            return;
          }
          if (event.cancelable) {
            event.preventDefault();
          }
          this.canvas.removeEventListener("touchmove", this._handleTouchMove);
          this._strokeEnd(this._touchEventToSignatureEvent(event));
        };
        this._handlePointerDown = (event) => {
          if (!this._isLeftButtonPressed(event) || this._drawingStroke) {
            return;
          }
          event.preventDefault();
          this._strokeBegin(this._pointerEventToSignatureEvent(event));
        };
        this._handlePointerMove = (event) => {
          if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {
            this._strokeEnd(this._pointerEventToSignatureEvent(event), false);
            return;
          }
          event.preventDefault();
          this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));
        };
        this._handlePointerUp = (event) => {
          if (this._isLeftButtonPressed(event)) {
            return;
          }
          event.preventDefault();
          this._strokeEnd(this._pointerEventToSignatureEvent(event));
        };
        this.velocityFilterWeight = options.velocityFilterWeight || 0.7;
        this.minWidth = options.minWidth || 0.5;
        this.maxWidth = options.maxWidth || 2.5;
        this.throttle = (_a = options.throttle) !== null && _a !== void 0 ? _a : 16;
        this.minDistance = (_b = options.minDistance) !== null && _b !== void 0 ? _b : 5;
        this.dotSize = options.dotSize || 0;
        this.penColor = options.penColor || "black";
        this.backgroundColor = options.backgroundColor || "rgba(0,0,0,0)";
        this.compositeOperation = options.compositeOperation || "source-over";
        this.canvasContextOptions = (_c = options.canvasContextOptions) !== null && _c !== void 0 ? _c : {};
        this._strokeMoveUpdate = this.throttle ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle) : SignaturePad.prototype._strokeUpdate;
        this._ctx = canvas.getContext("2d", this.canvasContextOptions);
        this.clear();
        this.on();
      }
      clear() {
        const { _ctx: ctx, canvas } = this;
        ctx.fillStyle = this.backgroundColor;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        this._data = [];
        this._reset(this._getPointGroupOptions());
        this._isEmpty = true;
      }
      fromDataURL(dataUrl, options = {}) {
        return new Promise((resolve2, reject) => {
          const image2 = new Image();
          const ratio = options.ratio || window.devicePixelRatio || 1;
          const width = options.width || this.canvas.width / ratio;
          const height = options.height || this.canvas.height / ratio;
          const xOffset = options.xOffset || 0;
          const yOffset = options.yOffset || 0;
          this._reset(this._getPointGroupOptions());
          image2.onload = () => {
            this._ctx.drawImage(image2, xOffset, yOffset, width, height);
            resolve2();
          };
          image2.onerror = (error) => {
            reject(error);
          };
          image2.crossOrigin = "anonymous";
          image2.src = dataUrl;
          this._isEmpty = false;
        });
      }
      toDataURL(type = "image/png", encoderOptions) {
        switch (type) {
          case "image/svg+xml":
            if (typeof encoderOptions !== "object") {
              encoderOptions = void 0;
            }
            return `data:image/svg+xml;base64,${btoa(this.toSVG(encoderOptions))}`;
          default:
            if (typeof encoderOptions !== "number") {
              encoderOptions = void 0;
            }
            return this.canvas.toDataURL(type, encoderOptions);
        }
      }
      on() {
        this.canvas.style.touchAction = "none";
        this.canvas.style.msTouchAction = "none";
        this.canvas.style.userSelect = "none";
        const isIOS = /Macintosh/.test(navigator.userAgent) && "ontouchstart" in document;
        if (window.PointerEvent && !isIOS) {
          this._handlePointerEvents();
        } else {
          this._handleMouseEvents();
          if ("ontouchstart" in window) {
            this._handleTouchEvents();
          }
        }
      }
      off() {
        this.canvas.style.touchAction = "auto";
        this.canvas.style.msTouchAction = "auto";
        this.canvas.style.userSelect = "auto";
        this.canvas.removeEventListener("pointerdown", this._handlePointerDown);
        this.canvas.removeEventListener("mousedown", this._handleMouseDown);
        this.canvas.removeEventListener("touchstart", this._handleTouchStart);
        this._removeMoveUpEventListeners();
      }
      _getListenerFunctions() {
        var _a;
        const canvasWindow = window.document === this.canvas.ownerDocument ? window : (_a = this.canvas.ownerDocument.defaultView) !== null && _a !== void 0 ? _a : this.canvas.ownerDocument;
        return {
          addEventListener: canvasWindow.addEventListener.bind(canvasWindow),
          removeEventListener: canvasWindow.removeEventListener.bind(canvasWindow)
        };
      }
      _removeMoveUpEventListeners() {
        const { removeEventListener: removeEventListener2 } = this._getListenerFunctions();
        removeEventListener2("pointermove", this._handlePointerMove);
        removeEventListener2("pointerup", this._handlePointerUp);
        removeEventListener2("mousemove", this._handleMouseMove);
        removeEventListener2("mouseup", this._handleMouseUp);
        removeEventListener2("touchmove", this._handleTouchMove);
        removeEventListener2("touchend", this._handleTouchEnd);
      }
      isEmpty() {
        return this._isEmpty;
      }
      fromData(pointGroups, { clear: clear2 = true } = {}) {
        if (clear2) {
          this.clear();
        }
        this._fromData(pointGroups, this._drawCurve.bind(this), this._drawDot.bind(this));
        this._data = this._data.concat(pointGroups);
      }
      toData() {
        return this._data;
      }
      _isLeftButtonPressed(event, only) {
        if (only) {
          return event.buttons === 1;
        }
        return (event.buttons & 1) === 1;
      }
      _pointerEventToSignatureEvent(event) {
        return {
          event,
          type: event.type,
          x: event.clientX,
          y: event.clientY,
          pressure: "pressure" in event ? event.pressure : 0
        };
      }
      _touchEventToSignatureEvent(event) {
        const touch = event.changedTouches[0];
        return {
          event,
          type: event.type,
          x: touch.clientX,
          y: touch.clientY,
          pressure: touch.force
        };
      }
      _getPointGroupOptions(group2) {
        return {
          penColor: group2 && "penColor" in group2 ? group2.penColor : this.penColor,
          dotSize: group2 && "dotSize" in group2 ? group2.dotSize : this.dotSize,
          minWidth: group2 && "minWidth" in group2 ? group2.minWidth : this.minWidth,
          maxWidth: group2 && "maxWidth" in group2 ? group2.maxWidth : this.maxWidth,
          velocityFilterWeight: group2 && "velocityFilterWeight" in group2 ? group2.velocityFilterWeight : this.velocityFilterWeight,
          compositeOperation: group2 && "compositeOperation" in group2 ? group2.compositeOperation : this.compositeOperation
        };
      }
      _strokeBegin(event) {
        const cancelled = !this.dispatchEvent(new CustomEvent("beginStroke", { detail: event, cancelable: true }));
        if (cancelled) {
          return;
        }
        const { addEventListener: addEventListener2 } = this._getListenerFunctions();
        switch (event.event.type) {
          case "mousedown":
            addEventListener2("mousemove", this._handleMouseMove);
            addEventListener2("mouseup", this._handleMouseUp);
            break;
          case "touchstart":
            addEventListener2("touchmove", this._handleTouchMove);
            addEventListener2("touchend", this._handleTouchEnd);
            break;
          case "pointerdown":
            addEventListener2("pointermove", this._handlePointerMove);
            addEventListener2("pointerup", this._handlePointerUp);
            break;
        }
        this._drawingStroke = true;
        const pointGroupOptions = this._getPointGroupOptions();
        const newPointGroup = Object.assign(Object.assign({}, pointGroupOptions), { points: [] });
        this._data.push(newPointGroup);
        this._reset(pointGroupOptions);
        this._strokeUpdate(event);
      }
      _strokeUpdate(event) {
        if (!this._drawingStroke) {
          return;
        }
        if (this._data.length === 0) {
          this._strokeBegin(event);
          return;
        }
        this.dispatchEvent(new CustomEvent("beforeUpdateStroke", { detail: event }));
        const point = this._createPoint(event.x, event.y, event.pressure);
        const lastPointGroup = this._data[this._data.length - 1];
        const lastPoints = lastPointGroup.points;
        const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];
        const isLastPointTooClose = lastPoint ? point.distanceTo(lastPoint) <= this.minDistance : false;
        const pointGroupOptions = this._getPointGroupOptions(lastPointGroup);
        if (!lastPoint || !(lastPoint && isLastPointTooClose)) {
          const curve = this._addPoint(point, pointGroupOptions);
          if (!lastPoint) {
            this._drawDot(point, pointGroupOptions);
          } else if (curve) {
            this._drawCurve(curve, pointGroupOptions);
          }
          lastPoints.push({
            time: point.time,
            x: point.x,
            y: point.y,
            pressure: point.pressure
          });
        }
        this.dispatchEvent(new CustomEvent("afterUpdateStroke", { detail: event }));
      }
      _strokeEnd(event, shouldUpdate = true) {
        this._removeMoveUpEventListeners();
        if (!this._drawingStroke) {
          return;
        }
        if (shouldUpdate) {
          this._strokeUpdate(event);
        }
        this._drawingStroke = false;
        this.dispatchEvent(new CustomEvent("endStroke", { detail: event }));
      }
      _handlePointerEvents() {
        this._drawingStroke = false;
        this.canvas.addEventListener("pointerdown", this._handlePointerDown);
      }
      _handleMouseEvents() {
        this._drawingStroke = false;
        this.canvas.addEventListener("mousedown", this._handleMouseDown);
      }
      _handleTouchEvents() {
        this.canvas.addEventListener("touchstart", this._handleTouchStart);
      }
      _reset(options) {
        this._lastPoints = [];
        this._lastVelocity = 0;
        this._lastWidth = (options.minWidth + options.maxWidth) / 2;
        this._ctx.fillStyle = options.penColor;
        this._ctx.globalCompositeOperation = options.compositeOperation;
      }
      _createPoint(x2, y2, pressure) {
        const rect = this.canvas.getBoundingClientRect();
        return new Point(x2 - rect.left, y2 - rect.top, pressure, (/* @__PURE__ */ new Date()).getTime());
      }
      _addPoint(point, options) {
        const { _lastPoints } = this;
        _lastPoints.push(point);
        if (_lastPoints.length > 2) {
          if (_lastPoints.length === 3) {
            _lastPoints.unshift(_lastPoints[0]);
          }
          const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2], options);
          const curve = Bezier.fromPoints(_lastPoints, widths);
          _lastPoints.shift();
          return curve;
        }
        return null;
      }
      _calculateCurveWidths(startPoint, endPoint, options) {
        const velocity = options.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - options.velocityFilterWeight) * this._lastVelocity;
        const newWidth = this._strokeWidth(velocity, options);
        const widths = {
          end: newWidth,
          start: this._lastWidth
        };
        this._lastVelocity = velocity;
        this._lastWidth = newWidth;
        return widths;
      }
      _strokeWidth(velocity, options) {
        return Math.max(options.maxWidth / (velocity + 1), options.minWidth);
      }
      _drawCurveSegment(x2, y2, width) {
        const ctx = this._ctx;
        ctx.moveTo(x2, y2);
        ctx.arc(x2, y2, width, 0, 2 * Math.PI, false);
        this._isEmpty = false;
      }
      _drawCurve(curve, options) {
        const ctx = this._ctx;
        const widthDelta = curve.endWidth - curve.startWidth;
        const drawSteps = Math.ceil(curve.length()) * 2;
        ctx.beginPath();
        ctx.fillStyle = options.penColor;
        for (let i2 = 0; i2 < drawSteps; i2 += 1) {
          const t2 = i2 / drawSteps;
          const tt2 = t2 * t2;
          const ttt = tt2 * t2;
          const u2 = 1 - t2;
          const uu = u2 * u2;
          const uuu = uu * u2;
          let x2 = uuu * curve.startPoint.x;
          x2 += 3 * uu * t2 * curve.control1.x;
          x2 += 3 * u2 * tt2 * curve.control2.x;
          x2 += ttt * curve.endPoint.x;
          let y2 = uuu * curve.startPoint.y;
          y2 += 3 * uu * t2 * curve.control1.y;
          y2 += 3 * u2 * tt2 * curve.control2.y;
          y2 += ttt * curve.endPoint.y;
          const width = Math.min(curve.startWidth + ttt * widthDelta, options.maxWidth);
          this._drawCurveSegment(x2, y2, width);
        }
        ctx.closePath();
        ctx.fill();
      }
      _drawDot(point, options) {
        const ctx = this._ctx;
        const width = options.dotSize > 0 ? options.dotSize : (options.minWidth + options.maxWidth) / 2;
        ctx.beginPath();
        this._drawCurveSegment(point.x, point.y, width);
        ctx.closePath();
        ctx.fillStyle = options.penColor;
        ctx.fill();
      }
      _fromData(pointGroups, drawCurve, drawDot) {
        for (const group2 of pointGroups) {
          const { points } = group2;
          const pointGroupOptions = this._getPointGroupOptions(group2);
          if (points.length > 1) {
            for (let j2 = 0; j2 < points.length; j2 += 1) {
              const basicPoint = points[j2];
              const point = new Point(basicPoint.x, basicPoint.y, basicPoint.pressure, basicPoint.time);
              if (j2 === 0) {
                this._reset(pointGroupOptions);
              }
              const curve = this._addPoint(point, pointGroupOptions);
              if (curve) {
                drawCurve(curve, pointGroupOptions);
              }
            }
          } else {
            this._reset(pointGroupOptions);
            drawDot(points[0], pointGroupOptions);
          }
        }
      }
      toSVG({ includeBackgroundColor = false } = {}) {
        const pointGroups = this._data;
        const ratio = Math.max(window.devicePixelRatio || 1, 1);
        const minX = 0;
        const minY = 0;
        const maxX = this.canvas.width / ratio;
        const maxY = this.canvas.height / ratio;
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        svg.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
        svg.setAttribute("viewBox", `${minX} ${minY} ${maxX} ${maxY}`);
        svg.setAttribute("width", maxX.toString());
        svg.setAttribute("height", maxY.toString());
        if (includeBackgroundColor && this.backgroundColor) {
          const rect = document.createElement("rect");
          rect.setAttribute("width", "100%");
          rect.setAttribute("height", "100%");
          rect.setAttribute("fill", this.backgroundColor);
          svg.appendChild(rect);
        }
        this._fromData(pointGroups, (curve, { penColor }) => {
          const path = document.createElement("path");
          if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {
            const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;
            path.setAttribute("d", attr);
            path.setAttribute("stroke-width", (curve.endWidth * 2.25).toFixed(3));
            path.setAttribute("stroke", penColor);
            path.setAttribute("fill", "none");
            path.setAttribute("stroke-linecap", "round");
            svg.appendChild(path);
          }
        }, (point, { penColor, dotSize, minWidth, maxWidth }) => {
          const circle = document.createElement("circle");
          const size2 = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;
          circle.setAttribute("r", size2.toString());
          circle.setAttribute("cx", point.x.toString());
          circle.setAttribute("cy", point.y.toString());
          circle.setAttribute("fill", penColor);
          svg.appendChild(circle);
        });
        return svg.outerHTML;
      }
    }
    function debounce$2(func, wait, onStart) {
      var timeout;
      return function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (!timeout) {
          onStart();
        } else {
          clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
          timeout = null;
          func.apply(this, args);
        }, wait);
      };
    }
    function useSignature(props, context, dependencies2) {
      var {
        fonts,
        colors,
        modes,
        accept,
        maxWidth,
        height,
        readonly: readonly2,
        maxFontSize,
        minFontSize,
        canClear,
        line,
        placeholder,
        autoload,
        maxSize,
        canUndo,
        columns: columns2,
        uploadWidth,
        uploadHeight,
        canDrop
      } = toRefs(props);
      var {
        el$,
        form$,
        input,
        isDisabled,
        value,
        Placeholder,
        available
      } = dependencies2;
      var mode$ = ref(null);
      var font$ = ref(null);
      var input$ = ref(null);
      var preview$ = ref(null);
      var pad$ = ref(null);
      var file$ = ref(null);
      var upload$ = ref(null);
      var uploadButton$ = ref(null);
      var mode = ref(null);
      var fontFamily = ref(null);
      var fontWeight = ref(null);
      var fontSize = ref(maxFontSize.value);
      var color = ref(null);
      var text2 = ref(null);
      var pad2 = ref(null);
      var image2 = ref(null);
      var created = ref(false);
      var creating = ref(false);
      var dragging = ref(false);
      var drawn = ref(false);
      var drawing = ref(false);
      var redos = ref([]);
      var undosLeft = ref(0);
      var width = ref(0);
      var lastWidth = ref(0);
      var isMouseOver = ref(false);
      var debouncer = ref(0);
      var fontFamilies = computed(() => {
        return fonts.value.map((f2) => f2.split("@")[0].replace("!", ""));
      });
      var fontWeights = computed(() => {
        return fonts.value.map((f2) => f2.split("@")[1] || 400);
      });
      var uploaded = computed(() => {
        return typeof value.value === "string";
      });
      var processing = computed(() => {
        return image2.value && !created.value;
      });
      var droppable = computed(() => {
        var div = document.createElement("div");
        return ("draggable" in div || "ondragstart" in div && "ondrop" in div) && "FormData" in window && "FileReader" in window && canDrop.value;
      });
      var resolvedModes = computed(() => {
        return modes.value.filter((m2) => ["type", "draw", "upload"].indexOf(m2) !== -1).map((mode2, i2) => {
          return {
            label: form$.value.translations.vueform.elements.signature[mode2],
            value: mode2,
            index: i2
          };
        });
      });
      var resolvedFonts = computed(() => {
        return fontFamilies.value.map((font, i2) => {
          var _text$value;
          return {
            label: '<div><span style="font-family: '.concat(font, "; font-weight: ").concat(fontWeights.value[i2], '" aria-hidden="true">').concat(((_text$value = text2.value) === null || _text$value === void 0 ? void 0 : _text$value.trim()) || form$.value.translations.vueform.elements.signature.fontPlaceholder, '</span><span style="position: absolute; left: -9999px; opacity: 0;">').concat(font, "</span></div>"),
            value: i2,
            index: i2
          };
        });
      });
      var fileAccept = computed(() => {
        return accept.value.reduce((prev, curr) => {
          switch (curr) {
            case "jpg":
            case "jpeg":
              prev.push("image/jpeg");
              break;
            case "png":
              prev.push("image/png");
              break;
            case "svg":
              prev.push("image/svg+xml");
              break;
          }
          return prev;
        }, []).join(", ");
      });
      var showLine = computed(() => {
        return mode.value !== "upload" && line.value;
      });
      var showInput = computed(() => {
        return !uploaded.value && mode.value === "type";
      });
      var showPlaceholder = computed(() => {
        return (!text2.value && mode.value === "type" || !drawn.value && mode.value === "draw") && placeholder.value !== false;
      });
      var showUploadContainer = computed(() => {
        return mode.value === "upload";
      });
      var showUpload = computed(() => {
        return mode.value === "upload" && !created.value;
      });
      var showPreview = computed(() => {
        return mode.value === "upload" && created.value;
      });
      var showPad = computed(() => {
        return mode.value === "draw";
      });
      var showUndos = computed(() => {
        return mode.value === "draw" && (redos.value.length || drawn.value) && !drawing.value && canUndo.value;
      });
      var showColors = computed(() => {
        return (mode.value === "upload" && created.value || mode.value === "type" || mode.value === "draw") && !drawing.value && colors.value.length > 1 && !isMouseOver.value;
      });
      var showModes = computed(() => {
        return !drawing.value && modes.value.length > 1;
      });
      var showFonts = computed(() => {
        return mode.value === "type" && resolvedFonts.value.length > 1;
      });
      var showClear = computed(() => {
        return (mode.value === "type" && text2.value || mode.value === "upload" && created.value || mode.value === "draw" && drawn.value || uploaded.value) && !isDisabled.value && !readonly2.value && !drawing.value && canClear.value;
      });
      var tabindex = computed(() => {
        return isDisabled.value || readonly2.value ? void 0 : 0;
      });
      var placeholderText = computed(() => {
        return Placeholder.value || form$.value.translations.vueform.elements.signature.placeholder;
      });
      var dndText = computed(() => {
        return "Drop an image here or";
      });
      var uploadButtonText = computed(() => {
        return "Select image";
      });
      var imgAltText = computed(() => {
        return form$.value.translations.vueform.elements.signature.imgAlt;
      });
      var imgTitleText = computed(() => {
        return form$.value.translations.vueform.elements.signature.imgTitle;
      });
      var fontText = computed(() => {
        return form$.value.translations.vueform.elements.signature.font;
      });
      var undoText = computed(() => {
        return form$.value.translations.vueform.elements.signature.undo;
      });
      var redoText = computed(() => {
        return form$.value.translations.vueform.elements.signature.redo;
      });
      var modeSelectorAria = computed(() => {
        return {
          "aria-label": form$.value.translations.vueform.elements.signature.modeSelectorAriaLabel
        };
      });
      var fontSelectorAria = computed(() => {
        return {
          "aria-label": form$.value.translations.vueform.elements.signature.fontSelectorAriaLabel
        };
      });
      var wrapperAriaLabel = computed(() => {
        return form$.value.translations.vueform.elements.signature.wrapperAriaLabel;
      });
      var inputAriaLabel = computed(() => {
        return form$.value.translations.vueform.elements.signature.inputAriaLabel;
      });
      var padAriaLabel = computed(() => {
        return form$.value.translations.vueform.elements.signature.padAriaLabel;
      });
      var clearAriaLabel = computed(() => {
        return form$.value.translations.vueform.elements.signature.clearAriaLabel;
      });
      var colorAriaLabel = computed(() => {
        return form$.value.translations.vueform.elements.signature.colorAriaLabel;
      });
      var padWidth = computed(() => {
        return width.value * 2;
      });
      var padHeight = computed(() => {
        return height.value * 2;
      });
      var padStyle = computed(() => {
        return {
          width: "".concat(width.value, "px"),
          height: "".concat(height.value, "px")
        };
      });
      var wrapperStyle = computed(() => {
        var style = {
          height: "".concat(height.value, "px")
        };
        if (maxWidth.value !== "auto") {
          style.maxWidth = "".concat(maxWidth.value, "px");
        }
        return style;
      });
      var inputStyle = computed(() => {
        return {
          fontFamily: fontFamily.value,
          fontWeight: fontWeight.value,
          fontSize: "".concat(fontSize.value, "px"),
          lineHeight: "".concat(fontSize.value, "px"),
          color: color.value,
          "-webkit-font-smoothing": "auto"
        };
      });
      var lineStyle = computed(() => {
        return {
          transform: "translateY(calc(".concat(fontSize.value / 2.2, "px))")
        };
      });
      var initPad = () => {
        if (pad2.value || !pad$.value || modes.value.indexOf("draw") === -1 && modes.value.length || !available.value) {
          return;
        }
        if (!width.value) {
          setWidth();
        }
        nextTick(() => {
          pad2.value = new SignaturePad(pad$.value);
          var ctx = pad$.value.getContext("2d");
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.scale(2, 2);
          setDrawColor();
          pad2.value.addEventListener("beginStroke", (e2) => {
            if (isDisabled.value || readonly2.value) {
              e2.preventDefault();
              return;
            }
            isMouseOver.value = true;
            drawn.value = true;
            drawing.value = true;
            redos.value = [];
          });
          pad2.value.addEventListener("endStroke", () => {
            drawing.value = false;
            undosLeft.value++;
            debounceTransform(drawingToImage, 500);
          });
        });
      };
      var resizePad = () => {
        setWidth();
        nextTick(() => {
          var ctx = pad$.value.getContext("2d");
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.scale(2, 2);
          clearDrawnSignature();
        });
      };
      var drawingToImage = () => {
        return new Promise((resolve2, reject) => {
          var originalCanvas = pad$.value;
          var originalCtx = originalCanvas.getContext("2d");
          var imageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
          var data = imageData.data;
          var minX = originalCanvas.width, minY = originalCanvas.height, maxX = 0, maxY = 0;
          for (var y2 = 0; y2 < originalCanvas.height; y2++) {
            for (var x2 = 0; x2 < originalCanvas.width; x2++) {
              var index2 = (y2 * originalCanvas.width + x2) * 4;
              if (data[index2 + 3] > 0) {
                if (x2 < minX)
                  minX = x2;
                if (y2 < minY)
                  minY = y2;
                if (x2 > maxX)
                  maxX = x2;
                if (y2 > maxY)
                  maxY = y2;
              }
            }
          }
          if (minX > maxX || minY > maxY) {
            reject(new Error("No drawing found on the canvas."));
            return;
          }
          var drawingWidth = maxX - minX + 1;
          var drawingHeight = maxY - minY + 1;
          var drawingCanvas = document.createElement("canvas");
          var drawingCtx = drawingCanvas.getContext("2d");
          drawingCanvas.width = drawingWidth;
          drawingCanvas.height = drawingHeight;
          drawingCtx.putImageData(imageData, -minX, -minY);
          var resizedCanvas = document.createElement("canvas");
          var resizedCtx = resizedCanvas.getContext("2d");
          var resizedWidth = uploadWidth.value;
          var resizedHeight = uploadHeight.value;
          resizedCanvas.width = resizedWidth;
          resizedCanvas.height = resizedHeight;
          var targetWidth = drawingWidth;
          var targetHeight = drawingHeight;
          if (targetWidth > resizedWidth || targetHeight > resizedHeight) {
            if (targetWidth / targetHeight > resizedWidth / resizedHeight) {
              targetWidth = resizedWidth;
              targetHeight = Math.floor(resizedWidth / drawingWidth * drawingHeight);
            } else {
              targetHeight = resizedHeight;
              targetWidth = Math.floor(resizedHeight / drawingHeight * drawingWidth);
            }
          }
          var offsetX = Math.floor((resizedWidth - targetWidth) / 2);
          var offsetY = Math.floor((resizedHeight - targetHeight) / 2);
          resizedCtx.drawImage(drawingCanvas, 0, 0, drawingWidth, drawingHeight, offsetX, offsetY, targetWidth, targetHeight);
          resizedCanvas.toBlob(function(blob) {
            value.value = blob;
            resolve2();
            resizedCanvas.remove();
          }, "image/png");
        });
      };
      var typingToImage = () => {
        return new Promise((resolve2, reject) => {
          if (!text2.value) {
            reject(new Error("No signature was typed."));
            return;
          }
          var canvas = document.createElement("canvas");
          var ctx = canvas.getContext("2d");
          var displayWidth = uploadWidth.value;
          var displayHeight = uploadHeight.value;
          canvas.width = displayWidth;
          canvas.height = displayHeight;
          nextTick(() => {
            ctx.clearRect(0, 0, displayWidth, displayHeight);
            var fontSize2 = displayHeight / 2;
            ctx.font = "".concat(fontWeight.value, " ").concat(fontSize2, "px ").concat(fontFamily.value);
            var textWidth = ctx.measureText(text2.value).width;
            while (textWidth > displayWidth - 10 && fontSize2 > 10) {
              fontSize2 -= 1;
              ctx.font = "".concat(fontWeight.value, " ").concat(fontSize2, "px ").concat(fontFamily.value);
              textWidth = ctx.measureText(text2.value).width;
            }
            ctx.fillStyle = color.value;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text2.value, displayWidth / 2, displayHeight / 2);
            canvas.toBlob(function(blob) {
              value.value = blob;
              canvas.remove();
              resolve2();
            }, "image/png");
          });
        });
      };
      var uploadToImage = () => {
        if (!image2.value) {
          return;
        }
        var file2 = image2.value;
        var reader = new FileReader();
        creating.value = true;
        reader.onload = function(e2) {
          var img = new Image();
          img.onload = function() {
            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext("2d");
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var colorHex = color.value;
            var colorRGB = hexToRgb(colorHex);
            var threshold = 220;
            for (var i2 = 0; i2 < data.length; i2 += 4) {
              var r2 = data[i2];
              var g2 = data[i2 + 1];
              var b2 = data[i2 + 2];
              if (r2 > threshold && g2 > threshold && b2 > threshold) {
                data[i2 + 3] = 0;
              } else {
                data[i2] = colorRGB.r;
                data[i2 + 1] = colorRGB.g;
                data[i2 + 2] = colorRGB.b;
              }
            }
            ctx.putImageData(imageData, 0, 0);
            var mainCanvas = preview$.value;
            var mainCtx = mainCanvas.getContext("2d");
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            var targetWidth = uploadWidth.value;
            var targetHeight = uploadHeight.value;
            var newWidth = targetWidth;
            var newHeight = newWidth / (img.width / img.height);
            if (newHeight > targetHeight) {
              newHeight = targetHeight;
              newWidth = newHeight * (img.width / img.height);
            }
            var xOffset = (targetWidth - newWidth) / 2;
            var yOffset = (targetHeight - newHeight) / 2;
            mainCtx.drawImage(canvas, 0, 0, img.width, img.height, xOffset, yOffset, newWidth, newHeight);
            mainCanvas.toBlob(function(blob) {
              value.value = blob;
              created.value = true;
              creating.value = false;
              canvas.remove();
            }, "image/png");
          };
          img.src = e2.target.result;
        };
        reader.readAsDataURL(file2);
      };
      var undo = () => {
        if (!pad2.value) {
          return;
        }
        var data = pad2.value.toData();
        if (!data.length) {
          return;
        }
        redos.value.push(data.pop());
        pad2.value.fromData(data);
        if (!data.length) {
          drawn.value = false;
        }
        undosLeft.value = data.length;
        debounceTransform(drawingToImage, 500);
      };
      var redo = () => {
        if (!pad2.value || !redos.value.length) {
          return;
        }
        var data = pad2.value.toData() || [];
        data.push(redos.value.pop());
        pad2.value.fromData(data);
        drawn.value = true;
        setDrawColor();
        undosLeft.value = data.length;
        debounceTransform(drawingToImage, 500);
      };
      var clearSignature = () => {
        text2.value = null;
        image2.value = null;
        created.value = false;
        value.value = null;
        clearDrawnSignature();
      };
      var clearDrawnSignature = () => {
        var _pad$value;
        (_pad$value = pad2.value) === null || _pad$value === void 0 || _pad$value.clear();
        drawn.value = false;
        redos.value = [];
      };
      var loadFonts = () => {
        fonts.value.forEach((font) => {
          var parts = font.split("@");
          var skip = parts[0].substr(0, 1) === "!";
          if (!skip) {
            var family = parts[0].replace("!", "").replace(/\s/g, "+");
            var weight = parts[1] || 400;
            var id = "font-".concat(family);
            if (!document.getElementById(id)) {
              var link = document.createElement("link");
              link.id = id;
              link.rel = "stylesheet";
              link.href = "https://fonts.googleapis.com/css2?family=".concat(family, ":wght@").concat(weight, "&display=swap");
              document.head.appendChild(link);
            }
          }
        });
      };
      var setDrawColor = () => {
        var {
          r: r2,
          g: g2,
          b: b2
        } = hexToRgb(color.value);
        pad2.value.penColor = "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")");
        if (drawn.value) {
          pad2.value.fromData(pad2.value.toData().map((d2) => {
            d2.penColor = pad2.value.penColor;
            return d2;
          }));
        }
      };
      var adjustFontSize = () => {
        if (!text2.value) {
          fontSize.value = maxFontSize.value;
          return;
        }
        var ua = navigator.userAgent.toLowerCase();
        var isSafari = ua.indexOf("safari") != -1 && ua.indexOf("chrome") == -1 && ua.indexOf("android") == -1;
        var inputElement = input$.value;
        var styles2 = window.getComputedStyle(inputElement);
        var textIndent = parseFloat(styles2.textIndent);
        var paddingRight = parseFloat(styles2.paddingRight);
        var maxWidth2 = Math.ceil(inputElement.getBoundingClientRect().width) - textIndent;
        var size2 = fontSize.value;
        while (inputElement.scrollWidth + (isSafari ? paddingRight : 0) - textIndent > maxWidth2 && size2 > minFontSize.value) {
          size2--;
          inputElement.style.fontSize = size2 + "px";
        }
        while (inputElement.scrollWidth + (isSafari ? paddingRight : 0) - textIndent <= maxWidth2 && size2 < maxFontSize.value) {
          inputElement.style.fontSize = size2 + 1 + "px";
          if (inputElement.scrollWidth + (isSafari ? paddingRight : 0) - textIndent > maxWidth2) {
            inputElement.style.fontSize = size2 + "px";
            break;
          }
          size2++;
        }
        fontSize.value = size2;
      };
      var hexToRgb = (hex) => {
        hex = hex.replace(/^#/, "");
        var bigint = parseInt(hex, 16);
        var r2 = bigint >> 16 & 255;
        var g2 = bigint >> 8 & 255;
        var b2 = bigint & 255;
        return {
          r: r2,
          g: g2,
          b: b2
        };
      };
      var checkFileExt = (file2) => {
        var accepted2 = accept.value.indexOf("jpg") !== -1 && accept.value.indexOf("jpeg") === -1 ? accept.value.concat(["jpeg"]) : accept.value;
        var valid = file2 && accepted2.indexOf(file2 === null || file2 === void 0 ? void 0 : file2.name.split(".").pop()) !== -1;
        if (!valid) {
          alert(form$.value.__(form$.value.translations.vueform.elements.signature.unsupportedFormat, {
            extensions: accept.value.join(", ")
          }));
          return false;
        }
        return true;
      };
      var checkFileSize = (file2) => {
        if (maxSize.value === -1) {
          return true;
        }
        if (file2.size / 1024 > maxSize.value) {
          alert(form$.value.__(form$.value.translations.vueform.elements.signature.maxSizeError, {
            max: maxSize.value
          }));
          return false;
        }
        return true;
      };
      var setWidth = () => {
        width.value = input.value.getBoundingClientRect().width;
      };
      var setLastWidth = () => {
        lastWidth.value = input.value.getBoundingClientRect().width;
      };
      var setDefaultMode = function setDefaultMode2() {
        var setDropdown = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        mode.value = modes.value[0] || "draw";
        if (setDropdown) {
          mode$.value.selected = resolvedModes.value[0] || {
            label: form$.value.translations.vueform.elements.signature.draw,
            value: "draw",
            index: 0
          };
        }
      };
      var setDefaultFont = function setDefaultFont2() {
        var setDropdown = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        fontFamily.value = fontFamilies.value[0] || "cursive";
        fontWeight.value = fontWeights.value[0] || 400;
        if (setDropdown) {
          font$.value.selected = {};
          font$.value.pointed = {};
        }
      };
      var setDefaultColor = () => {
        color.value = colors.value[0] || "#000000";
      };
      var setFont = (value2) => {
        fontFamily.value = fontFamilies.value[value2.index];
        fontWeight.value = fontWeights.value[value2.index];
      };
      var setImage = (file2) => {
        if (checkFileExt(file2) && checkFileSize(file2)) {
          image2.value = file2;
          uploadToImage(image2.value);
        } else {
          image2.value = null;
          created.value = false;
        }
      };
      var debounceTransform = function debounceTransform2(method) {
        var ms = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
        if (debouncer.value) {
          clearTimeout(debouncer.value);
        }
        debouncer.value = setTimeout(/* @__PURE__ */ _asyncToGenerator(function* () {
          try {
            yield method.call();
          } catch (e2) {
            value.value = null;
          }
        }), ms);
      };
      var handleInput = (e2) => {
        if (isDisabled.value || readonly2.value) {
          return;
        }
        text2.value = e2.target.value;
      };
      var handleModeSelect = (value2) => {
        if (isDisabled.value || readonly2.value) {
          return;
        }
        mode.value = value2.value;
        nextTick(() => {
          if (mode.value === "draw") {
            pad$.value.focus();
          } else if (mode.value === "type") {
            input$.value.focus();
          } else if (mode.value === "upload") {
            uploadButton$.value.focus();
          }
        });
      };
      var handleColorSelect = (value2) => {
        if (isDisabled.value || readonly2.value) {
          return;
        }
        color.value = value2;
      };
      var handleFontSelect = (value2) => {
        font$.value.selected = {};
        if (isDisabled.value || readonly2.value) {
          return;
        }
        setFont(value2);
      };
      var handleClear = () => {
        if (isDisabled.value || readonly2.value) {
          return;
        }
        if (!uploaded.value) {
          if (mode.value === "draw") {
            pad$.value.focus();
          } else if (mode.value === "type") {
            input$.value.focus();
          } else if (mode.value === "upload") {
            uploadButton$.value.focus();
          }
        }
        clearSignature();
        isMouseOver.value = false;
      };
      var handleUndo = () => {
        if (isDisabled.value || readonly2.value) {
          return;
        }
        undo();
        isMouseOver.value = false;
      };
      var handleRedo = () => {
        if (isDisabled.value || readonly2.value) {
          return;
        }
        redo();
        isMouseOver.value = false;
      };
      var handleSelectClick = () => {
        if (isDisabled.value || readonly2.value) {
          return;
        }
        file$.value.click();
      };
      var handleFileSelect = (event) => {
        if (isDisabled.value || readonly2.value) {
          return;
        }
        var file2 = event.target.files[0];
        setImage(file2);
        file$.value.value = "";
      };
      var handleDrop = (e2) => {
        if (isDisabled.value || readonly2.value || !droppable.value) {
          return;
        }
        var file2 = e2.dataTransfer.files[0];
        setImage(file2);
      };
      var handleMouseLeave = () => {
        isMouseOver.value = false;
      };
      var handleResize = () => {
        if (lastWidth.value === input.value.getBoundingClientRect().width) {
          return;
        }
        resizePad();
        adjustFontSize();
      };
      var handleResizeDebounce = debounce$2(handleResize, 200, () => {
        setLastWidth();
      });
      setDefaultMode();
      setDefaultFont();
      setDefaultColor();
      onMounted(() => {
        if (autoload.value) {
          loadFonts();
        }
        setWidth();
        if (mode$.value) {
          mode$.value.selected = resolvedModes.value[0] || {
            label: form$.value.translations.vueform.elements.signature.draw,
            value: "draw",
            index: 0
          };
        }
        var evts = ["drag", "dragstart", "dragenter", "dragleave", "dragend"];
        evts.forEach((event) => {
          input.value.addEventListener(event, (e2) => {
            e2.preventDefault();
            e2.stopPropagation();
            if (["dragleave", "dragend"].indexOf(event) === -1) {
              return;
            }
            if (isDisabled.value || !droppable.value) {
              return;
            }
            dragging.value = false;
          });
        });
        input.value.addEventListener("dragover", (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          if (isDisabled.value || !droppable.value) {
            return;
          }
          if (dragging.value !== true) {
            dragging.value = true;
          }
        });
        input.value.addEventListener("drop", (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          if (isDisabled.value || !droppable.value) {
            return;
          }
          handleDrop(e2);
          dragging.value = false;
        });
        nextTick(() => {
          initPad();
          window.addEventListener("resize", handleResizeDebounce);
        });
        watch(maxFontSize, () => {
          adjustFontSize();
        }, {
          flush: "post"
        });
        watch(modes, () => {
          initPad();
          setDefaultMode(true);
        });
        watch(available, () => {
          nextTick(() => {
            initPad();
          });
        }, {
          flush: "post"
        });
        watch(color, () => {
          if (pad2.value) {
            setDrawColor();
          }
          if (mode.value === "upload" && created.value && !creating.value) {
            uploadToImage();
          }
        });
        watch(columns2, () => {
          setLastWidth();
          nextTick(() => {
            handleResize();
            if (mode.value === "upload" && created.value && !creating.value) {
              uploadToImage();
            }
          });
        });
        watch(mode, () => {
          clearSignature();
        });
        watch([height, maxWidth], () => {
          resizePad();
          adjustFontSize();
        }, {
          flush: "post"
        });
        watch([text2, fontFamily], () => {
          nextTick(() => {
            adjustFontSize();
          });
        }, {
          flush: "post"
        });
        watch(text2, () => {
          debounceTransform(typingToImage, 1e3);
        }, {
          flush: "post"
        });
        watch(fonts, () => {
          if (autoload.value) {
            loadFonts();
          }
        });
      });
      onBeforeUnmount(() => {
        window.removeEventListener("resize", handleResizeDebounce);
      });
      return {
        mode$,
        font$,
        input$,
        preview$,
        pad$,
        file$,
        upload$,
        uploadButton$,
        mode,
        fontFamily,
        fontWeight,
        color,
        text: text2,
        fontSize,
        pad: pad2,
        image: image2,
        created,
        creating,
        dragging,
        drawn,
        drawing,
        redos,
        undosLeft,
        width,
        lastWidth,
        fontFamilies,
        fontWeights,
        uploaded,
        processing,
        droppable,
        resolvedModes,
        resolvedFonts,
        fileAccept,
        showLine,
        showInput,
        showPlaceholder,
        showUploadContainer,
        showUpload,
        showPreview,
        showPad,
        showUndos,
        showColors,
        showModes,
        showFonts,
        showClear,
        tabindex,
        placeholderText,
        dndText,
        uploadButtonText,
        imgAltText,
        imgTitleText,
        fontText,
        undoText,
        redoText,
        modeSelectorAria,
        fontSelectorAria,
        wrapperAriaLabel,
        inputAriaLabel,
        padAriaLabel,
        colorAriaLabel,
        clearAriaLabel,
        padWidth,
        padHeight,
        padStyle,
        wrapperStyle,
        inputStyle,
        lineStyle,
        initPad,
        resizePad,
        drawingToImage,
        typingToImage,
        uploadToImage,
        undo,
        redo,
        clearSignature,
        clearDrawnSignature,
        loadFonts,
        setDrawColor,
        adjustFontSize,
        hexToRgb,
        checkFileExt,
        checkFileSize,
        setWidth,
        setLastWidth,
        setDefaultMode,
        setDefaultFont,
        setDefaultColor,
        setFont,
        handleInput,
        handleModeSelect,
        handleColorSelect,
        handleFontSelect,
        handleClear,
        handleUndo,
        handleRedo,
        handleSelectClick,
        handleFileSelect,
        handleDrop,
        handleMouseLeave,
        handleResize,
        handleResizeDebounce
      };
    }
    var SignatureElement = {
      name: "SignatureElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "text",
          private: true
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        default: {
          required: false,
          type: [String, Number, Object],
          localized: true,
          default: null
        },
        debounce: {
          required: false,
          type: [Number],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        readonly: {
          required: false,
          type: [Boolean],
          default: false
        },
        modes: {
          required: false,
          type: [Array],
          default: () => ["draw", "type", "upload"]
        },
        fonts: {
          required: false,
          type: [Array],
          default: () => ["Caveat@400", "Sacramento@400", "Dancing Script@400"]
        },
        autoload: {
          required: false,
          type: [Boolean],
          default: true
        },
        minFontSize: {
          required: false,
          type: [Number],
          default: 10
        },
        maxFontSize: {
          required: false,
          type: [Number],
          default: 60
        },
        colors: {
          required: false,
          type: [Array],
          default: () => ["#000000", "#2558b2", "#f22f30"]
        },
        invertColors: {
          required: false,
          type: [Array],
          default: () => ["#000000"]
        },
        maxWidth: {
          required: false,
          type: [Number, String],
          default: "auto"
        },
        height: {
          required: false,
          type: [Number],
          default: 160
        },
        uploadWidth: {
          required: false,
          type: [Number],
          default: 480
        },
        uploadHeight: {
          required: false,
          type: [Number],
          default: 160
        },
        maxSize: {
          required: false,
          type: [Number],
          default: 2048
        },
        accept: {
          required: false,
          type: [Array],
          default: () => ["jpg", "png", "svg"]
        },
        placeholder: {
          required: false,
          type: [String, Object, Boolean],
          localized: true,
          default: null
        },
        line: {
          required: false,
          type: [Boolean],
          default: true
        },
        canClear: {
          required: false,
          type: [Boolean],
          default: true
        },
        canUndo: {
          required: false,
          type: [Boolean],
          default: true
        },
        canDrop: {
          required: false,
          type: [Boolean],
          default: true
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$1c, base$P, base$C, base$14, base$D, base$L, base$I, base$t, useSignature, signature, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$s, base$R, base$F, base$T];
        context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$7 = function base2(props, context, dependencies2) {
      var {
        lazy
      } = toRefs(props);
      var value = dependencies2.value;
      var handleUpdate = (val) => {
        if (lazy.value) {
          return;
        }
        value.value = val;
      };
      return {
        handleUpdate
      };
    };
    var SliderElement = {
      name: "SliderElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "slider",
          private: true
        },
        default: {
          required: false,
          type: [Number, Array],
          default: 0
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        min: {
          required: false,
          type: [Number],
          default: 0
        },
        max: {
          required: false,
          type: [Number],
          default: 100
        },
        step: {
          required: false,
          type: [Number],
          default: 1
        },
        tooltips: {
          required: false,
          type: [Boolean],
          default: true
        },
        showTooltip: {
          required: false,
          type: [String],
          default: "always"
        },
        tooltipPosition: {
          required: false,
          type: [String],
          default: null
        },
        merge: {
          required: false,
          type: [Number],
          default: -1
        },
        format: {
          required: false,
          type: [Object, Function],
          default: null
        },
        orientation: {
          required: false,
          type: [String],
          default: "horizontal"
        },
        direction: {
          required: false,
          type: [String],
          default: "ltr"
        },
        lazy: {
          required: false,
          type: [Boolean],
          default: true,
          private: true
        },
        extendOptions: {
          required: false,
          type: [Object],
          default: () => ({})
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, min$2, base$U, base$1c, base$P, base$C, slider, base$L, slider$1, base$14, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$u, base$7, base$R, base$F, base$T];
        context.slots = ["label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$6 = function base2(props, context, dependencies2) {
      var {
        content
      } = toRefs(props);
      var {
        fieldSlots,
        el$
      } = dependencies2;
      var isHtml = computed(() => {
        return typeof resolvedContent.value === "string";
      });
      var resolvedContent = computed(() => {
        return typeof content.value === "function" ? content.value(el$.value) : content.value;
      });
      var componentContent = computed(() => {
        var _content$value, _content$value2;
        if (!((_content$value = content.value) !== null && _content$value !== void 0 && _content$value.render) && !((_content$value2 = content.value) !== null && _content$value2 !== void 0 && _content$value2.template)) {
          return content.value;
        }
        return resolveComponent2(content.value);
      });
      var slotContent = computed(() => {
        var _fieldSlots$value$def, _fieldSlots$value$def2;
        if (!((_fieldSlots$value$def = fieldSlots.value.default) !== null && _fieldSlots$value$def !== void 0 && _fieldSlots$value$def.render) && !((_fieldSlots$value$def2 = fieldSlots.value.default) !== null && _fieldSlots$value$def2 !== void 0 && _fieldSlots$value$def2.template)) {
          return fieldSlots.value.default;
        }
        return resolveComponent2(fieldSlots.value.default);
      });
      var resolveComponent2 = (component) => {
        component = _objectSpread2$1({}, component);
        if (!component.props) {
          component.props = ["el$"];
        } else if (Array.isArray(component.props) && component.props.indexOf("el$") === -1) {
          component.props.push("el$");
        } else if (!Array.isArray(component.props) && !component.props.el$) {
          component.props["el$"] = {
            type: Object,
            required: false,
            default: () => ({})
          };
        }
        return component;
      };
      return {
        isHtml,
        componentContent,
        slotContent,
        resolvedContent
      };
    };
    var StaticElement = {
      name: "StaticElement",
      mixins: [BaseElement, HasView],
      emits: ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "static",
          private: true
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        content: {
          required: false,
          type: [String, Object, Function],
          default: ""
        },
        wrap: {
          required: false,
          type: [Boolean],
          default: true
        },
        tag: {
          required: false,
          type: [String],
          default: void 0
        },
        allowHtml: {
          required: false,
          type: [Boolean],
          default: true
        },
        href: {
          required: false,
          type: [String],
          default: void 0
        },
        target: {
          required: false,
          type: [String],
          default: void 0
        },
        src: {
          required: false,
          type: [String],
          default: void 0
        },
        alt: {
          required: false,
          type: [String],
          default: void 0
        },
        title: {
          required: false,
          type: [String],
          default: void 0
        },
        width: {
          required: false,
          type: [String],
          default: void 0
        },
        height: {
          required: false,
          type: [String],
          default: void 0
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        align: {
          required: false,
          type: [String],
          default: void 0
        },
        top: {
          required: false,
          type: [String, Number],
          default: 0
        },
        bottom: {
          required: false,
          type: [String, Number],
          default: 0
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, static_$1, base$1c, static_$2, base$14, base$$, base$Z, base$Y, base$1a, base$_, base$X, base$U, static_$3, base$T, base$6];
        context.slots = ["default", "label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, static_(props, context));
      }
    };
    var base$5 = function base2(props, context, dependencies2) {
      var fire = dependencies2.fire;
      var el$ = dependencies2.el$;
      var handleTag = (searchQuery) => {
        fire("tag", searchQuery, el$.value);
      };
      return {
        handleTag
      };
    };
    var TagsElement = {
      name: "TagsElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "select", "deselect", "search-change", "open", "close", "tag", "clear", "paste", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "tags",
          private: true
        },
        default: {
          required: false,
          type: [Array],
          default: () => []
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        floating: {
          required: false,
          type: [String, Boolean, Object],
          localized: true,
          default: null
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        placeholder: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        onSelect: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onDeselect: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onSearchChange: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onOpen: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onClose: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onTag: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onClear: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onPaste: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        items: {
          required: false,
          type: [Object, Array, Function, String],
          localized: true,
          default: () => ({})
        },
        labelProp: {
          type: [String],
          required: false,
          default: "label"
        },
        valueProp: {
          type: [String],
          required: false,
          default: "value"
        },
        dataKey: {
          type: [String],
          required: false,
          default: void 0
        },
        searchParam: {
          type: [String],
          required: false,
          default: "query"
        },
        search: {
          required: false,
          type: [Boolean],
          default: false
        },
        trackBy: {
          type: [String, Array],
          required: false,
          default: "label"
        },
        strict: {
          type: [Boolean],
          required: false,
          default: true
        },
        breakTags: {
          type: [Boolean],
          required: false,
          default: false
        },
        create: {
          required: false,
          type: [Boolean],
          default: false
        },
        appendNewOption: {
          type: [Boolean],
          required: false,
          default: true
        },
        addOptionOn: {
          type: [Array],
          required: false,
          default: () => ["enter"]
        },
        allowAbsent: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        object: {
          type: [Boolean],
          required: false,
          default: false
        },
        limit: {
          type: [Number],
          required: false,
          default: -1
        },
        max: {
          type: [Number],
          required: false,
          default: -1
        },
        groups: {
          type: [Boolean],
          required: false,
          default: false
        },
        groupLabel: {
          type: [String],
          required: false,
          default: "label"
        },
        groupOptions: {
          type: [String],
          required: false,
          default: "items"
        },
        groupHideEmpty: {
          type: [Boolean],
          required: false,
          default: false
        },
        groupSelect: {
          type: [Boolean],
          required: false,
          default: true
        },
        openDirection: {
          type: [String],
          required: false,
          default: "bottom"
        },
        appendToBody: {
          type: [Boolean],
          required: false,
          default: false,
          native: false
        },
        appendTo: {
          type: [String],
          required: false,
          default: void 0,
          native: false
        },
        canClear: {
          type: [Boolean],
          required: false,
          default: true
        },
        clearOnSelect: {
          type: [Boolean],
          required: false,
          default: true
        },
        closeOnSelect: {
          type: [Boolean],
          required: false,
          default: true
        },
        closeOnDeselect: {
          type: [Boolean],
          required: false,
          default: false
        },
        clearOnRefetch: {
          type: [Boolean],
          required: false,
          default: false
        },
        delay: {
          type: [Number],
          required: false,
          default: -1
        },
        minChars: {
          type: [Number],
          required: false,
          default: 0
        },
        resolveOnLoad: {
          type: [Boolean],
          required: false,
          default: true
        },
        filterResults: {
          type: [Boolean],
          required: false,
          default: true
        },
        clearOnSearch: {
          type: [Boolean],
          required: false,
          default: false
        },
        hideSelected: {
          type: [Boolean],
          required: false,
          default: true
        },
        showOptions: {
          type: [Boolean],
          required: false,
          default: true
        },
        caret: {
          type: [Boolean],
          required: false,
          default: true
        },
        loading: {
          type: [Boolean],
          required: false,
          default: false
        },
        noOptionsText: {
          type: [String, Object],
          required: false,
          default: void 0,
          "@default": "locale.multiselect.noOptions",
          localized: true
        },
        noResultsText: {
          type: [String, Object],
          required: false,
          default: void 0,
          "@default": "locale.multiselect.noResults",
          localized: true
        },
        autocomplete: {
          type: [String],
          required: false
        },
        inputType: {
          type: [String],
          required: false,
          default: "text"
        },
        extendOptions: {
          required: false,
          type: [Object],
          default: () => ({})
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, tags$4, base$O, base$S, array$1, base$U, base$G, base$1c, tags$5, base$C, base$D, base$H, tags$1, base$L, tags$2, base$14, array, tags$3, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$d, base$5, base$c, tags, base$R, base$F, base$T, base$t];
        context.slots = ["tag", "option", "placeholder", "group-label", "before-list", "after-list", "no-results", "no-options", "caret", "spinner", "clear", "label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$4 = function base2(props, context, dependencies2) {
      var {
        autogrow
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var input = dependencies2.input;
      var value = dependencies2.value;
      var autosize = () => {
        if (!autogrow.value) {
          return;
        }
        form$.value.$vueform.services.autosize.update(input.value);
      };
      watch(autogrow, (newValue) => {
        if (newValue) {
          form$.value.$vueform.services.autosize(input.value);
        } else {
          form$.value.$vueform.services.autosize.destroy(input.value);
        }
      });
      watch(value, () => {
        autosize();
      });
      onMounted(() => {
        if (autogrow.value) {
          nextTick(() => {
            form$.value.$vueform.services.autosize(input.value);
          });
        }
      });
      return {
        autosize
      };
    };
    var multilingual = function multilingual2(props, context, dependencies2) {
      var {
        autosize
      } = base$4(props, context, dependencies2);
      var form$ = dependencies2.form$;
      onMounted(() => {
        form$.value.on("language", () => {
          autosize();
        });
      });
      return {
        autosize
      };
    };
    var TextareaElement = {
      name: "TextareaElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "blur", "focus", "keydown", "keyup", "keypress", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "textarea",
          private: true
        },
        default: {
          required: false,
          type: [String, Number, Object],
          localized: true,
          default: null
        },
        addons: {
          required: false,
          type: [Object],
          localized: true,
          default: () => ({})
        },
        autogrow: {
          required: false,
          type: [Boolean],
          default: true
        },
        rows: {
          required: false,
          type: [Number],
          default: 3
        },
        debounce: {
          required: false,
          type: [Number],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        floating: {
          required: false,
          type: [String, Boolean, Object],
          localized: true,
          default: null
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        placeholder: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        readonly: {
          required: false,
          type: [Boolean],
          default: false
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        onBlur: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onKeydown: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onKeyup: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onKeypress: {
          required: false,
          type: [Function],
          default: null,
          private: true
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$G, base$1c, base$P, base$w, text$1, base$14, text$2, base$L, base$I, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$m, base$4, base$s, base$b, base$R, base$F, base$T, base$9, base$t];
        context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var TextElement = {
      name: "TextElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "blur", "focus", "keydown", "keyup", "keypress", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "text",
          private: true
        },
        default: {
          required: false,
          type: [String, Number, Object],
          localized: true,
          default: null
        },
        debounce: {
          required: false,
          type: [Number],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        floating: {
          required: false,
          type: [String, Boolean, Object],
          localized: true,
          default: null
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        placeholder: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        readonly: {
          required: false,
          type: [Boolean],
          default: false
        },
        inputType: {
          required: false,
          type: [String],
          default: "text"
        },
        forceNumbers: {
          required: false,
          type: [Boolean],
          default: null
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        addons: {
          required: false,
          type: [Object],
          localized: true,
          default: () => ({})
        },
        autocomplete: {
          required: false,
          type: [String, Number],
          default: null
        },
        loading: {
          type: [Boolean],
          required: false,
          default: false
        },
        onBlur: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onKeydown: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onKeyup: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onKeypress: {
          required: false,
          type: [Function],
          default: null,
          private: true
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$G, base$1c, base$P, base$w, text$1, base$14, text$2, base$H, base$L, base$I, text, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$m, base$s, base$b, base$R, base$F, base$T, base$9, base$t];
        context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var ToggleElement = {
      name: "ToggleElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "toggle",
          private: true
        },
        default: {
          required: false,
          type: [String, Number, Boolean],
          default: void 0
          // falseValue
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        text: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        labels: {
          required: false,
          type: [Object],
          localized: true,
          default: () => ({})
        },
        trueValue: {
          required: false,
          type: [Boolean, String, Number],
          default: true
        },
        falseValue: {
          required: false,
          type: [Boolean, String, Number],
          default: false
        },
        extendOptions: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        align: {
          required: false,
          type: [String],
          default: void 0
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, boolean, base$U, base$1c, base$P, toggle, base$C, base$14, base$D, base$L, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$u, base$z, toggle$1, base$F, base$T, base$A];
        context.slots = ["default", "label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$3 = function base2(props, context, dependencies2) {
      var {
        endpoint,
        method
      } = toRefs(props);
      var form$ = dependencies2.form$;
      var input = dependencies2.input;
      var focused = ref(false);
      var editorEndpoint = computed(() => {
        return endpoint.value || form$.value.$vueform.config.endpoints.attachment.url;
      });
      var editorMethod = computed(() => {
        return method.value || form$.value.$vueform.config.endpoints.attachment.method;
      });
      onMounted(() => {
        input.value.editor$.addEventListener("focus", () => {
          focused.value = true;
        });
        input.value.editor$.addEventListener("blur", () => {
          focused.value = false;
        });
      });
      return {
        editorEndpoint,
        editorMethod,
        focused
      };
    };
    var base$2 = function base2(props, context, dependencies2) {
      var fire = dependencies2.fire;
      var listeners = dependencies2.listeners;
      var handleAlert = (message) => {
        fire("alert", message);
        if (!listeners.value.alert) {
          alert(message);
        }
      };
      return {
        handleAlert
      };
    };
    var EditorElement = {
      name: "EditorElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "blur", "alert", "error", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "editor",
          private: true
        },
        default: {
          required: false,
          type: [String, Number, Object],
          localized: true,
          default: null
        },
        debounce: {
          required: false,
          type: [Number],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        placeholder: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        onError: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onAlert: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        accept: {
          required: false,
          type: [Array],
          default: () => []
        },
        acceptMimes: {
          required: false,
          type: [Array],
          default: () => []
        },
        endpoint: {
          required: false,
          type: [String, Function, Promise],
          default: null,
          "@default": "config.endpoints.attachment.url"
        },
        method: {
          required: false,
          type: [String],
          default: null,
          "@default": "config.endpoints.attachment.method"
        },
        hideTools: {
          required: false,
          type: [Array],
          default: () => []
        },
        onBlur: {
          required: false,
          type: [Function],
          default: null,
          private: true
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$1c, base$P, text$1, base$14, text$2, base$L, base$I, editor, base$$, base$J, base$Z, base$Y, base$3, base$1a, base$_, base$X, base$m, base$2, base$n, base$b, base$R, base$F, editor$1, base$t];
        context.slots = ["label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, base$N(props, context));
      }
    };
    var base$1 = function base2(props, context, dependencies2) {
      var form$ = dependencies2.form$;
      var language = computed(() => {
        return form$.value.selectedLanguage;
      });
      var languages = computed(() => {
        return keys_1(form$.value.options.languages);
      });
      return {
        language,
        languages
      };
    };
    var TTextareaElement = {
      name: "TTextareaElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "blur", "focus", "keydown", "keyup", "keypress", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "t-textarea",
          private: true
        },
        default: {
          required: false,
          type: [Object, String, Number],
          localized: true,
          default: null
        },
        addons: {
          required: false,
          type: [Object],
          localized: true,
          default: () => ({})
        },
        autogrow: {
          required: false,
          type: [Boolean],
          default: true
        },
        rows: {
          required: false,
          type: [Number],
          default: 3
        },
        debounce: {
          required: false,
          type: [Number],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        floating: {
          required: false,
          type: [String, Boolean, Object],
          localized: true,
          default: null
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        placeholder: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        readonly: {
          required: false,
          type: [Boolean],
          default: false
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        onBlur: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onKeydown: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onKeyup: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onKeypress: {
          required: false,
          type: [Function],
          default: null,
          private: true
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$U, base$G, base$1c, base$P, base$w, base$1, multilingual$6, multilingual$2, multilingual$7, base$14, multilingual$3, multilingual$5, multilingual$1, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$m, multilingual, base$s, base$b, base$R, multilingual$4, base$T, base$9, base$t];
        context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
        return _objectSpread2$1({}, multilingual$8(props, context));
      }
    };
    var TTextElement = {
      name: "TTextElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "blur", "focus", "keydown", "keyup", "keypress", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "t-text",
          private: true
        },
        default: {
          required: false,
          type: [Object, String, Number],
          localized: true,
          default: void 0
        },
        addons: {
          required: false,
          type: [Object],
          localized: true,
          default: () => ({})
        },
        autocomplete: {
          required: false,
          type: [String, Number],
          default: null
        },
        debounce: {
          required: false,
          type: [Number],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        floating: {
          required: false,
          type: [String, Boolean, Object],
          localized: true,
          default: null
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        inputType: {
          required: false,
          type: [String],
          default: "text"
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        },
        placeholder: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        readonly: {
          required: false,
          type: [Boolean],
          default: false
        },
        loading: {
          type: [Boolean],
          required: false,
          default: false
        },
        onBlur: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onKeydown: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onKeyup: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onKeypress: {
          required: false,
          type: [Function],
          default: null,
          private: true
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$U, base$G, base$1c, base$P, base$w, base$1, multilingual$6, multilingual$2, multilingual$7, base$14, multilingual$3, base$H, multilingual$5, multilingual$1, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$m, base$s, base$b, base$R, multilingual$4, base$T, base$9, base$t];
        context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
        return _objectSpread2$1({}, multilingual$8(props, context));
      }
    };
    var TEditorElement = {
      name: "TEditorElement",
      mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
      emits: ["change", "blur", "alert", "error", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
      props: {
        type: {
          required: false,
          type: [String],
          default: "t-editor",
          private: true
        },
        default: {
          required: false,
          type: [Object, String, Number],
          localized: true,
          default: null
        },
        debounce: {
          required: false,
          type: [Number],
          default: null
        },
        disabled: {
          required: false,
          type: [Boolean],
          default: false
        },
        id: {
          required: false,
          type: [String],
          default: null
        },
        placeholder: {
          required: false,
          type: [String, Object],
          localized: true,
          default: null
        },
        onError: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        onAlert: {
          required: false,
          type: [Function],
          default: null,
          private: true
        },
        accept: {
          required: false,
          type: [Array],
          default: null
        },
        acceptMimes: {
          required: false,
          type: [Array],
          default: null
        },
        endpoint: {
          required: false,
          type: [String, Function, Promise],
          default: null,
          "@default": "config.endpoints.attachment.url"
        },
        method: {
          required: false,
          type: [String],
          default: null,
          "@default": "config.endpoints.attachment.method"
        },
        hideTools: {
          required: false,
          type: [Array],
          default: () => []
        },
        onBlur: {
          required: false,
          type: [Function],
          default: null,
          private: true
        }
      },
      setup(props, ctx) {
        var context = _objectSpread2$1({}, ctx);
        context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$U, base$1c, base$P, base$1, multilingual$6, multilingual$2, multilingual$7, base$14, multilingual$3, multilingual$5, teditor, base$$, base$J, base$Z, base$Y, base$3, base$1a, base$_, base$X, base$m, base$2, base$n, base$b, base$R, multilingual$4, base$T, base$t];
        context.slots = ["label", "info", "description", "before", "between", "after"];
        return _objectSpread2$1({}, multilingual$8(props, context));
      }
    };
    var CheckboxgroupCheckbox = {
      name: "CheckboxgroupCheckbox",
      props: {
        item: {
          type: [Object, String, Number],
          required: true
        },
        value: {
          type: [String, Number],
          required: true
        },
        items: {
          type: [Object, Array],
          required: true
        },
        index: {
          type: [Number],
          required: true
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        }
      },
      setup(props, context) {
        var {
          value,
          item
        } = toRefs(props);
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var isDisabled = computed(() => {
          var _item$value;
          return el$.value.disabledItems.map((i2) => String(i2)).indexOf(String(value.value)) !== -1 || el$.value.isDisabled || !!((_item$value = item.value) !== null && _item$value !== void 0 && _item$value.disabled);
        });
        var checked = computed(() => {
          return el$.value.value.indexOf(String(value.value)) !== -1 || el$.value.value.indexOf(Number(value.value)) !== -1;
        });
        var id = computed(() => {
          return "".concat(el$.value.fieldId, "-").concat(value.value);
        });
        var name2 = computed(() => {
          return "".concat(el$.value.path, "-").concat(value.value);
        });
        var handleKeydown = (e2) => {
          if (["ArrowRight", "ArrowDown"].indexOf(e2.key) !== -1) {
            e2.preventDefault();
            var next = e2.target.nextElementSibling;
            if ((next === null || next === void 0 ? void 0 : next.getAttribute("role")) === "checkbox") {
              next.focus();
            }
          } else if (["ArrowLeft", "ArrowUp"].indexOf(e2.key) !== -1) {
            e2.preventDefault();
            var previous = e2.target.previousElementSibling;
            if ((previous === null || previous === void 0 ? void 0 : previous.getAttribute("role")) === "checkbox") {
              previous.focus();
            }
          }
        };
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme,
          isDisabled,
          id,
          name: name2,
          checked,
          handleKeydown
        };
      }
    };
    var base = function base2(props, context, dependencies2) {
      var el$ = dependencies2.el$;
      var form$ = dependencies2.form$;
      var visible = computed(() => {
        return el$.value.stage > 0;
      });
      var hasLink = computed(() => {
        return el$.value.link && el$.value.clickable;
      });
      var hasError = computed(() => {
        return el$.value.hasUploadError;
      });
      var link = computed(() => {
        return el$.value.link;
      });
      var filename = computed(() => {
        var filename2 = el$.value.filename && typeof el$.value.filename === "string" ? el$.value.filename.split("\\").pop().split("/").pop() : el$.value.filename;
        if (filename2) {
          filename2 = filename2.split("?")[0];
        }
        return filename2;
      });
      var clickable = computed(() => {
        return el$.value.clickable;
      });
      var uploaded = computed(() => {
        return el$.value.stage > 1;
      });
      var uploading = computed(() => {
        return el$.value.uploading;
      });
      var progress = computed(() => {
        return el$.value.progress;
      });
      var canRemove = computed(() => {
        return (el$.value.canRemove || el$.value.uploading) && !el$.value.isDisabled;
      });
      var canUploadTemp = computed(() => {
        return el$.value.canUploadTemp;
      });
      var uploadText = computed(() => {
        return form$.value.translations.vueform.elements.file.upload;
      });
      var ariaLabelledby = computed(() => {
        return el$.value.embed ? void 0 : el$.value.labelId;
      });
      var upload = () => {
        el$.value.uploadTemp();
      };
      var remove2 = () => {
        if (uploading.value) {
          el$.value.handleAbort();
        } else {
          el$.value.handleRemove();
        }
      };
      var handleKeyup = /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator(function* (e2) {
          switch (e2.key) {
            case "Backspace":
            case "Delete":
              remove2();
              if (!el$.value.canSelect) {
                return;
              }
              yield nextTick();
              document.querySelector("#".concat(el$.value.fieldId)).focus();
              break;
            case "Enter":
              if (el$.value.auto) {
                return;
              }
              upload();
              break;
          }
        });
        return function handleKeyup2(_x) {
          return _ref.apply(this, arguments);
        };
      }();
      return {
        visible,
        hasLink,
        hasError,
        link,
        filename,
        clickable,
        uploaded,
        uploading,
        progress,
        canRemove,
        canUploadTemp,
        uploadText,
        ariaLabelledby,
        upload,
        remove: remove2,
        handleKeyup
      };
    };
    var FilePreview = {
      name: "FilePreview",
      props: {
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        }
      },
      setup(props, context) {
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var {
          visible,
          hasLink,
          hasError,
          link,
          filename,
          clickable,
          uploaded,
          uploading,
          progress,
          canRemove,
          canUploadTemp,
          uploadText,
          ariaLabelledby,
          upload,
          remove: remove2,
          handleKeyup
        } = base(props, context, {
          el$,
          form$
        });
        var preview = computed(() => {
          return el$.value.preview;
        });
        var ariaPlaceholder = computed(() => {
          var text2 = el$.value.embed && el$.value.View !== "gallery" ? void 0 : filename.value;
          if (hasError.value) {
            if (text2) {
              text2 += ", error";
            } else {
              text2 = "error";
            }
          }
          return text2;
        });
        var ariaRoledescription = computed(() => {
          return el$.value.embed && el$.value.View !== "gallery" || uploaded.value || el$.value.auto ? void 0 : uploadText.value;
        });
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme,
          visible,
          hasLink,
          hasError,
          link,
          filename,
          clickable,
          uploaded,
          uploading,
          progress,
          canRemove,
          canUploadTemp,
          uploadText,
          preview,
          ariaLabelledby,
          ariaPlaceholder,
          ariaRoledescription,
          upload,
          remove: remove2,
          handleKeyup
        };
      }
    };
    var RadiogroupRadio = {
      name: "RadiogroupRadio",
      props: {
        item: {
          type: [Object, String, Number],
          required: true
        },
        value: {
          type: [String, Number],
          required: true
        },
        items: {
          type: [Object, Array],
          required: true
        },
        index: {
          type: [Number],
          required: true
        },
        attrs: {
          required: false,
          type: [Object],
          default: () => ({})
        }
      },
      setup(props, context) {
        var {
          value,
          item
        } = toRefs(props);
        var {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme
        } = base$10(props, context);
        var isDisabled = computed(() => {
          var _item$value;
          return el$.value.disabledItems.map((i2) => String(i2)).indexOf(String(value.value)) !== -1 || el$.value.isDisabled || !!((_item$value = item.value) !== null && _item$value !== void 0 && _item$value.disabled);
        });
        var checked = computed(() => {
          return el$.value.value === String(value.value) || el$.value.value === Number(value.value);
        });
        var id = computed(() => {
          return "".concat(el$.value.fieldId, "-").concat(value.value);
        });
        var name2 = computed(() => {
          return el$.value.path;
        });
        var handleKeydown = (e2) => {
          if (["ArrowRight", "ArrowDown"].indexOf(e2.key) !== -1) {
            e2.preventDefault();
            var next = e2.target.nextElementSibling;
            if ((next === null || next === void 0 ? void 0 : next.getAttribute("role")) === "radio") {
              next.focus();
            }
          } else if (["ArrowLeft", "ArrowUp"].indexOf(e2.key) !== -1) {
            e2.preventDefault();
            var previous = e2.target.previousElementSibling;
            if ((previous === null || previous === void 0 ? void 0 : previous.getAttribute("role")) === "radio") {
              previous.focus();
            }
          }
        };
        return {
          el$,
          form$,
          Size,
          View,
          classesInstance,
          classes: classes2,
          Templates,
          template,
          theme,
          isDisabled,
          id,
          name: name2,
          checked,
          handleKeydown
        };
      }
    };
    var index$3 = {
      Vueform: VueformComponent,
      FormErrors,
      FormMessages,
      FormLanguages,
      FormLanguage,
      FormTabs,
      FormTab,
      FormSteps,
      FormStepsControls,
      FormStepsControl,
      FormStep,
      FormElements,
      ElementLayout,
      ElementLayoutInline,
      ElementLoader,
      ElementLabelFloating,
      ElementLabel,
      ElementInfo,
      ElementDescription,
      ElementError,
      ElementMessage,
      ElementText,
      DragAndDrop,
      ElementAddon,
      ElementAddonOptions,
      DatepickerWrapper,
      EditorWrapper,
      ButtonElement,
      CaptchaElement,
      CheckboxElement,
      CheckboxgroupElement,
      DateElement,
      DatesElement,
      FileElement,
      GenericElement,
      GroupElement,
      HiddenElement,
      ListElement,
      LocationElement,
      MultifileElement,
      MultiselectElement,
      ObjectElement,
      PhoneElement,
      RadioElement,
      RadiogroupElement,
      SelectElement,
      SignatureElement,
      SliderElement,
      StaticElement,
      TagsElement,
      TextareaElement,
      TextElement,
      ToggleElement,
      EditorElement,
      TTextareaElement,
      TTextElement,
      TEditorElement,
      CheckboxgroupCheckbox,
      FilePreview,
      RadiogroupRadio
    };
    var components = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      "default": index$3,
      Vueform: VueformComponent,
      FormErrors,
      FormMessages,
      FormLanguages,
      FormLanguage,
      FormTabs,
      FormTab,
      FormSteps,
      FormStepsControls,
      FormStepsControl,
      FormStep,
      FormElements,
      ElementLayout,
      ElementLayoutInline,
      ElementLoader,
      ElementLabelFloating,
      ElementLabel,
      ElementInfo,
      ElementDescription,
      ElementError,
      ElementMessage,
      ElementText,
      DragAndDrop,
      ElementAddon,
      ElementAddonOptions,
      DatepickerWrapper,
      EditorWrapper,
      ButtonElement,
      CaptchaElement,
      CheckboxElement,
      CheckboxgroupElement,
      DateElement,
      DatesElement,
      FileElement,
      GenericElement,
      GroupElement,
      HiddenElement,
      ListElement,
      LocationElement,
      MultifileElement,
      MultiselectElement,
      ObjectElement,
      PhoneElement,
      RadioElement,
      RadiogroupElement,
      SelectElement,
      SignatureElement,
      SliderElement,
      StaticElement,
      TagsElement,
      TextareaElement,
      TextElement,
      ToggleElement,
      EditorElement,
      TTextareaElement,
      TTextElement,
      TEditorElement,
      CheckboxgroupCheckbox,
      FilePreview,
      RadiogroupRadio
    });
    installer(void 0, {
      Vueform: VueformComponent,
      FormElements
    }, {}, {
      moment: hooks
    });
    var vueform = installer(void 0, _objectSpread2$1({}, components), _objectSpread2$1({}, rules), {
      moment: hooks
    });
    const en$1 = {
      "vueform": {
        "elements": {
          "list": {
            "add": "+ Add",
            "remove": "&times;"
          },
          "file": {
            "defaultName": "File",
            "dndTitle": "Upload file",
            "dndDescription": "Drop file or click here to upload",
            "removeConfirm": "By removing the file it will be permanently deleted. Are you sure to continue?",
            "select": "Select file",
            "upload": "Upload"
          },
          "multifile": {
            "uploadButton": "Upload files",
            "dndTitle": "Upload files",
            "dndDescription": "Drop files or click here to upload"
          },
          "gallery": {
            "uploadButton": "Upload images",
            "dndTitle": "Upload images",
            "dndDescription": "Drop images or click here to upload"
          },
          "phone": {
            "ariaLabel": "Select a country"
          },
          "signature": {
            "type": "Type",
            "draw": "Draw",
            "upload": "Upload",
            "font": "Select typeface",
            "fontPlaceholder": "Your Name",
            "placeholder": "Sign here",
            "unsupportedFormat": "Unsupported file format. Accepted extenions are: :extensions",
            "maxSizeError": "Max file size is :max KBs",
            "imgAlt": "Signature",
            "imgTitle": "Signature",
            "undo": "Undo",
            "redo": "Redo",
            "dnd": "Drop an image here or",
            "uploadButton": "Select image",
            "modeSelectorAriaLabel": "Select signature mode",
            "fontSelectorAriaLabel": "Select typeface",
            "wrapperAriaLabel": "Signature input",
            "inputAriaLabel": "Type your signature here",
            "padAriaLabel": "Draw your signature in the box. Seek assistance if you need to.",
            "clearAriaLabel": "Clear signature",
            "colorAriaLabel": "Select color: "
          }
        },
        "steps": {
          "finish": "Finish",
          "next": "Next",
          "previous": "Previous"
        },
        "editor": {
          "acceptedMimesError": "Accepted mimes are: :mimes",
          "acceptedExtensionsError": "Accepted extenions are: :extensions"
        },
        "datepicker": {
          "weekdays": {
            "shorthand": [
              "Sun",
              "Mon",
              "Tue",
              "Wed",
              "Thu",
              "Fri",
              "Sat"
            ],
            "longhand": [
              "Sunday",
              "Monday",
              "Tuesday",
              "Wednesday",
              "Thursday",
              "Friday",
              "Saturday"
            ]
          },
          "months": {
            "shorthand": [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec"
            ],
            "longhand": [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ]
          },
          "daysInMonth": [
            31,
            28,
            31,
            30,
            31,
            30,
            31,
            31,
            30,
            31,
            30,
            31
          ],
          "firstDayOfWeek": 0,
          "ordinal": function(nth) {
            var s2 = nth % 100;
            if (s2 > 3 && s2 < 21)
              return "th";
            switch (s2 % 10) {
              case 1:
                return "st";
              case 2:
                return "nd";
              case 3:
                return "rd";
              default:
                return "th";
            }
          },
          "rangeSeparator": " to ",
          "weekAbbreviation": "Wk",
          "scrollTitle": "Scroll to increment",
          "toggleTitle": "Click to toggle",
          "amPM": [
            "AM",
            "PM"
          ],
          "yearAriaLabel": "Year",
          "monthAriaLabel": "Month",
          "hourAriaLabel": "Hour",
          "minuteAriaLabel": "Minute"
        },
        "dateFormats": {
          "datetimeSeconds24": "YYYY-MM-DD HH:mm:ss",
          "datetimeSeconds12": "YYYY-MM-DD hh:mm:ss a",
          "datetime24": "YYYY-MM-DD HH:mm",
          "datetime12": "YYYY-MM-DD hh:mm a",
          "timeSeconds24": "HH:mm:ss",
          "timeSeconds12": "hh:mm:ss a",
          "time24": "HH:mm",
          "time12": "hh:mm a",
          "date": "YYYY-MM-DD"
        },
        "multiselect": {
          "multipleLabelOne": "1 option selected",
          "multipleLabelMore": ":options options selected",
          "noResults": "No options found",
          "noOptions": "The list is empty"
        },
        "defaultMessage": "Invalid field",
        "a11y": {
          "file": {
            "description": "Press Backspace to remove"
          },
          "list": {
            "remove": "Remove item button"
          }
        },
        "countries": {
          "AF": "Afghanistan",
          "AL": "Albania",
          "DZ": "Algeria",
          "AS": "American Samoa",
          "AD": "Andorra",
          "AO": "Angola",
          "AI": "Anguilla",
          "AG": "Antigua & Barbuda",
          "AR": "Argentina",
          "AM": "Armenia",
          "AW": "Aruba",
          "AC": "Ascension Island",
          "AU": "Australia",
          "AT": "Austria",
          "AZ": "Azerbaijan",
          "BS": "Bahamas",
          "BH": "Bahrain",
          "BD": "Bangladesh",
          "BB": "Barbados",
          "BY": "Belarus",
          "BE": "Belgium",
          "BZ": "Belize",
          "BJ": "Benin",
          "BM": "Bermuda",
          "BT": "Bhutan",
          "BO": "Bolivia",
          "BA": "Bosnia & Herzegovina",
          "BW": "Botswana",
          "BR": "Brazil",
          "IO": "British Indian Ocean Territory",
          "VG": "British Virgin Islands",
          "BN": "Brunei",
          "BG": "Bulgaria",
          "BF": "Burkina Faso",
          "BI": "Burundi",
          "KH": "Cambodia",
          "CM": "Cameroon",
          "CA": "Canada",
          "CV": "Cape Verde",
          "BQ": "Caribbean Netherlands",
          "KY": "Cayman Islands",
          "CF": "Central African Republic",
          "TD": "Chad",
          "CL": "Chile",
          "CN": "China",
          "CO": "Colombia",
          "KM": "Comoros",
          "CG": "Congo - Brazzaville",
          "CD": "Congo - Kinshasa",
          "CK": "Cook Islands",
          "CR": "Costa Rica",
          "CI": "Côte d’Ivoire",
          "HR": "Croatia",
          "CU": "Cuba",
          "CW": "Curaçao",
          "CY": "Cyprus",
          "CZ": "Czechia",
          "DK": "Denmark",
          "DJ": "Djibouti",
          "DM": "Dominica",
          "DO": "Dominican Republic",
          "EC": "Ecuador",
          "EG": "Egypt",
          "SV": "El Salvador",
          "GQ": "Equatorial Guinea",
          "ER": "Eritrea",
          "EE": "Estonia",
          "SZ": "Eswatini",
          "ET": "Ethiopia",
          "FK": "Falkland Islands (Islas Malvinas)",
          "FO": "Faroe Islands",
          "FJ": "Fiji",
          "FI": "Finland",
          "FR": "France",
          "GF": "French Guiana",
          "PF": "French Polynesia",
          "GA": "Gabon",
          "GM": "Gambia",
          "GE": "Georgia",
          "DE": "Germany",
          "GH": "Ghana",
          "GI": "Gibraltar",
          "GR": "Greece",
          "GL": "Greenland",
          "GD": "Grenada",
          "GP": "Guadeloupe",
          "GU": "Guam",
          "GT": "Guatemala",
          "GN": "Guinea",
          "GW": "Guinea-Bissau",
          "GY": "Guyana",
          "HT": "Haiti",
          "HN": "Honduras",
          "HK": "Hong Kong",
          "HU": "Hungary",
          "IS": "Iceland",
          "IN": "India",
          "ID": "Indonesia",
          "IR": "Iran",
          "IQ": "Iraq",
          "IE": "Ireland",
          "IL": "Israel",
          "IT": "Italy",
          "JM": "Jamaica",
          "JP": "Japan",
          "JO": "Jordan",
          "KZ": "Kazakhstan",
          "KE": "Kenya",
          "KI": "Kiribati",
          "XK": "Kosovo",
          "KW": "Kuwait",
          "KG": "Kyrgyzstan",
          "LA": "Laos",
          "LV": "Latvia",
          "LB": "Lebanon",
          "LS": "Lesotho",
          "LR": "Liberia",
          "LY": "Libya",
          "LI": "Liechtenstein",
          "LT": "Lithuania",
          "LU": "Luxembourg",
          "MO": "Macao",
          "MG": "Madagascar",
          "MW": "Malawi",
          "MY": "Malaysia",
          "MV": "Maldives",
          "ML": "Mali",
          "MT": "Malta",
          "MH": "Marshall Islands",
          "MQ": "Martinique",
          "MR": "Mauritania",
          "MU": "Mauritius",
          "MX": "Mexico",
          "FM": "Micronesia",
          "MD": "Moldova",
          "MC": "Monaco",
          "MN": "Mongolia",
          "ME": "Montenegro",
          "MS": "Montserrat",
          "MA": "Morocco",
          "MZ": "Mozambique",
          "MM": "Myanmar (Burma)",
          "NA": "Namibia",
          "NR": "Nauru",
          "NP": "Nepal",
          "NL": "Netherlands",
          "NC": "New Caledonia",
          "NZ": "New Zealand",
          "NI": "Nicaragua",
          "NE": "Niger",
          "NG": "Nigeria",
          "NU": "Niue",
          "NF": "Norfolk Island",
          "KP": "North Korea",
          "MK": "North Macedonia",
          "MP": "Northern Mariana Islands",
          "NO": "Norway",
          "OM": "Oman",
          "PK": "Pakistan",
          "PW": "Palau",
          "PS": "Palestine",
          "PA": "Panama",
          "PG": "Papua New Guinea",
          "PY": "Paraguay",
          "PE": "Peru",
          "PH": "Philippines",
          "PL": "Poland",
          "PT": "Portugal",
          "PR": "Puerto Rico",
          "QA": "Qatar",
          "RE": "Réunion",
          "RO": "Romania",
          "RU": "Russia",
          "RW": "Rwanda",
          "WS": "Samoa",
          "SM": "San Marino",
          "ST": "São Tomé & Príncipe",
          "SA": "Saudi Arabia",
          "SN": "Senegal",
          "RS": "Serbia",
          "SC": "Seychelles",
          "SL": "Sierra Leone",
          "SG": "Singapore",
          "SX": "Sint Maarten",
          "SK": "Slovakia",
          "SI": "Slovenia",
          "SB": "Solomon Islands",
          "SO": "Somalia",
          "ZA": "South Africa",
          "KR": "South Korea",
          "SS": "South Sudan",
          "ES": "Spain",
          "LK": "Sri Lanka",
          "BL": "St. Barthélemy",
          "SH": "St. Helena",
          "KN": "St. Kitts & Nevis",
          "LC": "St. Lucia",
          "MF": "St. Martin",
          "PM": "St. Pierre & Miquelon",
          "VC": "St. Vincent & Grenadines",
          "SD": "Sudan",
          "SR": "Suriname",
          "SE": "Sweden",
          "CH": "Switzerland",
          "SY": "Syria",
          "TW": "Taiwan",
          "TJ": "Tajikistan",
          "TZ": "Tanzania",
          "TH": "Thailand",
          "TL": "Timor-Leste",
          "TG": "Togo",
          "TK": "Tokelau",
          "TO": "Tonga",
          "TT": "Trinidad & Tobago",
          "TN": "Tunisia",
          "TR": "Türkiye",
          "TM": "Turkmenistan",
          "TC": "Turks & Caicos Islands",
          "TV": "Tuvalu",
          "VI": "U.S. Virgin Islands",
          "UG": "Uganda",
          "UA": "Ukraine",
          "AE": "United Arab Emirates",
          "GB": "United Kingdom",
          "US": "United States",
          "UY": "Uruguay",
          "UZ": "Uzbekistan",
          "VU": "Vanuatu",
          "VA": "Vatican City",
          "VE": "Venezuela",
          "VN": "Vietnam",
          "WF": "Wallis & Futuna",
          "YE": "Yemen",
          "ZM": "Zambia",
          "ZW": "Zimbabwe"
        }
      },
      "validation": {
        "accepted": "The :attribute must be accepted.",
        "active_url": "The :attribute is not a valid URL.",
        "after": "The :attribute must be a date after :date.",
        "after_or_equal": "The :attribute must be a date after or equal to :date.",
        "alpha": "The :attribute may only contain letters.",
        "alpha_dash": "The :attribute may only contain letters, numbers, dashes and underscores.",
        "alpha_num": "The :attribute may only contain letters and numbers.",
        "array": "The :attribute must be an array.",
        "before": "The :attribute must be a date before :date.",
        "before_or_equal": "The :attribute must be a date before or equal to :date.",
        "between": {
          "numeric": "The :attribute must be between :min and :max.",
          "file": "The :attribute must be between :min and :max kilobytes.",
          "string": "The :attribute must be between :min and :max characters.",
          "array": "The :attribute must have between :min and :max items."
        },
        "boolean": "The :attribute field must be true or false.",
        "captcha": "Please verify that you are not a robot.",
        "completed": "Please fill in a valid phone number.",
        "confirmed": "The :attribute confirmation does not match.",
        "date": "The :attribute is not a valid date.",
        "date_format": "The :attribute does not match the format :format.",
        "date_equals": "The :attribute must be equal to :date.",
        "different": "The :attribute and :other must be different.",
        "digits": "The :attribute must be :digits digits.",
        "digits_between": "The :attribute must be between :min and :max digits.",
        "dimensions": "The :attribute has invalid image dimensions.",
        "distinct": "The :attribute field has a duplicate value.",
        "email": "The :attribute must be a valid email address.",
        "exists": "The selected :attribute is invalid.",
        "file": "The :attribute must be a file.",
        "filled": "The :attribute field must have a value.",
        "gt": {
          "numeric": "The :attribute must be greater than :value.",
          "file": "The :attribute must be greater than :value kilobytes.",
          "string": "The :attribute must be greater than :value characters.",
          "array": "The :attribute must have more than :value items."
        },
        "gte": {
          "numeric": "The :attribute must be greater than or equal :value.",
          "file": "The :attribute must be greater than or equal :value kilobytes.",
          "string": "The :attribute must be greater than or equal :value characters.",
          "array": "The :attribute must have :value items or more."
        },
        "image": "The :attribute must be an image.",
        "in": "The selected :attribute is invalid.",
        "in_array": "The :attribute field does not exist in :other.",
        "integer": "The :attribute must be an integer.",
        "ip": "The :attribute must be a valid IP address.",
        "ipv4": "The :attribute must be a valid IPv4 address.",
        "ipv6": "The :attribute must be a valid IPv6 address.",
        "json": "The :attribute must be a valid JSON string.",
        "lt": {
          "numeric": "The :attribute must be less than :value.",
          "file": "The :attribute must be less than :value kilobytes.",
          "string": "The :attribute must be less than :value characters.",
          "array": "The :attribute must have less than :value items."
        },
        "lte": {
          "numeric": "The :attribute must be less than or equal :value.",
          "file": "The :attribute must be less than or equal :value kilobytes.",
          "string": "The :attribute must be less than or equal :value characters.",
          "array": "The :attribute must not have more than :value items."
        },
        "max": {
          "numeric": "The :attribute may not be greater than :max.",
          "file": "The :attribute may not be greater than :max kilobytes.",
          "string": "The :attribute may not be greater than :max characters.",
          "array": "The :attribute may not have more than :max items."
        },
        "mimes": "The :attribute must be a file of type: :values.",
        "mimetypes": "The :attribute must be a file of type: :values.",
        "min": {
          "numeric": "The :attribute must be at least :min.",
          "file": "The :attribute must be at least :min kilobytes.",
          "string": "The :attribute must be at least :min characters.",
          "array": "The :attribute must have at least :min items."
        },
        "not_in": "The selected :attribute is invalid.",
        "not_regex": "The :attribute format is invalid.",
        "numeric": "The :attribute must be a number.",
        "present": "The :attribute field must be present.",
        "regex": "The :attribute format is invalid.",
        "required": "The :attribute field is required.",
        "required_if": "The :attribute field is required when :other is :value.",
        "required_unless": "The :attribute field is required unless :other is in :values.",
        "required_with": "The :attribute field is required when :values is present.",
        "required_with_all": "The :attribute field is required when :values are present.",
        "required_without": "The :attribute field is required when :values is not present.",
        "required_without_all": "The :attribute field is required when none of :values are present.",
        "same": "The :attribute and :other must match.",
        "size": {
          "numeric": "The :attribute must be :size.",
          "file": "The :attribute must be :size kilobytes.",
          "string": "The :attribute must be :size characters.",
          "array": "The :attribute must contain :size items."
        },
        "string": "The :attribute must be a string.",
        "timezone": "The :attribute must be a valid zone.",
        "unique": "The :attribute has already been taken.",
        "uploaded": "The :attribute failed to upload.",
        "url": "The :attribute format is invalid.",
        "uuid": "The :attribute must be a valid UUID.",
        "remote": "The :attribute field is invalid."
      }
    };
    /*!
     * Vueform v1.10.3 (https://github.com/vueform/vueform)
     * Copyright (c) 2024 Adam Berecz <adam@vueform.com>
     * Licensed under the MIT License
     */
    var script$28 = {
      data() {
        return {
          merge: true,
          defaultClasses: {
            form: ""
          }
        };
      }
    };
    function render$$(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_FormElements = resolveComponent("FormElements");
      return openBlock(), createElementBlock(
        "form",
        {
          class: normalizeClass(_ctx.classes.form),
          onSubmit: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.submit && _ctx.submit(...args), ["prevent"]))
        },
        [
          renderSlot(_ctx.$slots, "empty", { classes: _ctx.classes }, () => [
            _ctx.showMessages ? (openBlock(), createBlock(resolveDynamicComponent("FormMessages"), { key: 0 })) : createCommentVNode("v-if", true),
            _ctx.showErrors ? (openBlock(), createBlock(resolveDynamicComponent("FormErrors"), { key: 1 })) : createCommentVNode("v-if", true),
            _ctx.showLanguages ? (openBlock(), createBlock(resolveDynamicComponent("FormLanguages"), { key: 2 })) : createCommentVNode("v-if", true),
            _ctx.showTabs ? (openBlock(), createBlock(resolveDynamicComponent("FormTabs"), { key: 3 })) : createCommentVNode("v-if", true),
            _ctx.showSteps ? (openBlock(), createBlock(resolveDynamicComponent("FormSteps"), { key: 4 })) : createCommentVNode("v-if", true),
            createVNode(_component_FormElements, null, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
              /* FORWARDED */
            }),
            _ctx.showStepsControls ? (openBlock(), createBlock(resolveDynamicComponent("FormStepsControls"), { key: 5 })) : createCommentVNode("v-if", true)
          ])
        ],
        34
        /* CLASS, NEED_HYDRATION */
      );
    }
    script$28.render = render$$;
    script$28.__file = "themes/blank/templates/Vueform.vue";
    var script$27 = {
      name: "Vueform",
      render: script$28.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            form: ""
          }
        };
      }
    };
    script$27.__file = "themes/vueform/templates/Vueform.vue";
    var script$26 = {
      name: "FormErrors",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            error: ""
          }
        };
      }
    };
    const _hoisted_1$L = ["innerHTML"];
    function render$_(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList(_ctx.errors, (error, key, index2) => {
              return openBlock(), createElementBlock("div", {
                class: normalizeClass(_ctx.classes.error),
                innerHTML: error,
                key: index2
              }, null, 10, _hoisted_1$L);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ],
        2
        /* CLASS */
      );
    }
    script$26.render = render$_;
    script$26.__file = "themes/blank/templates/FormErrors.vue";
    var script$25 = {
      name: "FormErrors",
      render: script$26.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-errors",
            container_sm: "vf-errors-sm",
            container_md: "",
            container_lg: "vf-errors-lg",
            error: "",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ]
          }
        };
      }
    };
    function styleInject(css2, ref2) {
      if (ref2 === void 0)
        ref2 = {};
      var insertAt = ref2.insertAt;
      if (!css2 || typeof document === "undefined") {
        return;
      }
      var head2 = document.head || document.getElementsByTagName("head")[0];
      var style = document.createElement("style");
      style.type = "text/css";
      if (insertAt === "top") {
        if (head2.firstChild) {
          head2.insertBefore(style, head2.firstChild);
        } else {
          head2.appendChild(style);
        }
      } else {
        head2.appendChild(style);
      }
      if (style.styleSheet) {
        style.styleSheet.cssText = css2;
      } else {
        style.appendChild(document.createTextNode(css2));
      }
    }
    var css_248z$$ = ".vf-errors {\n  background: var(--vf-bg-danger);\n  color: var(--vf-color-danger);\n  border-radius: var(--vf-radius-input);\n  margin-bottom: var(--vf-gutter);\n  font-size: var(--vf-font-size);\n  line-height: var(--vf-line-height);\n  letter-spacing: var(--vf-letter-spacing);\n  padding: 0.5rem 0.75rem;\n}\n\n.vf-errors.vf-errors-sm {\n  border-radius: var(--vf-radius-input-sm);\n  margin-bottom: var(--vf-gutter-sm);\n  font-size: var(--vf-font-size-sm);\n  line-height: var(--vf-line-height-sm);\n  letter-spacing: var(--vf-letter-spacing-sm);\n  padding: 0.5rem 0.75rem;\n}\n\n.vf-errors.vf-errors-lg {\n  border-radius: var(--vf-radius-input-lg);\n  margin-bottom: var(--vf-gutter-lg);\n  font-size: var(--vf-font-size-lg);\n  line-height: var(--vf-line-height-lg);\n  letter-spacing: var(--vf-letter-spacing-lg);\n  padding: 0.75rem 1rem;\n}";
    styleInject(css_248z$$);
    script$25.__file = "themes/vueform/templates/FormErrors.vue";
    var script$24 = {
      name: "FormMessages",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            message: ""
          }
        };
      }
    };
    const _hoisted_1$K = ["innerHTML"];
    function render$Z(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList(_ctx.messages, (message, key, index2) => {
              return openBlock(), createElementBlock("div", {
                class: normalizeClass(_ctx.classes.message),
                innerHTML: message,
                key: index2
              }, null, 10, _hoisted_1$K);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ],
        2
        /* CLASS */
      );
    }
    script$24.render = render$Z;
    script$24.__file = "themes/blank/templates/FormMessages.vue";
    var script$23 = {
      name: "FormMessages",
      render: script$24.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-messages",
            container_sm: "vf-messages-sm",
            container_md: "",
            container_lg: "vf-messages-lg",
            message: "",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$_ = ".vf-messages {\n  background: var(--vf-bg-success);\n  color: var(--vf-color-success);\n  border-radius: var(--vf-radius-input);\n  margin-bottom: var(--vf-gutter);\n  font-size: var(--vf-font-size);\n  line-height: var(--vf-line-height);\n  letter-spacing: var(--vf-letter-spacing);\n  padding: 0.5rem 0.75rem;\n}\n\n.vf-messages.vf-messages-sm {\n  border-radius: var(--vf-radius-input-sm);\n  margin-bottom: var(--vf-gutter-sm);\n  font-size: var(--vf-font-size-sm);\n  line-height: var(--vf-line-height-sm);\n  letter-spacing: var(--vf-letter-spacing-sm);\n  padding: 0.5rem 0.75rem;\n}\n\n.vf-messages.vf-messages-lg {\n  border-radius: var(--vf-radius-input-lg);\n  margin-bottom: var(--vf-gutter-lg);\n  font-size: var(--vf-font-size-lg);\n  line-height: var(--vf-line-height-lg);\n  letter-spacing: var(--vf-letter-spacing-lg);\n  padding: 0.75rem 1rem;\n}";
    styleInject(css_248z$_);
    script$23.__file = "themes/vueform/templates/FormMessages.vue";
    var script$22 = {
      name: "FormLanguages",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: ""
          }
        };
      }
    };
    function render$Y(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_FormLanguage = resolveComponent("FormLanguage");
      return openBlock(), createElementBlock(
        "ul",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          renderSlot(_ctx.$slots, "default", {}, () => [
            (openBlock(true), createElementBlock(
              Fragment,
              null,
              renderList(_ctx.languages, (lang2, code, key) => {
                return openBlock(), createBlock(_component_FormLanguage, {
                  language: lang2,
                  code,
                  key,
                  onSelect: _ctx.handleSelect
                }, null, 8, ["language", "code", "onSelect"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ],
        2
        /* CLASS */
      );
    }
    script$22.render = render$Y;
    script$22.__file = "themes/blank/templates/FormLanguages.vue";
    var script$21 = {
      name: "FormLanguages",
      render: script$22.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-languages",
            container_sm: "vf-languages-sm",
            container_md: "",
            container_lg: "vf-languages-lg",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$Z = ".vf-languages {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  list-style: none;\n  padding: 0;\n  margin: 0 0 var(--vf-gutter-lg) 0;\n  font-size: var(--vf-font-size);\n  line-height: var(--vf-line-height);\n  letter-spacing: var(--vf-letter-spacing);\n}\n\n.vf-languages.vf-languages-sm {\n  margin: 0 0 var(--vf-gutter) 0;\n  font-size: var(--vf-font-size-sm);\n  line-height: var(--vf-line-height-sm);\n  letter-spacing: var(--vf-letter-spacing-sm);\n}\n\n.vf-languages.vf-languages-lg {\n  margin: 0 0 var(--vf-gutter-lg) 0;\n  font-size: var(--vf-font-size-lg);\n  line-height: var(--vf-line-height-lg);\n  letter-spacing: var(--vf-letter-spacing-lg);\n}";
    styleInject(css_248z$Z);
    script$21.__file = "themes/vueform/templates/FormLanguages.vue";
    var script$20 = {
      name: "FormLanguage",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: ""
          }
        };
      }
    };
    function render$X(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "li",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          createBaseVNode(
            "a",
            {
              href: "#",
              class: normalizeClass(_ctx.classes.wrapper),
              onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.select && _ctx.select(...args), ["prevent"]))
            },
            toDisplayString(_ctx.language),
            3
            /* TEXT, CLASS */
          )
        ],
        2
        /* CLASS */
      );
    }
    script$20.render = render$X;
    script$20.__file = "themes/blank/templates/FormLanguage.vue";
    var script$1$ = {
      name: "FormLanguage",
      render: script$20.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-language",
            wrapper: "vf-language-wrapper",
            wrapper_sm: "vf-language-wrapper-sm",
            wrapper_md: "",
            wrapper_lg: "vf-language-wrapper-lg",
            wrapper_active: "vf-language-wrapper-active",
            wrapper_inactive: "",
            $wrapper: (classes2, { selected, Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`],
              selected ? classes2.wrapper_active : classes2.wrapper_inactive
            ]
          }
        };
      }
    };
    var css_248z$Y = ".vf-language {\n  flex-grow: 1;\n  flex-shrink: 1;\n  width: 100%;\n}\n\n.vf-language-wrapper {\n  padding: 0.5rem 1rem;\n  display: block;\n  margin-left: 1px;\n  margin-right: 1px;\n  text-decoration: none;\n  border-bottom: 2px solid transparent;\n  color: var(--vf-color-input);\n  text-align: center;\n}\n\n.vf-language-wrapper:hover {\n  text-decoration: none;\n}\n\n.vf-language-wrapper.vf-language-wrapper-sm {\n  padding: 0.375rem 0.875rem;\n}\n\n.vf-language-wrapper.vf-language-wrapper-lg {\n  padding: 0.5rem 1rem;\n}\n\n.vf-language-wrapper.vf-language-wrapper-active {\n  border-color: var(--vf-primary);\n}\n\n.vf-language-wrapper.vf-language-wrapper-invalid {\n  border-color: var(--vf-danger);\n  color: var(--vf-color-danger);\n}";
    styleInject(css_248z$Y);
    script$1$.__file = "themes/vueform/templates/FormLanguage.vue";
    var script$1_ = {
      name: "FormTabs",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: ""
          }
        };
      }
    };
    function render$W(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_FormTab = resolveComponent("FormTab");
      return openBlock(), createElementBlock(
        "ul",
        {
          class: normalizeClass(_ctx.classes.container),
          role: "tablist"
        },
        [
          renderSlot(_ctx.$slots, "default", {}, () => [
            (openBlock(true), createElementBlock(
              Fragment,
              null,
              renderList(_ctx.tabs, (tab, name2, i2) => {
                return openBlock(), createBlock(_component_FormTab, mergeProps({ ref_for: true }, tab, {
                  name: name2,
                  index: i2,
                  key: name2
                }), null, 16, ["name", "index"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ],
        2
        /* CLASS */
      );
    }
    script$1_.render = render$W;
    script$1_.__file = "themes/blank/templates/FormTabs.vue";
    var script$1Z = {
      name: "FormTabs",
      render: script$1_.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-tabs",
            container_sm: "vf-tabs-sm",
            container_md: "",
            container_lg: "vf-tabs-lg",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$X = ".vf-tabs {\n  display: flex;\n  align-items: flex-end;\n  list-style: none;\n  padding: 0;\n  margin: 0 0 var(--vf-gutter) 0;\n  font-size: var(--vf-font-size);\n  line-height: var(--vf-line-height);\n  letter-spacing: var(--vf-letter-spacing);\n}\n\n.vf-tabs.vf-tabs-sm {\n  margin: 0 0 var(--vf-gutter) 0;\n  font-size: var(--vf-font-size-sm);\n  line-height: var(--vf-line-height-sm);\n  letter-spacing: var(--vf-letter-spacing-sm);\n}\n\n.vf-tabs.vf-tabs-lg {\n  margin: 0 0 var(--vf-gutter-lg) 0;\n  font-size: var(--vf-font-size-lg);\n  line-height: var(--vf-line-height-lg);\n  letter-spacing: var(--vf-letter-spacing-lg);\n}";
    styleInject(css_248z$X);
    script$1Z.__file = "themes/vueform/templates/FormTabs.vue";
    var script$1Y = {
      name: "FormTab",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: ""
          }
        };
      }
    };
    const _hoisted_1$J = ["aria-selected"];
    const _hoisted_2$s = { key: 0 };
    const _hoisted_3$h = ["innerHTML"];
    function render$V(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock(
        "li",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.classes.wrapper),
            tabindex: "0",
            role: "tab",
            "aria-selected": _ctx.active,
            onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.select && _ctx.select(...args), ["prevent"])),
            onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.select && _ctx.select(...args), ["prevent"]), ["enter", "space"]))
          }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createCommentVNode(" If label is a component "),
              _ctx.isLabelComponent ? (openBlock(), createElementBlock("span", _hoisted_2$s, [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.tabLabel), { form$: _ctx.form$ }, null, 8, ["form$"]))
              ])) : (openBlock(), createElementBlock(
                Fragment,
                { key: 1 },
                [
                  createCommentVNode(" If label is HTML "),
                  createBaseVNode("span", { innerHTML: _ctx.tabLabel }, null, 8, _hoisted_3$h)
                ],
                2112
                /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
              ))
            ])
          ], 42, _hoisted_1$J)
        ],
        2
        /* CLASS */
      )), [
        [vShow, _ctx.visible]
      ]);
    }
    script$1Y.render = render$V;
    script$1Y.__file = "themes/blank/templates/FormTab.vue";
    var script$1X = {
      name: "FormTab",
      render: script$1Y.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-tab",
            wrapper: "vf-tab-wrapper",
            wrapper_active: "vf-tab-wrapper-active",
            wrapper_inactive: "",
            wrapper_valid: "",
            wrapper_invalid: "vf-tab-wrapper-invalid",
            wrapper_sm: "vf-tab-wrapper-sm",
            wrapper_md: "",
            wrapper_lg: "vf-tab-wrapper-lg",
            $container: (classes2, {}) => [
              classes2.container
            ],
            $wrapper: (classes2, { active, invalid, Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`],
              active ? classes2.wrapper_active : classes2.wrapper_inactive,
              invalid ? classes2.wrapper_invalid : classes2.wrapper_valid
            ]
          }
        };
      }
    };
    var css_248z$W = ".vf-tab-wrapper {\n  padding: 0.5rem 1rem;\n  display: block;\n  margin-left: 1px;\n  margin-right: 1px;\n  text-decoration: none;\n  border-bottom: 2px solid transparent;\n  color: var(--vf-color-input);\n}\n\n.vf-tab-wrapper:hover {\n  text-decoration: none;\n}\n\n.vf-tab-wrapper.vf-tab-wrapper-sm {\n  padding: 0.375rem 0.875rem;\n}\n\n.vf-tab-wrapper.vf-tab-wrapper-lg {\n  padding: 0.5rem 1rem;\n}\n\n.vf-tab-wrapper.vf-tab-wrapper-active {\n  border-color: var(--vf-primary);\n}\n\n.vf-tab-wrapper.vf-tab-wrapper-invalid {\n  border-color: var(--vf-danger);\n  color: var(--vf-color-danger);\n}";
    styleInject(css_248z$W);
    script$1X.__file = "themes/vueform/templates/FormTab.vue";
    var script$1W = {
      name: "FormSteps",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: ""
          }
        };
      }
    };
    function render$U(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_FormStep = resolveComponent("FormStep");
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(_ctx.classes.container),
          role: "tablist"
        },
        [
          createBaseVNode(
            "ul",
            {
              class: normalizeClass(_ctx.classes.wrapper)
            },
            [
              renderSlot(_ctx.$slots, "default", {}, () => [
                (openBlock(true), createElementBlock(
                  Fragment,
                  null,
                  renderList(_ctx.steps, (step, name2) => {
                    return openBlock(), createBlock(_component_FormStep, mergeProps({ ref_for: true }, step, {
                      name: name2,
                      key: name2
                    }), null, 16, ["name"]);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ])
            ],
            2
            /* CLASS */
          )
        ],
        2
        /* CLASS */
      );
    }
    script$1W.render = render$U;
    script$1W.__file = "themes/blank/templates/FormSteps.vue";
    var script$1V = {
      name: "FormSteps",
      render: script$1W.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-steps-container",
            container_sm: "vf-steps-container-sm",
            container_md: "",
            container_lg: "vf-steps-container-lg",
            wrapper: "vf-steps-wrapper",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$V = '.vf-steps-container {\n  width: 100%;\n  position: relative;\n  margin: 0 0 var(--vf-gutter-lg) 0;\n  font-size: var(--vf-font-size);\n  line-height: var(--vf-line-height);\n  letter-spacing: var(--vf-letter-spacing);\n}\n\n.vf-steps-container:before {\n  content: " ";\n  display: inline-block;\n  background: var(--vf-bg-passive);\n  position: absolute;\n  top: 0.375rem;\n  left: 0.125rem;\n  right: 0.125rem;\n  height: 0.25rem;\n}\n\n.vf-steps-container.vf-steps-container-sm {\n  margin: 0 0 var(--vf-gutter) 0;\n  font-size: var(--vf-font-size-sm);\n  line-height: var(--vf-line-height-sm);\n  letter-spacing: var(--vf-letter-spacing-sm);\n}\n\n.vf-steps-container.vf-steps-container-lg {\n  margin: 0 0 var(--vf-gutter-lg) 0;\n  font-size: var(--vf-font-size-lg);\n  line-height: var(--vf-line-height-lg);\n  letter-spacing: var(--vf-letter-spacing-lg);\n}\n\n.vf-steps-wrapper {\n  list-style: none;\n  display: flex;\n  justify-content: space-between;\n  padding: 0;\n  overflow-x: auto;\n}';
    styleInject(css_248z$V);
    script$1V.__file = "themes/vueform/templates/FormSteps.vue";
    var script$1U = {
      name: "FormStepsControls",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: ""
          }
        };
      }
    };
    function render$T(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_FormStepsControl = resolveComponent("FormStepsControl");
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          createVNode(_component_FormStepsControl, {
            type: "previous",
            labels: _ctx.labels
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "previous")
            ]),
            _: 3
            /* FORWARDED */
          }, 8, ["labels"]),
          createVNode(_component_FormStepsControl, {
            type: "next",
            labels: _ctx.labels
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "next")
            ]),
            _: 3
            /* FORWARDED */
          }, 8, ["labels"]),
          createVNode(_component_FormStepsControl, {
            type: "finish",
            labels: _ctx.labels
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "finish")
            ]),
            _: 3
            /* FORWARDED */
          }, 8, ["labels"])
        ],
        2
        /* CLASS */
      );
    }
    script$1U.render = render$T;
    script$1U.__file = "themes/blank/templates/FormStepsControls.vue";
    var script$1T = {
      name: "FormStepsControls",
      render: script$1U.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-steps-controls",
            container_sm: "vf-steps-controls-sm",
            container_md: "",
            container_lg: "vf-steps-controls-lg",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$U = ".vf-steps-controls {\n  display: flex;\n  justify-content: space-between;\n  margin: var(--vf-gutter-lg) 0 0 0;\n  font-size: var(--vf-font-size);\n  line-height: var(--vf-line-height);\n  letter-spacing: var(--vf-letter-spacing);\n}\n\n.vf-steps-controls.vf-steps-controls-sm {\n  margin: var(--vf-gutter) 0 0 0;\n  font-size: var(--vf-font-size-sm);\n  line-height: var(--vf-line-height-sm);\n  letter-spacing: var(--vf-letter-spacing-md);\n}\n\n.vf-steps-controls.vf-steps-controls-lg {\n  margin: var(--vf-gutter-lg) 0 0 0;\n  font-size: var(--vf-font-size-lg);\n  line-height: var(--vf-line-height-lg);\n  letter-spacing: var(--vf-letter-spacing-lg);\n}";
    styleInject(css_248z$U);
    script$1T.__file = "themes/vueform/templates/FormStepsControls.vue";
    var script$1S = {
      name: "FormStepsControl",
      data() {
        return {
          merge: true,
          defaultClasses: {
            button: ""
          }
        };
      }
    };
    const _hoisted_1$I = ["disabled"];
    const _hoisted_2$r = ["innerHTML", "disabled"];
    const _hoisted_3$g = ["disabled"];
    function render$S(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        Fragment,
        null,
        [
          createCommentVNode(" If label is a component "),
          _ctx.visible && _ctx.label && _ctx.isLabelComponent ? (openBlock(), createElementBlock("button", {
            key: 0,
            disabled: _ctx.isDisabled,
            class: normalizeClass(_ctx.classes.button),
            onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["prevent"])),
            onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["prevent"]), ["enter", "space"]))
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.label), { step$: _ctx.current$ }, null, 8, ["step$"]))
          ], 42, _hoisted_1$I)) : _ctx.visible && _ctx.label ? (openBlock(), createElementBlock(
            Fragment,
            { key: 1 },
            [
              createCommentVNode(" If label is HTML "),
              createBaseVNode("button", {
                innerHTML: _ctx.label,
                disabled: _ctx.isDisabled,
                class: normalizeClass(_ctx.classes.button),
                onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["prevent"])),
                onKeypress: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["prevent"]), ["enter", "space"]))
              }, null, 42, _hoisted_2$r)
            ],
            2112
            /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )) : _ctx.visible ? (openBlock(), createElementBlock(
            Fragment,
            { key: 2 },
            [
              createCommentVNode(" If label is a slot "),
              createBaseVNode("button", {
                disabled: _ctx.isDisabled,
                class: normalizeClass(_ctx.classes.button),
                onClick: _cache[4] || (_cache[4] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["prevent"])),
                onKeypress: _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["prevent"]), ["enter", "space"]))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 42, _hoisted_3$g)
            ],
            2112
            /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )) : createCommentVNode("v-if", true)
        ],
        2112
        /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
      );
    }
    script$1S.render = render$S;
    script$1S.__file = "themes/blank/templates/FormStepsControl.vue";
    var script$1R = {
      name: "FormStepsControl",
      render: script$1S.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            button: "vf-btn",
            button_previous: "",
            button_previous_enabled: "vf-btn-secondary",
            button_previous_disabled: "vf-btn-secondary vf-btn-disabled",
            button_next: "",
            button_next_enabled: "vf-btn-primary",
            button_next_disabled: "vf-btn-primary vf-btn-disabled",
            button_next_loading: "vf-btn-loading vf-btn-loading-primary",
            button_finish: "",
            button_finish_enabled: "vf-btn-primary",
            button_finish_disabled: "vf-btn-primary vf-btn-disabled",
            button_finish_loading: "vf-btn-loading vf-btn-loading-primary",
            button_sm: "vf-btn-sm",
            button_md: "",
            button_lg: "vf-btn-lg",
            $button: (classes2, { isDisabled, isLoading, type, Size }) => [
              classes2.button,
              classes2[`button_${Size}`],
              classes2[`button_${type}`],
              isDisabled ? classes2[`button_${type}_disabled`] : classes2[`button_${type}_enabled`],
              isLoading ? classes2[`button_${type}_loading`] : null
            ]
          }
        };
      }
    };
    script$1R.__file = "themes/vueform/templates/FormStepsControl.vue";
    var script$1Q = {
      name: "FormStep",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: ""
          }
        };
      }
    };
    const _hoisted_1$H = ["tabindex", "aria-selected"];
    const _hoisted_2$q = { key: 0 };
    const _hoisted_3$f = ["innerHTML"];
    function render$R(_ctx, _cache, $props, $setup, $data, $options) {
      return _ctx.visible ? (openBlock(), createElementBlock(
        "li",
        {
          key: 0,
          class: normalizeClass(_ctx.classes.container)
        },
        [
          createBaseVNode("a", {
            href: "",
            class: normalizeClass(_ctx.classes.wrapper),
            tabindex: _ctx.isDisabled ? -1 : 0,
            role: "tab",
            "aria-selected": _ctx.active,
            onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.select && _ctx.select(...args), ["prevent"])),
            onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.select && _ctx.select(...args), ["prevent"]), ["enter", "space"]))
          }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createCommentVNode(" If label is a component "),
              _ctx.isLabelComponent ? (openBlock(), createElementBlock("span", _hoisted_2$q, [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.stepLabel), { form$: _ctx.form$ }, null, 8, ["form$"]))
              ])) : (openBlock(), createElementBlock(
                Fragment,
                { key: 1 },
                [
                  createCommentVNode(" If label is HTML "),
                  createBaseVNode("span", { innerHTML: _ctx.stepLabel }, null, 8, _hoisted_3$f)
                ],
                2112
                /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
              ))
            ])
          ], 42, _hoisted_1$H)
        ],
        2
        /* CLASS */
      )) : createCommentVNode("v-if", true);
    }
    script$1Q.render = render$R;
    script$1Q.__file = "themes/blank/templates/FormStep.vue";
    var script$1P = {
      name: "FormStep",
      render: script$1Q.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-step",
            wrapper: "",
            container_active: "vf-step-active",
            container_inactive: "",
            container_invalid: "vf-step-invalid",
            container_valid: "",
            container_disabled: "vf-step-disabled",
            container_enabled: "",
            container_completed: "vf-step-completed",
            container_incompleted: "",
            container_pending: "vf-step-pending",
            $container: (classes2, { active, isDisabled, completed: completed2, invalid, pending }) => [
              classes2.container,
              active ? classes2.container_active : classes2.container_inactive,
              isDisabled ? classes2.container_disabled : classes2.container_enabled,
              completed2 ? classes2.container_completed : classes2.container_incompleted,
              invalid ? classes2.container_invalid : classes2.container_valid,
              pending ? classes2.container_pending : null
            ]
          }
        };
      }
    };
    var css_248z$T = `.vf-step {
  display: block;
  position: relative;
  white-space: nowrap;
  flex: 1 1;
  text-align: center;
  padding: 1.25rem 0.625rem 0;
}

.vf-step a {
  text-decoration: none !important;
  color: inherit;
}

.vf-step a:hover, .vf-step a:focus, .vf-step a:active {
  text-decoration: none !important;
  color: inherit;
}

.vf-step a:before {
  content: " ";
  display: inline-block;
  width: 1rem;
  height: 1rem;
  position: absolute;
  background: var(--vf-primary);
  border-radius: 50%;
  left: 50%;
  transform: translateX(-50%);
  top: 0px;
}

.vf-step a:after {
  content: " ";
  display: inline-block;
  width: 0.5rem;
  height: 0.5rem;
  position: absolute;
  background: #FFFFFF;
  border-radius: 50%;
  left: calc(50% - 0.25rem);
  transform: scale(0);
  top: 0.25rem;
  transition: transform 0.3s ease-in-out;
}

.vf-step:first-of-type {
  padding-left: 0;
  text-align: left;
}

.vf-step:first-of-type:before {
  display: none;
}

.vf-step:first-of-type:after {
  left: 0;
}

.vf-step:first-of-type a:before {
  left: 0;
  transform: none;
}

.vf-step:first-of-type a:after {
  left: 0.25rem;
  transform: scale(0);
}

.vf-step:last-of-type {
  padding-right: 0;
  text-align: right;
}

.vf-step:last-of-type:after {
  display: none;
}

.vf-step:last-of-type:before {
  right: 0;
}

.vf-step:last-of-type a:before {
  right: 0;
  left: auto;
  left: initial;
  transform: none;
}

.vf-step:last-of-type a:after {
  left: auto;
  left: initial;
  transform: scale(0);
  right: 0.25rem;
}

.vf-step.vf-step-disabled:before {
  background: var(--vf-bg-passive);
  left: -100%;
}

.vf-step.vf-step-disabled a {
  color: var(--vf-color-passive);
}

.vf-step.vf-step-disabled a:before {
  background: var(--vf-bg-passive);
}

.vf-step.vf-step-completed + .vf-step:not(.vf-step-completed):before {
  content: " ";
  display: inline-block;
  background: var(--vf-primary);
  position: absolute;
  top: 0.375rem;
  left: 0px;
  right: 50%;
  height: 0.25rem;
}

.vf-step.vf-step-completed + .vf-step:last-of-type:before {
  right: 0px;
}

.vf-step.vf-step-completed:before {
  content: " ";
  display: inline-block;
  background: var(--vf-primary);
  position: absolute;
  top: 0.375rem;
  left: 0px;
  right: 0px;
  height: 0.25rem;
}

.vf-step.vf-step-completed a:after {
  mask-image: url('data:image/svg+xml;utf8,<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="check" class="svg-inline--fa fa-check fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="white" d="M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"></path></svg>');
  -webkit-mask-image: url('data:image/svg+xml;utf8,<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="check" class="svg-inline--fa fa-check fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="white" d="M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"></path></svg>');
  mask-size: 0.5rem 0.5rem;
  -webkit-mask-size: 0.5rem 0.5rem;
  mask-position: 0 0;
  -webkit-mask-position: 0 0;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  background-color: var(--vf-color-on-primary);
  border-radius: 0;
  transform: scale(1);
}

.vf-step.vf-step-active a:after {
  mask-image: none;
  -webkit-mask-image: none;
  background-color: var(--vf-color-on-primary);
  top: 0.25rem;
  transform: scale(1);
  border-radius: 50%;
}

.vf-step.vf-step-invalid a {
  color: var(--vf-bg-btn-danger);
}

.vf-step.vf-step-invalid a:before {
  background-color: var(--vf-bg-btn-danger);
}

.vf-step.vf-step-invalid a:after {
  mask-image: url('data:image/svg+xml;utf8,<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="exclamation" class="svg-inline--fa fa-exclamation fa-w-6" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><path fill="white" d="M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z"></path></svg>');
  -webkit-mask-image: url('data:image/svg+xml;utf8,<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="exclamation" class="svg-inline--fa fa-exclamation fa-w-6" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><path fill="white" d="M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z"></path></svg>');
  mask-size: 0.5rem 0.5rem;
  -webkit-mask-size: 0.5rem 0.5rem;
  mask-position: 0 0;
  -webkit-mask-position: 0 0;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  background-color: var(--vf-color-btn-danger);
  width: 0.5rem;
  height: 0.5rem;
  top: 0.25rem;
  border-radius: 0;
}

.vf-step.vf-step-invalid.vf-step-active a:after {
  mask-image: none;
  -webkit-mask-image: none;
  background-color: var(--vf-color-on-primary);
  transform: scale(1);
  border-radius: 50%;
}

.vf-step.vf-step-pending a:after {
  animation: 1s linear infinite step-loading;
  background: var(--vf-color-btn-danger);
  top: 0.25rem;
  border-radius: 50%;
}

@keyframes step-loading {
  0% {
    transform: scale(0.5);
  }

  20% {
    transform: scale(1.2);
  }

  100% {
    transform: scale(0.5);
  }
}`;
    styleInject(css_248z$T);
    script$1P.__file = "themes/vueform/templates/FormStep.vue";
    var script$1O = {
      name: "FormElements",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: ""
          }
        };
      }
    };
    function render$Q(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          renderSlot(_ctx.$slots, "default", {}, () => [
            (openBlock(true), createElementBlock(
              Fragment,
              null,
              renderList(_ctx.schema, (element, name2) => {
                return openBlock(), createBlock(resolveDynamicComponent(_ctx.component(element)), mergeProps({ ref_for: true }, element, {
                  name: name2,
                  key: name2
                }), null, 16, ["name"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ],
        2
        /* CLASS */
      );
    }
    script$1O.render = render$Q;
    script$1O.__file = "themes/blank/templates/FormElements.vue";
    var script$1N = {
      name: "FormElements",
      render: script$1O.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-row",
            container_sm: "vf-row-sm",
            container_md: "",
            container_lg: "vf-row-lg",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$S = "/* Some styles are contained in Vueform.vue */";
    styleInject(css_248z$S);
    script$1N.__file = "themes/vueform/templates/FormElements.vue";
    var script$1M = {
      name: "ElementLayout",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            outerWrapper: "",
            innerContainer: "",
            innerWrapperBefore: "",
            innerWrapper: "",
            innerWrapperAfter: ""
          }
        };
      }
    };
    function render$P(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ElementLabel = resolveComponent("ElementLabel");
      const _component_ElementText = resolveComponent("ElementText");
      const _component_ElementDescription = resolveComponent("ElementDescription");
      const _component_ElementError = resolveComponent("ElementError");
      const _component_ElementMessage = resolveComponent("ElementMessage");
      return withDirectives((openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          createBaseVNode(
            "div",
            {
              class: normalizeClass(_ctx.classes.outerWrapper)
            },
            [
              createVNode(_component_ElementLabel, null, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "label")
                ]),
                info: withCtx(() => [
                  renderSlot(_ctx.$slots, "info")
                ]),
                _: 3
                /* FORWARDED */
              }),
              createBaseVNode(
                "div",
                {
                  class: normalizeClass(_ctx.classes.innerContainer)
                },
                [
                  createBaseVNode(
                    "div",
                    {
                      class: normalizeClass(_ctx.classes.innerWrapperBefore)
                    },
                    [
                      createVNode(_component_ElementText, { type: "before" }, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "before")
                        ]),
                        _: 3
                        /* FORWARDED */
                      })
                    ],
                    2
                    /* CLASS */
                  ),
                  createBaseVNode(
                    "div",
                    {
                      class: normalizeClass(_ctx.classes.innerWrapper)
                    },
                    [
                      renderSlot(_ctx.$slots, "element")
                    ],
                    2
                    /* CLASS */
                  ),
                  createBaseVNode(
                    "div",
                    {
                      class: normalizeClass(_ctx.classes.innerWrapperAfter)
                    },
                    [
                      createVNode(_component_ElementText, { type: "between" }, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "between")
                        ]),
                        _: 3
                        /* FORWARDED */
                      }),
                      createVNode(_component_ElementDescription, null, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "description")
                        ]),
                        _: 3
                        /* FORWARDED */
                      }),
                      createVNode(_component_ElementError),
                      createVNode(_component_ElementMessage),
                      createVNode(_component_ElementText, { type: "after" }, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "after")
                        ]),
                        _: 3
                        /* FORWARDED */
                      })
                    ],
                    2
                    /* CLASS */
                  )
                ],
                2
                /* CLASS */
              )
            ],
            2
            /* CLASS */
          )
        ],
        2
        /* CLASS */
      )), [
        [vShow, _ctx.visible]
      ]);
    }
    script$1M.render = render$P;
    script$1M.__file = "themes/blank/templates/ElementLayout.vue";
    var script$1L = {
      name: "ElementLayout",
      render: script$1M.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-element-layout",
            container_sm: "vf-element-layout-sm",
            container_md: "",
            container_lg: "vf-element-layout-lg",
            container_error: "vf-element-layout-error",
            outerWrapper: "vf-element-layout-outer-wrapper",
            innerContainer: "vf-layout-inner-container",
            innerWrapperBefore: "vf-layout-inner-wrapper-before",
            innerWrapper: "vf-layout-inner-wrapper",
            innerWrapperAfter: "vf-layout-inner-wrapper-after",
            $container: (classes2, { el$, Size }) => [
              classes2.container,
              classes2[`container_${Size}`],
              el$.columnsClasses.container,
              el$.classes.container,
              !el$.isStatic && el$.errors && !!el$.errors.length ? classes2.container_error : null
            ],
            $innerContainer: (classes2, { el$ }) => [
              classes2.innerContainer,
              el$.columnsClasses.innerContainer
            ],
            $innerWrapper: (classes2, { el$ }) => [
              classes2.innerWrapper,
              el$.columnsClasses.wrapper
            ]
          }
        };
      }
    };
    var css_248z$R = "/* Some styles are contained in Vueform.vue */\n\n.vf-element-layout {\n  font-size: var(--vf-font-size);\n  line-height: var(--vf-line-height);\n  letter-spacing: var(--vf-letter-spacing);\n}\n\n.vf-element-layout.vf-element-layout-sm {\n  font-size: var(--vf-font-size-sm);\n  line-height: var(--vf-line-height-sm);\n  letter-spacing: var(--vf-letter-spacing-sm);\n}\n\n.vf-element-layout.vf-element-layout-lg {\n  font-size: var(--vf-font-size-lg);\n  line-height: var(--vf-line-height-lg);\n  letter-spacing: var(--vf-letter-spacing-lg);\n}\n\n.vf-layout-inner-container {\n  flex: 1 1 0%;\n  display: grid;\n  grid-template-columns: repeat(12, minmax(0, 1fr));\n}\n\n.vf-layout-inner-container .vf-layout-inner-wrapper,\n.vf-layout-inner-container .vf-layout-inner-wrapper-before,\n.vf-layout-inner-container .vf-layout-inner-wrapper-after {\n  padding-left: 0;\n  padding-right: 0;\n}\n\n.vf-layout-inner-wrapper-before,\n.vf-layout-inner-wrapper-after {\n  grid-column: span 12/span 12;\n  padding-left: var(--vf-gutter);\n  padding-right: var(--vf-gutter);\n}\n\n.vf-element-layout-outer-wrapper {\n  display: grid;\n  grid-template-columns: repeat(12, minmax(0, 1fr));\n}";
    styleInject(css_248z$R);
    script$1L.__file = "themes/vueform/templates/ElementLayout.vue";
    var script$1K = {
      name: "ElementLayoutInline",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: ""
          }
        };
      }
    };
    function render$O(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ElementLabel = resolveComponent("ElementLabel");
      const _component_ElementText = resolveComponent("ElementText");
      const _component_ElementDescription = resolveComponent("ElementDescription");
      const _component_ElementError = resolveComponent("ElementError");
      const _component_ElementMessage = resolveComponent("ElementMessage");
      return withDirectives((openBlock(), createElementBlock(
        "span",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          createVNode(_component_ElementLabel, null, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "label")
            ]),
            _: 3
            /* FORWARDED */
          }),
          createVNode(_component_ElementText, { type: "before" }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "before")
            ]),
            _: 3
            /* FORWARDED */
          }),
          renderSlot(_ctx.$slots, "element"),
          createVNode(_component_ElementText, { type: "between" }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "between")
            ]),
            _: 3
            /* FORWARDED */
          }),
          createVNode(_component_ElementDescription, null, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "description")
            ]),
            _: 3
            /* FORWARDED */
          }),
          createVNode(_component_ElementError),
          createVNode(_component_ElementMessage),
          createVNode(_component_ElementText, { type: "after" }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "after")
            ]),
            _: 3
            /* FORWARDED */
          })
        ],
        2
        /* CLASS */
      )), [
        [vShow, _ctx.visible]
      ]);
    }
    script$1K.render = render$O;
    script$1K.__file = "themes/blank/templates/ElementLayoutInline.vue";
    var script$1J = {
      name: "ElementLayoutInline",
      render: script$1K.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-inline-layout",
            container_error: "has-error",
            $container: (classes2, { el$ }) => [
              classes2.container,
              !el$.isStatic && el$.errors && !!el$.errors.length ? classes2.container_error : null
            ]
          }
        };
      }
    };
    var css_248z$Q = ".vf-inline-layout {\n  display: flex;\n}";
    styleInject(css_248z$Q);
    script$1J.__file = "themes/vueform/templates/ElementLayoutInline.vue";
    var script$1I = {
      name: "ElementLoader",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            loader: ""
          }
        };
      }
    };
    function render$N(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          createBaseVNode(
            "span",
            {
              class: normalizeClass(_ctx.classes.loader)
            },
            null,
            2
            /* CLASS */
          )
        ],
        2
        /* CLASS */
      );
    }
    script$1I.render = render$N;
    script$1I.__file = "themes/blank/templates/ElementLoader.vue";
    var script$1H = {
      name: "ElementLoader",
      render: script$1I.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-element-loader-container",
            loader: "vf-element-loader",
            loader_sm: "vf-element-loader-sm",
            loader_md: "",
            loader_lg: "vf-element-loader-lg",
            $loader: (classes2, { Size }) => [
              classes2.loader,
              classes2[`loader_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$P = '.vf-element-loader-container {\n  position: relative;\n  z-index: 1;\n  order: 1;\n}\n\n.vf-element-loader {\n  position: absolute;\n  width: 1rem;\n  height: 1rem;\n  display: block;\n  right: var(--vf-px-input);\n  top: 50%;\n  transform: translateY(-50%);\n}\n\n.vf-element-loader:before, .vf-element-loader:after {\n  position: absolute;\n  content: "";\n  top: 50%;\n  left: 50%;\n  margin: -0.5rem 0 0 -0.5rem;\n  width: 1rem;\n  height: 1rem;\n  border-radius: 100%;\n  border-color: var(--vf-primary) transparent transparent;\n  border-style: solid;\n  border-width: 2px;\n  box-shadow: 0 0 0 1px transparent;\n  box-sizing: border-box;\n}\n\n.vf-element-loader:before {\n  animation: vf-element-loader 2.4s infinite cubic-bezier(0.41, 0.26, 0.2, 0.62);\n}\n\n.vf-element-loader:after {\n  animation: vf-element-loader 2.4s infinite cubic-bezier(0.51, 0.09, 0.21, 0.8);\n}\n\n.vf-element-loader.vf-element-loader-sm {\n  right: var(--vf-px-input-sm);\n}\n\n.vf-element-loader.vf-element-loader-lg {\n  right: var(--vf-px-input-lg);\n}\n\n@keyframes vf-element-loader {\n  from {\n    transform: rotate(0);\n  }\n\n  to {\n    transform: rotate(2turn);\n  }\n}';
    styleInject(css_248z$P);
    script$1H.__file = "themes/vueform/templates/ElementLoader.vue";
    var script$1G = {
      name: "ElementLabelFloating",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            label: ""
          }
        };
      }
    };
    const _hoisted_1$G = ["innerHTML"];
    function render$M(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          createBaseVNode("span", {
            class: normalizeClass(_ctx.classes.label),
            innerHTML: _ctx.floating
          }, null, 10, _hoisted_1$G)
        ],
        2
        /* CLASS */
      );
    }
    script$1G.render = render$M;
    script$1G.__file = "themes/blank/templates/ElementLabelFloating.vue";
    var script$1F = {
      name: "ElementLabelFloating",
      render: script$1G.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-floating-wrapper",
            label: "vf-floating-label",
            label_enabled: "",
            label_disabled: "vf-floating-label-disabled",
            label_danger: "vf-floating-label-danger",
            label_success: "vf-floating-label-success",
            label_focused: "vf-floating-label-focus",
            label_sm: "vf-floating-label-sm",
            label_md: "",
            label_lg: "vf-floating-label-lg",
            label_invisible: "",
            label_visible: "vf-floating-label-visible",
            $label: (classes2, { visible, Size, el$ }) => [
              classes2.label,
              classes2[`label_${Size}`],
              visible ? classes2.label_visible : classes2.label_invisible,
              el$.focused ? classes2.label_focused : null,
              !el$.isDisabled && !el$.isDanger && !el$.isSuccess ? classes2.label_enabled : null,
              el$.isDisabled ? classes2.label_disabled : null,
              el$.isDanger ? classes2.label_danger : null,
              el$.isSuccess ? classes2.label_success : null
            ]
          }
        };
      }
    };
    var css_248z$O = ".vf-floating-wrapper {\n  position: relative;\n}\n\n.vf-floating-label {\n  position: absolute;\n  z-index: 1;\n  left: var(--vf-px-input);\n  font-size: 0.6875rem;\n  background-color: var(--vf-bg-input);\n  padding: 0 1px;\n  line-height: 1px;\n  transition-property: box-shadow, color, background-color, border-color;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 200ms;\n  opacity: 0;\n  visibility: hidden;\n  white-space: nowrap;\n  color: var(--vf-color-floating);\n  margin-top: var(--vf-floating-top);\n}\n\n.vf-floating-label.vf-floating-label-visible {\n  opacity: 1;\n  visibility: visible;\n}\n\n.vf-floating-label.vf-floating-label-sm {\n  left: var(--vf-px-input-sm);\n  margin-top: var(--vf-floating-top-sm);\n}\n\n.vf-floating-label.vf-floating-label-lg {\n  left: var(--vf-px-input-lg);\n  margin-top: var(--vf-floating-top-lg);\n  background-color: transparent !important;\n}\n\n.vf-floating-label.vf-floating-label-disabled {\n  background-color: var(--vf-bg-disabled);\n}\n\n.vf-floating-label.vf-floating-label-focus {\n  background-color: var(--vf-bg-input-focus);\n  color: var(--vf-color-floating-focus);\n}\n\n.vf-floating-label.vf-floating-label-danger {\n  background-color: var(--vf-bg-input-danger);\n  color: var(--vf-color-floating-danger);\n}\n\n.vf-floating-label.vf-floating-label-success {\n  background-color: var(--vf-bg-input-success);\n  color: var(--vf-color-floating-success);\n}\n\n.vf-input-group .vf-floating-label {\n  top: calc(var(--vf-border-width-input-t) * -1);\n}\n\n[dir=rtl] .vf-floating-label {\n  left: auto;\n  right: var(--vf-px-input);\n}\n\n[dir=rtl] .vf-floating-label.vf-floating-label-sm {\n  left: auto;\n  right: var(--vf-px-input-sm);\n}\n\n[dir=rtl] .vf-floating-label.vf-floating-label-lg {\n  left: auto;\n  right: var(--vf-px-input-lg);\n}";
    styleInject(css_248z$O);
    script$1F.__file = "themes/vueform/templates/ElementLabelFloating.vue";
    var script$1E = {
      name: "ElementLabel",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: ""
          }
        };
      }
    };
    const _hoisted_1$F = ["for", "id"];
    const _hoisted_2$p = ["for", "id"];
    const _hoisted_3$e = ["innerHTML"];
    const _hoisted_4$b = ["for", "id"];
    const _hoisted_5$7 = ["for", "id"];
    function render$L(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ElementInfo = resolveComponent("ElementInfo");
      return openBlock(), createElementBlock(
        Fragment,
        null,
        [
          createCommentVNode(" If label is a component "),
          _ctx.label && _ctx.isLabelComponent ? (openBlock(), createElementBlock("label", {
            key: 0,
            class: normalizeClass(_ctx.classes.container),
            for: _ctx.name,
            id: _ctx.id
          }, [
            createBaseVNode(
              "span",
              {
                class: normalizeClass(_ctx.classes.wrapper)
              },
              [
                _ctx.isLabelComponent ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.label), { key: 0 })) : createCommentVNode("v-if", true)
              ],
              2
              /* CLASS */
            ),
            createVNode(_component_ElementInfo, null, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "info")
              ]),
              _: 3
              /* FORWARDED */
            })
          ], 10, _hoisted_1$F)) : _ctx.label ? (openBlock(), createElementBlock(
            Fragment,
            { key: 1 },
            [
              createCommentVNode(" If label is HTML "),
              createBaseVNode("label", {
                class: normalizeClass(_ctx.classes.container),
                for: _ctx.name,
                id: _ctx.id
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(_ctx.classes.wrapper),
                  innerHTML: _ctx.label
                }, null, 10, _hoisted_3$e),
                createVNode(_component_ElementInfo, null, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "info")
                  ]),
                  _: 3
                  /* FORWARDED */
                })
              ], 10, _hoisted_2$p)
            ],
            2112
            /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )) : _ctx.isSlot ? (openBlock(), createElementBlock(
            Fragment,
            { key: 2 },
            [
              createCommentVNode(" If label is a slot "),
              createBaseVNode("label", {
                class: normalizeClass(_ctx.classes.container),
                for: _ctx.name,
                id: _ctx.id
              }, [
                createBaseVNode(
                  "span",
                  {
                    class: normalizeClass(_ctx.classes.wrapper)
                  },
                  [
                    renderSlot(_ctx.$slots, "default")
                  ],
                  2
                  /* CLASS */
                ),
                createVNode(_component_ElementInfo, null, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "info")
                  ]),
                  _: 3
                  /* FORWARDED */
                })
              ], 10, _hoisted_4$b)
            ],
            2112
            /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )) : _ctx.hasLabel ? (openBlock(), createElementBlock(
            Fragment,
            { key: 3 },
            [
              createCommentVNode(" If labels are forced but has no value "),
              createBaseVNode("label", {
                class: normalizeClass(_ctx.classes.container),
                for: _ctx.name,
                id: _ctx.id
              }, null, 10, _hoisted_5$7)
            ],
            2112
            /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )) : createCommentVNode("v-if", true)
        ],
        2112
        /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
      );
    }
    script$1E.render = render$L;
    script$1E.__file = "themes/blank/templates/ElementLabel.vue";
    var script$1D = {
      name: "ElementLabel",
      render: script$1E.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-label",
            container_sm: "vf-label-sm",
            container_md: "",
            container_lg: "vf-label-lg",
            container_horizontal_sm: "vf-horizontal-label-sm",
            container_horizontal_md: "vf-horizontal-label",
            container_horizontal_lg: "vf-horizontal-label-lg",
            container_vertical_sm: "vf-vertical-label-sm",
            container_vertical_md: "vf-vertical-label",
            container_vertical_lg: "vf-vertical-label-lg",
            wrapper: "",
            $container: (classes2, { el$, Size }) => [
              classes2.container,
              classes2[`container_${Size}`],
              !el$.inline ? el$.columnsClasses.label : null,
              el$.cols.default.label < 12 ? classes2[`container_horizontal_${Size}`] : classes2[`container_vertical_${Size}`],
              ...Object.keys(el$.cols).length > 1 ? (el$.$vueform.config.breakpoints || ["sm", "md", "lg", "xl", "2xl"]).map((breakpoint) => {
                var _a;
                if (!((_a = el$.cols[breakpoint]) == null ? void 0 : _a.label)) {
                  return null;
                }
                return el$.cols[breakpoint].label < 12 ? classes2[`container_horizontal_${Size}`].map((c2) => `vf-${breakpoint}:${c2}`).join(" ") : classes2[`container_vertical_${Size}`].map((c2) => `vf-${breakpoint}:${c2}`).join(" ");
              }) : []
            ]
          }
        };
      }
    };
    var css_248z$N = "/* Styles can be found at scss/_label.scss */";
    styleInject(css_248z$N);
    script$1D.__file = "themes/vueform/templates/ElementLabel.vue";
    var script$1C = {
      name: "ElementInfo",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            content: ""
          }
        };
      }
    };
    const _hoisted_1$E = ["id"];
    const _hoisted_2$o = ["innerHTML"];
    function render$K(_ctx, _cache, $props, $setup, $data, $options) {
      return _ctx.info || _ctx.isSlot ? (openBlock(), createElementBlock(
        "span",
        {
          key: 0,
          class: normalizeClass(_ctx.classes.container),
          onMouseover: _cache[0] || (_cache[0] = (...args) => _ctx.handleMouseOver && _ctx.handleMouseOver(...args))
        },
        [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.classes.wrapper),
            id: _ctx.id
          }, [
            _ctx.isSlot ? (openBlock(), createElementBlock(
              "span",
              {
                key: 0,
                class: normalizeClass(_ctx.classes.content)
              },
              [
                renderSlot(_ctx.$slots, "default")
              ],
              2
              /* CLASS */
            )) : (openBlock(), createElementBlock("span", {
              key: 1,
              class: normalizeClass(_ctx.classes.content),
              innerHTML: _ctx.info
            }, null, 10, _hoisted_2$o))
          ], 10, _hoisted_1$E)
        ],
        34
        /* CLASS, NEED_HYDRATION */
      )) : createCommentVNode("v-if", true);
    }
    script$1C.render = render$K;
    script$1C.__file = "themes/blank/templates/ElementInfo.vue";
    var script$1B = {
      name: "ElementInfo",
      render: script$1C.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-element-info",
            wrapper: "vf-element-info-wrapper",
            wrapper_left: "vf-element-info-wrapper-left",
            wrapper_right: "vf-element-info-wrapper-right",
            wrapper_top: "vf-element-info-wrapper-top",
            wrapper_bottom: "vf-element-info-wrapper-bottom",
            content: "vf-element-info-content",
            $wrapper: (classes2, { position }) => [
              classes2.wrapper,
              classes2[`wrapper_${position}`]
            ]
          }
        };
      }
    };
    var css_248z$M = `.vf-element-info {
  margin-left: 0.25rem;
  position: relative;
  top: 1px;
  cursor: pointer;
}

.vf-element-info:before {
  content: "";
  mask-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='15px' height='14px' viewBox='0 0 15 14' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E%3Cpath d='M7.40520349,0.18129431 C11.1501134,0.18129431 14.1864373,3.21871306 14.1864373,6.96252814 C14.1864373,10.7085329 11.1501134,13.743762 7.40520349,13.743762 C3.6602936,13.743762 0.62396966,10.7085329 0.62396966,6.96252814 C0.62396966,3.21871306 3.6602936,0.18129431 7.40520349,0.18129431 Z M7.40520349,3.18909964 C6.77093148,3.18909964 6.25676873,3.70326238 6.25676873,4.3375344 C6.25676873,4.97180642 6.77093148,5.48596916 7.40520349,5.48596916 C8.03947551,5.48596916 8.55363825,4.97180642 8.55363825,4.3375344 C8.55363825,3.70326238 8.03947551,3.18909964 7.40520349,3.18909964 Z M8.93644984,10.1343956 L8.93644984,9.47814714 C8.93644984,9.29694183 8.78953094,9.15002293 8.60832562,9.15002293 L8.28020141,9.15002293 L8.28020141,6.41565445 C8.28020141,6.23444913 8.13328251,6.08753023 7.95207719,6.08753023 L6.20208136,6.08753023 C6.02087604,6.08753023 5.87395714,6.23444913 5.87395714,6.41565445 L5.87395714,7.07190288 C5.87395714,7.2531082 6.02087604,7.4000271 6.20208136,7.4000271 L6.53020558,7.4000271 L6.53020558,9.15002293 L6.20208136,9.15002293 C6.02087604,9.15002293 5.87395714,9.29694183 5.87395714,9.47814714 L5.87395714,10.1343956 C5.87395714,10.3156009 6.02087604,10.4625198 6.20208136,10.4625198 L8.60832562,10.4625198 C8.78953094,10.4625198 8.93644984,10.3156009 8.93644984,10.1343956 Z' id='info-circle' fill='currentColor'%3E%3C/path%3E%3C/g%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='15px' height='14px' viewBox='0 0 15 14' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E%3Cpath d='M7.40520349,0.18129431 C11.1501134,0.18129431 14.1864373,3.21871306 14.1864373,6.96252814 C14.1864373,10.7085329 11.1501134,13.743762 7.40520349,13.743762 C3.6602936,13.743762 0.62396966,10.7085329 0.62396966,6.96252814 C0.62396966,3.21871306 3.6602936,0.18129431 7.40520349,0.18129431 Z M7.40520349,3.18909964 C6.77093148,3.18909964 6.25676873,3.70326238 6.25676873,4.3375344 C6.25676873,4.97180642 6.77093148,5.48596916 7.40520349,5.48596916 C8.03947551,5.48596916 8.55363825,4.97180642 8.55363825,4.3375344 C8.55363825,3.70326238 8.03947551,3.18909964 7.40520349,3.18909964 Z M8.93644984,10.1343956 L8.93644984,9.47814714 C8.93644984,9.29694183 8.78953094,9.15002293 8.60832562,9.15002293 L8.28020141,9.15002293 L8.28020141,6.41565445 C8.28020141,6.23444913 8.13328251,6.08753023 7.95207719,6.08753023 L6.20208136,6.08753023 C6.02087604,6.08753023 5.87395714,6.23444913 5.87395714,6.41565445 L5.87395714,7.07190288 C5.87395714,7.2531082 6.02087604,7.4000271 6.20208136,7.4000271 L6.53020558,7.4000271 L6.53020558,9.15002293 L6.20208136,9.15002293 C6.02087604,9.15002293 5.87395714,9.29694183 5.87395714,9.47814714 L5.87395714,10.1343956 C5.87395714,10.3156009 6.02087604,10.4625198 6.20208136,10.4625198 L8.60832562,10.4625198 C8.78953094,10.4625198 8.93644984,10.3156009 8.93644984,10.1343956 Z' id='info-circle' fill='currentColor'%3E%3C/path%3E%3C/g%3E%3C/svg%3E");
  mask-position: center center;
  -webkit-mask-position: center center;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-size: contain;
  -webkit-mask-size: contain;
  background-color: var(--vf-bg-passive);
  width: 0.875rem;
  height: 0.875rem;
  display: inline-block;
}

.vf-element-info:hover .vf-element-info-wrapper {
  opacity: 1;
  visibility: visible;
}

.vf-element-info-wrapper {
  position: absolute;
  opacity: 0;
  visibility: hidden;
  transition: 0.3s;
  z-index: 1000;
  width: 12.5rem;
}

.vf-element-info-wrapper.vf-element-info-wrapper-left {
  top: -0.5625rem;
  right: 1.375rem;
}

.vf-element-info-wrapper.vf-element-info-wrapper-right {
  top: -0.5625rem;
  left: 1.375rem;
}

.vf-element-info-wrapper.vf-element-info-wrapper-top {
  bottom: 1.375rem;
  left: 50%;
  transform: translateX(-50%);
}

.vf-element-info-wrapper.vf-element-info-wrapper-bottom {
  top: 1.375rem;
  left: 50%;
  transform: translateX(-50%);
}

.vf-element-info-content {
  background: rgba(0, 0, 0, 0.85);
  color: #FFFFFF;
  border-radius: var(--vf-radius-small);
  font-size: var(--vf-font-size-small);
  line-height: var(--vf-line-height-small);
  letter-spacing: var(--vf-letter-spacing-small);
  padding: 0.3125rem 0.625rem;
  font-style: normal;
  display: inline-block;
  position: relative;
}

.vf-element-info-content:after {
  right: 100%;
  top: 0.625rem;
  border: solid transparent;
  content: "";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none;
  border-color: rgba(0, 0, 0, 0);
  border-right-color: rgba(0, 0, 0, 0.85);
  border-width: 5px;
}`;
    styleInject(css_248z$M);
    script$1B.__file = "themes/vueform/templates/ElementInfo.vue";
    var script$1A = {
      name: "ElementDescription",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: ""
          }
        };
      }
    };
    const _hoisted_1$D = ["innerHTML", "id"];
    const _hoisted_2$n = ["id"];
    function render$J(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        Fragment,
        null,
        [
          createCommentVNode(" If description is HTML "),
          _ctx.description ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.classes.container),
            innerHTML: _ctx.description,
            id: _ctx.id
          }, null, 10, _hoisted_1$D)) : _ctx.isSlot ? (openBlock(), createElementBlock(
            Fragment,
            { key: 1 },
            [
              createCommentVNode(" If description is a slot "),
              createBaseVNode("div", {
                class: normalizeClass(_ctx.classes.container),
                id: _ctx.id
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 10, _hoisted_2$n)
            ],
            2112
            /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )) : createCommentVNode("v-if", true)
        ],
        2112
        /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
      );
    }
    script$1A.render = render$J;
    script$1A.__file = "themes/blank/templates/ElementDescription.vue";
    var script$1z = {
      name: "ElementDescription",
      render: script$1A.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-description",
            container_sm: "vf-description-sm",
            container_md: "",
            container_lg: "vf-description-lg",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$L = ".vf-description {\n  font-size: var(--vf-font-size-small);\n  line-height: var(--vf-line-height-small);\n  letter-spacing: var(--vf-letter-spacing-small);\n  color: var(--vf-color-muted);\n  margin-top: 0.25rem;\n}\n\n.vf-description.vf-description-sm {\n  font-size: var(--vf-font-size-small-sm);\n  line-height: var(--vf-line-height-small-sm);\n  letter-spacing: var(--vf-letter-spacing-small-sm);\n  margin-top: 0.125rem;\n}\n\n.vf-description.vf-description-lg {\n  font-size: var(--vf-font-size-small-lg);\n  line-height: var(--vf-line-height-small-lg);\n  letter-spacing: var(--vf-letter-spacing-small-lg);\n}";
    styleInject(css_248z$L);
    script$1z.__file = "themes/vueform/templates/ElementDescription.vue";
    var script$1y = {
      name: "ElementError",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: ""
          }
        };
      }
    };
    const _hoisted_1$C = ["id", "innerHTML"];
    function render$I(_ctx, _cache, $props, $setup, $data, $options) {
      return _ctx.error ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.classes.container),
        id: _ctx.id,
        "aria-live": "assertive",
        innerHTML: _ctx.error
      }, null, 10, _hoisted_1$C)) : createCommentVNode("v-if", true);
    }
    script$1y.render = render$I;
    script$1y.__file = "themes/blank/templates/ElementError.vue";
    var script$1x = {
      name: "ElementError",
      render: script$1y.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-element-error",
            container_sm: "vf-element-error-sm",
            container_md: "",
            container_lg: "vf-element-error-lg",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$K = ".vf-element-error {\n  font-size: var(--vf-font-size-small);\n  line-height: var(--vf-line-height-small);\n  letter-spacing: var(--vf-letter-spacing-small);\n  color: var(--vf-color-danger);\n  margin-top: 0.25rem;\n}\n\n.vf-element-error.vf-element-error-sm {\n  font-size: var(--vf-font-size-small-sm);\n  line-height: var(--vf-line-height-small-sm);\n  letter-spacing: var(--vf-letter-spacing-small-sm);\n  margin-top: 0.125rem;\n}\n\n.vf-element-error.vf-element-error-lg {\n  font-size: var(--vf-font-size-small-lg);\n  line-height: var(--vf-line-height-small-lg);\n  letter-spacing: var(--vf-letter-spacing-small-lg);\n}";
    styleInject(css_248z$K);
    script$1x.__file = "themes/vueform/templates/ElementError.vue";
    var script$1w = {
      name: "ElementMessage",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: ""
          }
        };
      }
    };
    const _hoisted_1$B = ["innerHTML"];
    function render$H(_ctx, _cache, $props, $setup, $data, $options) {
      return _ctx.message ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.classes.container),
        innerHTML: _ctx.message
      }, null, 10, _hoisted_1$B)) : createCommentVNode("v-if", true);
    }
    script$1w.render = render$H;
    script$1w.__file = "themes/blank/templates/ElementMessage.vue";
    var script$1v = {
      name: "ElementMessage",
      render: script$1w.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-element-message",
            container_sm: "vf-element-message-sm",
            container_md: "",
            container_lg: "vf-element-message-lg",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$J = ".vf-element-message {\n  font-size: var(--vf-font-size-small);\n  line-height: var(--vf-line-height-small);\n  letter-spacing: var(--vf-letter-spacing-small);\n  color: var(--vf-color-success);\n  margin-top: 0.25rem;\n}\n\n.vf-element-message.vf-element-message-sm {\n  font-size: var(--vf-font-size-small-sm);\n  line-height: var(--vf-line-height-small-sm);\n  letter-spacing: var(--vf-letter-spacing-small-sm);\n  margin-top: 0.125rem;\n}\n\n.vf-element-message.vf-element-message-lg {\n  font-size: var(--vf-font-size-small-lg);\n  line-height: var(--vf-line-height-small-lg);\n  letter-spacing: var(--vf-letter-spacing-small-lg);\n}";
    styleInject(css_248z$J);
    script$1v.__file = "themes/vueform/templates/ElementMessage.vue";
    var script$1u = {
      name: "ElementText",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: ""
          }
        };
      }
    };
    const _hoisted_1$A = ["innerHTML"];
    function render$G(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        Fragment,
        null,
        [
          createCommentVNode(" If content is HTML "),
          _ctx.content ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.classes.container),
            innerHTML: _ctx.content
          }, null, 10, _hoisted_1$A)) : _ctx.isSlot ? (openBlock(), createElementBlock(
            Fragment,
            { key: 1 },
            [
              createCommentVNode(" If content is a slot "),
              createBaseVNode(
                "div",
                {
                  class: normalizeClass(_ctx.classes.container)
                },
                [
                  renderSlot(_ctx.$slots, "default")
                ],
                2
                /* CLASS */
              )
            ],
            2112
            /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )) : createCommentVNode("v-if", true)
        ],
        2112
        /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
      );
    }
    script$1u.render = render$G;
    script$1u.__file = "themes/blank/templates/ElementText.vue";
    var script$1t = {
      name: "ElementText",
      render: script$1u.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            container_before: "",
            container_between: "",
            container_after: "",
            $container: (classes2, { type }) => [
              classes2.container,
              classes2[`container_${type}`]
            ]
          }
        };
      }
    };
    script$1t.__file = "themes/vueform/templates/ElementText.vue";
    var script$1s = {
      name: "ElementAddon",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: ""
          }
        };
      }
    };
    const _hoisted_1$z = ["innerHTML"];
    function render$F(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        Fragment,
        null,
        [
          createCommentVNode(" If addon is a component "),
          _ctx.addon && _ctx.isAddonComponent ? (openBlock(), createElementBlock(
            "div",
            {
              key: 0,
              class: normalizeClass(_ctx.classes.container)
            },
            [
              createBaseVNode(
                "div",
                {
                  class: normalizeClass(_ctx.classes.wrapper)
                },
                [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.addon)))
                ],
                2
                /* CLASS */
              )
            ],
            2
            /* CLASS */
          )) : _ctx.addon ? (openBlock(), createElementBlock(
            Fragment,
            { key: 1 },
            [
              createCommentVNode(" If addon is HTML "),
              createBaseVNode(
                "div",
                {
                  class: normalizeClass(_ctx.classes.container)
                },
                [
                  createBaseVNode("div", {
                    class: normalizeClass(_ctx.classes.wrapper),
                    innerHTML: _ctx.addon
                  }, null, 10, _hoisted_1$z)
                ],
                2
                /* CLASS */
              )
            ],
            2112
            /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )) : _ctx.isSlot ? (openBlock(), createElementBlock(
            Fragment,
            { key: 2 },
            [
              createCommentVNode(" If addon is a slot "),
              createBaseVNode(
                "div",
                {
                  class: normalizeClass(_ctx.classes.container)
                },
                [
                  createBaseVNode(
                    "div",
                    {
                      class: normalizeClass(_ctx.classes.wrapper)
                    },
                    [
                      renderSlot(_ctx.$slots, "default")
                    ],
                    2
                    /* CLASS */
                  )
                ],
                2
                /* CLASS */
              )
            ],
            2112
            /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )) : createCommentVNode("v-if", true)
        ],
        2112
        /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
      );
    }
    script$1s.render = render$F;
    script$1s.__file = "themes/blank/templates/ElementAddon.vue";
    var script$1r = {
      name: "ElementAddon",
      render: script$1s.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-addon",
            container_before: "vf-addon-before",
            container_after: "vf-addon-after",
            container_sm: "vf-addon-sm",
            container_md: "",
            container_lg: "vf-addon-lg",
            container_before_sm: "",
            container_before_md: "",
            container_before_lg: "",
            container_after_sm: "",
            container_after_md: "",
            container_after_lg: "",
            wrapper: "vf-addon-wrapper",
            $container: (classes2, { type, Size }) => [
              classes2.container,
              classes2[`container_${Size}`],
              classes2[`container_${type}`],
              classes2[`container_${type}_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$I = ".vf-addon {\n  background: var(--vf-bg-addon);\n  color: var(--vf-color-addon);\n  border-radius: var(--vf-radius-input);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex: 0 0 0%;\n}\n\n.vf-addon.vf-addon-before {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  padding: 0 var(--vf-space-addon) 0 var(--vf-px-input);\n}\n\n.vf-addon.vf-addon-before.vf-addon-sm {\n  padding: 0 var(--vf-space-addon-sm) 0 var(--vf-px-input-sm);\n}\n\n.vf-addon.vf-addon-before.vf-addon-lg {\n  padding: 0 var(--vf-space-addon-lg) 0 var(--vf-px-input-lg);\n}\n\n.vf-addon.vf-addon-after {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  padding: 0 var(--vf-px-input) 0 var(--vf-space-addon);\n  order: 2;\n}\n\n.vf-addon.vf-addon-after.vf-addon-sm {\n  padding: 0 var(--vf-px-input-sm) 0 var(--vf-space-addon-sm);\n}\n\n.vf-addon.vf-addon-after.vf-addon-lg {\n  padding: 0 var(--vf-px-input-lg) 0 var(--vf-space-addon-lg);\n}\n\n.vf-addon-wrapper {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}";
    styleInject(css_248z$I);
    script$1r.__file = "themes/vueform/templates/ElementAddon.vue";
    var script$1q = {
      name: "ElementAddonOptions",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            caret: "",
            dropdown: "",
            option: ""
          }
        };
      }
    };
    const _hoisted_1$y = ["aria-expanded", "aria-controls", "tabindex"];
    const _hoisted_2$m = ["innerHTML"];
    const _hoisted_3$d = ["innerHTML"];
    const _hoisted_4$a = ["innerHTML"];
    const _hoisted_5$6 = ["innerHTML"];
    const _hoisted_6$5 = ["data-dropdown-for", "id"];
    const _hoisted_7$3 = ["innerHTML", "data-index", "data-selected", "onMouseover", "onClick", "tabindex", "aria-selected"];
    const _hoisted_8$2 = ["innerHTML", "data-index", "data-selected", "onMouseover", "onClick", "tabindex", "aria-selected"];
    function render$E(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          createBaseVNode("div", mergeProps({
            class: _ctx.classes.wrapper,
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleSelectorClick && _ctx.handleSelectorClick(...args)),
            onKeydown: _cache[1] || (_cache[1] = (...args) => _ctx.handleSelectorKeydown && _ctx.handleSelectorKeydown(...args))
          }, _ctx.aria, {
            "aria-expanded": _ctx.isOpen,
            "aria-haspopup": "listbox",
            "aria-controls": `dropdown-${_ctx.el$.fieldId}`,
            role: "button",
            tabindex: _ctx.el$.isDisabled || _ctx.el$.readonly ? void 0 : 0,
            ref: "selector"
          }), [
            Object.keys(_ctx.selected).length ? (openBlock(), createElementBlock(
              Fragment,
              { key: 0 },
              [
                _ctx.selected.valueDisplay && typeof _ctx.selected.valueDisplay === "object" && [_ctx.selected.valueDisplay.render || _ctx.selected.valueDisplay.template] ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.selected.valueDisplay), {
                  key: 0,
                  el$: _ctx.el$,
                  option: _ctx.selected
                }, null, 8, ["el$", "option"])) : _ctx.selected.valueDisplay && typeof _ctx.selected.valueDisplay === "function" ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  innerHTML: _ctx.selected.valueDisplay(_ctx.selected, _ctx.el$)
                }, null, 8, _hoisted_2$m)) : (openBlock(), createElementBlock("div", {
                  key: 2,
                  innerHTML: _ctx.selected.label
                }, null, 8, _hoisted_3$d))
              ],
              64
              /* STABLE_FRAGMENT */
            )) : (openBlock(), createElementBlock(
              Fragment,
              { key: 1 },
              [
                _ctx.placeholder && typeof _ctx.placeholder === "object" && [_ctx.placeholder.render || _ctx.placeholder.template] ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.placeholder), {
                  key: 0,
                  el$: _ctx.el$,
                  option: _ctx.selected
                }, null, 8, ["el$", "option"])) : _ctx.placeholder && typeof _ctx.placeholder === "function" ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  innerHTML: _ctx.placeholder(_ctx.selected, _ctx.el$)
                }, null, 8, _hoisted_4$a)) : (openBlock(), createElementBlock("div", {
                  key: 2,
                  innerHTML: _ctx.placeholder
                }, null, 8, _hoisted_5$6))
              ],
              64
              /* STABLE_FRAGMENT */
            )),
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.caret)
              },
              null,
              2
              /* CLASS */
            ),
            (openBlock(), createBlock(Teleport, { to: "body" }, [
              _ctx.isOpen ? (openBlock(), createElementBlock("div", {
                key: 0,
                "data-dropdown-for": _ctx.el$.fieldId,
                id: `dropdown-${_ctx.el$.fieldId}`,
                class: normalizeClass(_ctx.classes.dropdown),
                style: normalizeStyle(_ctx.style),
                ref: "dropdown",
                role: "listbox",
                tabindex: "-1"
              }, [
                (openBlock(true), createElementBlock(
                  Fragment,
                  null,
                  renderList(_ctx.options, (option, index2) => {
                    return openBlock(), createElementBlock(
                      "div",
                      {
                        class: normalizeClass(_ctx.classes.optionWrapper),
                        key: option.value
                      },
                      [
                        option.display && typeof option.display === "object" && [option.display.render || option.display.template] ? (openBlock(), createBlock(resolveDynamicComponent(option.display), {
                          key: 0,
                          el$: _ctx.el$,
                          option,
                          index: index2,
                          selected: _ctx.selected.index === option.index,
                          pointed: _ctx.pointed.index === option.index,
                          "data-index": option.index,
                          "data-selected": _ctx.selected.index === option.index,
                          onMouseover: ($event) => _ctx.handleOptionPoint(option),
                          onClick: ($event) => _ctx.handleOptionClick(option),
                          role: "option",
                          tabindex: _ctx.pointed.index === option.index ? 0 : -1,
                          "aria-selected": _ctx.selected.index === option.index
                        }, null, 40, ["el$", "option", "index", "selected", "pointed", "data-index", "data-selected", "onMouseover", "onClick", "tabindex", "aria-selected"])) : option.display && typeof option.display === "function" ? (openBlock(), createElementBlock("div", {
                          key: 1,
                          innerHTML: option.display(option, index2, _ctx.selected.index === option.index, _ctx.pointed.index === option.index, _ctx.el$),
                          class: normalizeClass(_ctx.classes.option(option, index2, _ctx.el$)),
                          "data-index": option.index,
                          "data-selected": _ctx.selected.index === option.index,
                          onMouseover: ($event) => _ctx.handleOptionPoint(option),
                          onClick: ($event) => _ctx.handleOptionClick(option),
                          role: "option",
                          tabindex: _ctx.pointed.index === option.index ? 0 : -1,
                          "aria-selected": _ctx.selected.index === option.index
                        }, null, 42, _hoisted_7$3)) : (openBlock(), createElementBlock("div", {
                          key: 2,
                          innerHTML: option.label,
                          class: normalizeClass(_ctx.classes.option(option, index2, _ctx.el$)),
                          "data-index": option.index,
                          "data-selected": _ctx.selected.index === option.index,
                          onMouseover: ($event) => _ctx.handleOptionPoint(option),
                          onClick: ($event) => _ctx.handleOptionClick(option),
                          role: "option",
                          tabindex: _ctx.pointed.index === option.index ? 0 : -1,
                          "aria-selected": _ctx.selected.index === option.index
                        }, null, 42, _hoisted_8$2))
                      ],
                      2
                      /* CLASS */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ], 14, _hoisted_6$5)) : createCommentVNode("v-if", true)
            ]))
          ], 16, _hoisted_1$y)
        ],
        2
        /* CLASS */
      );
    }
    script$1q.render = render$E;
    script$1q.__file = "themes/blank/templates/ElementAddonOptions.vue";
    var script$1p = {
      name: "ElementAddonOptions",
      render: script$1q.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-addon-options",
            container_sm: "vf-addon-options-sm",
            container_md: "",
            container_lg: "vf-addon-options-lg",
            container_disabled: "vf-addon-options-disabled",
            wrapper: "vf-addon-options-wrapper",
            wrapper_relaxed: "vf-addon-options-wrapper-relaxed",
            caret: "vf-addon-options-caret",
            dropdown: "vf-addon-options-dropdown",
            option: "vf-addon-options-option",
            option_active: "vf-addon-options-option-active",
            $container: (classes2, { Size, el$ }) => [
              classes2.container,
              classes2[`container_${Size}`],
              el$.isDisabled || el$.readonly ? classes2.container_disabled : null
            ],
            $wrapper: (classes2, { relaxed }) => [
              classes2.wrapper,
              relaxed ? classes2.wrapper_relaxed : classes2.wrapper_default
            ],
            $option: (classes2, { selected, pointed }) => (option) => [
              classes2.option,
              selected.index === option.index || pointed.index === option.index ? classes2.option_active : null
            ]
          }
        };
      }
    };
    var css_248z$H = `.vf-addon-options {
  display: flex;
  align-items: center;
  font-size: var(--vf-font-size);
  line-height: var(--vf-line-height);
  letter-spacing: var(--vf-letter-spacing);
}

.vf-addon-options.vf-addon-options-sm {
  font-size: var(--vf-font-size-sm);
  line-height: var(--vf-line-height-sm);
  letter-spacing: var(--vf-letter-spacing-sm);
}

.vf-addon-options.vf-addon-options-lg {
  font-size: var(--vf-font-size-lg);
  line-height: var(--vf-line-height-lg);
  letter-spacing: var(--vf-letter-spacing-lg);
}

.vf-addon-options.vf-addon-options-disabled {
  opacity: 0.5;
  cursor: initial;
  pointer-events: none;
}

.vf-addon-options-wrapper {
  display: flex;
  align-items: center;
  border-radius: 4px;
  padding: 4px 4px;
  cursor: pointer;
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
  outline: none;
}

.vf-addon-options-wrapper:hover, .vf-addon-options-wrapper:focus {
  background: var(--vf-bg-selected);
}

.vf-addon-options-wrapper.vf-addon-options-wrapper-relaxed {
  padding: 6px 12px;
}

.vf-addon-options-caret {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z'%3E%3C/path%3E%3C/svg%3E");
  mask-position: center center;
  -webkit-mask-position: center center;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  background-color: var(--vf-bg-icon);
  color: var(--vf-color-input);
  width: 0.625rem;
  height: 1rem;
  padding: 1px 0;
  margin-left: 0.5rem;
}

.vf-addon-options-dropdown {
  background-color: var(--vf-bg-input);
  border-width: var(--vf-border-width-dropdown);
  border-style: solid;
  border-color: var(--vf-border-color-input);
  box-shadow: var(--vf-shadow-dropdown);
  color: var(--vf-color-input);
  position: fixed;
  z-index: 1002;
  overflow-x: scroll;
  max-height: calc(100vh - 2rem);
}

.vf-addon-options-option {
  display: flex;
  align-items: center;
  cursor: pointer;
  padding: 0.3125rem 0.75rem;
  white-space: nowrap;
}

.vf-addon-options-option-active {
  background: var(--vf-bg-selected);
}

[dir=rtl] .vf-addon-options-caret {
  margin-left: 0;
  margin-right: 0.5rem;
}`;
    styleInject(css_248z$H);
    script$1p.__file = "themes/vueform/templates/ElementAddonOptions.vue";
    var script$1o = {
      name: "ButtonElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            button: ""
          }
        };
      }
    };
    const _hoisted_1$x = ["tabindex", "disabled"];
    const _hoisted_2$l = ["innerHTML", "tabindex", "disabled"];
    const _hoisted_3$c = ["tabindex", "disabled"];
    const _hoisted_4$9 = ["tabindex"];
    const _hoisted_5$5 = ["innerHTML", "tabindex"];
    const _hoisted_6$4 = ["tabindex"];
    function render$D(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createCommentVNode(" Use `button` tag "),
            _ctx.buttonType === "button" ? (openBlock(), createElementBlock(
              Fragment,
              { key: 0 },
              [
                createCommentVNode(" Use it as a component "),
                _ctx.buttonLabel && _ctx.isButtonLabelComponent ? (openBlock(), createElementBlock("button", mergeProps({ key: 0 }, {
                  ..._ctx.button,
                  ..._ctx.aria
                }, {
                  tabindex: _ctx.isDisabled || _ctx.isLoading ? -1 : void 0,
                  disabled: _ctx.isDisabled,
                  class: _ctx.classes.button,
                  onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["prevent"]))
                }), [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.buttonLabel)))
                ], 16, _hoisted_1$x)) : _ctx.buttonLabel ? (openBlock(), createElementBlock(
                  Fragment,
                  { key: 1 },
                  [
                    createCommentVNode(" Use it as HTML "),
                    createBaseVNode("button", mergeProps({
                      ..._ctx.button,
                      ..._ctx.aria
                    }, {
                      innerHTML: _ctx.resolvedButtonLabel,
                      tabindex: _ctx.isDisabled || _ctx.isLoading ? -1 : void 0,
                      class: _ctx.classes.button,
                      disabled: _ctx.isDisabled,
                      onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["prevent"]))
                    }), null, 16, _hoisted_2$l)
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                )) : (openBlock(), createElementBlock(
                  Fragment,
                  { key: 2 },
                  [
                    createCommentVNode(" Use it as slot "),
                    createBaseVNode("button", mergeProps({
                      ..._ctx.button,
                      ..._ctx.aria
                    }, {
                      tabindex: _ctx.isDisabled || _ctx.isLoading ? -1 : void 0,
                      class: _ctx.classes.button,
                      disabled: _ctx.isDisabled,
                      onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["prevent"]))
                    }), [
                      renderSlot(_ctx.$slots, "default", { el$: _ctx.el$ }, () => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots.default), { el$: _ctx.el$ }, null, 8, ["el$"]))
                      ])
                    ], 16, _hoisted_3$c)
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                ))
              ],
              64
              /* STABLE_FRAGMENT */
            )) : (openBlock(), createElementBlock(
              Fragment,
              { key: 1 },
              [
                createCommentVNode(" Use `anchor` tag "),
                createCommentVNode(" Use it as a component "),
                _ctx.buttonLabel && _ctx.isButtonLabelComponent ? (openBlock(), createElementBlock("a", mergeProps({ key: 0 }, {
                  ..._ctx.button,
                  ..._ctx.aria
                }, {
                  tabindex: _ctx.isDisabled || _ctx.isLoading ? -1 : void 0,
                  class: _ctx.classes.button,
                  onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
                }), [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.buttonLabel)))
                ], 16, _hoisted_4$9)) : _ctx.buttonLabel ? (openBlock(), createElementBlock(
                  Fragment,
                  { key: 1 },
                  [
                    createCommentVNode(" Use it as HTML "),
                    createBaseVNode("a", mergeProps({
                      ..._ctx.button,
                      ..._ctx.aria
                    }, {
                      innerHTML: _ctx.resolvedButtonLabel,
                      tabindex: _ctx.isDisabled || _ctx.isLoading ? -1 : void 0,
                      class: _ctx.classes.button,
                      onClick: _cache[4] || (_cache[4] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
                    }), null, 16, _hoisted_5$5)
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                )) : (openBlock(), createElementBlock(
                  Fragment,
                  { key: 2 },
                  [
                    createCommentVNode(" Use it as slot "),
                    createBaseVNode("a", mergeProps({
                      ..._ctx.button,
                      ..._ctx.aria
                    }, {
                      tabindex: _ctx.isDisabled || _ctx.isLoading ? -1 : void 0,
                      class: _ctx.classes.button,
                      onClick: _cache[5] || (_cache[5] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
                    }), [
                      renderSlot(_ctx.$slots, "default", { el$: _ctx.el$ }, () => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots.default), { el$: _ctx.el$ }, null, 8, ["el$"]))
                      ])
                    ], 16, _hoisted_6$4)
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                ))
              ],
              64
              /* STABLE_FRAGMENT */
            ))
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$1o.render = render$D;
    script$1o.__file = "themes/blank/templates/elements/ButtonElement.vue";
    var script$1n = {
      name: "ButtonElement",
      render: script$1o.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            button: "vf-btn",
            button_enabled: "",
            button_disabled: "vf-btn-disabled",
            button_loading: "vf-btn-loading",
            button_loading_primary: "vf-btn-loading-primary",
            button_loading_secondary: "vf-btn-loading-secondary",
            button_loading_danger: "vf-btn-loading-danger",
            button_primary: "vf-btn-primary",
            button_secondary: "vf-btn-secondary",
            button_danger: "vf-btn-danger",
            button_full: "vf-btn-full",
            button_not_full: "",
            button_left: "vf-btn-left",
            button_center: "vf-btn-center",
            button_right: "vf-btn-right",
            button_sm: "vf-btn-sm",
            button_md: "",
            button_lg: "vf-btn-lg",
            $button: (classes2, { isDisabled, isLoading, buttonClass, Size, danger, secondary, full, align }) => [
              classes2.button,
              danger ? classes2.button_danger : null,
              secondary ? classes2.button_secondary : null,
              !danger && !secondary ? classes2.button_primary : null,
              classes2[`button_${Size}`],
              isDisabled ? classes2.button_disabled : null,
              !isDisabled && !isLoading ? classes2.button_enabled : null,
              isLoading ? classes2.button_loading : null,
              isLoading && danger ? classes2.button_loading_danger : null,
              isLoading && secondary ? classes2.button_loading_secondary : null,
              isLoading && !secondary && !danger ? classes2.button_loading_primary : null,
              full ? classes2.button_full : classes2.button_not_full,
              align === "left" ? classes2.button_left : null,
              align === "center" ? classes2.button_center : null,
              align === "right" ? classes2.button_right : null,
              buttonClass
            ]
          }
        };
      }
    };
    var css_248z$G = "/* Some styles are contained in Vueform.vue */";
    styleInject(css_248z$G);
    script$1n.__file = "themes/vueform/templates/elements/ButtonElement.vue";
    var script$1m = {
      name: "CaptchaElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            captcha: ""
          }
        };
      }
    };
    const _hoisted_1$w = ["id"];
    function render$C(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            _ctx.shouldVerify ? (openBlock(), createElementBlock(
              "div",
              {
                key: 0,
                class: normalizeClass(_ctx.classes.wrapper)
              },
              [
                createBaseVNode("div", {
                  id: _ctx.fieldId,
                  class: normalizeClass(_ctx.classes.captcha),
                  ref: "input"
                }, null, 10, _hoisted_1$w)
              ],
              2
              /* CLASS */
            )) : createCommentVNode("v-if", true)
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$1m.render = render$C;
    script$1m.__file = "themes/blank/templates/elements/CaptchaElement.vue";
    var script$1l = {
      name: "CaptchaElement",
      render: script$1m.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            captcha: ""
          }
        };
      }
    };
    script$1l.__file = "themes/vueform/templates/elements/CaptchaElement.vue";
    var script$1k = {
      name: "CheckboxElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            input: "",
            text: ""
          }
        };
      }
    };
    const _hoisted_1$v = ["name", "id", "true-value", "false-value", "disabled"];
    const _hoisted_2$k = ["innerHTML"];
    function render$B(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createBaseVNode(
              "label",
              {
                class: normalizeClass(_ctx.classes.wrapper)
              },
              [
                withDirectives(createBaseVNode("input", mergeProps({
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value = $event)
                }, _ctx.aria, {
                  class: _ctx.classes.input,
                  name: _ctx.path,
                  id: _ctx.fieldId,
                  "true-value": _ctx.trueValue,
                  "false-value": _ctx.falseValue,
                  disabled: _ctx.isDisabled,
                  ref: "input"
                }), null, 16, _hoisted_1$v), [
                  [vModelCheckbox, _ctx.value]
                ]),
                createCommentVNode(" If label is HTML "),
                _ctx.Text ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: normalizeClass(_ctx.classes.text),
                  innerHTML: _ctx.Text
                }, null, 10, _hoisted_2$k)) : (openBlock(), createElementBlock(
                  Fragment,
                  { key: 1 },
                  [
                    createCommentVNode(" If label is slot "),
                    createBaseVNode(
                      "span",
                      {
                        class: normalizeClass(_ctx.classes.text)
                      },
                      [
                        renderSlot(_ctx.$slots, "default", { el$: _ctx.el$ }, () => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots.default), { el$: _ctx.el$ }, null, 8, ["el$"]))
                        ])
                      ],
                      2
                      /* CLASS */
                    )
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                ))
              ],
              2
              /* CLASS */
            )
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$1k.render = render$B;
    script$1k.__file = "themes/blank/templates/elements/CheckboxElement.vue";
    var script$1j = {
      name: "CheckboxElement",
      render: script$1k.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-contains-link",
            wrapper: "vf-checkbox-wrapper",
            wrapper_sm: "vf-checkbox-wrapper-sm",
            wrapper_md: "",
            wrapper_lg: "vf-checkbox-wrapper-lg",
            wrapper_left: "vf-checkbox-wrapper-left",
            wrapper_right: "vf-checkbox-wrapper-right",
            input: "vf-checkbox",
            input_enabled: "",
            input_disabled: "",
            input_danger: "vf-checkbox-danger",
            input_sm: "vf-checkbox-sm",
            input_md: "",
            input_lg: "vf-checkbox-lg",
            input_left: "vf-checkbox-left",
            input_right: "vf-checkbox-right",
            text: "vf-checkbox-text",
            text_left: "vf-checkbox-text-left",
            text_right: "vf-checkbox-text-right",
            $wrapper: (classes2, { Size, align }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`],
              align === "left" ? classes2.wrapper_left : null,
              align === "right" ? classes2.wrapper_right : null
            ],
            $input: (classes2, { isDisabled, Size, isDanger, align }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : classes2.input_enabled,
              !isDisabled && isDanger ? classes2.input_danger : null,
              align === "left" ? classes2.input_left : null,
              align === "right" ? classes2.input_right : null
            ],
            $text: (classes2, { align }) => [
              classes2.text,
              align === "left" ? classes2.text_left : null,
              align === "right" ? classes2.text_right : null
            ]
          }
        };
      }
    };
    var css_248z$F = "/* Some styles are contained in Vueform.vue */";
    styleInject(css_248z$F);
    script$1j.__file = "themes/vueform/templates/elements/CheckboxElement.vue";
    var script$1i = {
      name: "CheckboxgroupElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: ""
          }
        };
      }
    };
    const _hoisted_1$u = ["aria-labelledby"];
    function render$A(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_CheckboxgroupCheckbox = resolveComponent("CheckboxgroupCheckbox");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.classes.wrapper),
              "aria-labelledby": _ctx.labelId,
              role: "group"
            }, [
              (openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(_ctx.resolvedOptions, (item, index2, key) => {
                  return openBlock(), createBlock(_component_CheckboxgroupCheckbox, {
                    items: _ctx.resolvedOptions,
                    index: index2,
                    item,
                    value: item.value,
                    key,
                    attrs: _ctx.aria
                  }, {
                    default: withCtx((scope2) => [
                      renderSlot(_ctx.$slots, "checkbox", mergeProps({ ref_for: true }, scope2, { el$: _ctx.el$ }), () => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots.checkbox), mergeProps({ ref_for: true }, scope2, { el$: _ctx.el$ }), null, 16, ["el$"]))
                      ])
                    ]),
                    _: 2
                    /* DYNAMIC */
                  }, 1032, ["items", "index", "item", "value", "attrs"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ], 10, _hoisted_1$u)
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$1i.render = render$A;
    script$1i.__file = "themes/blank/templates/elements/CheckboxgroupElement.vue";
    var script$1h = {
      name: "CheckboxgroupElement",
      render: script$1i.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "vf-checkboxgroup-wrapper",
            wrapper_sm: "vf-checkboxgroup-wrapper-sm",
            wrapper_md: "",
            wrapper_lg: "vf-checkboxgroup-wrapper-lg",
            $wrapper: (classes2, { Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$E = ".vf-checkboxgroup-wrapper {\n  cursor: pointer;\n}\n\n.vf-checkboxgroup-wrapper .vf-checkbox-container {\n  padding-top: 0;\n}";
    styleInject(css_248z$E);
    script$1h.__file = "themes/vueform/templates/elements/CheckboxgroupElement.vue";
    var script$1g = {
      name: "CheckboxgroupElement_tabs",
      render: script$1i.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "vf-checkboxgroup-tabs-wrapper",
            wrapper_sm: "vf-checkboxgroup-tabs-wrapper-sm",
            wrapper_md: "",
            wrapper_lg: "vf-checkboxgroup-tabs-wrapper-lg",
            $wrapper: (classes2, { Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$D = ".vf-checkboxgroup-tabs-wrapper {\n  display: grid;\n  grid-auto-flow: column;\n  box-shadow: var(--vf-shadow-input);\n  border-radius: var(--vf-radius-large);\n}\n\n.vf-checkboxgroup-tabs-wrapper.vf-checkboxgroup-tabs-wrapper-sm {\n  border-radius: var(--vf-radius-large-sm);\n}\n\n.vf-checkboxgroup-tabs-wrapper.vf-checkboxgroup-tabs-wrapper-lg {\n  border-radius: var(--vf-radius-large-lg);\n}";
    styleInject(css_248z$D);
    script$1g.__file = "themes/vueform/templates/elements/CheckboxgroupElement_tabs.vue";
    var script$1f = {
      name: "CheckboxgroupElement_blocks",
      render: script$1i.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "vf-checkboxgroup-blocks-wrapper",
            wrapper_sm: "vf-checkboxgroup-blocks-wrapper-sm",
            wrapper_md: "",
            wrapper_lg: "vf-checkboxgroup-blocks-wrapper-lg",
            $wrapper: (classes2, { Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$C = ".vf-checkboxgroup-blocks-wrapper {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  box-shadow: var(--vf-shadow-input);\n  border-radius: var(--vf-radius-large);\n}\n\n.vf-checkboxgroup-blocks-wrapper.vf-checkboxgroup-blocks-wrapper-sm {\n  border-radius: var(--vf-radius-large-sm);\n}\n\n.vf-checkboxgroup-blocks-wrapper.vf-checkboxgroup-blocks-wrapper-lg {\n  border-radius: var(--vf-radius-large-lg);\n}";
    styleInject(css_248z$C);
    script$1f.__file = "themes/vueform/templates/elements/CheckboxgroupElement_blocks.vue";
    var script$1e = {
      name: "DateElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            inputContainer: "",
            inputWrapper: "",
            input: ""
          }
        };
      }
    };
    function render$z(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ElementAddon = resolveComponent("ElementAddon");
      const _component_ElementLabelFloating = resolveComponent("ElementLabelFloating");
      const _component_DatepickerWrapper = resolveComponent("DatepickerWrapper");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.inputContainer)
              },
              [
                _ctx.hasAddonBefore ? (openBlock(), createBlock(_component_ElementAddon, {
                  key: 0,
                  type: "before"
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "addon-before", {}, () => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots["addon-before"]), { el$: _ctx.el$ }, null, 8, ["el$"]))
                    ])
                  ]),
                  _: 3
                  /* FORWARDED */
                })) : createCommentVNode("v-if", true),
                _ctx.hasAddonAfter ? (openBlock(), createBlock(_component_ElementAddon, {
                  key: 1,
                  type: "after"
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "addon-after", {}, () => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots["addon-after"]), { el$: _ctx.el$ }, null, 8, ["el$"]))
                    ])
                  ]),
                  _: 3
                  /* FORWARDED */
                })) : createCommentVNode("v-if", true),
                _ctx.hasFloating && !_ctx.empty ? (openBlock(), createBlock(_component_ElementLabelFloating, {
                  key: 2,
                  visible: !_ctx.empty
                }, null, 8, ["visible"])) : createCommentVNode("v-if", true),
                createBaseVNode(
                  "div",
                  {
                    class: normalizeClass(_ctx.classes.inputWrapper)
                  },
                  [
                    createVNode(_component_DatepickerWrapper, {
                      value: _ctx.model,
                      options: _ctx.fieldOptions,
                      id: _ctx.fieldId,
                      class: normalizeClass(_ctx.classes.input),
                      placeholder: _ctx.Placeholder,
                      disabled: _ctx.isDisabled,
                      readonly: _ctx.readonly,
                      attrs: _ctx.aria,
                      onChange: _ctx.handleChange,
                      ref: "input"
                    }, null, 8, ["value", "options", "id", "class", "placeholder", "disabled", "readonly", "attrs", "onChange"])
                  ],
                  2
                  /* CLASS */
                )
              ],
              2
              /* CLASS */
            )
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$1e.render = render$z;
    script$1e.__file = "themes/blank/templates/elements/DateElement.vue";
    var script$1d = {
      name: "DateElement",
      render: script$1e.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            inputContainer: "vf-input-group",
            inputContainer_sm: "vf-input-group-sm",
            inputContainer_md: "",
            inputContainer_lg: "vf-input-group-lg",
            inputContainer_default: "",
            inputContainer_disabled: "vf-input-group-disabled",
            inputContainer_focused: "vf-input-group-focused",
            inputContainer_success: "vf-input-group-success",
            inputContainer_danger: "vf-input-group-danger",
            inputWrapper: "vf-datepicker-wrapper",
            input: "vf-input-field",
            input_sm: "",
            input_md: "",
            input_lg: "",
            input_enabled: "",
            input_disabled: "",
            input_focused: "",
            input_success: "",
            input_danger: "",
            $inputContainer: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.inputContainer,
              classes2[`inputContainer_${Size}`],
              isDisabled ? classes2.inputContainer_disabled : null,
              !isDisabled && !isSuccess && !isDanger ? classes2.inputContainer_default : null,
              !isDisabled && focused ? classes2.inputContainer_focused : null,
              !isDisabled && isSuccess ? classes2.inputContainer_success : null,
              !isDisabled && isDanger ? classes2.inputContainer_danger : null
            ],
            $input: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : null,
              !isDisabled && !isSuccess && !isDanger && !focused ? classes2.input_enabled : null,
              !isDisabled && focused && !isSuccess && !isDanger ? classes2.input_focused : null,
              !isDisabled && isDanger ? classes2.input_danger : null,
              !isDisabled && isSuccess ? classes2.input_success : null
            ]
          }
        };
      }
    };
    var css_248z$B = "/* Some styles are contained in Vueform.vue & DatepickerWrapper.vue */\n\n.vf-datepicker-wrapper {\n  display: block;\n  width: 100%;\n  height: 100%;\n}";
    styleInject(css_248z$B);
    script$1d.__file = "themes/vueform/templates/elements/DateElement.vue";
    var script$1c = {
      name: "DatesElement",
      render: script$1e.render,
      staticRenderFns: script$1e.staticRenderFns,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            inputContainer: "",
            input: ""
          }
        };
      }
    };
    script$1c.__file = "themes/blank/templates/elements/DatesElement.vue";
    var script$1b = {
      name: "DatesElement",
      render: script$1c.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            inputContainer: "vf-input-group",
            inputContainer_sm: "vf-input-group-sm",
            inputContainer_md: "",
            inputContainer_lg: "vf-input-group-lg",
            inputContainer_default: "",
            inputContainer_disabled: "vf-input-group-disabled",
            inputContainer_focused: "vf-input-group-focused",
            inputContainer_success: "vf-input-group-success",
            inputContainer_danger: "vf-input-group-danger",
            inputWrapper: "vf-datepicker-wrapper",
            input: "vf-input-field",
            input_sm: "",
            input_md: "",
            input_lg: "",
            input_enabled: "",
            input_disabled: "",
            input_focused: "",
            input_success: "",
            input_danger: "",
            $inputContainer: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.inputContainer,
              classes2[`inputContainer_${Size}`],
              isDisabled ? classes2.inputContainer_disabled : null,
              !isDisabled && !isSuccess && !isDanger ? classes2.inputContainer_default : null,
              !isDisabled && focused ? classes2.inputContainer_focused : null,
              !isDisabled && isSuccess ? classes2.inputContainer_success : null,
              !isDisabled && isDanger ? classes2.inputContainer_danger : null
            ],
            $input: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : null,
              !isDisabled && !isSuccess && !isDanger && !focused ? classes2.input_enabled : null,
              !isDisabled && focused && !isSuccess && !isDanger ? classes2.input_focused : null,
              !isDisabled && isDanger ? classes2.input_danger : null,
              !isDisabled && isSuccess ? classes2.input_success : null
            ]
          }
        };
      }
    };
    var css_248z$A = "/* Some styles are contained in Vueform.vue & DatepickerWrapper.vue */";
    styleInject(css_248z$A);
    script$1b.__file = "themes/vueform/templates/elements/DatesElement.vue";
    var script$1a = {
      name: "FileElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            button: ""
          }
        };
      }
    };
    const _hoisted_1$t = ["aria-labelledby", "aria-placeholder"];
    const _hoisted_2$j = ["id", "accept"];
    function render$y(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_DragAndDrop = resolveComponent("DragAndDrop");
      const _component_FilePreview = resolveComponent("FilePreview");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createCommentVNode(" Drag n drop "),
            _ctx.drop && _ctx.canDrop && _ctx.canSelect ? (openBlock(), createBlock(_component_DragAndDrop, {
              key: 0,
              title: _ctx.form$.translations.vueform.elements[_ctx.type].dndTitle,
              description: _ctx.form$.translations.vueform.elements[_ctx.type].dndDescription,
              disabled: _ctx.isDisabled,
              onClick: _ctx.handleClick,
              onDrop: _ctx.handleDrop
            }, null, 8, ["title", "description", "disabled", "onClick", "onDrop"])) : _ctx.canSelect ? (openBlock(), createElementBlock(
              Fragment,
              { key: 1 },
              [
                createCommentVNode(" Upload button "),
                createBaseVNode("div", mergeProps(_ctx.aria, {
                  class: _ctx.classes.button,
                  "aria-labelledby": _ctx.labelId,
                  "aria-placeholder": _ctx.form$.translations.vueform.elements[_ctx.type].select,
                  onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["prevent"])),
                  onKeypress: _cache[1] || (_cache[1] = withKeys((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["enter", "space"])),
                  role: "button",
                  tabindex: "0"
                }), toDisplayString(_ctx.form$.translations.vueform.elements[_ctx.type].select), 17, _hoisted_1$t)
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : createCommentVNode("v-if", true),
            createCommentVNode(" Hidden file input "),
            _ctx.canSelect && !_ctx.isDisabled && !_ctx.preparing ? withDirectives((openBlock(), createElementBlock("input", {
              key: 2,
              id: _ctx.fieldId,
              type: "file",
              accept: _ctx.accept,
              onChange: _cache[2] || (_cache[2] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
              ref: "input"
            }, null, 40, _hoisted_2$j)), [
              [vShow, false]
            ]) : createCommentVNode("v-if", true),
            createCommentVNode(" Preview "),
            renderSlot(_ctx.$slots, "preview", {}, () => [
              (openBlock(), createBlock(_component_FilePreview, {
                key: _ctx.view,
                attrs: _ctx.aria
              }, null, 8, ["attrs"]))
            ])
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$1a.render = render$y;
    script$1a.__file = "themes/blank/templates/elements/FileElement.vue";
    var script$19 = {
      name: "FileElement",
      render: script$1a.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-file vf-text-type",
            container_removing: "vf-file-removing",
            button: "vf-btn vf-btn-secondary",
            button_enabled: "",
            button_disabled: "vf-btn-disabled",
            button_sm: "vf-btn-sm",
            button_md: "",
            button_lg: "vf-btn-lg",
            assertiveText: "vf-assertive-text",
            $container: (classes2, { removing }) => [
              classes2.container,
              removing ? classes2.container_removing : null
            ],
            $button: (classes2, { isDisabled, preparing, Size }) => [
              classes2.button,
              classes2[`button_${Size}`],
              !isDisabled && !preparing ? classes2.button_enabled : null,
              isDisabled || preparing ? classes2.button_disabled : null
            ]
          }
        };
      }
    };
    var css_248z$z = "/* Some styles are contained in Vueform.vue */";
    styleInject(css_248z$z);
    script$19.__file = "themes/vueform/templates/elements/FileElement.vue";
    var script$18 = {
      name: "GroupElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: ""
          }
        };
      }
    };
    const _hoisted_1$s = ["aria-labelledby"];
    function render$x(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        {
          multiple: true,
          ref: "container"
        },
        createSlots({
          element: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.classes.wrapper),
              role: "group",
              "aria-labelledby": _ctx.labelId
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                (openBlock(true), createElementBlock(
                  Fragment,
                  null,
                  renderList(_ctx.children, (element, name2) => {
                    return openBlock(), createBlock(resolveDynamicComponent(_ctx.component(element)), mergeProps({ ref_for: true }, element, {
                      name: name2,
                      key: name2
                    }), null, 16, ["name"]);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ])
            ], 10, _hoisted_1$s)
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$18.render = render$x;
    script$18.__file = "themes/blank/templates/elements/GroupElement.vue";
    var script$17 = {
      name: "GroupElement",
      render: script$18.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "vf-row",
            wrapper_sm: "vf-row-sm",
            wrapper_md: "",
            wrapper_lg: "vf-row-lg",
            $wrapper: (classes2, { Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$y = "/* Some styles are contained in Vueform.vue */";
    styleInject(css_248z$y);
    script$17.__file = "themes/vueform/templates/elements/GroupElement.vue";
    var script$16 = {
      name: "HiddenElement",
      data() {
        return {
          merge: true,
          defaultClasses: {}
        };
      }
    };
    const _hoisted_1$r = {
      key: 0,
      ref: "container"
    };
    const _hoisted_2$i = ["name", "id"];
    function render$w(_ctx, _cache, $props, $setup, $data, $options) {
      return !_ctx.meta ? (openBlock(), createElementBlock(
        "span",
        _hoisted_1$r,
        [
          withDirectives(createBaseVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value = $event),
            type: "hidden",
            name: _ctx.name,
            id: _ctx.fieldId,
            ref: "input"
          }, null, 8, _hoisted_2$i), [
            [vModelText, _ctx.value]
          ])
        ],
        512
        /* NEED_PATCH */
      )) : createCommentVNode("v-if", true);
    }
    script$16.render = render$w;
    script$16.__file = "themes/blank/templates/elements/HiddenElement.vue";
    var script$15 = {
      name: "HiddenElement",
      render: script$16.render,
      data() {
        return {
          merge: true,
          defaultClasses: {}
        };
      }
    };
    script$15.__file = "themes/vueform/templates/elements/HiddenElement.vue";
    var script$14 = {
      name: "ListElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            list: "",
            listItem: "",
            handle: "",
            handleIcon: "",
            remove: "",
            removeIcon: "",
            add: ""
          }
        };
      }
    };
    const _hoisted_1$q = ["aria-labelledby"];
    const _hoisted_2$h = ["data-id"];
    const _hoisted_3$b = ["aria-roledescription", "id", "onClick", "onKeypress"];
    const _hoisted_4$8 = ["id", "innerHTML"];
    function render$v(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createCommentVNode(" Sorting container "),
            createBaseVNode("div", {
              class: normalizeClass(_ctx.classes.list),
              role: "list",
              "aria-labelledby": _ctx.labelId,
              ref: "list"
            }, [
              (openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(_ctx.value, (val, i2) => {
                  return openBlock(), createElementBlock("div", {
                    key: i2,
                    class: normalizeClass(_ctx.classes.listItem),
                    role: "listitem",
                    "data-id": `${_ctx.path}-${i2}`
                  }, [
                    renderSlot(_ctx.$slots, "default", { index: i2 }, () => [
                      _ctx.prototype.type ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.component(_ctx.prototype)), mergeProps({
                        key: 0,
                        ref_for: true
                      }, _ctx.prototype, {
                        name: i2,
                        key: i2
                      }), null, 16, ["name"])) : createCommentVNode("v-if", true)
                    ]),
                    createCommentVNode(" Sort handle "),
                    _ctx.hasSort ? (openBlock(), createElementBlock(
                      "span",
                      {
                        key: 0,
                        class: normalizeClass(_ctx.classes.handle),
                        "data-handle": ""
                      },
                      [
                        createBaseVNode(
                          "span",
                          {
                            class: normalizeClass(_ctx.classes.handleIcon)
                          },
                          null,
                          2
                          /* CLASS */
                        )
                      ],
                      2
                      /* CLASS */
                    )) : createCommentVNode("v-if", true),
                    createCommentVNode(" Remove button "),
                    _ctx.hasRemove ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      "aria-roledescription": _ctx.form$.translations.vueform.a11y.list.remove,
                      class: normalizeClass(_ctx.classes.remove),
                      id: `${_ctx.path}-${i2}-remove-button`,
                      onClick: withModifiers(($event) => _ctx.handleRemove(i2), ["prevent"]),
                      onKeypress: withKeys(($event) => _ctx.handleRemove(i2), ["space", "enter"]),
                      role: "button",
                      tabindex: "0"
                    }, [
                      createBaseVNode(
                        "span",
                        {
                          class: normalizeClass(_ctx.classes.removeIcon)
                        },
                        null,
                        2
                        /* CLASS */
                      )
                    ], 42, _hoisted_3$b)) : createCommentVNode("v-if", true)
                  ], 10, _hoisted_2$h);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ], 10, _hoisted_1$q),
            createCommentVNode(" Add button "),
            _ctx.hasAdd ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.classes.add),
              id: `${_ctx.fieldId}-add-button`,
              onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleAdd && _ctx.handleAdd(...args), ["prevent"])),
              onKeypress: _cache[1] || (_cache[1] = withKeys((...args) => _ctx.handleAdd && _ctx.handleAdd(...args), ["enter", "space"])),
              innerHTML: _ctx.addLabel,
              role: "button",
              tabindex: "0"
            }, null, 42, _hoisted_4$8)) : createCommentVNode("v-if", true)
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$14.render = render$v;
    script$14.__file = "themes/blank/templates/elements/ListElement.vue";
    var script$13 = {
      name: "ListElement",
      render: script$14.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            list: "vf-rowset",
            list_sm: "vf-rowset-sm",
            list_md: "",
            list_lg: "vf-rowset-lg",
            list_disabled: "vf-list-disabled",
            list_sorting: "vf-list-sorting",
            listItem: "vf-row",
            listItem_sm: "vf-row-sm",
            listItem_md: "",
            listItem_lg: "vf-row-lg",
            handle: "vf-list-handle",
            handle_sm: "vf-list-handle-sm",
            handle_md: "",
            handle_lg: "vf-list-handle-lg",
            handleIcon: "vf-list-handle-icon",
            remove: "vf-list-remove",
            removeIcon: "vf-list-remove-icon",
            add: "vf-btn vf-btn-primary vf-btn-small vf-btn-list-add",
            add_sm: "vf-btn-small-sm vf-btn-list-add-sm",
            add_md: "",
            add_lg: "vf-btn-small-lg vf-btn-list-add-lg",
            $list: (classes2, { isDisabled, sorting, Size }) => [
              classes2.list,
              classes2[`list_${Size}`],
              isDisabled ? classes2.list_disabled : null,
              sorting ? classes2.list_sorting : null
            ],
            $listItem: (classes2, { Size }) => [
              classes2.listItem,
              classes2[`listItem_${Size}`]
            ],
            $handle: (classes2, { Size }) => [
              classes2.handle,
              classes2[`handle_${Size}`]
            ],
            $add: (classes2, { Size }) => [
              classes2.add,
              classes2[`add_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$x = `/* Some styles are contained in Vueform.vue */

.vf-rowset > .vf-row {
  position: relative;
}

.vf-rowset > .vf-row:hover > .vf-list-remove, .vf-rowset > .vf-row:hover > .vf-list-handle {
  visibility: visible;
  opacity: 1;
}

.vf-rowset.vf-list-sorting > div:hover .vf-list-handle, .vf-rowset.vf-list-sorting > div:hover .vf-list-remove {
  visibility: hidden;
  opacity: 0;
}

.vf-list-remove, .vf-list-handle {
  opacity: 0;
  transition: 0.3s;
}

.vf-list-remove span, .vf-list-handle span {
  display: flex;
  align-items: center;
  justify-content: center;
  background-repeat: no-repeat;
  background-position: center center;
}

.vf-list-remove {
  position: absolute;
  left: 0;
  transform: translateX(-50%) translateY(-50%);
  top: 0;
  z-index: 999;
  background-color: var(--vf-bg-passive);
  border-radius: 999px;
  transition: 0.15s;
}

.vf-list-remove:hover {
  filter: brightness(0.9);
}

.vf-list-remove:focus {
  opacity: 1;
}

.vf-list-remove-icon {
  display: flex;
  width: 1.125rem;
  height: 1.125rem;
  align-items: center;
  justify-content: center;
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  mask-size: 0.75rem 0.75rem;
  -webkit-mask-size: 0.75rem 0.75rem;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-position: center center;
  -webkit-mask-position: center center;
  background-color: var(--vf-color-passive);
}

.vf-list-handle {
  position: absolute;
  left: 0;
  transform: translateX(-100%);
  top: 0;
  cursor: grab;
  z-index: 999;
}

.vf-list-handle:active {
  cursor: grabbing;
}

.vf-list-handle-icon {
  width: var(--vf-min-height-input);
  height: var(--vf-min-height-input);
  mask-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='11px' height='9px' viewBox='0 0 11 9' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3C!-- Generator: Sketch 52.6 (67491) - http://www.bohemiancoding.com/sketch --%3E%3Ctitle%3Ebars%3C/title%3E%3Cdesc%3ECreated with Sketch.%3C/desc%3E%3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E%3Cpath d='M10.0418527,0.894571939 L0.309709821,0.894571939 C0.235791888,0.894571939 0.17578125,0.834156736 0.17578125,0.759740479 L0.17578125,0.220414636 C0.17578125,0.145998379 0.235791888,0.0855831754 0.309709821,0.0855831754 L10.0418527,0.0855831754 C10.1157706,0.0855831754 10.1757812,0.145998379 10.1757812,0.220414636 L10.1757812,0.759740479 C10.1757812,0.834156736 10.1157706,0.894571939 10.0418527,0.894571939 Z M10.0418527,4.8049452 L0.309709821,4.8049452 C0.235791888,4.8049452 0.17578125,4.74453 0.17578125,4.67011374 L0.17578125,4.1307879 C0.17578125,4.05637164 0.235791888,3.99595644 0.309709821,3.99595644 L10.0418527,3.99595644 C10.1157706,3.99595644 10.1757812,4.05637164 10.1757812,4.1307879 L10.1757812,4.67011374 C10.1757812,4.74453 10.1157706,4.8049452 10.0418527,4.8049452 Z M10.0418527,8.80953919 L0.309709821,8.80953919 C0.235791888,8.80953919 0.17578125,8.74912399 0.17578125,8.67470773 L0.17578125,8.13538189 C0.17578125,8.06096563 0.235791888,8.00055043 0.309709821,8.00055043 L10.0418527,8.00055043 C10.1157706,8.00055043 10.1757812,8.06096563 10.1757812,8.13538189 L10.1757812,8.67470773 C10.1757812,8.74912399 10.1157706,8.80953919 10.0418527,8.80953919 Z' id='bars' fill='currentColor' %3E%3C/path%3E%3C/g%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='11px' height='9px' viewBox='0 0 11 9' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3C!-- Generator: Sketch 52.6 (67491) - http://www.bohemiancoding.com/sketch --%3E%3Ctitle%3Ebars%3C/title%3E%3Cdesc%3ECreated with Sketch.%3C/desc%3E%3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E%3Cpath d='M10.0418527,0.894571939 L0.309709821,0.894571939 C0.235791888,0.894571939 0.17578125,0.834156736 0.17578125,0.759740479 L0.17578125,0.220414636 C0.17578125,0.145998379 0.235791888,0.0855831754 0.309709821,0.0855831754 L10.0418527,0.0855831754 C10.1157706,0.0855831754 10.1757812,0.145998379 10.1757812,0.220414636 L10.1757812,0.759740479 C10.1757812,0.834156736 10.1157706,0.894571939 10.0418527,0.894571939 Z M10.0418527,4.8049452 L0.309709821,4.8049452 C0.235791888,4.8049452 0.17578125,4.74453 0.17578125,4.67011374 L0.17578125,4.1307879 C0.17578125,4.05637164 0.235791888,3.99595644 0.309709821,3.99595644 L10.0418527,3.99595644 C10.1157706,3.99595644 10.1757812,4.05637164 10.1757812,4.1307879 L10.1757812,4.67011374 C10.1757812,4.74453 10.1157706,4.8049452 10.0418527,4.8049452 Z M10.0418527,8.80953919 L0.309709821,8.80953919 C0.235791888,8.80953919 0.17578125,8.74912399 0.17578125,8.67470773 L0.17578125,8.13538189 C0.17578125,8.06096563 0.235791888,8.00055043 0.309709821,8.00055043 L10.0418527,8.00055043 C10.1157706,8.00055043 10.1757812,8.06096563 10.1757812,8.13538189 L10.1757812,8.67470773 C10.1757812,8.74912399 10.1157706,8.80953919 10.0418527,8.80953919 Z' id='bars' fill='currentColor' %3E%3C/path%3E%3C/g%3E%3C/svg%3E");
  mask-size: 0.7rem 0.7rem;
  -webkit-mask-size: 0.7rem 0.7rem;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-position: center center;
  -webkit-mask-position: center center;
  background-color: var(--vf-color-passive);
}

.vf-list-handle-sm .vf-list-handle-icon {
  width: var(--vf-min-height-input-sm);
  height: var(--vf-min-height-input-sm);
}

.vf-list-handle-lg .vf-list-handle-icon {
  width: var(--vf-min-height-input-lg);
  height: var(--vf-min-height-input-lg);
}

.vf-btn-list-add {
  margin-top: var(--vf-gutter);
}

.vf-btn-list-add.vf-btn-list-add-sm {
  margin-top: var(--vf-gutter-sm);
}

.vf-btn-list-add.vf-btn-list-add-lg {
  margin-top: var(--vf-gutter-lg);
}

.sortable-ghost {
  opacity: 0.6;
}`;
    styleInject(css_248z$x);
    script$13.__file = "themes/vueform/templates/elements/ListElement.vue";
    var script$12 = {
      name: "LocationElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            inputContainer: "",
            input: ""
          }
        };
      }
    };
    const _hoisted_1$p = ["name", "id", "placeholder", "disabled", "readonly", "aria-labelledby"];
    function render$u(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ElementAddon = resolveComponent("ElementAddon");
      const _component_ElementLabelFloating = resolveComponent("ElementLabelFloating");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.inputContainer)
              },
              [
                _ctx.hasAddonBefore ? (openBlock(), createBlock(_component_ElementAddon, {
                  key: 0,
                  type: "before"
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "addon-before", {}, () => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots["addon-before"]), { el$: _ctx.el$ }, null, 8, ["el$"]))
                    ])
                  ]),
                  _: 3
                  /* FORWARDED */
                })) : createCommentVNode("v-if", true),
                _ctx.hasAddonAfter ? (openBlock(), createBlock(_component_ElementAddon, {
                  key: 1,
                  type: "after"
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "addon-after", {}, () => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots["addon-after"]), { el$: _ctx.el$ }, null, 8, ["el$"]))
                    ])
                  ]),
                  _: 3
                  /* FORWARDED */
                })) : createCommentVNode("v-if", true),
                _ctx.hasFloating && !_ctx.empty ? (openBlock(), createBlock(_component_ElementLabelFloating, {
                  key: 2,
                  visible: !_ctx.empty
                }, null, 8, ["visible"])) : createCommentVNode("v-if", true),
                createBaseVNode("input", mergeProps({
                  type: "search",
                  name: _ctx.name,
                  id: _ctx.fieldId,
                  class: _ctx.classes.input,
                  placeholder: _ctx.Placeholder,
                  disabled: _ctx.isDisabled,
                  readonly: _ctx.readonly,
                  "aria-labelledby": _ctx.labelId,
                  autocomplete: "off"
                }, _ctx.attrs, {
                  ref: "input",
                  onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.handleLocationBlur && _ctx.handleLocationBlur(...args))
                }), null, 16, _hoisted_1$p)
              ],
              2
              /* CLASS */
            )
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$12.render = render$u;
    script$12.__file = "themes/blank/templates/elements/LocationElement.vue";
    var script$11 = {
      name: "LocationElement",
      render: script$12.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            inputContainer: "vf-input-group",
            inputContainer_sm: "vf-input-group-sm",
            inputContainer_md: "",
            inputContainer_lg: "vf-input-group-lg",
            inputContainer_default: "",
            inputContainer_disabled: "vf-input-group-disabled",
            inputContainer_focused: "vf-input-group-focused",
            inputContainer_success: "vf-input-group-success",
            inputContainer_danger: "vf-input-group-danger",
            input: "vf-input-field",
            input_sm: "",
            input_md: "",
            input_lg: "",
            input_enabled: "",
            input_disabled: "",
            input_focused: "",
            input_success: "",
            input_danger: "",
            $inputContainer: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.inputContainer,
              classes2[`inputContainer_${Size}`],
              isDisabled ? classes2.inputContainer_disabled : null,
              !isDisabled && !isSuccess && !isDanger ? classes2.inputContainer_default : null,
              !isDisabled && focused ? classes2.inputContainer_focused : null,
              !isDisabled && isSuccess ? classes2.inputContainer_success : null,
              !isDisabled && isDanger ? classes2.inputContainer_danger : null
            ],
            $input: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : null,
              !isDisabled && !isSuccess && !isDanger && !focused ? classes2.input_enabled : null,
              !isDisabled && focused && !isSuccess && !isDanger ? classes2.input_focused : null,
              !isDisabled && isDanger ? classes2.input_danger : null,
              !isDisabled && isSuccess ? classes2.input_success : null
            ]
          }
        };
      }
    };
    var css_248z$w = `/* Google */

.pac-container {
  border-color: var(--vf-border-color-input);
  background: var(--vf-bg-input);
}

.pac-item {
  display: flex;
  align-items: center;
  padding: 0.375rem 0.75rem;
  border-color: var(--vf-border-color-input);
  background: var(--vf-bg-input);
  color: var(--vf-color-input);
  cursor: pointer;
}

.pac-item > span:last-of-type {
  font-size: 0.75rem;
  color: var(--vf-color-muted);
}

.pac-item:hover, .pac-item.pac-item-selected {
  background: var(--vf-bg-selected);
}

.pac-item-query {
  font-size: 0.875rem;
  line-height: 1;
  margin-right: 0.25rem;
  padding-right: 0.25rem;
  color: var(--vf-color-input);
}

.pac-icon-marker {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 384 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 384 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z'%3e%3c/path%3e%3c/svg%3e");
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-position: center center;
  -webkit-mask-position: center center;
  mask-size: contain;
  -webkit-mask-size: contain;
  background: var(--vf-bg-icon);
  width: 0.875rem;
  width: 0.875rem;
  margin-right: 0.75rem;
  margin-top: 0;
  padding-top: 1px;
  padding-bottom: 1px;
  box-sizing: content-box;
  flex-shrink: 0;
}

.pac-logo:after {
  margin-left: 0.625rem;
  margin-right: 0.625rem;
  margin-bottom: 0.625rem;
}

.pac-icon, .hdpi .pac-icon {
  background-image: none;
}`;
    styleInject(css_248z$w);
    script$11.__file = "themes/vueform/templates/elements/LocationElement.vue";
    var script$10 = {
      name: "MultifileElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            list: "",
            listItem: "",
            handle: "",
            handleIcon: "",
            dnd: "",
            button: ""
          }
        };
      }
    };
    const _hoisted_1$o = ["aria-labelledby", "aria-placeholder"];
    const _hoisted_2$g = ["id", "accept", "disabled"];
    function render$t(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_DragAndDrop = resolveComponent("DragAndDrop");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        {
          multiple: true,
          ref: "container"
        },
        createSlots({
          element: withCtx(() => [
            createCommentVNode(" Drag n drop "),
            _ctx.drop && _ctx.canDrop && _ctx.hasAdd ? (openBlock(), createBlock(_component_DragAndDrop, {
              key: 0,
              title: _ctx.form$.translations.vueform.elements[_ctx.type].dndTitle,
              description: _ctx.form$.translations.vueform.elements[_ctx.type].dndDescription,
              disabled: _ctx.isDisabled,
              class: normalizeClass(_ctx.classes.dnd),
              onClick: _ctx.handleClick,
              onDrop: _ctx.handleDrop
            }, null, 8, ["title", "description", "disabled", "class", "onClick", "onDrop"])) : _ctx.hasAdd ? (openBlock(), createElementBlock(
              Fragment,
              { key: 1 },
              [
                createCommentVNode(" Upload button "),
                createBaseVNode("div", mergeProps(_ctx.aria, {
                  class: _ctx.classes.button,
                  "aria-labelledby": _ctx.labelId,
                  "aria-placeholder": _ctx.form$.translations.vueform.elements.multifile.uploadButton,
                  onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["prevent"])),
                  onKeypress: _cache[1] || (_cache[1] = withKeys((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["enter", "space"])),
                  role: "button",
                  tabindex: "0"
                }), toDisplayString(_ctx.form$.translations.vueform.elements.multifile.uploadButton), 17, _hoisted_1$o)
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : createCommentVNode("v-if", true),
            createCommentVNode(" Actual input field "),
            withDirectives(createBaseVNode("input", {
              multiple: "",
              id: _ctx.fieldId,
              type: "file",
              onChange: _cache[2] || (_cache[2] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
              accept: _ctx.accept,
              disabled: _ctx.isDisabled,
              ref: "input"
            }, null, 40, _hoisted_2$g), [
              [vShow, false]
            ]),
            withDirectives((openBlock(), createElementBlock(
              "div",
              {
                class: normalizeClass(_ctx.classes.list),
                key: `${_ctx.fieldId}-${_ctx.length}`,
                ref: "list"
              },
              [
                (openBlock(true), createElementBlock(
                  Fragment,
                  null,
                  renderList(_ctx.value, (val, i2) => {
                    return openBlock(), createElementBlock(
                      "div",
                      {
                        key: i2,
                        class: normalizeClass(_ctx.classes.listItem)
                      },
                      [
                        _ctx.prototype.type ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.component(_ctx.prototype)), mergeProps({
                          key: 0,
                          ref_for: true
                        }, _ctx.prototype, {
                          disabled: !_ctx.hasRemove,
                          embed: true,
                          name: i2,
                          onRemove: ($event) => _ctx.remove(i2)
                        }), null, 16, ["disabled", "name", "onRemove"])) : createCommentVNode("v-if", true),
                        createCommentVNode(" Sort handle "),
                        _ctx.hasSort ? (openBlock(), createElementBlock(
                          "span",
                          {
                            key: 1,
                            class: normalizeClass(_ctx.classes.handle),
                            "data-handle": ""
                          },
                          [
                            createBaseVNode(
                              "span",
                              {
                                class: normalizeClass(_ctx.classes.handleIcon)
                              },
                              null,
                              2
                              /* CLASS */
                            )
                          ],
                          2
                          /* CLASS */
                        )) : createCommentVNode("v-if", true)
                      ],
                      2
                      /* CLASS */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ],
              2
              /* CLASS */
            )), [
              [vShow, !_ctx.empty]
            ])
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$10.render = render$t;
    script$10.__file = "themes/blank/templates/elements/MultifileElement.vue";
    var script$$ = {
      name: "MultifileElement",
      render: script$10.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            list: "vf-multifile-list",
            list_sm: "vf-multifile-list-sm",
            list_md: "",
            list_lg: "vf-multifile-list-lg",
            list_file: "vf-multifile-list-file",
            list_file_sm: "",
            list_file_md: "",
            list_file_lg: "",
            list_image: "vf-multifile-list-image",
            list_image_sm: "vf-multifile-list-image-sm",
            list_image_md: "",
            list_image_lg: "vf-multifile-list-image-lg",
            list_gallery: "vf-multifile-list-gallery",
            list_gallery_sm: "vf-multifile-list-gallery-sm",
            list_gallery_md: "",
            list_gallery_lg: "vf-multifile-list-gallery-lg",
            list_disabled: "vf-multifile-list-disabled",
            list_sorting: "vf-multifile-list-sorting",
            listItem: "",
            handle: "",
            handle_file: "vf-multifile-handle-file",
            handle_file_sm: "vf-multifile-handle-file-sm",
            handle_file_md: "",
            handle_file_lg: "vf-multifile-handle-file-lg",
            handle_image: "vf-multifile-handle-image",
            handle_image_sm: "vf-multifile-handle-image-sm",
            handle_image_md: "",
            handle_image_lg: "vf-multifile-handle-image-lg",
            handle_gallery: "vf-multifile-handle-gallery",
            handle_gallery_sm: "",
            handle_gallery_md: "",
            handle_gallery_lg: "",
            handleIcon: "",
            handleIcon_file: "vf-multifile-handle-icon-file",
            handleIcon_image: "vf-multifile-handle-icon-image",
            handleIcon_gallery: "vf-multifile-handle-icon-gallery",
            dnd: "",
            button: "vf-btn vf-btn-secondary",
            button_enabled: "",
            button_disabled: "vf-btn-disabled",
            button_sm: "vf-btn-sm",
            button_md: "",
            button_lg: "vf-btn-lg",
            $list: (classes2, { isDisabled, sorting, view, Size }) => [
              classes2.list,
              classes2[`list_${Size}`],
              isDisabled ? classes2.list_disabled : null,
              sorting ? classes2.list_sorting : null,
              classes2[`list_${view}`],
              classes2[`list_${view}_${Size}`]
            ],
            $handle: (classes2, { view, Size }) => [
              classes2.handle,
              classes2[`handle_${view}`],
              classes2[`handle_${view}_${Size}`]
            ],
            $handleIcon: (classes2, { view }) => [
              classes2.handleIcon,
              classes2[`handleIcon_${view}`]
            ],
            $button: (classes2, { isDisabled, preparing, Size }) => [
              classes2.button,
              classes2[`button_${Size}`],
              !isDisabled && !preparing ? classes2.button_enabled : null,
              isDisabled || preparing ? classes2.button_disabled : null
            ]
          }
        };
      }
    };
    var css_248z$v = `/* Some styles are contained in Vueform.vue */

.vf-multifile-list {
  margin-top: var(--vf-gutter);
}

.vf-multifile-list.vf-multifile-list-sm {
  margin-top: var(--vf-gutter-sm);
}

.vf-multifile-list.vf-multifile-list-lg {
  margin-top: var(--vf-gutter-lg);
}

.vf-multifile-list-file,
.vf-multifile-list-image {
  display: grid;
}

.vf-multifile-list-file > .vf-row,
.vf-multifile-list-image > .vf-row {
  position: relative;
}

.vf-multifile-list-file > .vf-row:hover .vf-multifile-handle-file,
.vf-multifile-list-file > .vf-row:hover .vf-multifile-handle-image,
.vf-multifile-list-image > .vf-row:hover .vf-multifile-handle-file,
.vf-multifile-list-image > .vf-row:hover .vf-multifile-handle-image {
  visibility: visible;
  opacity: 1;
}

.vf-multifile-list-file.vf-multifile-list-sorting > div:hover .vf-multifile-handle-file,
.vf-multifile-list-file.vf-multifile-list-sorting > div:hover .vf-multifile-handle-image,
.vf-multifile-list-image.vf-multifile-list-sorting > div:hover .vf-multifile-handle-file,
.vf-multifile-list-image.vf-multifile-list-sorting > div:hover .vf-multifile-handle-image {
  visibility: hidden;
  opacity: 0;
}

.vf-multifile-list-file {
  row-gap: calc(var(--vf-gutter) / 2);
}

.vf-multifile-list-file.vf-multifile-list-file-sm {
  row-gap: calc(var(--vf-gutter-sm) / 2);
}

.vf-multifile-list-file.vf-multifile-list-file-lg {
  row-gap: calc(var(--vf-gutter-lg) / 2);
}

.vf-multifile-list-image {
  row-gap: calc(var(--vf-gutter) / 2);
}

.vf-multifile-list-image.vf-multifile-list-image-sm {
  row-gap: calc(var(--vf-gutter-sm) / 2);
}

.vf-multifile-list-image.vf-multifile-list-image-lg {
  row-gap: calc(var(--vf-gutter-lg) / 2);
}

.vf-multifile-list-gallery {
  display: flex;
  flex-wrap: wrap;
  gap: calc(var(--vf-gutter) / 2);
}

.vf-multifile-list-gallery.vf-multifile-list-sorting > div:hover .vf-multifile-handle-gallery {
  visibility: hidden;
  opacity: 0;
}

.vf-multifile-list-gallery > div {
  position: relative;
}

.vf-multifile-list-gallery > div:hover .vf-multifile-handle-gallery {
  visibility: visible;
  opacity: 1;
}

.vf-multifile-handle-file,
.vf-multifile-handle-image {
  position: absolute;
  left: var(--vf-gutter);
  transform: translateX(-100%);
  top: 0;
  cursor: grab;
  visibility: hidden;
  opacity: 0;
  transition: 0.3s;
}

.vf-multifile-handle-file:active,
.vf-multifile-handle-image:active {
  cursor: grabbing;
}

.vf-multifile-handle-icon-file,
.vf-multifile-handle-icon-image {
  display: flex;
  align-items: center;
  justify-content: center;
  background-repeat: no-repeat;
  background-position: center center;
  width: var(--vf-min-height-input);
  height: var(--vf-min-height-input);
  mask-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='11px' height='9px' viewBox='0 0 11 9' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3C!-- Generator: Sketch 52.6 (67491) - http://www.bohemiancoding.com/sketch --%3E%3Ctitle%3Ebars%3C/title%3E%3Cdesc%3ECreated with Sketch.%3C/desc%3E%3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E%3Cpath d='M10.0418527,0.894571939 L0.309709821,0.894571939 C0.235791888,0.894571939 0.17578125,0.834156736 0.17578125,0.759740479 L0.17578125,0.220414636 C0.17578125,0.145998379 0.235791888,0.0855831754 0.309709821,0.0855831754 L10.0418527,0.0855831754 C10.1157706,0.0855831754 10.1757812,0.145998379 10.1757812,0.220414636 L10.1757812,0.759740479 C10.1757812,0.834156736 10.1157706,0.894571939 10.0418527,0.894571939 Z M10.0418527,4.8049452 L0.309709821,4.8049452 C0.235791888,4.8049452 0.17578125,4.74453 0.17578125,4.67011374 L0.17578125,4.1307879 C0.17578125,4.05637164 0.235791888,3.99595644 0.309709821,3.99595644 L10.0418527,3.99595644 C10.1157706,3.99595644 10.1757812,4.05637164 10.1757812,4.1307879 L10.1757812,4.67011374 C10.1757812,4.74453 10.1157706,4.8049452 10.0418527,4.8049452 Z M10.0418527,8.80953919 L0.309709821,8.80953919 C0.235791888,8.80953919 0.17578125,8.74912399 0.17578125,8.67470773 L0.17578125,8.13538189 C0.17578125,8.06096563 0.235791888,8.00055043 0.309709821,8.00055043 L10.0418527,8.00055043 C10.1157706,8.00055043 10.1757812,8.06096563 10.1757812,8.13538189 L10.1757812,8.67470773 C10.1757812,8.74912399 10.1157706,8.80953919 10.0418527,8.80953919 Z' id='bars' fill='currentColor' %3E%3C/path%3E%3C/g%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='11px' height='9px' viewBox='0 0 11 9' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3C!-- Generator: Sketch 52.6 (67491) - http://www.bohemiancoding.com/sketch --%3E%3Ctitle%3Ebars%3C/title%3E%3Cdesc%3ECreated with Sketch.%3C/desc%3E%3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E%3Cpath d='M10.0418527,0.894571939 L0.309709821,0.894571939 C0.235791888,0.894571939 0.17578125,0.834156736 0.17578125,0.759740479 L0.17578125,0.220414636 C0.17578125,0.145998379 0.235791888,0.0855831754 0.309709821,0.0855831754 L10.0418527,0.0855831754 C10.1157706,0.0855831754 10.1757812,0.145998379 10.1757812,0.220414636 L10.1757812,0.759740479 C10.1757812,0.834156736 10.1157706,0.894571939 10.0418527,0.894571939 Z M10.0418527,4.8049452 L0.309709821,4.8049452 C0.235791888,4.8049452 0.17578125,4.74453 0.17578125,4.67011374 L0.17578125,4.1307879 C0.17578125,4.05637164 0.235791888,3.99595644 0.309709821,3.99595644 L10.0418527,3.99595644 C10.1157706,3.99595644 10.1757812,4.05637164 10.1757812,4.1307879 L10.1757812,4.67011374 C10.1757812,4.74453 10.1157706,4.8049452 10.0418527,4.8049452 Z M10.0418527,8.80953919 L0.309709821,8.80953919 C0.235791888,8.80953919 0.17578125,8.74912399 0.17578125,8.67470773 L0.17578125,8.13538189 C0.17578125,8.06096563 0.235791888,8.00055043 0.309709821,8.00055043 L10.0418527,8.00055043 C10.1157706,8.00055043 10.1757812,8.06096563 10.1757812,8.13538189 L10.1757812,8.67470773 C10.1757812,8.74912399 10.1157706,8.80953919 10.0418527,8.80953919 Z' id='bars' fill='currentColor' %3E%3C/path%3E%3C/g%3E%3C/svg%3E");
  mask-size: 0.7rem 0.7rem;
  -webkit-mask-size: 0.7rem 0.7rem;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-position: center center;
  -webkit-mask-position: center center;
  background-color: currentColor;
}

.vf-multifile-handle-file.vf-multifile-handle-file-sm .vf-multifile-handle-icon-file {
  width: var(--vf-min-height-input-sm);
  height: var(--vf-min-height-input-sm);
}

.vf-multifile-handle-file.vf-multifile-handle-file-lg .vf-multifile-handle-icon-file {
  width: var(--vf-min-height-input-lg);
  height: var(--vf-min-height-input-lg);
}

.vf-multifile-handle-image.vf-multifile-handle-image-sm .vf-multifile-handle-icon-image {
  width: var(--vf-min-height-input-sm);
  height: var(--vf-min-height-input-sm);
}

.vf-multifile-handle-image.vf-multifile-handle-image-lg .vf-multifile-handle-icon-image {
  width: var(--vf-min-height-input-lg);
  height: var(--vf-min-height-input-lg);
}

.vf-multifile-handle-gallery {
  position: absolute;
  cursor: grab;
  visibility: hidden;
  opacity: 0;
  transition: 0.3s;
  border-radius: 999px;
  left: 0.1875rem;
  top: 0.1875rem;
  transform: none;
  background: var(--vf-gray-200);
}

.vf-multifile-handle-gallery:active {
  cursor: grabbing;
}

.vf-multifile-handle-gallery:hover {
  background-color: var(--vf-gray-300);
}

.vf-multifile-handle-icon-gallery {
  display: flex;
  align-items: center;
  justify-content: center;
  background-repeat: no-repeat;
  background-position: center center;
  width: 1rem;
  height: 1rem;
  mask-size: 0.75rem 0.75rem;
  -webkit-mask-size: 0.75rem 0.75rem;
  mask-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='12px' height='13px' viewBox='0 0 12 13' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg stroke='none' stroke-width='1' fill='%236B7280' fill-rule='evenodd'%3E%3Cpath d='M7.93929644,10.4886534 L6.22140503,12.2179202 C6.11156489,12.3277374 5.93349525,12.3277374 5.82363223,12.2179202 L4.10576371,10.4886534 C3.99594646,10.3788132 3.99594646,10.2007436 4.10576371,10.0909263 L4.27147376,9.92521629 C4.381291,9.81537616 4.55938354,9.81537616 4.66922367,9.92521629 L5.62409352,10.89137 L5.64753097,10.89137 L5.64753097,6.67528507 L1.43144605,6.67528507 L1.43144605,6.69872252 L2.39762264,7.65359237 C2.50746277,7.76340962 2.50746277,7.94150215 2.39762264,8.05134228 L2.2318897,8.21705233 C2.12207245,8.32686958 1.94400281,8.32686958 1.83416268,8.21705233 L0.104918753,6.49916092 C-0.0048984896,6.38932079 -0.0048984896,6.21125115 0.104918753,6.10138813 L1.83418557,4.38349671 C1.9440257,4.27367947 2.12209534,4.27367947 2.23193547,4.38349671 L2.39766841,4.54922966 C2.50750855,4.6590469 2.50750855,4.83713943 2.39766841,4.94697956 L1.43144605,5.90184942 L1.43144605,5.92528686 L5.64753097,5.92528686 L5.64753097,1.70920194 L5.62409352,1.70920194 L4.66922367,2.67537853 C4.55940642,2.78521867 4.38131389,2.78521867 4.27147376,2.67537853 L4.10576371,2.50964559 C3.99594646,2.39982835 3.99592358,2.2217587 4.10576371,2.11191857 L5.82365512,0.382651762 C5.93349525,0.272834518 6.11156489,0.272834518 6.22142791,0.382651762 L7.93931933,2.11191857 C8.04913657,2.2217587 8.04913657,2.39982835 7.93931933,2.50966848 L7.77358638,2.67540142 C7.66376914,2.78524155 7.48567661,2.78524155 7.37583648,2.67540142 L6.42096662,1.70920194 L6.39752918,1.70920194 L6.39752918,5.92528686 L10.6136141,5.92528686 L10.6136141,5.90184942 L9.64743751,4.94697956 C9.53759737,4.83716232 9.53759737,4.65906979 9.64743751,4.54922966 L9.81317045,4.3835196 C9.92298769,4.27370236 10.1010573,4.27370236 10.2108975,4.3835196 L11.9401643,6.10141102 C12.0500044,6.21125115 12.0499815,6.38932079 11.9401643,6.49918381 L10.2108975,8.21707522 C10.1010573,8.32689246 9.92298769,8.32689246 9.81317045,8.21707522 L9.64743751,8.05136517 C9.53759737,7.94154792 9.53759737,7.76345539 9.64743751,7.65361526 L10.6136141,6.69872252 L10.6136141,6.67528507 L6.39752918,6.67528507 L6.39752918,10.89137 L6.42096662,10.89137 L7.37583648,9.9251934 C7.48565372,9.81535327 7.66374625,9.81535327 7.77358638,9.9251934 L7.93929644,10.0909263 C8.04911368,10.2007207 8.04911368,10.3787903 7.93929644,10.4886534 Z' id='arrows' fill='currentColor'%3E%3C/path%3E%3C/g%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='12px' height='13px' viewBox='0 0 12 13' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg stroke='none' stroke-width='1' fill='%236B7280' fill-rule='evenodd'%3E%3Cpath d='M7.93929644,10.4886534 L6.22140503,12.2179202 C6.11156489,12.3277374 5.93349525,12.3277374 5.82363223,12.2179202 L4.10576371,10.4886534 C3.99594646,10.3788132 3.99594646,10.2007436 4.10576371,10.0909263 L4.27147376,9.92521629 C4.381291,9.81537616 4.55938354,9.81537616 4.66922367,9.92521629 L5.62409352,10.89137 L5.64753097,10.89137 L5.64753097,6.67528507 L1.43144605,6.67528507 L1.43144605,6.69872252 L2.39762264,7.65359237 C2.50746277,7.76340962 2.50746277,7.94150215 2.39762264,8.05134228 L2.2318897,8.21705233 C2.12207245,8.32686958 1.94400281,8.32686958 1.83416268,8.21705233 L0.104918753,6.49916092 C-0.0048984896,6.38932079 -0.0048984896,6.21125115 0.104918753,6.10138813 L1.83418557,4.38349671 C1.9440257,4.27367947 2.12209534,4.27367947 2.23193547,4.38349671 L2.39766841,4.54922966 C2.50750855,4.6590469 2.50750855,4.83713943 2.39766841,4.94697956 L1.43144605,5.90184942 L1.43144605,5.92528686 L5.64753097,5.92528686 L5.64753097,1.70920194 L5.62409352,1.70920194 L4.66922367,2.67537853 C4.55940642,2.78521867 4.38131389,2.78521867 4.27147376,2.67537853 L4.10576371,2.50964559 C3.99594646,2.39982835 3.99592358,2.2217587 4.10576371,2.11191857 L5.82365512,0.382651762 C5.93349525,0.272834518 6.11156489,0.272834518 6.22142791,0.382651762 L7.93931933,2.11191857 C8.04913657,2.2217587 8.04913657,2.39982835 7.93931933,2.50966848 L7.77358638,2.67540142 C7.66376914,2.78524155 7.48567661,2.78524155 7.37583648,2.67540142 L6.42096662,1.70920194 L6.39752918,1.70920194 L6.39752918,5.92528686 L10.6136141,5.92528686 L10.6136141,5.90184942 L9.64743751,4.94697956 C9.53759737,4.83716232 9.53759737,4.65906979 9.64743751,4.54922966 L9.81317045,4.3835196 C9.92298769,4.27370236 10.1010573,4.27370236 10.2108975,4.3835196 L11.9401643,6.10141102 C12.0500044,6.21125115 12.0499815,6.38932079 11.9401643,6.49918381 L10.2108975,8.21707522 C10.1010573,8.32689246 9.92298769,8.32689246 9.81317045,8.21707522 L9.64743751,8.05136517 C9.53759737,7.94154792 9.53759737,7.76345539 9.64743751,7.65361526 L10.6136141,6.69872252 L10.6136141,6.67528507 L6.39752918,6.67528507 L6.39752918,10.89137 L6.42096662,10.89137 L7.37583648,9.9251934 C7.48565372,9.81535327 7.66374625,9.81535327 7.77358638,9.9251934 L7.93929644,10.0909263 C8.04911368,10.2007207 8.04911368,10.3787903 7.93929644,10.4886534 Z' id='arrows' fill='currentColor'%3E%3C/path%3E%3C/g%3E%3C/svg%3E");
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-position: center center;
  -webkit-mask-position: center center;
  background-color: var(--vf-gray-600);
}

.sortable-ghost {
  opacity: 0.6;
}`;
    styleInject(css_248z$v);
    script$$.__file = "themes/vueform/templates/elements/MultifileElement.vue";
    function isNullish$1(val) {
      return val === null || val === void 0;
    }
    function useData(props, context, dep) {
      const { object: object2, valueProp, mode } = toRefs(props);
      const $this = getCurrentInstance().proxy;
      const iv = dep.iv;
      const update = (val, triggerInput = true) => {
        iv.value = makeInternal(val);
        const externalVal = makeExternal(val);
        context.emit("change", externalVal, $this);
        if (triggerInput) {
          context.emit("input", externalVal);
          context.emit("update:modelValue", externalVal);
        }
      };
      const makeExternal = (val) => {
        if (object2.value) {
          return val;
        }
        if (isNullish$1(val)) {
          return val;
        }
        return !Array.isArray(val) ? val[valueProp.value] : val.map((v2) => v2[valueProp.value]);
      };
      const makeInternal = (val) => {
        if (isNullish$1(val)) {
          return mode.value === "single" ? {} : [];
        }
        return val;
      };
      return {
        update
      };
    }
    function toRef(get2) {
      return customRef(() => ({ get: get2, set: (
        /* istanbul ignore next */
        () => {
        }
      ) }));
    }
    function useValue$3(props, context) {
      const { value, modelValue, mode, valueProp } = toRefs(props);
      const iv = ref(mode.value !== "single" ? [] : {});
      const ev = toRef(() => {
        return modelValue.value !== void 0 ? modelValue.value : value.value;
      });
      const plainValue = computed(() => {
        return mode.value === "single" ? iv.value[valueProp.value] : iv.value.map((v2) => v2[valueProp.value]);
      });
      const textValue = toRef(() => {
        return mode.value !== "single" ? iv.value.map((v2) => v2[valueProp.value]).join(",") : iv.value[valueProp.value];
      });
      return {
        iv,
        internalValue: iv,
        ev,
        externalValue: ev,
        textValue,
        plainValue
      };
    }
    function useSearch(props, context, dep) {
      const { regex: regex2 } = toRefs(props);
      const $this = getCurrentInstance().proxy;
      const isOpen = dep.isOpen;
      const open = dep.open;
      const search = ref(null);
      const clearSearch = () => {
        search.value = "";
      };
      const handleSearchInput = (e2) => {
        search.value = e2.target.value;
      };
      const handleKeypress = (e2) => {
        if (regex2.value) {
          let regexp = regex2.value;
          if (typeof regexp === "string") {
            regexp = new RegExp(regexp);
          }
          if (!e2.key.match(regexp)) {
            e2.preventDefault();
          }
        }
      };
      const handlePaste = (e2) => {
        if (regex2.value) {
          let clipboardData = e2.clipboardData || /* istanbul ignore next */
          window.clipboardData;
          let pastedData = clipboardData.getData("Text");
          let regexp = regex2.value;
          if (typeof regexp === "string") {
            regexp = new RegExp(regexp);
          }
          if (!pastedData.split("").every((c2) => !!c2.match(regexp))) {
            e2.preventDefault();
          }
        }
        context.emit("paste", e2, $this);
      };
      watch(search, (val) => {
        if (!isOpen.value && val) {
          open();
        }
        context.emit("search-change", val, $this);
      });
      return {
        search,
        clearSearch,
        handleSearchInput,
        handleKeypress,
        handlePaste
      };
    }
    function usePointer$1(props, context, dep) {
      const { groupSelect, mode, groups, disabledProp } = toRefs(props);
      const pointer = ref(null);
      const setPointer = (option) => {
        if (option === void 0 || option !== null && option[disabledProp.value]) {
          return;
        }
        if (groups.value && option && option.group && (mode.value === "single" || !groupSelect.value)) {
          return;
        }
        pointer.value = option;
      };
      const clearPointer = () => {
        setPointer(null);
      };
      return {
        pointer,
        setPointer,
        clearPointer
      };
    }
    function normalize(str, strict = true) {
      return strict ? String(str).toLowerCase().trim() : String(str).toLowerCase().normalize("NFD").trim().replace(/æ/g, "ae").replace(/œ/g, "oe").replace(/ø/g, "o").replace(/\p{Diacritic}/gu, "");
    }
    function isObject(variable) {
      return Object.prototype.toString.call(variable) === "[object Object]";
    }
    function arraysEqual$1(array1, array2) {
      if (array1.length !== array2.length) {
        return false;
      }
      const array2Sorted = array2.slice().sort();
      return array1.slice().sort().every(function(value, index2) {
        return value === array2Sorted[index2];
      });
    }
    function useOptions(props, context, dep) {
      const {
        options,
        mode,
        trackBy: trackBy_,
        limit: limit2,
        hideSelected,
        createTag,
        createOption: createOption_,
        label,
        appendNewTag,
        appendNewOption: appendNewOption_,
        multipleLabel,
        object: object2,
        loading,
        delay,
        resolveOnLoad,
        minChars,
        filterResults,
        clearOnSearch,
        clearOnSelect,
        valueProp,
        allowAbsent,
        groupLabel,
        canDeselect,
        max: max2,
        strict,
        closeOnSelect,
        closeOnDeselect,
        groups: groupped,
        reverse,
        infinite,
        groupOptions,
        groupHideEmpty,
        groupSelect,
        onCreate,
        disabledProp,
        searchStart,
        searchFilter
      } = toRefs(props);
      const $this = getCurrentInstance().proxy;
      const iv = dep.iv;
      const ev = dep.ev;
      const search = dep.search;
      const clearSearch = dep.clearSearch;
      const update = dep.update;
      const pointer = dep.pointer;
      const setPointer = dep.setPointer;
      const clearPointer = dep.clearPointer;
      const focus = dep.focus;
      const deactivate = dep.deactivate;
      const close = dep.close;
      const localize2 = dep.localize;
      const ap = ref([]);
      const ro = ref([]);
      const resolving = ref(false);
      const searchWatcher = ref(null);
      const offset2 = ref(infinite.value && limit2.value === -1 ? 10 : limit2.value);
      const resolvedOptions = computed({
        get: () => ro.value,
        set: (v2) => ro.value = v2
      });
      const createOption = toRef(() => {
        return createTag.value || createOption_.value || false;
      });
      const appendNewOption = toRef(() => {
        if (appendNewTag.value !== void 0) {
          return appendNewTag.value;
        } else if (appendNewOption_.value !== void 0) {
          return appendNewOption_.value;
        }
        return true;
      });
      const eo = computed(() => {
        if (groupped.value) {
          let groups = eg.value || /* istanbul ignore next */
          [];
          let eo2 = [];
          groups.forEach((group2) => {
            optionsToArray(group2[groupOptions.value]).forEach((option) => {
              eo2.push(Object.assign({}, option, group2[disabledProp.value] ? { [disabledProp.value]: true } : {}));
            });
          });
          return eo2;
        } else {
          let eo2 = optionsToArray(ro.value || /* istanbul ignore next */
          []);
          if (ap.value.length) {
            eo2 = eo2.concat(ap.value);
          }
          return eo2;
        }
      });
      const pfo = computed(() => {
        let options2 = eo.value;
        if (reverse.value) {
          options2 = options2.reverse();
        }
        if (createdOption.value.length) {
          options2 = createdOption.value.concat(options2);
        }
        return filterOptions(options2);
      });
      const fo = computed(() => {
        let options2 = pfo.value;
        if (offset2.value > 0) {
          options2 = options2.slice(0, offset2.value);
        }
        return options2;
      });
      const eg = computed(() => {
        if (!groupped.value) {
          return [];
        }
        let eg2 = [];
        let groups = ro.value || /* istanbul ignore next */
        [];
        if (ap.value.length) {
          eg2.push({
            [groupLabel.value]: " ",
            [groupOptions.value]: [...ap.value],
            __CREATE__: true
          });
        }
        return eg2.concat(groups);
      });
      const pfg = computed(() => {
        let groups = [...eg.value].map((g2) => ({ ...g2 }));
        if (createdOption.value.length) {
          if (groups[0] && groups[0].__CREATE__) {
            groups[0][groupOptions.value] = [...createdOption.value, ...groups[0][groupOptions.value]];
          } else {
            groups = [{
              [groupLabel.value]: " ",
              [groupOptions.value]: [...createdOption.value],
              __CREATE__: true
            }].concat(groups);
          }
        }
        return groups;
      });
      const fg = computed(() => {
        if (!groupped.value) {
          return [];
        }
        let options2 = pfg.value;
        return filterGroups((options2 || /* istanbul ignore next */
        []).map((group2, index2) => {
          const arrayOptions = optionsToArray(group2[groupOptions.value]);
          return {
            ...group2,
            index: index2,
            group: true,
            [groupOptions.value]: filterOptions(arrayOptions, false).map((o2) => Object.assign({}, o2, group2[disabledProp.value] ? { [disabledProp.value]: true } : {})),
            __VISIBLE__: filterOptions(arrayOptions).map((o2) => Object.assign({}, o2, group2[disabledProp.value] ? { [disabledProp.value]: true } : {}))
          };
        }));
      });
      const hasSelected = computed(() => {
        switch (mode.value) {
          case "single":
            return !isNullish$1(iv.value[valueProp.value]);
          case "multiple":
          case "tags":
            return !isNullish$1(iv.value) && iv.value.length > 0;
        }
      });
      const multipleLabelText = computed(() => {
        return multipleLabel.value !== void 0 ? multipleLabel.value(iv.value, $this) : iv.value && iv.value.length > 1 ? `${iv.value.length} options selected` : `1 option selected`;
      });
      const noOptions = toRef(() => {
        return !eo.value.length && !resolving.value && !createdOption.value.length;
      });
      const noResults = toRef(() => {
        return eo.value.length > 0 && fo.value.length == 0 && (search.value && groupped.value || !groupped.value);
      });
      const createdOption = computed(() => {
        if (createOption.value === false || !search.value) {
          return [];
        }
        if (getOptionByTrackBy(search.value) !== -1) {
          return [];
        }
        return [{
          [valueProp.value]: search.value,
          [trackBy.value[0]]: search.value,
          [label.value]: search.value,
          __CREATE__: true
        }];
      });
      const trackBy = computed(() => {
        return trackBy_.value ? Array.isArray(trackBy_.value) ? trackBy_.value : [trackBy_.value] : [label.value];
      });
      const nullValue = toRef(() => {
        switch (mode.value) {
          case "single":
            return null;
          case "multiple":
          case "tags":
            return [];
        }
      });
      const busy = toRef(() => {
        return loading.value || resolving.value;
      });
      const select2 = (option) => {
        if (typeof option !== "object") {
          option = getOption(option);
        }
        switch (mode.value) {
          case "single":
            update(option);
            break;
          case "multiple":
          case "tags":
            update(iv.value.concat(option));
            break;
        }
        context.emit("select", finalValue(option), option, $this);
      };
      const deselect = (option) => {
        if (typeof option !== "object") {
          option = getOption(option);
        }
        switch (mode.value) {
          case "single":
            clear2();
            break;
          case "tags":
          case "multiple":
            update(Array.isArray(option) ? iv.value.filter((v2) => option.map((o2) => o2[valueProp.value]).indexOf(v2[valueProp.value]) === -1) : iv.value.filter((v2) => v2[valueProp.value] != option[valueProp.value]));
            break;
        }
        context.emit("deselect", finalValue(option), option, $this);
      };
      const finalValue = (option) => {
        return object2.value ? option : option[valueProp.value];
      };
      const remove2 = (option) => {
        deselect(option);
      };
      const handleTagRemove = (option, e2) => {
        if (e2.button !== 0) {
          e2.preventDefault();
          return;
        }
        remove2(option);
      };
      const clear2 = () => {
        update(nullValue.value);
        context.emit("clear", $this);
      };
      const isSelected = (option) => {
        if (option.group !== void 0) {
          return mode.value === "single" ? false : areAllSelected(option[groupOptions.value]) && option[groupOptions.value].length;
        }
        switch (mode.value) {
          case "single":
            return !isNullish$1(iv.value) && iv.value[valueProp.value] == option[valueProp.value];
          case "tags":
          case "multiple":
            return !isNullish$1(iv.value) && iv.value.map((o2) => o2[valueProp.value]).indexOf(option[valueProp.value]) !== -1;
        }
      };
      const isDisabled = (option) => {
        return option[disabledProp.value] === true;
      };
      const isMax = () => {
        if (max2 === void 0 || max2.value === -1 || !hasSelected.value && max2.value > 0) {
          return false;
        }
        return iv.value.length >= max2.value;
      };
      const handleOptionClick = (option) => {
        if (isDisabled(option)) {
          return;
        }
        if (onCreate.value && !isSelected(option) && option.__CREATE__) {
          option = { ...option };
          delete option.__CREATE__;
          option = onCreate.value(option, $this);
          if (option instanceof Promise) {
            resolving.value = true;
            option.then((result) => {
              resolving.value = false;
              handleOptionSelect(result);
            });
            return;
          }
        }
        handleOptionSelect(option);
      };
      const handleOptionSelect = (option) => {
        if (option.__CREATE__) {
          option = { ...option };
          delete option.__CREATE__;
        }
        switch (mode.value) {
          case "single":
            if (option && isSelected(option)) {
              if (canDeselect.value) {
                deselect(option);
              }
              if (closeOnDeselect.value) {
                clearPointer();
                close();
              }
              return;
            }
            if (option) {
              handleOptionAppend(option);
            }
            if (clearOnSelect.value) {
              clearSearch();
            }
            if (closeOnSelect.value) {
              clearPointer();
              close();
            }
            if (option) {
              select2(option);
            }
            break;
          case "multiple":
            if (option && isSelected(option)) {
              deselect(option);
              if (closeOnDeselect.value) {
                clearPointer();
                close();
              }
              return;
            }
            if (isMax()) {
              context.emit("max", $this);
              return;
            }
            if (option) {
              handleOptionAppend(option);
              select2(option);
            }
            if (clearOnSelect.value) {
              clearSearch();
            }
            if (hideSelected.value) {
              clearPointer();
            }
            if (closeOnSelect.value) {
              close();
            }
            break;
          case "tags":
            if (option && isSelected(option)) {
              deselect(option);
              if (closeOnDeselect.value) {
                clearPointer();
                close();
              }
              return;
            }
            if (isMax()) {
              context.emit("max", $this);
              return;
            }
            if (option) {
              handleOptionAppend(option);
            }
            if (clearOnSelect.value) {
              clearSearch();
            }
            if (option) {
              select2(option);
            }
            if (hideSelected.value) {
              clearPointer();
            }
            if (closeOnSelect.value) {
              close();
            }
            break;
        }
        if (!closeOnSelect.value) {
          focus();
        }
      };
      const handleGroupClick = (group2) => {
        if (isDisabled(group2) || mode.value === "single" || !groupSelect.value) {
          return;
        }
        switch (mode.value) {
          case "multiple":
          case "tags":
            if (areAllEnabledSelected(group2[groupOptions.value])) {
              deselect(group2[groupOptions.value]);
            } else {
              select2(
                group2[groupOptions.value].filter((o2) => iv.value.map((v2) => v2[valueProp.value]).indexOf(o2[valueProp.value]) === -1).filter((o2) => !o2[disabledProp.value]).filter((o2, k2) => iv.value.length + 1 + k2 <= max2.value || max2.value === -1)
              );
            }
            if (hideSelected.value && pointer.value) {
              setPointer(fg.value.filter((g2) => !g2[disabledProp.value])[pointer.value.index]);
            }
            break;
        }
        if (closeOnSelect.value) {
          deactivate();
        }
      };
      const handleOptionAppend = (option) => {
        if (getOption(option[valueProp.value]) === void 0 && createOption.value) {
          context.emit("tag", option[valueProp.value], $this);
          context.emit("option", option[valueProp.value], $this);
          context.emit("create", option[valueProp.value], $this);
          if (appendNewOption.value) {
            appendOption(option);
          }
          clearSearch();
        }
      };
      const selectAll = () => {
        if (mode.value === "single") {
          return;
        }
        select2(fo.value.filter((o2) => !o2.disabled && !isSelected(o2)));
      };
      const areAllEnabledSelected = (options2) => {
        return options2.find((o2) => !isSelected(o2) && !o2[disabledProp.value]) === void 0;
      };
      const areAllSelected = (options2) => {
        return options2.find((o2) => !isSelected(o2)) === void 0;
      };
      const getOption = (val) => {
        return eo.value[eo.value.map((o2) => String(o2[valueProp.value])).indexOf(String(val))];
      };
      const getOptionByTrackBy = (val) => {
        return eo.value.findIndex((o2) => {
          return trackBy.value.some((track2) => {
            return (parseInt(o2[track2]) == o2[track2] ? parseInt(o2[track2]) : o2[track2]) === (parseInt(val) == val ? parseInt(val) : val);
          });
        });
      };
      const shouldHideOption = (option) => {
        return ["tags", "multiple"].indexOf(mode.value) !== -1 && hideSelected.value && isSelected(option);
      };
      const appendOption = (option) => {
        ap.value.push(option);
      };
      const filterGroups = (groups) => {
        return groupHideEmpty.value ? groups.filter(
          (g2) => search.value ? g2.__VISIBLE__.length : g2[groupOptions.value].length
        ) : groups.filter((g2) => search.value ? g2.__VISIBLE__.length : true);
      };
      const filterOptions = (options2, excludeHideSelected = true) => {
        let fo2 = options2;
        if (search.value && filterResults.value) {
          let filter2 = searchFilter.value;
          if (!filter2) {
            filter2 = (option, query, $this2) => {
              return trackBy.value.some((track2) => {
                let target = normalize(localize2(option[track2]), strict.value);
                return searchStart.value ? target.startsWith(normalize(query, strict.value)) : target.indexOf(normalize(query, strict.value)) !== -1;
              });
            };
          }
          fo2 = fo2.filter((o2) => {
            return filter2(o2, search.value, $this);
          });
        }
        if (hideSelected.value && excludeHideSelected) {
          fo2 = fo2.filter((option) => !shouldHideOption(option));
        }
        return fo2;
      };
      const optionsToArray = (options2) => {
        let uo = options2;
        if (isObject(uo)) {
          uo = Object.keys(uo).map((key) => {
            let val = uo[key];
            return { [valueProp.value]: key, [trackBy.value[0]]: val, [label.value]: val };
          });
        }
        if (!Array.isArray(uo)) {
          return [];
        }
        uo = uo.map((val) => {
          return typeof val === "object" ? val : { [valueProp.value]: val, [trackBy.value[0]]: val, [label.value]: val };
        });
        return uo;
      };
      const initInternalValue = () => {
        if (!isNullish$1(ev.value)) {
          iv.value = makeInternal(ev.value);
        }
      };
      const resolveOptions = (callback) => {
        resolving.value = true;
        return new Promise((resolve2, reject) => {
          options.value(search.value, $this).then((response) => {
            ro.value = response || [];
            if (typeof callback == "function") {
              callback(response);
            }
            resolving.value = false;
          }).catch((e2) => {
            console.error(e2);
            ro.value = [];
            resolving.value = false;
          }).finally(() => {
            resolve2();
          });
        });
      };
      const refreshLabels = () => {
        if (!hasSelected.value) {
          return;
        }
        if (mode.value === "single") {
          let option = getOption(iv.value[valueProp.value]);
          if (option !== void 0) {
            let newLabel = option[label.value];
            iv.value[label.value] = newLabel;
            if (object2.value) {
              ev.value[label.value] = newLabel;
            }
          }
        } else {
          iv.value.forEach((val, i2) => {
            let option = getOption(iv.value[i2][valueProp.value]);
            if (option !== void 0) {
              let newLabel = option[label.value];
              iv.value[i2][label.value] = newLabel;
              if (object2.value) {
                ev.value[i2][label.value] = newLabel;
              }
            }
          });
        }
      };
      const refreshOptions = (callback) => {
        resolveOptions(callback);
      };
      const makeInternal = (val) => {
        if (isNullish$1(val)) {
          return mode.value === "single" ? {} : [];
        }
        if (object2.value) {
          return val;
        }
        return mode.value === "single" ? getOption(val) || (allowAbsent.value ? {
          [label.value]: val,
          [valueProp.value]: val,
          [trackBy.value[0]]: val
        } : {}) : val.filter((v2) => !!getOption(v2) || allowAbsent.value).map((v2) => getOption(v2) || {
          [label.value]: v2,
          [valueProp.value]: v2,
          [trackBy.value[0]]: v2
        });
      };
      const initSearchWatcher = () => {
        searchWatcher.value = watch(search, (query) => {
          if (query.length < minChars.value || !query && minChars.value !== 0) {
            return;
          }
          resolving.value = true;
          if (clearOnSearch.value) {
            ro.value = [];
          }
          setTimeout(() => {
            if (query != search.value) {
              return;
            }
            options.value(search.value, $this).then((response) => {
              if (query == search.value || !search.value) {
                ro.value = response;
                pointer.value = fo.value.filter((o2) => o2[disabledProp.value] !== true)[0] || null;
                resolving.value = false;
              }
            }).catch(
              /* istanbul ignore next */
              (e2) => {
                console.error(e2);
              }
            );
          }, delay.value);
        }, { flush: "sync" });
      };
      if (mode.value !== "single" && !isNullish$1(ev.value) && !Array.isArray(ev.value)) {
        throw new Error(`v-model must be an array when using "${mode.value}" mode`);
      }
      if (options && typeof options.value == "function") {
        if (resolveOnLoad.value) {
          resolveOptions(initInternalValue);
        } else if (object2.value == true) {
          initInternalValue();
        }
      } else {
        ro.value = options.value;
        initInternalValue();
      }
      if (delay.value > -1) {
        initSearchWatcher();
      }
      watch(delay, (value, old) => {
        if (searchWatcher.value) {
          searchWatcher.value();
        }
        if (value >= 0) {
          initSearchWatcher();
        }
      });
      watch(ev, (newValue) => {
        if (isNullish$1(newValue)) {
          update(makeInternal(newValue), false);
          return;
        }
        switch (mode.value) {
          case "single":
            if (object2.value ? newValue[valueProp.value] != iv.value[valueProp.value] : newValue != iv.value[valueProp.value]) {
              update(makeInternal(newValue), false);
            }
            break;
          case "multiple":
          case "tags":
            if (!arraysEqual$1(object2.value ? newValue.map((o2) => o2[valueProp.value]) : newValue, iv.value.map((o2) => o2[valueProp.value]))) {
              update(makeInternal(newValue), false);
            }
            break;
        }
      }, { deep: true });
      watch(options, (n2, o2) => {
        if (typeof props.options === "function") {
          if (resolveOnLoad.value && (!o2 || n2 && n2.toString() !== o2.toString())) {
            resolveOptions();
          }
        } else {
          ro.value = props.options;
          if (!Object.keys(iv.value).length) {
            initInternalValue();
          }
          refreshLabels();
        }
      });
      watch(label, refreshLabels);
      watch(limit2, (n2, o2) => {
        offset2.value = infinite.value && n2 === -1 ? 10 : n2;
      });
      return {
        resolvedOptions,
        pfo,
        fo,
        filteredOptions: fo,
        hasSelected,
        multipleLabelText,
        eo,
        extendedOptions: eo,
        eg,
        extendedGroups: eg,
        fg,
        filteredGroups: fg,
        noOptions,
        noResults,
        resolving,
        busy,
        offset: offset2,
        select: select2,
        deselect,
        remove: remove2,
        selectAll,
        clear: clear2,
        isSelected,
        isDisabled,
        isMax,
        getOption,
        handleOptionClick,
        handleGroupClick,
        handleTagRemove,
        refreshOptions,
        resolveOptions,
        refreshLabels
      };
    }
    function usePointer(props, context, dep) {
      const {
        valueProp,
        showOptions,
        searchable,
        groupLabel,
        groups: groupped,
        mode,
        groupSelect,
        disabledProp,
        groupOptions
      } = toRefs(props);
      const fo = dep.fo;
      const fg = dep.fg;
      const handleOptionClick = dep.handleOptionClick;
      const handleGroupClick = dep.handleGroupClick;
      const search = dep.search;
      const pointer = dep.pointer;
      const setPointer = dep.setPointer;
      const clearPointer = dep.clearPointer;
      const multiselect2 = dep.multiselect;
      const isOpen = dep.isOpen;
      const options = computed(() => {
        return fo.value.filter((o2) => !o2[disabledProp.value]);
      });
      const groups = computed(() => {
        return fg.value.filter((g2) => !g2[disabledProp.value]);
      });
      const canPointGroups = toRef(() => {
        return mode.value !== "single" && groupSelect.value;
      });
      const isPointerGroup = toRef(() => {
        return pointer.value && pointer.value.group;
      });
      const currentGroup = computed(() => {
        return getParentGroup(pointer.value);
      });
      const prevGroup = computed(() => {
        const group2 = isPointerGroup.value ? pointer.value : (
          /* istanbul ignore next */
          getParentGroup(pointer.value)
        );
        const groupIndex = groups.value.map((g2) => g2[groupLabel.value]).indexOf(group2[groupLabel.value]);
        let prevGroup2 = groups.value[groupIndex - 1];
        if (prevGroup2 === void 0) {
          prevGroup2 = lastGroup.value;
        }
        return prevGroup2;
      });
      const nextGroup = computed(() => {
        let nextIndex = groups.value.map((g2) => g2.label).indexOf(isPointerGroup.value ? pointer.value[groupLabel.value] : getParentGroup(pointer.value)[groupLabel.value]) + 1;
        if (groups.value.length <= nextIndex) {
          nextIndex = 0;
        }
        return groups.value[nextIndex];
      });
      const lastGroup = computed(() => {
        return [...groups.value].slice(-1)[0];
      });
      const currentGroupFirstEnabledOption = computed(() => {
        return pointer.value.__VISIBLE__.filter((o2) => !o2[disabledProp.value])[0];
      });
      const currentGroupPrevEnabledOption = computed(() => {
        const options2 = currentGroup.value.__VISIBLE__.filter((o2) => !o2[disabledProp.value]);
        return options2[options2.map((o2) => o2[valueProp.value]).indexOf(pointer.value[valueProp.value]) - 1];
      });
      const currentGroupNextEnabledOption = computed(() => {
        const options2 = getParentGroup(pointer.value).__VISIBLE__.filter((o2) => !o2[disabledProp.value]);
        return options2[options2.map((o2) => o2[valueProp.value]).indexOf(pointer.value[valueProp.value]) + 1];
      });
      const prevGroupLastEnabledOption = computed(() => {
        return [...prevGroup.value.__VISIBLE__.filter((o2) => !o2[disabledProp.value])].slice(-1)[0];
      });
      const lastGroupLastEnabledOption = computed(() => {
        return [...lastGroup.value.__VISIBLE__.filter((o2) => !o2[disabledProp.value])].slice(-1)[0];
      });
      const isPointed = (option) => {
        return !!pointer.value && (!option.group && pointer.value[valueProp.value] === option[valueProp.value] || option.group !== void 0 && pointer.value[groupLabel.value] === option[groupLabel.value]) ? true : void 0;
      };
      const setPointerFirst = () => {
        setPointer(options.value[0] || null);
      };
      const selectPointer = () => {
        if (!pointer.value || pointer.value[disabledProp.value] === true) {
          return;
        }
        if (isPointerGroup.value) {
          handleGroupClick(pointer.value);
        } else {
          handleOptionClick(pointer.value);
        }
      };
      const forwardPointer = () => {
        if (pointer.value === null) {
          setPointer((groupped.value && canPointGroups.value ? !groups.value[0].__CREATE__ ? groups.value[0] : options.value[0] : options.value[0]) || null);
        } else if (groupped.value && canPointGroups.value) {
          let nextPointer = isPointerGroup.value ? currentGroupFirstEnabledOption.value : currentGroupNextEnabledOption.value;
          if (nextPointer === void 0) {
            nextPointer = nextGroup.value;
            if (nextPointer.__CREATE__) {
              nextPointer = nextPointer[groupOptions.value][0];
            }
          }
          setPointer(nextPointer || /* istanbul ignore next */
          null);
        } else {
          let next = options.value.map((o2) => o2[valueProp.value]).indexOf(pointer.value[valueProp.value]) + 1;
          if (options.value.length <= next) {
            next = 0;
          }
          setPointer(options.value[next] || null);
        }
        nextTick(() => {
          adjustWrapperScrollToPointer();
        });
      };
      const backwardPointer = () => {
        if (pointer.value === null) {
          let prevPointer = options.value[options.value.length - 1];
          if (groupped.value && canPointGroups.value) {
            prevPointer = lastGroupLastEnabledOption.value;
            if (prevPointer === void 0) {
              prevPointer = lastGroup.value;
            }
          }
          setPointer(prevPointer || null);
        } else if (groupped.value && canPointGroups.value) {
          let prevPointer = isPointerGroup.value ? prevGroupLastEnabledOption.value : currentGroupPrevEnabledOption.value;
          if (prevPointer === void 0) {
            prevPointer = isPointerGroup.value ? prevGroup.value : currentGroup.value;
            if (prevPointer.__CREATE__) {
              prevPointer = prevGroupLastEnabledOption.value;
              if (prevPointer === void 0) {
                prevPointer = prevGroup.value;
              }
            }
          }
          setPointer(prevPointer || /* istanbul ignore next */
          null);
        } else {
          let prevIndex = options.value.map((o2) => o2[valueProp.value]).indexOf(pointer.value[valueProp.value]) - 1;
          if (prevIndex < 0) {
            prevIndex = options.value.length - 1;
          }
          setPointer(options.value[prevIndex] || null);
        }
        nextTick(() => {
          adjustWrapperScrollToPointer();
        });
      };
      const getParentGroup = (option) => {
        return groups.value.find((group2) => {
          return group2.__VISIBLE__.map((o2) => o2[valueProp.value]).indexOf(option[valueProp.value]) !== -1;
        });
      };
      const adjustWrapperScrollToPointer = () => {
        let pointedOption = multiselect2.value.querySelector(`[data-pointed]`);
        if (!pointedOption) {
          return;
        }
        let wrapper = pointedOption.parentElement.parentElement;
        if (groupped.value) {
          wrapper = isPointerGroup.value ? pointedOption.parentElement.parentElement.parentElement : pointedOption.parentElement.parentElement.parentElement.parentElement;
        }
        if (pointedOption.offsetTop + pointedOption.offsetHeight > wrapper.clientHeight + wrapper.scrollTop) {
          wrapper.scrollTop = pointedOption.offsetTop + pointedOption.offsetHeight - wrapper.clientHeight;
        }
        if (pointedOption.offsetTop < wrapper.scrollTop) {
          wrapper.scrollTop = pointedOption.offsetTop;
        }
      };
      watch(search, (val) => {
        if (searchable.value) {
          if (val.length && showOptions.value) {
            setPointerFirst();
          } else {
            clearPointer();
          }
        }
      });
      watch(isOpen, (val) => {
        if (val && multiselect2 && multiselect2.value) {
          let firstSelected = multiselect2.value.querySelectorAll(`[data-selected]`)[0];
          if (!firstSelected) {
            return;
          }
          let wrapper = firstSelected.parentElement.parentElement;
          nextTick(() => {
            wrapper.scrollTop = firstSelected.offsetTop;
          });
        }
      });
      return {
        pointer,
        canPointGroups,
        isPointed,
        setPointerFirst,
        selectPointer,
        forwardPointer,
        backwardPointer
      };
    }
    function getWindow(node) {
      if (node == null) {
        return window;
      }
      if (node.toString() !== "[object Window]") {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }
      return node;
    }
    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }
    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }
    function isShadowRoot(node) {
      if (typeof ShadowRoot === "undefined") {
        return false;
      }
      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }
    var max = Math.max;
    var min = Math.min;
    var round = Math.round;
    function getUAString() {
      var uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
        return uaData.brands.map(function(item) {
          return item.brand + "/" + item.version;
        }).join(" ");
      }
      return navigator.userAgent;
    }
    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }
    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
      }
      var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width,
        height,
        top: y2,
        right: x2 + width,
        bottom: y2 + height,
        left: x2,
        x: x2,
        y: y2
      };
    }
    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft,
        scrollTop
      };
    }
    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }
    function getNodeName(element) {
      return element ? (element.nodeName || "").toLowerCase() : null;
    }
    function getDocumentElement(element) {
      return ((isElement(element) ? element.ownerDocument : (
        // $FlowFixMe[prop-missing]
        element.document
      )) || window.document).documentElement;
    }
    function getWindowScrollBarX(element) {
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }
    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function isScrollParent(element) {
      var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round(rect.width) / element.offsetWidth || 1;
      var scaleY = round(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    }
    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element);
      var width = element.offsetWidth;
      var height = element.offsetHeight;
      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }
      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width,
        height
      };
    }
    function getParentNode(element) {
      if (getNodeName(element) === "html") {
        return element;
      }
      return (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || // DOM Element detected
        (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element)
      );
    }
    function getScrollParent(node) {
      if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
        return node.ownerDocument.body;
      }
      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }
      return getScrollParent(getParentNode(node));
    }
    function listScrollParents(element, list2) {
      var _element$ownerDocumen;
      if (list2 === void 0) {
        list2 = [];
      }
      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list2.concat(target);
      return isBody ? updatedList : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        updatedList.concat(listScrollParents(getParentNode(target)))
      );
    }
    function isTableElement(element) {
      return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
    }
    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === "fixed") {
        return null;
      }
      return element.offsetParent;
    }
    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());
      if (isIE && isHTMLElement(element)) {
        var elementCss = getComputedStyle$1(element);
        if (elementCss.position === "fixed") {
          return null;
        }
      }
      var currentNode = getParentNode(element);
      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }
      while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
        var css2 = getComputedStyle$1(currentNode);
        if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
      return null;
    }
    function getOffsetParent(element) {
      var window2 = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
        return window2;
      }
      return offsetParent || getContainingBlock(element) || window2;
    }
    var top = "top";
    var bottom = "bottom";
    var right = "right";
    var left = "left";
    var auto = "auto";
    var basePlacements = [top, bottom, right, left];
    var start = "start";
    var end = "end";
    var clippingParents = "clippingParents";
    var viewport = "viewport";
    var popper = "popper";
    var reference = "reference";
    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []);
    var beforeRead = "beforeRead";
    var read = "read";
    var afterRead = "afterRead";
    var beforeMain = "beforeMain";
    var main = "main";
    var afterMain = "afterMain";
    var beforeWrite = "beforeWrite";
    var write = "write";
    var afterWrite = "afterWrite";
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
    function order(modifiers) {
      var map2 = /* @__PURE__ */ new Map();
      var visited = /* @__PURE__ */ new Set();
      var result = [];
      modifiers.forEach(function(modifier) {
        map2.set(modifier.name, modifier);
      });
      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
          if (!visited.has(dep)) {
            var depModifier = map2.get(dep);
            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }
      modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) {
          sort(modifier);
        }
      });
      return result;
    }
    function orderModifiers(modifiers) {
      var orderedModifiers = order(modifiers);
      return modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }
    function debounce(fn2) {
      var pending;
      return function() {
        if (!pending) {
          pending = new Promise(function(resolve2) {
            Promise.resolve().then(function() {
              pending = void 0;
              resolve2(fn2());
            });
          });
        }
        return pending;
      };
    }
    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function(merged2, current) {
        var existing = merged2[current.name];
        merged2[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged2;
      }, {});
      return Object.keys(merged).map(function(key) {
        return merged[key];
      });
    }
    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x2 = 0;
      var y2 = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();
        if (layoutViewport || !layoutViewport && strategy === "fixed") {
          x2 = visualViewport.offsetLeft;
          y2 = visualViewport.offsetTop;
        }
      }
      return {
        width,
        height,
        x: x2 + getWindowScrollBarX(element),
        y: y2
      };
    }
    function getDocumentRect(element) {
      var _element$ownerDocumen;
      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y2 = -winScroll.scrollTop;
      if (getComputedStyle$1(body || html).direction === "rtl") {
        x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }
      return {
        width,
        height,
        x: x2,
        y: y2
      };
    }
    function contains(parent2, child) {
      var rootNode = child.getRootNode && child.getRootNode();
      if (parent2.contains(child)) {
        return true;
      } else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;
        do {
          if (next && parent2.isSameNode(next)) {
            return true;
          }
          next = next.parentNode || next.host;
        } while (next);
      }
      return false;
    }
    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }
    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === "fixed");
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    }
    function getClippingParents(element) {
      var clippingParents2 = listScrollParents(getParentNode(element));
      var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
      if (!isElement(clipperElement)) {
        return [];
      }
      return clippingParents2.filter(function(clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
      });
    }
    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
      var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents2[0];
      var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }
    function getBasePlacement(placement) {
      return placement.split("-")[0];
    }
    function getVariation(placement) {
      return placement.split("-")[1];
    }
    function getMainAxisFromPlacement(placement) {
      return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
    }
    function computeOffsets(_ref) {
      var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference2.x + reference2.width / 2 - element.width / 2;
      var commonY = reference2.y + reference2.height / 2 - element.height / 2;
      var offsets;
      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference2.y - element.height
          };
          break;
        case bottom:
          offsets = {
            x: commonX,
            y: reference2.y + reference2.height
          };
          break;
        case right:
          offsets = {
            x: reference2.x + reference2.width,
            y: commonY
          };
          break;
        case left:
          offsets = {
            x: reference2.x - element.width,
            y: commonY
          };
          break;
        default:
          offsets = {
            x: reference2.x,
            y: reference2.y
          };
      }
      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
      if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
            break;
          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
            break;
        }
      }
      return offsets;
    }
    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }
    function expandToHashMap(value, keys2) {
      return keys2.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }
    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets2 = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset;
      if (elementContext === popper && offsetData) {
        var offset2 = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
          overflowOffsets[key] += offset2[axis] * multiply;
        });
      }
      return overflowOffsets;
    }
    var DEFAULT_OPTIONS = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
      });
    }
    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }
      var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper2(reference2, popper2, options) {
        if (options === void 0) {
          options = defaultOptions;
        }
        var state = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference2,
            popper: popper2
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state,
          setOptions: function setOptions(setOptionsAction) {
            var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options2);
            state.scrollParents = {
              reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
              popper: listScrollParents(popper2)
            };
            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
            state.orderedModifiers = orderedModifiers.filter(function(m2) {
              return m2.enabled;
            });
            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }
            var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
            if (!areValidElements(reference3, popper3)) {
              return;
            }
            state.rects = {
              reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
              popper: getLayoutRect(popper3)
            };
            state.reset = false;
            state.placement = state.options.placement;
            state.orderedModifiers.forEach(function(modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
              if (state.reset === true) {
                state.reset = false;
                index2 = -1;
                continue;
              }
              var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
              if (typeof fn2 === "function") {
                state = fn2({
                  state,
                  options: _options,
                  name: name2,
                  instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce(function() {
            return new Promise(function(resolve2) {
              instance.forceUpdate();
              resolve2(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };
        if (!areValidElements(reference2, popper2)) {
          return instance;
        }
        instance.setOptions(options).then(function(state2) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state2);
          }
        });
        function runModifierEffects() {
          state.orderedModifiers.forEach(function(_ref) {
            var name2 = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
            if (typeof effect2 === "function") {
              var cleanupFn = effect2({
                state,
                name: name2,
                instance,
                options: options2
              });
              var noopFn = function noopFn2() {
              };
              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }
        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function(fn2) {
            return fn2();
          });
          effectCleanupFns = [];
        }
        return instance;
      };
    }
    var passive = {
      passive: true
    };
    function effect$1(_ref) {
      var state = _ref.state, instance = _ref.instance, options = _ref.options;
      var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
      var window2 = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.addEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.addEventListener("resize", instance.update, passive);
      }
      return function() {
        if (scroll) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, passive);
          });
        }
        if (resize) {
          window2.removeEventListener("resize", instance.update, passive);
        }
      };
    }
    var eventListeners = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function fn2() {
      },
      effect: effect$1,
      data: {}
    };
    function popperOffsets(_ref) {
      var state = _ref.state, name2 = _ref.name;
      state.modifiersData[name2] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
      });
    }
    var popperOffsets$1 = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: popperOffsets,
      data: {}
    };
    var unsetSides = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function roundOffsetsByDPR(_ref, win) {
      var x2 = _ref.x, y2 = _ref.y;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(x2 * dpr) / dpr || 0,
        y: round(y2 * dpr) / dpr || 0
      };
    }
    function mapToStyles(_ref2) {
      var _Object$assign2;
      var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
      var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x: x2,
        y: y2
      }) : {
        x: x2,
        y: y2
      };
      x2 = _ref3.x;
      y2 = _ref3.y;
      var hasX = offsets.hasOwnProperty("x");
      var hasY = offsets.hasOwnProperty("y");
      var sideX = left;
      var sideY = top;
      var win = window;
      if (adaptive) {
        var offsetParent = getOffsetParent(popper2);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow(popper2)) {
          offsetParent = getDocumentElement(popper2);
          if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
            heightProp = "scrollHeight";
            widthProp = "scrollWidth";
          }
        }
        offsetParent = offsetParent;
        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            offsetParent[heightProp]
          );
          y2 -= offsetY - popperRect.height;
          y2 *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            offsetParent[widthProp]
          );
          x2 -= offsetX - popperRect.width;
          x2 *= gpuAcceleration ? 1 : -1;
        }
      }
      var commonStyles = Object.assign({
        position
      }, adaptive && unsetSides);
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x2,
        y: y2
      }, getWindow(popper2)) : {
        x: x2,
        y: y2
      };
      x2 = _ref4.x;
      y2 = _ref4.y;
      if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
      }
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
    }
    function computeStyles(_ref5) {
      var state = _ref5.state, options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration,
        isFixed: state.options.strategy === "fixed"
      };
      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive,
          roundOffsets
        })));
      }
      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: "absolute",
          adaptive: false,
          roundOffsets
        })));
      }
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement
      });
    }
    var computeStyles$1 = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: computeStyles,
      data: {}
    };
    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function(name2) {
        var style = state.styles[name2] || {};
        var attributes = state.attributes[name2] || {};
        var element = state.elements[name2];
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name3) {
          var value = attributes[name3];
          if (value === false) {
            element.removeAttribute(name3);
          } else {
            element.setAttribute(name3, value === true ? "" : value);
          }
        });
      });
    }
    function effect(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
      return function() {
        Object.keys(state.elements).forEach(function(name2) {
          var element = state.elements[name2];
          var attributes = state.attributes[name2] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
          var style = styleProperties.reduce(function(style2, property2) {
            style2[property2] = "";
            return style2;
          }, {});
          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }
          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function(attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    }
    var applyStyles$1 = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: applyStyles,
      effect,
      requires: ["computeStyles"]
    };
    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
    var createPopper = /* @__PURE__ */ popperGenerator({
      defaultModifiers
    });
    function getAltAxis(axis) {
      return axis === "x" ? "y" : "x";
    }
    function within(min$12, value, max$12) {
      return max(min$12, min(value, max$12));
    }
    function withinMaxClamp(min2, value, max2) {
      var v2 = within(min2, value, max2);
      return v2 > max2 ? max2 : v2;
    }
    function preventOverflow(_ref) {
      var state = _ref.state, options = _ref.options, name2 = _ref.name;
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary,
        rootBoundary,
        padding,
        altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };
      if (!popperOffsets2) {
        return;
      }
      if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? top : left;
        var altSide = mainAxis === "y" ? bottom : right;
        var len = mainAxis === "y" ? "height" : "width";
        var offset2 = popperOffsets2[mainAxis];
        var min$12 = offset2 + overflow[mainSide];
        var max$12 = offset2 - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide];
        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset2 + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min(min$12, tetherMin) : min$12, offset2, tether ? max(max$12, tetherMax) : max$12);
        popperOffsets2[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset2;
      }
      if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? top : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
      state.modifiersData[name2] = data;
    }
    var preventOverflow$1 = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: preventOverflow,
      requiresIfExists: ["offset"]
    };
    var hash$1 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash$1[matched];
      });
    }
    var hash = {
      start: "end",
      end: "start"
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
      });
    }
    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
        return getVariation(placement2) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function(placement2) {
        return allowedAutoPlacements.indexOf(placement2) >= 0;
      });
      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      }
      var overflows = allowedPlacements.reduce(function(acc, placement2) {
        acc[placement2] = detectOverflow(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding
        })[getBasePlacement(placement2)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function(a2, b2) {
        return overflows[a2] - overflows[b2];
      });
    }
    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }
      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }
    function flip(_ref) {
      var state = _ref.state, options = _ref.options, name2 = _ref.name;
      if (state.modifiersData[name2]._skip) {
        return;
      }
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
        return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding,
          flipVariations,
          allowedAutoPlacements
        }) : placement2);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = /* @__PURE__ */ new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements2[0];
      for (var i2 = 0; i2 < placements2.length; i2++) {
        var placement = placements2[i2];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = detectOverflow(state, {
          placement,
          boundary,
          rootBoundary,
          altBoundary,
          padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }
        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }
        if (checks.every(function(check2) {
          return check2;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }
        checksMap.set(placement, checks);
      }
      if (makeFallbackChecks) {
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop2(_i3) {
          var fittingPlacement = placements2.find(function(placement2) {
            var checks2 = checksMap.get(placement2);
            if (checks2) {
              return checks2.slice(0, _i3).every(function(check2) {
                return check2;
              });
            }
          });
          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };
        for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
          var _ret = _loop(_i2);
          if (_ret === "break")
            break;
        }
      }
      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name2]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    }
    var flip$1 = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: flip,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function useDropdown(props, context, dep) {
      const { disabled, appendTo, appendToBody, openDirection } = toRefs(props);
      const $this = getCurrentInstance().proxy;
      const multiselect2 = dep.multiselect;
      const dropdown = dep.dropdown;
      const isOpen = ref(false);
      const popper2 = ref(null);
      const forcedPlacement = ref(null);
      const appended = toRef(() => {
        return appendTo.value || appendToBody.value;
      });
      const placement = toRef(() => {
        return openDirection.value === "top" && forcedPlacement.value === "bottom" || openDirection.value === "bottom" && forcedPlacement.value !== "top" ? "bottom" : "top";
      });
      const open = () => {
        if (isOpen.value || disabled.value) {
          return;
        }
        isOpen.value = true;
        context.emit("open", $this);
        if (appended.value) {
          nextTick(() => {
            updatePopper();
          });
        }
      };
      const close = () => {
        if (!isOpen.value) {
          return;
        }
        isOpen.value = false;
        context.emit("close", $this);
      };
      const updatePopper = () => {
        if (!popper2.value) {
          return;
        }
        let borderTopWidth = parseInt(window.getComputedStyle(dropdown.value).borderTopWidth.replace("px", ""));
        let borderBottomWidth = parseInt(window.getComputedStyle(dropdown.value).borderBottomWidth.replace("px", ""));
        popper2.value.setOptions((options) => ({
          ...options,
          modifiers: [
            ...options.modifiers,
            {
              name: "offset",
              options: {
                offset: [0, (placement.value === "top" ? borderTopWidth : borderBottomWidth) * -1]
              }
            }
          ]
        }));
        popper2.value.update();
      };
      const hasFixedParent = (element) => {
        while (element && element !== document.body) {
          const style = getComputedStyle(element);
          if (style.position === "fixed") {
            return true;
          }
          element = element.parentElement;
        }
        return false;
      };
      onMounted(() => {
        if (!appended.value) {
          return;
        }
        popper2.value = createPopper(multiselect2.value, dropdown.value, {
          strategy: hasFixedParent(multiselect2.value) ? (
            /* istanbul ignore next: UI feature */
            "fixed"
          ) : void 0,
          placement: openDirection.value,
          modifiers: [
            preventOverflow$1,
            flip$1,
            {
              name: "sameWidth",
              enabled: true,
              phase: "beforeWrite",
              requires: ["computeStyles"],
              fn: ({ state }) => {
                state.styles.popper.width = `${state.rects.reference.width}px`;
              },
              effect: ({ state }) => {
                state.elements.popper.style.width = `${state.elements.reference.offsetWidth}px`;
              }
            },
            {
              name: "toggleClass",
              enabled: true,
              phase: "write",
              fn({ state }) {
                forcedPlacement.value = state.placement;
              }
            }
          ]
        });
      });
      onBeforeUnmount(() => {
        if (!appended.value || !popper2.value) {
          return;
        }
        popper2.value.destroy();
        popper2.value = null;
      });
      return {
        popper: popper2,
        isOpen,
        open,
        close,
        placement,
        updatePopper
      };
    }
    function useMultiselect(props, context, dep) {
      const { searchable, disabled, clearOnBlur } = toRefs(props);
      const input = dep.input;
      const open = dep.open;
      const close = dep.close;
      const clearSearch = dep.clearSearch;
      const isOpen = dep.isOpen;
      const wrapper = dep.wrapper;
      const tags2 = dep.tags;
      const isActive = ref(false);
      const mouseClicked = ref(false);
      const tabindex = toRef(() => {
        return searchable.value || disabled.value ? -1 : 0;
      });
      const blur = () => {
        if (searchable.value) {
          input.value.blur();
        }
        wrapper.value.blur();
      };
      const focus = () => {
        if (searchable.value && !disabled.value) {
          input.value.focus();
        }
      };
      const activate = (shouldOpen = true) => {
        if (disabled.value) {
          return;
        }
        isActive.value = true;
        if (shouldOpen) {
          open();
        }
      };
      const deactivate = () => {
        isActive.value = false;
        setTimeout(() => {
          if (!isActive.value) {
            close();
            if (clearOnBlur.value) {
              clearSearch();
            }
          }
        }, 1);
      };
      const handleFocusIn = (e2) => {
        if (e2.target.closest("[data-tags]") && e2.target.nodeName !== "INPUT" || e2.target.closest("[data-clear]")) {
          return;
        }
        activate(mouseClicked.value);
      };
      const handleFocusOut = () => {
        deactivate();
      };
      const handleCaretClick = () => {
        deactivate();
        blur();
      };
      const handleMousedown = (e2) => {
        mouseClicked.value = true;
        if (isOpen.value && (e2.target.isEqualNode(wrapper.value) || e2.target.isEqualNode(tags2.value))) {
          setTimeout(() => {
            deactivate();
          }, 0);
        } else if (!isOpen.value && (document.activeElement.isEqualNode(wrapper.value) || document.activeElement.isEqualNode(input.value))) {
          activate();
        }
        setTimeout(() => {
          mouseClicked.value = false;
        }, 0);
      };
      return {
        tabindex,
        isActive,
        mouseClicked,
        blur,
        focus,
        activate,
        deactivate,
        handleFocusIn,
        handleFocusOut,
        handleCaretClick,
        handleMousedown
      };
    }
    function useKeyboard(props, context, dep) {
      const {
        mode,
        addTagOn,
        openDirection,
        searchable,
        showOptions,
        valueProp,
        groups: groupped,
        addOptionOn: addOptionOn_,
        createTag,
        createOption: createOption_,
        reverse
      } = toRefs(props);
      const $this = getCurrentInstance().proxy;
      const iv = dep.iv;
      const update = dep.update;
      const deselect = dep.deselect;
      const search = dep.search;
      const setPointer = dep.setPointer;
      const selectPointer = dep.selectPointer;
      const backwardPointer = dep.backwardPointer;
      const forwardPointer = dep.forwardPointer;
      const multiselect2 = dep.multiselect;
      const wrapper = dep.wrapper;
      const tags2 = dep.tags;
      const isOpen = dep.isOpen;
      const open = dep.open;
      const blur = dep.blur;
      const fo = dep.fo;
      const createOption = toRef(() => {
        return createTag.value || createOption_.value || false;
      });
      const addOptionOn = toRef(() => {
        if (addTagOn.value !== void 0) {
          return addTagOn.value;
        } else if (addOptionOn_.value !== void 0) {
          return addOptionOn_.value;
        }
        return ["enter"];
      });
      const preparePointer = () => {
        if (mode.value === "tags" && !showOptions.value && createOption.value && searchable.value && !groupped.value) {
          setPointer(fo.value[fo.value.map((o2) => o2[valueProp.value]).indexOf(search.value)]);
        }
      };
      const handleKeydown = (e2) => {
        context.emit("keydown", e2, $this);
        let tagList;
        let activeIndex;
        if (["ArrowLeft", "ArrowRight", "Enter"].indexOf(e2.key) !== -1 && mode.value === "tags") {
          tagList = [...multiselect2.value.querySelectorAll(`[data-tags] > *`)].filter((e3) => e3 !== tags2.value);
          activeIndex = tagList.findIndex((e3) => e3 === document.activeElement);
        }
        switch (e2.key) {
          case "Backspace":
            if (mode.value === "single") {
              return;
            }
            if (searchable.value && [null, ""].indexOf(search.value) === -1) {
              return;
            }
            if (iv.value.length === 0) {
              return;
            }
            let deselectables = iv.value.filter((v2) => !v2.disabled && v2.remove !== false);
            if (deselectables.length) {
              deselect(deselectables[deselectables.length - 1]);
            }
            break;
          case "Enter":
            e2.preventDefault();
            if (e2.keyCode === 229) {
              return;
            }
            if (activeIndex !== -1 && activeIndex !== void 0) {
              update([...iv.value].filter((v2, k2) => k2 !== activeIndex));
              if (activeIndex === tagList.length - 1) {
                if (tagList.length - 1) {
                  tagList[tagList.length - 2].focus();
                } else if (searchable.value) {
                  tags2.value.querySelector("input").focus();
                } else {
                  wrapper.value.focus();
                }
              }
              return;
            }
            if (addOptionOn.value.indexOf("enter") === -1 && createOption.value) {
              return;
            }
            preparePointer();
            selectPointer();
            break;
          case " ":
            if (!createOption.value && !searchable.value) {
              e2.preventDefault();
              preparePointer();
              selectPointer();
              return;
            }
            if (!createOption.value) {
              return false;
            }
            if (addOptionOn.value.indexOf("space") === -1 && createOption.value) {
              return;
            }
            e2.preventDefault();
            preparePointer();
            selectPointer();
            break;
          case "Tab":
          case ";":
          case ",":
            if (addOptionOn.value.indexOf(e2.key.toLowerCase()) === -1 || !createOption.value) {
              return;
            }
            preparePointer();
            selectPointer();
            e2.preventDefault();
            break;
          case "Escape":
            blur();
            break;
          case "ArrowUp":
            e2.preventDefault();
            if (!showOptions.value) {
              return;
            }
            if (!isOpen.value) {
              open();
            }
            backwardPointer();
            break;
          case "ArrowDown":
            e2.preventDefault();
            if (!showOptions.value) {
              return;
            }
            if (!isOpen.value) {
              open();
            }
            forwardPointer();
            break;
          case "ArrowLeft":
            if (searchable.value && tags2.value && tags2.value.querySelector("input").selectionStart || e2.shiftKey || mode.value !== "tags" || !iv.value || !iv.value.length) {
              return;
            }
            e2.preventDefault();
            if (activeIndex === -1) {
              tagList[tagList.length - 1].focus();
            } else if (activeIndex > 0) {
              tagList[activeIndex - 1].focus();
            }
            break;
          case "ArrowRight":
            if (activeIndex === -1 || e2.shiftKey || mode.value !== "tags" || !iv.value || !iv.value.length) {
              return;
            }
            e2.preventDefault();
            if (tagList.length > activeIndex + 1) {
              tagList[activeIndex + 1].focus();
            } else if (searchable.value) {
              tags2.value.querySelector("input").focus();
            } else if (!searchable.value) {
              wrapper.value.focus();
            }
            break;
        }
      };
      const handleKeyup = (e2) => {
        context.emit("keyup", e2, $this);
      };
      return {
        handleKeydown,
        handleKeyup,
        preparePointer
      };
    }
    function useClasses$2(props, context, dependencies2) {
      const {
        classes: classes_,
        disabled,
        showOptions,
        breakTags
      } = toRefs(props);
      const isOpen = dependencies2.isOpen;
      const isPointed = dependencies2.isPointed;
      const isSelected = dependencies2.isSelected;
      const isDisabled = dependencies2.isDisabled;
      const isActive = dependencies2.isActive;
      const canPointGroups = dependencies2.canPointGroups;
      const resolving = dependencies2.resolving;
      const fo = dependencies2.fo;
      const placement = dependencies2.placement;
      const classes2 = toRef(() => ({
        container: "multiselect",
        containerDisabled: "is-disabled",
        containerOpen: "is-open",
        containerOpenTop: "is-open-top",
        containerActive: "is-active",
        wrapper: "multiselect-wrapper",
        singleLabel: "multiselect-single-label",
        singleLabelText: "multiselect-single-label-text",
        multipleLabel: "multiselect-multiple-label",
        search: "multiselect-search",
        tags: "multiselect-tags",
        tag: "multiselect-tag",
        tagWrapper: "multiselect-tag-wrapper",
        tagWrapperBreak: "multiselect-tag-wrapper-break",
        tagDisabled: "is-disabled",
        tagRemove: "multiselect-tag-remove",
        tagRemoveIcon: "multiselect-tag-remove-icon",
        tagsSearchWrapper: "multiselect-tags-search-wrapper",
        tagsSearch: "multiselect-tags-search",
        tagsSearchCopy: "multiselect-tags-search-copy",
        placeholder: "multiselect-placeholder",
        caret: "multiselect-caret",
        caretOpen: "is-open",
        clear: "multiselect-clear",
        clearIcon: "multiselect-clear-icon",
        spinner: "multiselect-spinner",
        inifinite: "multiselect-inifite",
        inifiniteSpinner: "multiselect-inifite-spinner",
        dropdown: "multiselect-dropdown",
        dropdownTop: "is-top",
        dropdownHidden: "is-hidden",
        options: "multiselect-options",
        optionsTop: "is-top",
        group: "multiselect-group",
        groupLabel: "multiselect-group-label",
        groupLabelPointable: "is-pointable",
        groupLabelPointed: "is-pointed",
        groupLabelSelected: "is-selected",
        groupLabelDisabled: "is-disabled",
        groupLabelSelectedPointed: "is-selected is-pointed",
        groupLabelSelectedDisabled: "is-selected is-disabled",
        groupOptions: "multiselect-group-options",
        option: "multiselect-option",
        optionPointed: "is-pointed",
        optionSelected: "is-selected",
        optionDisabled: "is-disabled",
        optionSelectedPointed: "is-selected is-pointed",
        optionSelectedDisabled: "is-selected is-disabled",
        noOptions: "multiselect-no-options",
        noResults: "multiselect-no-results",
        fakeInput: "multiselect-fake-input",
        assist: "multiselect-assistive-text",
        spacer: "multiselect-spacer",
        ...classes_.value
      }));
      const showDropdown = toRef(() => {
        return !!(isOpen.value && showOptions.value && (!resolving.value || resolving.value && fo.value.length));
      });
      const classList = computed(() => {
        const c2 = classes2.value;
        return {
          container: [c2.container].concat(disabled.value ? c2.containerDisabled : []).concat(showDropdown.value && placement.value === "top" ? c2.containerOpenTop : []).concat(showDropdown.value && placement.value !== "top" ? c2.containerOpen : []).concat(isActive.value ? c2.containerActive : []),
          wrapper: c2.wrapper,
          spacer: c2.spacer,
          singleLabel: c2.singleLabel,
          singleLabelText: c2.singleLabelText,
          multipleLabel: c2.multipleLabel,
          search: c2.search,
          tags: c2.tags,
          tag: [c2.tag].concat(disabled.value ? c2.tagDisabled : []),
          tagWrapper: [c2.tagWrapper, breakTags.value ? c2.tagWrapperBreak : null],
          tagDisabled: c2.tagDisabled,
          tagRemove: c2.tagRemove,
          tagRemoveIcon: c2.tagRemoveIcon,
          tagsSearchWrapper: c2.tagsSearchWrapper,
          tagsSearch: c2.tagsSearch,
          tagsSearchCopy: c2.tagsSearchCopy,
          placeholder: c2.placeholder,
          caret: [c2.caret].concat(isOpen.value ? c2.caretOpen : []),
          clear: c2.clear,
          clearIcon: c2.clearIcon,
          spinner: c2.spinner,
          inifinite: c2.inifinite,
          inifiniteSpinner: c2.inifiniteSpinner,
          dropdown: [c2.dropdown].concat(placement.value === "top" ? c2.dropdownTop : []).concat(!isOpen.value || !showOptions.value || !showDropdown.value ? c2.dropdownHidden : []),
          options: [c2.options].concat(placement.value === "top" ? c2.optionsTop : []),
          group: c2.group,
          groupLabel: (g2) => {
            let groupLabel = [c2.groupLabel];
            if (isPointed(g2)) {
              groupLabel.push(isSelected(g2) ? c2.groupLabelSelectedPointed : c2.groupLabelPointed);
            } else if (isSelected(g2) && canPointGroups.value) {
              groupLabel.push(isDisabled(g2) ? c2.groupLabelSelectedDisabled : c2.groupLabelSelected);
            } else if (isDisabled(g2)) {
              groupLabel.push(c2.groupLabelDisabled);
            }
            if (canPointGroups.value) {
              groupLabel.push(c2.groupLabelPointable);
            }
            return groupLabel;
          },
          groupOptions: c2.groupOptions,
          option: (o2, g2) => {
            let option = [c2.option];
            if (isPointed(o2)) {
              option.push(isSelected(o2) ? c2.optionSelectedPointed : c2.optionPointed);
            } else if (isSelected(o2)) {
              option.push(isDisabled(o2) ? c2.optionSelectedDisabled : c2.optionSelected);
            } else if (isDisabled(o2) || g2 && isDisabled(g2)) {
              option.push(c2.optionDisabled);
            }
            return option;
          },
          noOptions: c2.noOptions,
          noResults: c2.noResults,
          assist: c2.assist,
          fakeInput: c2.fakeInput
        };
      });
      return {
        classList,
        showDropdown
      };
    }
    function useScroll(props, context, dep) {
      const {
        limit: limit2,
        infinite
      } = toRefs(props);
      const isOpen = dep.isOpen;
      const offset2 = dep.offset;
      const search = dep.search;
      const pfo = dep.pfo;
      const eo = dep.eo;
      const observer = ref(null);
      const infiniteLoader = shallowRef(null);
      const hasMore = toRef(() => {
        return offset2.value < pfo.value.length;
      });
      const handleIntersectionObserver = (entries) => {
        const { isIntersecting, target } = entries[0];
        if (isIntersecting) {
          const parent2 = target.offsetParent;
          const scrollTop = parent2.scrollTop;
          offset2.value += limit2.value == -1 ? 10 : limit2.value;
          nextTick(() => {
            parent2.scrollTop = scrollTop;
          });
        }
      };
      const observe = () => {
        if (isOpen.value && offset2.value < pfo.value.length) {
          observer.value.observe(infiniteLoader.value);
        } else if (!isOpen.value && observer.value) {
          observer.value.disconnect();
        }
      };
      watch(isOpen, () => {
        if (!infinite.value) {
          return;
        }
        observe();
      });
      watch(search, () => {
        if (!infinite.value) {
          return;
        }
        offset2.value = limit2.value;
        observe();
      }, { flush: "post" });
      watch(eo, () => {
        if (!infinite.value) {
          return;
        }
        observe();
      }, { immediate: false, flush: "post" });
      onMounted(() => {
        if (window && window.IntersectionObserver) {
          observer.value = new IntersectionObserver(handleIntersectionObserver);
        }
      });
      return {
        hasMore,
        infiniteLoader
      };
    }
    function useA11y(props, context, dep) {
      const {
        placeholder,
        id,
        valueProp,
        label: labelProp,
        mode,
        groupLabel,
        aria,
        searchable
      } = toRefs(props);
      const pointer = dep.pointer;
      const iv = dep.iv;
      const hasSelected = dep.hasSelected;
      const multipleLabelText = dep.multipleLabelText;
      const label = ref(null);
      const ariaAssist = toRef(() => `${id.value ? id.value + "-" : ""}assist`);
      const ariaControls = toRef(() => `${id.value ? id.value + "-" : ""}multiselect-options`);
      const ariaActiveDescendant = toRef(() => {
        if (pointer.value) {
          let texts = id.value ? `${id.value}-` : "";
          texts += `${pointer.value.group ? "multiselect-group" : "multiselect-option"}-`;
          texts += pointer.value.group ? pointer.value.index : pointer.value[valueProp.value];
          return texts;
        }
      });
      const ariaPlaceholder = toRef(() => {
        return placeholder.value;
      });
      const ariaMultiselectable = toRef(() => {
        return mode.value !== "single";
      });
      const ariaLabel = computed(() => {
        if (mode.value === "single" && hasSelected.value) {
          return iv.value[labelProp.value];
        }
        if (mode.value === "multiple" && hasSelected.value) {
          return multipleLabelText.value;
        }
        if (mode.value === "tags" && hasSelected.value) {
          return iv.value.map((v2) => v2[labelProp.value]).join(", ");
        }
        return "";
      });
      const arias = computed(() => {
        let arias2 = { ...aria.value };
        if (searchable.value) {
          arias2["aria-labelledby"] = arias2["aria-labelledby"] ? `${ariaAssist.value} ${arias2["aria-labelledby"]}` : ariaAssist.value;
          if (ariaLabel.value && arias2["aria-label"]) {
            arias2["aria-label"] = `${ariaLabel.value}, ${arias2["aria-label"]}`;
          }
        }
        return arias2;
      });
      const ariaOptionId = (option) => `${id.value ? id.value + "-" : ""}multiselect-option-${option[valueProp.value]}`;
      const ariaGroupId = (option) => `${id.value ? id.value + "-" : ""}multiselect-group-${option.index}`;
      const ariaOptionLabel = (label2) => `${label2}`;
      const ariaGroupLabel = (label2) => `${label2}`;
      const ariaTagLabel = (label2) => `${label2} ❎`;
      onMounted(() => {
        if (id.value && document && document.querySelector) {
          let forTag = document.querySelector(`[for="${id.value}"]`);
          label.value = forTag ? forTag.innerText : null;
        }
      });
      return {
        arias,
        ariaLabel,
        ariaAssist,
        ariaControls,
        ariaPlaceholder,
        ariaMultiselectable,
        ariaActiveDescendant,
        ariaOptionId,
        ariaOptionLabel,
        ariaGroupId,
        ariaGroupLabel,
        ariaTagLabel
      };
    }
    function useI18n(props, context, dep) {
      const {
        locale: locale2,
        fallbackLocale
      } = toRefs(props);
      const localize2 = (target) => {
        if (!target || typeof target !== "object") {
          return target;
        }
        if (target && target[locale2.value]) {
          return target[locale2.value];
        } else if (target && locale2.value && target[locale2.value.toUpperCase()]) {
          return target[locale2.value.toUpperCase()];
        } else if (target && target[fallbackLocale.value]) {
          return target[fallbackLocale.value];
        } else if (target && fallbackLocale.value && target[fallbackLocale.value.toUpperCase()]) {
          return target[fallbackLocale.value.toUpperCase()];
        } else if (target && Object.keys(target)[0]) {
          return target[Object.keys(target)[0]];
        } else {
          return "";
        }
      };
      return {
        localize: localize2
      };
    }
    function useRefs(props, context, dep) {
      const multiselect2 = shallowRef(null);
      const wrapper = shallowRef(null);
      const tags2 = shallowRef(null);
      const input = shallowRef(null);
      const dropdown = shallowRef(null);
      return {
        multiselect: multiselect2,
        wrapper,
        tags: tags2,
        input,
        dropdown
      };
    }
    function resolveDeps(props, context, features, deps = {}) {
      features.forEach((composable) => {
        deps = {
          ...deps,
          ...composable(props, context, deps)
        };
      });
      return deps;
    }
    var script$_ = {
      name: "Multiselect",
      emits: [
        "paste",
        "open",
        "close",
        "select",
        "deselect",
        "input",
        "search-change",
        "tag",
        "option",
        "update:modelValue",
        "change",
        "clear",
        "keydown",
        "keyup",
        "max",
        "create"
      ],
      props: {
        value: {
          required: false
        },
        modelValue: {
          required: false
        },
        options: {
          type: [Array, Object, Function],
          required: false,
          default: () => []
        },
        id: {
          type: [String, Number],
          required: false,
          default: void 0
        },
        name: {
          type: [String, Number],
          required: false,
          default: "multiselect"
        },
        disabled: {
          type: Boolean,
          required: false,
          default: false
        },
        label: {
          type: String,
          required: false,
          default: "label"
        },
        trackBy: {
          type: [String, Array],
          required: false,
          default: void 0
        },
        valueProp: {
          type: String,
          required: false,
          default: "value"
        },
        placeholder: {
          type: String,
          required: false,
          default: null
        },
        mode: {
          type: String,
          required: false,
          default: "single"
          // single|multiple|tags
        },
        searchable: {
          type: Boolean,
          required: false,
          default: false
        },
        limit: {
          type: Number,
          required: false,
          default: -1
        },
        hideSelected: {
          type: Boolean,
          required: false,
          default: true
        },
        createTag: {
          type: Boolean,
          required: false,
          default: void 0
        },
        createOption: {
          type: Boolean,
          required: false,
          default: void 0
        },
        appendNewTag: {
          type: Boolean,
          required: false,
          default: void 0
        },
        appendNewOption: {
          type: Boolean,
          required: false,
          default: void 0
        },
        addTagOn: {
          type: Array,
          required: false,
          default: void 0
        },
        addOptionOn: {
          type: Array,
          required: false,
          default: void 0
        },
        caret: {
          type: Boolean,
          required: false,
          default: true
        },
        loading: {
          type: Boolean,
          required: false,
          default: false
        },
        noOptionsText: {
          type: [String, Object],
          required: false,
          default: "The list is empty"
        },
        noResultsText: {
          type: [String, Object],
          required: false,
          default: "No results found"
        },
        multipleLabel: {
          type: Function,
          required: false,
          default: void 0
        },
        object: {
          type: Boolean,
          required: false,
          default: false
        },
        delay: {
          type: Number,
          required: false,
          default: -1
        },
        minChars: {
          type: Number,
          required: false,
          default: 0
        },
        resolveOnLoad: {
          type: Boolean,
          required: false,
          default: true
        },
        filterResults: {
          type: Boolean,
          required: false,
          default: true
        },
        clearOnSearch: {
          type: Boolean,
          required: false,
          default: false
        },
        clearOnSelect: {
          type: Boolean,
          required: false,
          default: true
        },
        canDeselect: {
          type: Boolean,
          required: false,
          default: true
        },
        canClear: {
          type: Boolean,
          required: false,
          default: true
        },
        max: {
          type: Number,
          required: false,
          default: -1
        },
        showOptions: {
          type: Boolean,
          required: false,
          default: true
        },
        required: {
          type: Boolean,
          required: false,
          default: false
        },
        openDirection: {
          type: String,
          required: false,
          default: "bottom"
        },
        nativeSupport: {
          type: Boolean,
          required: false,
          default: false
        },
        classes: {
          type: Object,
          required: false,
          default: () => ({})
        },
        strict: {
          type: Boolean,
          required: false,
          default: true
        },
        closeOnSelect: {
          type: Boolean,
          required: false,
          default: true
        },
        closeOnDeselect: {
          type: Boolean,
          required: false,
          default: false
        },
        autocomplete: {
          type: String,
          required: false,
          default: void 0
        },
        groups: {
          type: Boolean,
          required: false,
          default: false
        },
        groupLabel: {
          type: String,
          required: false,
          default: "label"
        },
        groupOptions: {
          type: String,
          required: false,
          default: "options"
        },
        groupHideEmpty: {
          type: Boolean,
          required: false,
          default: false
        },
        groupSelect: {
          type: Boolean,
          required: false,
          default: true
        },
        inputType: {
          type: String,
          required: false,
          default: "text"
        },
        attrs: {
          required: false,
          type: Object,
          default: () => ({})
        },
        onCreate: {
          required: false,
          type: Function,
          default: void 0
        },
        disabledProp: {
          type: String,
          required: false,
          default: "disabled"
        },
        searchStart: {
          type: Boolean,
          required: false,
          default: false
        },
        reverse: {
          type: Boolean,
          required: false,
          default: false
        },
        regex: {
          type: [Object, String, RegExp],
          required: false,
          default: void 0
        },
        rtl: {
          type: Boolean,
          required: false,
          default: false
        },
        infinite: {
          type: Boolean,
          required: false,
          default: false
        },
        aria: {
          required: false,
          type: Object,
          default: () => ({})
        },
        clearOnBlur: {
          required: false,
          type: Boolean,
          default: true
        },
        locale: {
          required: false,
          type: String,
          default: null
        },
        fallbackLocale: {
          required: false,
          type: String,
          default: "en"
        },
        searchFilter: {
          required: false,
          type: Function,
          default: null
        },
        allowAbsent: {
          required: false,
          type: Boolean,
          default: false
        },
        appendToBody: {
          required: false,
          type: Boolean,
          default: false
        },
        closeOnScroll: {
          required: false,
          type: Boolean,
          default: false
        },
        breakTags: {
          required: false,
          type: Boolean,
          default: false
        },
        appendTo: {
          required: false,
          type: String,
          default: void 0
        }
      },
      setup(props, context) {
        return resolveDeps(props, context, [
          useRefs,
          useI18n,
          useValue$3,
          usePointer$1,
          useDropdown,
          useSearch,
          useData,
          useMultiselect,
          useOptions,
          useScroll,
          usePointer,
          useKeyboard,
          useClasses$2,
          useA11y
        ]);
      },
      beforeMount() {
        if (this.$root.constructor && this.$root.constructor.version && this.$root.constructor.version.match(/^2\./) || this.vueVersionMs === 2) {
          if (!this.$options.components.Teleport) {
            this.$options.components.Teleport = {
              render() {
                return this.$slots.default ? this.$slots.default[0] : null;
              }
            };
          }
        }
      }
    };
    const _hoisted_1$n = ["id", "dir"];
    const _hoisted_2$f = ["tabindex", "aria-controls", "aria-placeholder", "aria-expanded", "aria-activedescendant", "aria-multiselectable", "role"];
    const _hoisted_3$a = ["type", "modelValue", "value", "autocomplete", "id", "aria-controls", "aria-placeholder", "aria-expanded", "aria-activedescendant", "aria-multiselectable"];
    const _hoisted_4$7 = ["onKeyup", "aria-label"];
    const _hoisted_5$4 = ["onClick"];
    const _hoisted_6$3 = ["type", "modelValue", "value", "id", "autocomplete", "aria-controls", "aria-placeholder", "aria-expanded", "aria-activedescendant", "aria-multiselectable"];
    const _hoisted_7$2 = ["innerHTML"];
    const _hoisted_8$1 = ["id"];
    const _hoisted_9$1 = ["id"];
    const _hoisted_10$1 = ["id", "aria-label", "aria-selected"];
    const _hoisted_11$1 = ["data-pointed", "onMouseenter", "onClick"];
    const _hoisted_12$1 = ["innerHTML"];
    const _hoisted_13$1 = ["aria-label"];
    const _hoisted_14 = ["data-pointed", "data-selected", "onMouseenter", "onClick", "id", "aria-selected", "aria-label"];
    const _hoisted_15 = ["data-pointed", "data-selected", "onMouseenter", "onClick", "id", "aria-selected", "aria-label"];
    const _hoisted_16 = ["innerHTML"];
    const _hoisted_17 = ["innerHTML"];
    const _hoisted_18 = ["value"];
    const _hoisted_19 = ["name", "value"];
    const _hoisted_20 = ["name", "value"];
    const _hoisted_21 = ["id"];
    function render$s(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        ref: "multiselect",
        class: normalizeClass(_ctx.classList.container),
        id: $props.searchable ? void 0 : $props.id,
        dir: $props.rtl ? "rtl" : void 0,
        onFocusin: _cache[12] || (_cache[12] = (...args) => _ctx.handleFocusIn && _ctx.handleFocusIn(...args)),
        onFocusout: _cache[13] || (_cache[13] = (...args) => _ctx.handleFocusOut && _ctx.handleFocusOut(...args)),
        onKeyup: _cache[14] || (_cache[14] = (...args) => _ctx.handleKeyup && _ctx.handleKeyup(...args)),
        onKeydown: _cache[15] || (_cache[15] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
      }, [
        createBaseVNode("div", mergeProps({
          class: _ctx.classList.wrapper,
          onMousedown: _cache[9] || (_cache[9] = (...args) => _ctx.handleMousedown && _ctx.handleMousedown(...args)),
          ref: "wrapper",
          tabindex: _ctx.tabindex,
          "aria-controls": !$props.searchable ? _ctx.ariaControls : void 0,
          "aria-placeholder": !$props.searchable ? _ctx.ariaPlaceholder : void 0,
          "aria-expanded": !$props.searchable ? _ctx.isOpen : void 0,
          "aria-activedescendant": !$props.searchable ? _ctx.ariaActiveDescendant : void 0,
          "aria-multiselectable": !$props.searchable ? _ctx.ariaMultiselectable : void 0,
          role: !$props.searchable ? "combobox" : void 0
        }, !$props.searchable ? _ctx.arias : {}), [
          createCommentVNode(" Search "),
          $props.mode !== "tags" && $props.searchable && !$props.disabled ? (openBlock(), createElementBlock("input", mergeProps({
            key: 0,
            type: $props.inputType,
            modelValue: _ctx.search,
            value: _ctx.search,
            class: _ctx.classList.search,
            autocomplete: $props.autocomplete,
            id: $props.searchable ? $props.id : void 0,
            onInput: _cache[0] || (_cache[0] = (...args) => _ctx.handleSearchInput && _ctx.handleSearchInput(...args)),
            onKeypress: _cache[1] || (_cache[1] = (...args) => _ctx.handleKeypress && _ctx.handleKeypress(...args)),
            onPaste: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handlePaste && _ctx.handlePaste(...args), ["stop"])),
            ref: "input",
            "aria-controls": _ctx.ariaControls,
            "aria-placeholder": _ctx.ariaPlaceholder,
            "aria-expanded": _ctx.isOpen,
            "aria-activedescendant": _ctx.ariaActiveDescendant,
            "aria-multiselectable": _ctx.ariaMultiselectable,
            role: "combobox"
          }, {
            ...$props.attrs,
            ..._ctx.arias
          }), null, 16, _hoisted_3$a)) : createCommentVNode("v-if", true),
          createCommentVNode(" Tags (with search) "),
          $props.mode == "tags" ? (openBlock(), createElementBlock(
            "div",
            {
              key: 1,
              class: normalizeClass(_ctx.classList.tags),
              "data-tags": ""
            },
            [
              (openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(_ctx.iv, (option, i2, key) => {
                  return renderSlot(_ctx.$slots, "tag", {
                    option,
                    handleTagRemove: _ctx.handleTagRemove,
                    disabled: $props.disabled
                  }, () => [
                    (openBlock(), createElementBlock("span", {
                      class: normalizeClass([
                        _ctx.classList.tag,
                        option.disabled ? _ctx.classList.tagDisabled : null
                      ]),
                      tabindex: "-1",
                      onKeyup: withKeys(($event) => _ctx.handleTagRemove(option, $event), ["enter"]),
                      key,
                      "aria-label": _ctx.ariaTagLabel(_ctx.localize(option[$props.label]))
                    }, [
                      createBaseVNode(
                        "span",
                        {
                          class: normalizeClass(_ctx.classList.tagWrapper)
                        },
                        toDisplayString(_ctx.localize(option[$props.label])),
                        3
                        /* TEXT, CLASS */
                      ),
                      !$props.disabled && !option.disabled ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        class: normalizeClass(_ctx.classList.tagRemove),
                        onClick: withModifiers(($event) => _ctx.handleTagRemove(option, $event), ["stop"])
                      }, [
                        createBaseVNode(
                          "span",
                          {
                            class: normalizeClass(_ctx.classList.tagRemoveIcon)
                          },
                          null,
                          2
                          /* CLASS */
                        )
                      ], 10, _hoisted_5$4)) : createCommentVNode("v-if", true)
                    ], 42, _hoisted_4$7))
                  ]);
                }),
                256
                /* UNKEYED_FRAGMENT */
              )),
              createBaseVNode(
                "div",
                {
                  class: normalizeClass(_ctx.classList.tagsSearchWrapper),
                  ref: "tags"
                },
                [
                  createCommentVNode(" Used for measuring search width "),
                  createBaseVNode(
                    "span",
                    {
                      class: normalizeClass(_ctx.classList.tagsSearchCopy)
                    },
                    toDisplayString(_ctx.search),
                    3
                    /* TEXT, CLASS */
                  ),
                  createCommentVNode(" Actual search input "),
                  $props.searchable && !$props.disabled ? (openBlock(), createElementBlock("input", mergeProps({
                    key: 0,
                    type: $props.inputType,
                    modelValue: _ctx.search,
                    value: _ctx.search,
                    class: _ctx.classList.tagsSearch,
                    id: $props.searchable ? $props.id : void 0,
                    autocomplete: $props.autocomplete,
                    onInput: _cache[3] || (_cache[3] = (...args) => _ctx.handleSearchInput && _ctx.handleSearchInput(...args)),
                    onKeypress: _cache[4] || (_cache[4] = (...args) => _ctx.handleKeypress && _ctx.handleKeypress(...args)),
                    onPaste: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.handlePaste && _ctx.handlePaste(...args), ["stop"])),
                    ref: "input",
                    "aria-controls": _ctx.ariaControls,
                    "aria-placeholder": _ctx.ariaPlaceholder,
                    "aria-expanded": _ctx.isOpen,
                    "aria-activedescendant": _ctx.ariaActiveDescendant,
                    "aria-multiselectable": _ctx.ariaMultiselectable,
                    role: "combobox"
                  }, {
                    ...$props.attrs,
                    ..._ctx.arias
                  }), null, 16, _hoisted_6$3)) : createCommentVNode("v-if", true)
                ],
                2
                /* CLASS */
              )
            ],
            2
            /* CLASS */
          )) : createCommentVNode("v-if", true),
          createCommentVNode(" Single label "),
          $props.mode == "single" && _ctx.hasSelected && !_ctx.search && _ctx.iv ? renderSlot(_ctx.$slots, "singlelabel", {
            key: 2,
            value: _ctx.iv
          }, () => [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classList.singleLabel)
              },
              [
                createBaseVNode(
                  "span",
                  {
                    class: normalizeClass(_ctx.classList.singleLabelText)
                  },
                  toDisplayString(_ctx.localize(_ctx.iv[$props.label])),
                  3
                  /* TEXT, CLASS */
                )
              ],
              2
              /* CLASS */
            )
          ]) : createCommentVNode("v-if", true),
          createCommentVNode(" Multiple label "),
          $props.mode == "multiple" && _ctx.hasSelected && !_ctx.search ? renderSlot(_ctx.$slots, "multiplelabel", {
            key: 3,
            values: _ctx.iv
          }, () => [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.classList.multipleLabel),
              innerHTML: _ctx.multipleLabelText
            }, null, 10, _hoisted_7$2)
          ]) : createCommentVNode("v-if", true),
          createCommentVNode(" Placeholder "),
          $props.placeholder && !_ctx.hasSelected && !_ctx.search ? renderSlot(_ctx.$slots, "placeholder", { key: 4 }, () => [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classList.placeholder),
                "aria-hidden": "true"
              },
              toDisplayString($props.placeholder),
              3
              /* TEXT, CLASS */
            )
          ]) : createCommentVNode("v-if", true),
          createCommentVNode(" Spinner "),
          $props.loading || _ctx.resolving ? renderSlot(_ctx.$slots, "spinner", { key: 5 }, () => [
            createBaseVNode(
              "span",
              {
                class: normalizeClass(_ctx.classList.spinner),
                "aria-hidden": "true"
              },
              null,
              2
              /* CLASS */
            )
          ]) : createCommentVNode("v-if", true),
          createCommentVNode(" Clear "),
          _ctx.hasSelected && !$props.disabled && $props.canClear && !_ctx.busy ? renderSlot(_ctx.$slots, "clear", {
            key: 6,
            clear: _ctx.clear
          }, () => [
            createBaseVNode(
              "span",
              {
                "aria-hidden": "true",
                tabindex: "0",
                role: "button",
                "data-clear": "",
                "aria-roledescription": "❎",
                class: normalizeClass(_ctx.classList.clear),
                onClick: _cache[6] || (_cache[6] = (...args) => _ctx.clear && _ctx.clear(...args)),
                onKeyup: _cache[7] || (_cache[7] = withKeys((...args) => _ctx.clear && _ctx.clear(...args), ["enter"]))
              },
              [
                createBaseVNode(
                  "span",
                  {
                    class: normalizeClass(_ctx.classList.clearIcon)
                  },
                  null,
                  2
                  /* CLASS */
                )
              ],
              34
              /* CLASS, NEED_HYDRATION */
            )
          ]) : createCommentVNode("v-if", true),
          createCommentVNode(" Caret "),
          $props.caret && $props.showOptions ? renderSlot(_ctx.$slots, "caret", {
            key: 7,
            handleCaretClick: _ctx.handleCaretClick,
            isOpen: _ctx.isOpen
          }, () => [
            createBaseVNode(
              "span",
              {
                class: normalizeClass(_ctx.classList.caret),
                onClick: _cache[8] || (_cache[8] = (...args) => _ctx.handleCaretClick && _ctx.handleCaretClick(...args)),
                "aria-hidden": "true"
              },
              null,
              2
              /* CLASS */
            )
          ]) : createCommentVNode("v-if", true)
        ], 16, _hoisted_2$f),
        createCommentVNode(" Options "),
        (openBlock(), createBlock(Teleport, {
          to: $props.appendTo || "body",
          disabled: !$props.appendToBody && !$props.appendTo
        }, [
          createBaseVNode("div", {
            id: $props.id ? `${$props.id}-dropdown` : void 0,
            class: normalizeClass(_ctx.classList.dropdown),
            tabindex: "-1",
            ref: "dropdown",
            onFocusin: _cache[10] || (_cache[10] = (...args) => _ctx.handleFocusIn && _ctx.handleFocusIn(...args)),
            onFocusout: _cache[11] || (_cache[11] = (...args) => _ctx.handleFocusOut && _ctx.handleFocusOut(...args))
          }, [
            renderSlot(_ctx.$slots, "beforelist", { options: _ctx.fo }),
            createBaseVNode("ul", {
              class: normalizeClass(_ctx.classList.options),
              id: _ctx.ariaControls,
              role: "listbox"
            }, [
              $props.groups ? (openBlock(true), createElementBlock(
                Fragment,
                { key: 0 },
                renderList(_ctx.fg, (group2, i2, key) => {
                  return openBlock(), createElementBlock("li", {
                    class: normalizeClass(_ctx.classList.group),
                    key,
                    id: _ctx.ariaGroupId(group2),
                    "aria-label": _ctx.ariaGroupLabel(_ctx.localize(group2[$props.groupLabel])),
                    "aria-selected": _ctx.isSelected(group2),
                    role: "option"
                  }, [
                    !group2.__CREATE__ ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass(_ctx.classList.groupLabel(group2)),
                      "data-pointed": _ctx.isPointed(group2),
                      onMouseenter: ($event) => _ctx.setPointer(group2, i2),
                      onClick: ($event) => _ctx.handleGroupClick(group2)
                    }, [
                      renderSlot(_ctx.$slots, "grouplabel", {
                        group: group2,
                        isSelected: _ctx.isSelected,
                        isPointed: _ctx.isPointed
                      }, () => [
                        createBaseVNode("span", {
                          innerHTML: _ctx.localize(group2[$props.groupLabel])
                        }, null, 8, _hoisted_12$1)
                      ])
                    ], 42, _hoisted_11$1)) : createCommentVNode("v-if", true),
                    createBaseVNode("ul", {
                      class: normalizeClass(_ctx.classList.groupOptions),
                      "aria-label": _ctx.ariaGroupLabel(_ctx.localize(group2[$props.groupLabel])),
                      role: "group"
                    }, [
                      (openBlock(true), createElementBlock(
                        Fragment,
                        null,
                        renderList(group2.__VISIBLE__, (option, i3, key2) => {
                          return openBlock(), createElementBlock("li", {
                            class: normalizeClass(_ctx.classList.option(option, group2)),
                            "data-pointed": _ctx.isPointed(option),
                            "data-selected": _ctx.isSelected(option) || void 0,
                            key: key2,
                            onMouseenter: ($event) => _ctx.setPointer(option),
                            onClick: ($event) => _ctx.handleOptionClick(option),
                            id: _ctx.ariaOptionId(option),
                            "aria-selected": _ctx.isSelected(option),
                            "aria-label": _ctx.ariaOptionLabel(_ctx.localize(option[$props.label])),
                            role: "option"
                          }, [
                            renderSlot(_ctx.$slots, "option", {
                              option,
                              isSelected: _ctx.isSelected,
                              isPointed: _ctx.isPointed,
                              search: _ctx.search
                            }, () => [
                              createBaseVNode(
                                "span",
                                null,
                                toDisplayString(_ctx.localize(option[$props.label])),
                                1
                                /* TEXT */
                              )
                            ])
                          ], 42, _hoisted_14);
                        }),
                        128
                        /* KEYED_FRAGMENT */
                      ))
                    ], 10, _hoisted_13$1)
                  ], 10, _hoisted_10$1);
                }),
                128
                /* KEYED_FRAGMENT */
              )) : (openBlock(true), createElementBlock(
                Fragment,
                { key: 1 },
                renderList(_ctx.fo, (option, i2, key) => {
                  return openBlock(), createElementBlock("li", {
                    class: normalizeClass(_ctx.classList.option(option)),
                    "data-pointed": _ctx.isPointed(option),
                    "data-selected": _ctx.isSelected(option) || void 0,
                    key,
                    onMouseenter: ($event) => _ctx.setPointer(option),
                    onClick: ($event) => _ctx.handleOptionClick(option),
                    id: _ctx.ariaOptionId(option),
                    "aria-selected": _ctx.isSelected(option),
                    "aria-label": _ctx.ariaOptionLabel(_ctx.localize(option[$props.label])),
                    role: "option"
                  }, [
                    renderSlot(_ctx.$slots, "option", {
                      option,
                      isSelected: _ctx.isSelected,
                      isPointed: _ctx.isPointed,
                      search: _ctx.search
                    }, () => [
                      createBaseVNode(
                        "span",
                        null,
                        toDisplayString(_ctx.localize(option[$props.label])),
                        1
                        /* TEXT */
                      )
                    ])
                  ], 42, _hoisted_15);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ], 10, _hoisted_9$1),
            _ctx.noOptions ? renderSlot(_ctx.$slots, "nooptions", { key: 0 }, () => [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.classList.noOptions),
                innerHTML: _ctx.localize($props.noOptionsText)
              }, null, 10, _hoisted_16)
            ]) : createCommentVNode("v-if", true),
            _ctx.noResults ? renderSlot(_ctx.$slots, "noresults", { key: 1 }, () => [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.classList.noResults),
                innerHTML: _ctx.localize($props.noResultsText)
              }, null, 10, _hoisted_17)
            ]) : createCommentVNode("v-if", true),
            $props.infinite && _ctx.hasMore ? (openBlock(), createElementBlock(
              "div",
              {
                key: 2,
                class: normalizeClass(_ctx.classList.inifinite),
                ref: "infiniteLoader"
              },
              [
                renderSlot(_ctx.$slots, "infinite", {}, () => [
                  createBaseVNode(
                    "span",
                    {
                      class: normalizeClass(_ctx.classList.inifiniteSpinner)
                    },
                    null,
                    2
                    /* CLASS */
                  )
                ])
              ],
              2
              /* CLASS */
            )) : createCommentVNode("v-if", true),
            renderSlot(_ctx.$slots, "afterlist", { options: _ctx.fo })
          ], 42, _hoisted_8$1)
        ], 8, ["to", "disabled"])),
        createCommentVNode(" Hacky input element to show HTML5 required warning "),
        $props.required ? (openBlock(), createElementBlock("input", {
          key: 0,
          class: normalizeClass(_ctx.classList.fakeInput),
          tabindex: "-1",
          value: _ctx.textValue,
          required: ""
        }, null, 10, _hoisted_18)) : createCommentVNode("v-if", true),
        createCommentVNode(" Native input support "),
        $props.nativeSupport ? (openBlock(), createElementBlock(
          Fragment,
          { key: 1 },
          [
            $props.mode == "single" ? (openBlock(), createElementBlock("input", {
              key: 0,
              type: "hidden",
              name: $props.name,
              value: _ctx.plainValue !== void 0 ? _ctx.plainValue : ""
            }, null, 8, _hoisted_19)) : (openBlock(true), createElementBlock(
              Fragment,
              { key: 1 },
              renderList(_ctx.plainValue, (v2, i2) => {
                return openBlock(), createElementBlock("input", {
                  type: "hidden",
                  name: `${$props.name}[]`,
                  value: v2,
                  key: i2
                }, null, 8, _hoisted_20);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          64
          /* STABLE_FRAGMENT */
        )) : createCommentVNode("v-if", true),
        createCommentVNode(" Screen reader assistive text "),
        $props.searchable && _ctx.hasSelected ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass(_ctx.classList.assist),
          id: _ctx.ariaAssist,
          "aria-hidden": "true"
        }, toDisplayString(_ctx.ariaLabel), 11, _hoisted_21)) : createCommentVNode("v-if", true),
        createCommentVNode(" Create height for empty input "),
        createBaseVNode(
          "div",
          {
            class: normalizeClass(_ctx.classList.spacer)
          },
          null,
          2
          /* CLASS */
        )
      ], 42, _hoisted_1$n);
    }
    script$_.render = render$s;
    script$_.__file = "node_modules/@vueform/multiselect/src/Multiselect.vue";
    var script$Z = {
      name: "MultiselectElement",
      components: {
        Multiselect: script$_
      },
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            input: "",
            inputWrapper: "",
            select: {
              container: "",
              containerDisabled: "",
              containerOpen: "",
              containerOpenTop: "",
              containerActive: "",
              multipleLabel: "",
              search: "",
              placeholder: "",
              caret: "",
              caretOpen: "",
              clear: "",
              clearIcon: "",
              spinner: "",
              dropdown: "",
              dropdownTop: "",
              dropdownHidden: "",
              options: "",
              optionsTop: "",
              group: "",
              groupLabel: "",
              groupLabelPointable: "",
              groupLabelPointed: "",
              groupLabelSelected: "",
              groupLabelDisabled: "",
              groupLabelSelectedPointed: "",
              groupLabelSelectedDisabled: "",
              groupOptions: "",
              option: "",
              optionPointed: "",
              optionSelected: "",
              optionDisabled: "",
              optionSelectedPointed: "",
              optionSelectedDisabled: "",
              noOptions: "",
              noResults: "",
              fakeInput: "",
              spacer: ""
            }
          }
        };
      }
    };
    const _hoisted_1$m = ["name", "id", "disabled"];
    const _hoisted_2$e = ["value"];
    function render$r(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ElementLabelFloating = resolveComponent("ElementLabelFloating");
      const _component_Multiselect = resolveComponent("Multiselect");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            _ctx.hasFloating && !_ctx.empty ? (openBlock(), createBlock(_component_ElementLabelFloating, {
              key: 0,
              visible: !_ctx.empty
            }, null, 8, ["visible"])) : createCommentVNode("v-if", true),
            createCommentVNode(" Native select "),
            _ctx.isNative ? (openBlock(), createElementBlock(
              "div",
              {
                key: 1,
                class: normalizeClass(_ctx.classes.inputWrapper)
              },
              [
                withDirectives(createBaseVNode("select", mergeProps({
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value = $event),
                  class: _ctx.classes.input,
                  name: _ctx.name,
                  id: _ctx.fieldId,
                  multiple: true,
                  disabled: _ctx.isDisabled
                }, {
                  ..._ctx.attrs,
                  ..._ctx.aria
                }, { ref: "input" }), [
                  (openBlock(true), createElementBlock(
                    Fragment,
                    null,
                    renderList(_ctx.resolvedOptions, (option, index2) => {
                      return openBlock(), createElementBlock("option", {
                        value: option.value,
                        key: index2
                      }, toDisplayString(option.label), 9, _hoisted_2$e);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ], 16, _hoisted_1$m), [
                  [vModelSelect, _ctx.value]
                ]),
                _ctx.placeholder && _ctx.empty && !_ctx.isDisabled && _ctx.type == "select" ? (openBlock(), createElementBlock(
                  "span",
                  {
                    key: 0,
                    class: normalizeClass(_ctx.classes.inputPlaceholder)
                  },
                  toDisplayString(_ctx.placeholder),
                  3
                  /* TEXT, CLASS */
                )) : createCommentVNode("v-if", true)
              ],
              2
              /* CLASS */
            )) : (openBlock(), createElementBlock(
              Fragment,
              { key: 2 },
              [
                createCommentVNode(" @vueform/multiselect copmonent "),
                createVNode(_component_Multiselect, mergeProps(_ctx.fieldOptions, {
                  modelValue: _ctx.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.value = $event),
                  classes: _ctx.classes.select,
                  id: _ctx.fieldId,
                  name: _ctx.name,
                  options: _ctx.resolvedOptions,
                  disabled: _ctx.isDisabled,
                  placeholder: _ctx.Placeholder,
                  attrs: _ctx.attrs,
                  aria: _ctx.aria,
                  locale: _ctx.form$.locale$,
                  onSelect: _ctx.handleSelect,
                  onDeselect: _ctx.handleDeselect,
                  onSearchChange: _ctx.handleSearchChange,
                  onTag: _ctx.handleTag,
                  onOpen: _ctx.handleOpen,
                  onClose: _ctx.handleClose,
                  onClear: _ctx.handleClear,
                  onPaste: _ctx.handlePaste,
                  ref: "input"
                }), createSlots({
                  _: 2
                  /* DYNAMIC */
                }, [
                  renderList({
                    option: "option",
                    noresults: "no-results",
                    nooptions: "no-options",
                    afterlist: "after-list",
                    beforelist: "before-list",
                    placeholder: "placeholder",
                    grouplabel: "group-label",
                    caret: "caret",
                    clear: "clear",
                    spinner: "spinner",
                    default: "default"
                  }, (slotName, slotKey) => {
                    return {
                      name: slotKey,
                      fn: withCtx((props) => [
                        renderSlot(_ctx.$slots, slotName, mergeProps(props, { el$: _ctx.el$ }), () => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots[slotName]), mergeProps(props, { el$: _ctx.el$ }), null, 16, ["el$"]))
                        ])
                      ])
                    };
                  }),
                  _ctx.fieldOptions.mode == "multiple" ? {
                    name: "multiplelabel",
                    fn: withCtx(({ values: values2 }) => [
                      renderSlot(_ctx.$slots, "multiple-label", {
                        values: values2,
                        el$: _ctx.el$
                      }, () => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots["multiple-label"]), {
                          values: values2,
                          el$: _ctx.el$
                        }, null, 8, ["values", "el$"]))
                      ])
                    ]),
                    key: "0"
                  } : void 0
                ]), 1040, ["modelValue", "classes", "id", "name", "options", "disabled", "placeholder", "attrs", "aria", "locale", "onSelect", "onDeselect", "onSearchChange", "onTag", "onOpen", "onClose", "onClear", "onPaste"])
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            ))
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$Z.render = render$r;
    script$Z.__file = "themes/blank/templates/elements/MultiselectElement.vue";
    var script$Y = {
      name: "MultiselectElement",
      components: {
        Multiselect: script$_
      },
      render: script$Z.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            input: "vf-input",
            input_enabled: "",
            input_disabled: "",
            input_success: "vf-input-success",
            input_danger: "vf-input-danger",
            input_sm: "vf-input-sm",
            input_md: "",
            input_lg: "vf-input-lg",
            inputWrapper: "",
            select: {
              multipleLabel: "vf-multiselect-multiple-label",
              multipleLabel_sm: "vf-multiselect-multiple-label-sm",
              multipleLabel_md: "",
              multipleLabel_lg: "vf-multiselect-multiple-label-lg",
              multipleLabel_noClear: "vf-multiselect-multiple-label-no-clear",
              multipleLabel_noCaret: "vf-multiselect-multiple-label-no-caret",
              container: "vf-multiselect",
              container_enabled: "",
              container_disabled: "vf-multiselect-disabled",
              container_success: "vf-multiselect-success",
              container_danger: "vf-multiselect-danger",
              container_sm: "vf-multiselect-sm",
              container_md: "",
              container_lg: "vf-multiselect-lg",
              containerDisabled: "",
              containerOpen: "vf-multiselect-open",
              containerOpenTop: "vf-multiselect-open-top",
              containerActive: "vf-multiselect-active",
              containerActive_enabled: "",
              wrapper: "vf-multiselect-wrapper",
              wrapper_sm: "vf-multiselect-wrapper-sm",
              wrapper_md: "",
              wrapper_lg: "vf-multiselect-wrapper-lg",
              search: "vf-multiselect-search",
              search_sm: "vf-multiselect-search-sm",
              search_md: "",
              search_lg: "vf-multiselect-search-lg",
              placeholder: "vf-multiselect-placeholder",
              placeholder_sm: "vf-multiselect-placeholder-sm",
              placeholder_md: "",
              placeholder_lg: "vf-multiselect-placeholder-lg",
              caret: "vf-multiselect-caret",
              caret_sm: "vf-multiselect-caret-sm",
              caret_md: "",
              caret_lg: "vf-multiselect-caret-lg",
              caretOpen: "vf-multiselect-caret-open",
              clear: "vf-multiselect-clear",
              clear_sm: "vf-multiselect-clear-sm",
              clear_md: "",
              clear_lg: "vf-multiselect-clear-lg",
              clearIcon: "vf-multiselect-clear-icon",
              spinner: "vf-multiselect-spinner",
              spinner_sm: "vf-multiselect-spinner-sm",
              spinner_md: "",
              spinner_lg: "vf-multiselect-spinner-lg",
              infinite: "vf-multiselect-infinite",
              infinite_sm: "vf-multiselect-infinite-sm",
              infinite_md: "",
              infinite_lg: "vf-multiselect-infinite-lg",
              infiniteSpinner: "vf-multiselect-infinite-spinner",
              dropdown: "vf-multiselect-dropdown",
              dropdown_sm: "vf-multiselect-dropdown-sm",
              dropdown_md: "",
              dropdown_lg: "vf-multiselect-dropdown-lg",
              dropdownTop: "vf-multiselect-dropdown-top",
              dropdownTop_sm: "vf-multiselect-dropdown-top-sm",
              dropdownTop_md: "",
              dropdownTop_lg: "vf-multiselect-dropdown-top-lg",
              dropdownHidden: "vf-multiselect-dropdown-hidden",
              options: "vf-multiselect-options",
              optionsTop: "vf-multiselect-options-top",
              group: "vf-multiselect-group",
              groupLabel: "vf-multiselect-group-label",
              groupLabel_sm: "vf-multiselect-group-label-sm",
              groupLabel_md: "",
              groupLabel_lg: "vf-multiselect-group-label-lg",
              groupLabelPointable: "vf-multiselect-group-label-pointable",
              groupLabelPointed: "vf-multiselect-group-label-pointed",
              groupLabelSelected: "vf-multiselect-group-label-selected",
              groupLabelDisabled: "vf-multiselect-group-label-disabled",
              groupLabelSelectedPointed: "vf-multiselect-group-label-selected vf-multiselect-group-label-pointed",
              groupLabelSelectedDisabled: "vf-multiselect-group-label-selected vf-multiselect-group-label-disabled",
              groupOptions: "vf-multiselect-group-options",
              option: "vf-multiselect-option",
              option_sm: "vf-multiselect-option-sm",
              option_md: "",
              option_lg: "vf-multiselect-option-lg",
              optionPointed: "vf-multiselect-option-pointed",
              optionSelected: "vf-multiselect-option-selected",
              optionDisabled: "vf-multiselect-option-disabled",
              optionSelectedPointed: "vf-multiselect-option-selected vf-multiselect-option-pointed",
              optionSelectedDisabled: "vf-multiselect-option-selected vf-multiselect-option-disabled",
              noOptions: "vf-multiselect-no-options",
              noOptions_sm: "vf-multiselect-no-options-sm",
              noOptions_md: "",
              noOptions_lg: "vf-multiselect-no-options-lg",
              noResults: "vf-multiselect-no-results",
              noResults_sm: "vf-multiselect-no-results-sm",
              noResults_md: "",
              noResults_lg: "vf-multiselect-no-results-lg",
              fakeInput: "vf-multiselect-fake-input",
              assist: "vf-assistive-text",
              spacer: "vf-multiselect-spacer",
              spacer_sm: "vf-multiselect-spacer-sm",
              spacer_md: "",
              spacer_lg: "vf-multiselect-spacer-lg",
              $container: (classes2, { Size, isDanger, isSuccess, isDisabled }) => [
                classes2.select.container,
                classes2.select[`container_${Size}`],
                isDisabled ? classes2.select.container_disabled : null,
                !isDisabled && !isSuccess && !isDanger ? classes2.select.container_enabled : null,
                !isDisabled && isDanger ? classes2.select.container_danger : null,
                !isDisabled && isSuccess ? classes2.select.container_success : null
              ],
              $containerActive: (classes2, { Size, isDanger, isSuccess, isDisabled }) => [
                classes2.select.containerActive,
                classes2.select[`container_${Size}`],
                !isDisabled && !isSuccess && !isDanger ? classes2.select.containerActive_enabled : null
              ],
              $wrapper: (classes2, { Size }) => [
                classes2.select.wrapper,
                classes2.select[`wrapper_${Size}`]
              ],
              $search: (classes2, { Size }) => [
                classes2.select.search,
                classes2.select[`search_${Size}`]
              ],
              $placeholder: (classes2, { Size }) => [
                classes2.select.placeholder,
                classes2.select[`placeholder_${Size}`]
              ],
              $caret: (classes2, { Size }) => [
                classes2.select.caret,
                classes2.select[`caret_${Size}`]
              ],
              $clear: (classes2, { Size }) => [
                classes2.select.clear,
                classes2.select[`clear_${Size}`]
              ],
              $spinner: (classes2, { Size }) => [
                classes2.select.spinner,
                classes2.select[`spinner_${Size}`]
              ],
              $infinite: (classes2, { Size }) => [
                classes2.select.infinite,
                classes2.select[`infinite_${Size}`]
              ],
              $dropdown: (classes2, { Size }) => [
                classes2.select.dropdown,
                classes2.select[`dropdown_${Size}`]
              ],
              $dropdownTop: (classes2, { Size }) => [
                classes2.select.dropdownTop,
                classes2.select[`dropdownTop_${Size}`]
              ],
              $groupLabel: (classes2, { Size }) => [
                classes2.select.groupLabel,
                classes2.select[`groupLabel_${Size}`]
              ],
              $option: (classes2, { Size }) => [
                classes2.select.option,
                classes2.select[`option_${Size}`]
              ],
              $spacer: (classes2, { Size }) => [
                classes2.select.spacer,
                classes2.select[`spacer_${Size}`]
              ],
              $noOptions: (classes2, { Size }) => [
                classes2.select.noOptions,
                classes2.select[`noOptions_${Size}`]
              ],
              $noResults: (classes2, { Size }) => [
                classes2.select.noResults,
                classes2.select[`noResults_${Size}`]
              ],
              $multipleLabel: (classes2, { Size, canClear, caret }) => [
                classes2.select.multipleLabel,
                classes2.select[`multipleLabel_${Size}`],
                !canClear ? classes2.select[`multipleLabel_noClear`] : null,
                !caret ? classes2.select[`multipleLabel_noCaret`] : null
              ]
            },
            $input: (classes2, { isDisabled, Size, isDanger, isSuccess }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : null,
              !isDisabled && !isSuccess && !isDanger ? classes2.input_enabled : null,
              !isDisabled && isDanger ? classes2.input_danger : null,
              !isDisabled && isSuccess ? classes2.input_success : null
            ]
          }
        };
      }
    };
    var css_248z$u = "/* Some styles are contained in Vueform.vue & SelectElement.vue */\n\n.vf-multiselect-multiple-label {\n  display: flex;\n  align-items: center;\n  height: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  pointer-events: none;\n  background: transparent;\n  padding-left: var(--vf-px-input);\n  padding-right: calc(var(--vf-px-input) * 2.5 + 20px);\n}\n\n.vf-multiselect-multiple-label.vf-multiselect-multiple-label-no-caret, .vf-multiselect-multiple-label.vf-multiselect-multiple-label-no-clear {\n  padding-right: calc(var(--vf-px-input) * 1.5 + 10px);\n}\n\n.vf-multiselect-multiple-label.vf-multiselect-multiple-label-no-caret.vf-multiselect-multiple-label-no-clear {\n  padding-right: var(--vf-px-input);\n}\n\n.vf-multiselect-multiple-label.vf-multiselect-multiple-label-sm {\n  padding-left: var(--vf-px-input-sm);\n  padding-right: calc(var(--vf-px-input-sm) * 1.5 + 20px);\n}\n\n.vf-multiselect-multiple-label.vf-multiselect-multiple-label-sm.vf-multiselect-multiple-label-no-caret, .vf-multiselect-multiple-label.vf-multiselect-multiple-label-sm.vf-multiselect-multiple-label-no-clear {\n  padding-right: calc(var(--vf-px-input-sm) * 1.5 + 10px);\n}\n\n.vf-multiselect-multiple-label.vf-multiselect-multiple-label-sm.vf-multiselect-multiple-label-no-caret.vf-multiselect-multiple-label-no-clear {\n  padding-right: var(--vf-px-input-sm);\n}\n\n.vf-multiselect-multiple-label.vf-multiselect-multiple-label-lg {\n  padding-left: var(--vf-px-input-lg);\n  padding-right: calc(var(--vf-px-input-lg) * 2.5 + 20px);\n}\n\n.vf-multiselect-multiple-label.vf-multiselect-multiple-label-lg.vf-multiselect-multiple-label-no-caret, .vf-multiselect-multiple-label.vf-multiselect-multiple-label-lg.vf-multiselect-multiple-label-no-clear {\n  padding-right: calc(var(--vf-px-input-lg) * 1.5 + 10px);\n}\n\n.vf-multiselect-multiple-label.vf-multiselect-multiple-label-lg.vf-multiselect-multiple-label-no-caret.vf-multiselect-multiple-label-no-clear {\n  padding-right: var(--vf-px-input-lg);\n}\n\n.vf-floating-wrapper ~ .vf-multiselect-multiple-label,\n.vf-floating-wrapper ~ div .vf-multiselect-multiple-label {\n  padding-top: calc(var(--vf-py-input) + var(--vf-floating-top) / 2);\n  padding-bottom: calc(var(--vf-py-input) - var(--vf-floating-top) / 2);\n}\n\n.vf-floating-wrapper ~ .vf-multiselect-multiple-label-sm,\n.vf-floating-wrapper ~ div .vf-multiselect-multiple-label-sm {\n  padding-top: calc(var(--vf-py-input-sm) + var(--vf-floating-top-sm) / 2);\n  padding-bottom: calc(var(--vf-py-input-sm) - var(--vf-floating-top-sm) / 2);\n}\n\n.vf-floating-wrapper ~ .vf-multiselect-multiple-label-lg,\n.vf-floating-wrapper ~ div .vf-multiselect-multiple-label-lg {\n  padding-top: calc(var(--vf-py-input-lg) + var(--vf-floating-top-lg) / 2);\n  padding-bottom: calc(var(--vf-py-input-lg) - var(--vf-floating-top-lg) / 2);\n}\n\n[dir=rtl] .vf-multiselect-multiple-label {\n  padding-left: calc(var(--vf-px-input) * 2.5 + 20px);\n  padding-right: var(--vf-px-input);\n  left: auto;\n  right: 0;\n}\n\n[dir=rtl] .vf-multiselect-multiple-label.vf-multiselect-multiple-label-no-caret, [dir=rtl] .vf-multiselect-multiple-label.vf-multiselect-multiple-label-no-clear {\n  padding-left: calc(var(--vf-px-input) * 1.5 + 10px);\n  padding-right: var(--vf-px-input);\n}\n\n[dir=rtl] .vf-multiselect-multiple-label.vf-multiselect-multiple-label-no-caret.vf-multiselect-multiple-label-no-clear {\n  padding-left: var(--vf-px-input);\n  padding-right: var(--vf-px-input);\n}\n\n[dir=rtl] .vf-multiselect-multiple-label.vf-multiselect-multiple-label-sm {\n  padding-left: calc(var(--vf-px-input-sm) * 2.5 + 20px);\n  padding-right: var(--vf-px-input-sm);\n}\n\n[dir=rtl] .vf-multiselect-multiple-label.vf-multiselect-multiple-label-sm.vf-multiselect-multiple-label-no-caret, [dir=rtl] .vf-multiselect-multiple-label.vf-multiselect-multiple-label-sm.vf-multiselect-multiple-label-no-clear {\n  padding-left: calc(var(--vf-px-input-sm) * 1.5 + 10px);\n  padding-right: var(--vf-px-input-sm);\n}\n\n[dir=rtl] .vf-multiselect-multiple-label.vf-multiselect-multiple-label-sm.vf-multiselect-multiple-label-no-caret.vf-multiselect-multiple-label-no-clear {\n  padding-left: var(--vf-px-input-sm);\n  padding-right: var(--vf-px-input-sm);\n}\n\n[dir=rtl] .vf-multiselect-multiple-label.vf-multiselect-multiple-label-lg {\n  padding-left: calc(var(--vf-px-input-lg) * 2.5 + 20px);\n  padding-right: var(--vf-px-input-lg);\n}\n\n[dir=rtl] .vf-multiselect-multiple-label.vf-multiselect-multiple-label-lg.vf-multiselect-multiple-label-no-caret, [dir=rtl] .vf-multiselect-multiple-label.vf-multiselect-multiple-label-lg.vf-multiselect-multiple-label-no-clear {\n  padding-left: calc(var(--vf-px-input-lg) * 1.5 + 10px);\n  padding-right: var(--vf-px-input-lg);\n}\n\n[dir=rtl] .vf-multiselect-multiple-label.vf-multiselect-multiple-label-lg.vf-multiselect-multiple-label-no-caret.vf-multiselect-multiple-label-no-clear {\n  padding-left: var(--vf-px-input-lg);\n  padding-right: var(--vf-px-input-lg);\n}";
    styleInject(css_248z$u);
    script$Y.__file = "themes/vueform/templates/elements/MultiselectElement.vue";
    var script$X = {
      name: "ObjectElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: ""
          }
        };
      }
    };
    const _hoisted_1$l = ["aria-labelledby"];
    function render$q(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        {
          multiple: true,
          ref: "container"
        },
        createSlots({
          element: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.classes.wrapper),
              role: "group",
              "aria-labelledby": _ctx.labelId
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                (openBlock(true), createElementBlock(
                  Fragment,
                  null,
                  renderList(_ctx.children, (element, name2) => {
                    return openBlock(), createBlock(resolveDynamicComponent(_ctx.component(element)), mergeProps({ ref_for: true }, element, {
                      embed: _ctx.embed,
                      name: name2,
                      key: name2,
                      onRemove: _cache[0] || (_cache[0] = (e2) => _ctx.$emit("remove", e2))
                    }), null, 16, ["embed", "name"]);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ])
            ], 10, _hoisted_1$l)
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$X.render = render$q;
    script$X.__file = "themes/blank/templates/elements/ObjectElement.vue";
    var script$W = {
      name: "ObjectElement",
      render: script$X.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "vf-row",
            wrapper_sm: "vf-row-sm",
            wrapper_md: "",
            wrapper_lg: "vf-row-lg",
            wrapper_embed: "vf-row-embed",
            $wrapper: (classes2, { Size, embed }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`],
              embed ? classes2.wrapper_embed : null
            ]
          }
        };
      }
    };
    var css_248z$t = "/* Some styles are contained in Vueform.vue */";
    styleInject(css_248z$t);
    script$W.__file = "themes/vueform/templates/elements/ObjectElement.vue";
    var script$V = {
      name: "PhoneElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            inputContainer: "",
            input: ""
          }
        };
      }
    };
    const _hoisted_1$k = ["value", "type", "name", "id", "placeholder", "autocomplete", "disabled", "readonly"];
    function render$p(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ElementAddonOptions = resolveComponent("ElementAddonOptions");
      const _component_ElementLabelFloating = resolveComponent("ElementLabelFloating");
      const _component_ElementLoader = resolveComponent("ElementLoader");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.inputContainer)
              },
              [
                createBaseVNode(
                  "div",
                  {
                    class: normalizeClass(_ctx.classes.optionsWrapper)
                  },
                  [
                    createVNode(_component_ElementAddonOptions, {
                      options: _ctx.addonOptions,
                      placeholder: _ctx.addonPlaceholder,
                      aria: _ctx.optionsAria,
                      onSelect: _ctx.handleOptionSelect,
                      onOpen: _ctx.handleOpen,
                      onClose: _ctx.handleClose,
                      ref: "options$"
                    }, null, 8, ["options", "placeholder", "aria", "onSelect", "onOpen", "onClose"])
                  ],
                  2
                  /* CLASS */
                ),
                _ctx.hasFloating && !_ctx.empty ? (openBlock(), createBlock(_component_ElementLabelFloating, {
                  key: 0,
                  visible: !_ctx.empty
                }, null, 8, ["visible"])) : createCommentVNode("v-if", true),
                _ctx.isLoading ? (openBlock(), createBlock(_component_ElementLoader, { key: 1 })) : createCommentVNode("v-if", true),
                createBaseVNode("input", mergeProps({
                  value: _ctx.model,
                  type: _ctx.inputType,
                  name: _ctx.name,
                  id: _ctx.fieldId,
                  class: _ctx.classes.input,
                  placeholder: _ctx.Placeholder,
                  autocomplete: _ctx.autocomplete,
                  disabled: _ctx.isDisabled,
                  readonly: _ctx.readonly
                }, {
                  ..._ctx.attrs,
                  ..._ctx.aria
                }, {
                  onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args)),
                  onInput: _cache[1] || (_cache[1] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
                  onSelect: _cache[2] || (_cache[2] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
                  onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                  onFocus: _cache[4] || (_cache[4] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                  ref: "input"
                }), null, 16, _hoisted_1$k)
              ],
              2
              /* CLASS */
            )
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$V.render = render$p;
    script$V.__file = "themes/blank/templates/elements/PhoneElement.vue";
    var script$U = {
      name: "PhoneElement",
      render: script$V.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            inputContainer: "vf-input-group",
            inputContainer_sm: "vf-input-group-sm",
            inputContainer_md: "",
            inputContainer_lg: "vf-input-group-lg",
            inputContainer_default: "",
            inputContainer_disabled: "vf-input-group-disabled",
            inputContainer_focused: "vf-input-group-focused",
            inputContainer_success: "vf-input-group-success",
            inputContainer_danger: "vf-input-group-danger",
            input: "vf-input-field",
            input_sm: "",
            input_md: "",
            input_lg: "",
            input_enabled: "",
            input_disabled: "",
            input_focused: "",
            input_success: "",
            input_danger: "",
            optionsWrapper: "vf-phone-options-wrapper",
            optionsWrapper_sm: "vf-phone-options-wrapper-sm",
            optionsWrapper_md: "",
            optionsWrapper_lg: "vf-phone-options-wrapper-lg",
            optionWrapper: "",
            option: "vf-phone-option",
            option_active: "vf-phone-option-active",
            optionWrapper: "vf-phone-option-wrapper",
            flag: "vf-phone-flag",
            country: "vf-phone-country",
            number: "vf-phone-number",
            placeholder: "vf-phone-flag vf-phone-flag-placeholder",
            $optionsWrapper: (classes2, { Size }) => [
              classes2.optionsWrapper,
              classes2[`optionsWrapper_${Size}`]
            ],
            $option: (classes2) => (active) => [
              classes2.option,
              active ? classes2.option_active : null
            ],
            $inputContainer: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.inputContainer,
              classes2[`inputContainer_${Size}`],
              isDisabled ? classes2.inputContainer_disabled : null,
              !isDisabled && !isSuccess && !isDanger ? classes2.inputContainer_default : null,
              !isDisabled && focused ? classes2.inputContainer_focused : null,
              !isDisabled && isSuccess ? classes2.inputContainer_success : null,
              !isDisabled && isDanger ? classes2.inputContainer_danger : null
            ],
            $input: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : null,
              !isDisabled && !isSuccess && !isDanger && !focused ? classes2.input_enabled : null,
              !isDisabled && focused && !isSuccess && !isDanger ? classes2.input_focused : null,
              !isDisabled && isDanger ? classes2.input_danger : null,
              !isDisabled && isSuccess ? classes2.input_success : null
            ]
          }
        };
      }
    };
    var css_248z$s = '/* Some styles are contained in Vueform.vue */\n\n.vf-phone-option {\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  padding: 0.3125rem 0.75rem;\n  white-space: nowrap;\n}\n\n.vf-phone-option-active {\n  background: var(--vf-bg-selected);\n}\n\n.vf-phone-options-wrapper {\n  display: flex;\n  align-items: center;\n  margin-left: var(--vf-px-input);\n}\n\n.vf-phone-options-wrapper.vf-phone-options-wrapper-sm {\n  margin-left: var(--vf-px-input-sm);\n}\n\n.vf-phone-options-wrapper.vf-phone-options-wrapper-lg {\n  margin-left: var(--vf-px-input-lg);\n}\n\n.vf-phone-option-wrapper {\n  display: flex;\n  align-items: center;\n}\n\n.vf-phone-flag {\n  background: no-repeat 0 0;\n  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAACTYCAMAAAChOY3VAAAC/VBMVEUAAADr7e6gAh/l5uQxh+TfP1zi6/UAO5jYACfw8PAAUrRtpUT/2kQzivNJbi0AAACiAB3+/v7/mBEuUrLaDjMPXLhNTk/gTmh1qk7bFRYAJXx2GUXPBSkPDgxKl/MEjzo6lArcDykITq7w7OrpRDP84gQAlMeXvnvkdYpwrPJUdjX11kbj6O7Az+NQiMnlfI8QWaz+0EKivd00dcEHPKt3qUSyyOCBl3vL1+dilsy+SWHaGTzmj5/otL3rn6mTGlTY4OuVtNnbJUWft0RCfsXrwcnt09gpbb/ry9Dv3+JgWyfv5ujs0UkbZbywPjLdNVOCqNXusTzjaH1HOIaOczrCBip/kTyFuvH9ygKsT3nbLEzFa4Le5tlcoPORARvdjDRsmc/Jycnkz17AXytFAQyMrtf6vUDLHSu5ubt1kWD/3UziNS6vKCfRsQrXz9VxcnJ1n9EsQpjhW3MzTSXykDrOyERwob4VFxiulS/fJizSlKBFZbnueziUoWD6tVuspzg/NRGdn6DykxavFyA5cJmcsJJcX1rcx0DoWDMpap/mh5huhDL07tlXc7+6IUYsLCuJiIgoIgyEqq2zNEp4SirqqrTHgZipqLS2s2SFs2SlyfKxzpusFUHevDu+xHiRfh7b29pSfY76x0LJ2r1fjY+fiCywuYn74G34sD/1njy0fjl5jX+3ssz46amfXCmqnxK3ya28wEKYp86hxIjZxlRiARGhW4bWdi3S3cnz6sjURlvraTWbKyj26rn55pHOs8evg6fOwFlVShS/1vHA1rBEcTXlThLOoLQfY5xmhE+LQiv+tB9jLHT9311zZBo0AQhpZ7CCLGDqyT9KoNnKszrjpzvARSmClsz75Hxgn1iSs0T0fBXz1aWgpnBggDK/XGw7PD2vuqFRWp95AhTJU3WoMF3EnzMhO4r/xTNwhsMIcEX9oy6CR4/Bx7q+lq7ezBJUlHAQLE1ZvNz2xIBEksDml2JMddSJelPSyW/SypP+/Qcjn6PDk1jmZF3f2aq8rzgbAAAACHRSTlMA/vv8+f4arFpOVUwAAIXvSURBVHja7JlfSFNRHMfv7Q+dM07eMdJe7h7MHooM+wPRPysiszSfYg8jiCQRaaEEe2gh4RqERAyHlS+FEQQL6iWYIVaIDwtaGIlvCj2IMhB6Gb33u2d3O/Pqab9DaLe4H+e8Y9/P/f1+95w7ULX7EnSdrvml1UmgErS6+/BlPer6huJ98MN+JRds7ndSoBOyXKpSAQK9VO/sBQPSRUVCuUJfD/TTQ6kdl2JV4A8ubaabRVwm2HEgrlM6IjqSCqUxhyjV4/wYMzQwQumQOLlUEBX64nEe5j3KBetdu+8eaAixcOUpe6AlfoAYmr8fp7SvPPNvBNH3EOQxFcQpRVyO+vbulCAVqCLqQp0ibhSoIhsg6Iq48bIqCx7uwHBikgrMGiee8H8JkYmJiIIQ6WZAdwQrRBh7EY2+YCyCFLpZlABR1o0TIhCs7+6uBzGCEiagwCBjg1BiQllAtxQbHIwhWkIMjb+s+IXDbw2X7VZP2GjBwx0QRTxh4wRzIZNIZBZMtJAxOBm08LUofMUIIYtSBf6iihA0HASrCAtOYaHaDP6uyniXv/rQoUohJBla1tUC7rImuux+Eth18BcFP0EKZmnhTJTA8/bDRAmhoNF11TCudhnBEEYAI8OLmJkQ+n5IGEBC4QYqVsAIwoA8ShDb3F0fAn9Z8HAHNRJ0CVKBSvAENwttjz6fvKAgfCbE3LnncQNWeE/Ie5WWHhFy05rh4imkcJOQtpqapqatD5BCiP/WcPEEOdt0XkFoIWRni0pLp1qaHigOTVtUL6v6wiluDXftVk9YL0GXoHm4gwNqXNZ8eHZdPm0STSlNkpOaQvr45FFKNUT6y2lipwGtavqplf7B01zApM9QTvvvhVs8HR6BdJE7w1xApiHvT3BBljbDrxspIPL+71xApXneL1oS6W8hQnaMibTIA5tsQZoWPIG4aEmkT4y91imV5e2WRHqSpyV50dKuy5CGTXWEAvI8r9Dc3E41vq12wEaR5wVPG6hW3ooS54qIJ4Y/FWcQm33/Wvnh71ee3Gke9jeLzSd3HhZ+Ft5w3l0vvHnIBQHM73A+3GCVjDsEoHzNdMoZ/1iJqCCotipOwbnuCEG+s4SAceSC/O4QAtKRC/I7XAh4BymITyltmxJfnmoe7uCAA+ag3sGqreEUiANP2EghFwjk0EI+l8sFAPiRRwmQLpFDCnPZbBbOv4wWsvCGNYiLhBzjwex6CflAoCjMBXDrwOzrPwciToASgXz2HjwhBW5YksLms/KMrafA8nm33XH/lqD8ce/hDkxF3Pg/lP9ZeJHujykJDOhXEWK7XzH2Ci/U1xMyCDWwQqS/P0LIbsZiWOHgQRBImvVjhBh0FI1CT1AijRHS6QikLSHCDq4SjNW8ZOx2ih+l2D7DwVpCcJQx9jIIR1NsFiEAqduM7ZsOGrfZKEJoG4CngSXGZqC3VHWhje2bMoCpZwxmMRAVliA3lRqYmmXA0gBiBphZMI0ZOjU6O3NpdnR6BuYIVhcEwemXsqHleIIlBBXRPNzBYu+RDp+FHjbNsM4PO470LvokaMnQZOMxH0DDhISpDzjWOBlKSoVrY+bicyhSEuD0zxfNsWtSwdc6wouUBH76kVafVIDvYpGiIE4vE3SA6u2UFgVK2+ElIBXCZZKEJMUrqUAkKAt/0lJtbaVAi4ihbez3z/l8rfv3t8KB47L2li5r78rLekZvpLSBNupnxMK9TZorF85Mvm0tC9YfadNQsSzw06/YGqIIFwqB9Px4AQTc5gOh0ACSEPjpheDY3iCMQz/zy0LwSbGF5bvzKsJR+vBuoDA+T48ihUNWQx/g6RBSOLzX5jBKADq2czp8OAGo3bJ9+5ZaH1oAeBovAJ7gQuEXu3bP0jAUhmE4HBxsieRF3EoydNLB3Q+sIGRycHAQhHaQ/oG6KJ3ExSUgEVxC61YH945d2rktFIdu+RuOntLGxKSv5BEKRzw3tEPhgjxp6NBEp0Z1G6pukG0B2WRQDQE1Cahr5a5LM0BjK2djmgOy8w6IQGaG789emQERyM7oT3x/0s8MiEBqhm9bI/PhwRxZtp8aEIPkjDuz3TZl8v0uOSAG6Rkdc1EnNSAC6RmjCIySA9KA6jfzHm/fv7p9XHxYpywQjSJbQywBVCoXmcolSoJYcKBEywGdF5d2TgxgZjQEC6hWXjKgRjygg91MB8QDWTP7SMHPQLiFb7mCA1Gt00Ki0xYxIC5MgpAYwMxoEgOYGa5gADMjNYAHFDIDWEDNeAAHsjNcAQA5Qw5AgAhDwQCdGjlgxgaYBoqAHTCjAMYAT4YArzcc9jwATE3ZND/w5sBbAQAOCRgNn1Yw+NJQ8fLWIEf4z71OjfT96f8CjsFU/BdOg5WANzBjE0wDRcA9mKFTow2stV+CiyoI9gIM7GxXHABUg+etk6PAyQucQeVwff3SHTi5D6k6OLsOHGSDU3HBsxRcgKDqYECmwV8DV1gfhol1ZeyD4RtesF7xDU9gKn7Tn+ydwWriQBjHZ+gK+WevGXwALx4mCgkERV0aSZsuIg2yJ714yVVCH6P3+hR72qOXHL3uQ/S8z7AzcZJJpSkObCEL/qC1Fn6Z+U++b0rSgJ8vXGkHh5xSGsS2xqfUKqDUt+uw8e1Dl1jW6w6gKdMCcBKAN4Lvfl+dLvyczQ3AM/ahEHuLoWMJ4bgW3yd7ALeDZoGlVP7ptNYzktJ98dMRgBs1CFs+K477DSBirJuNHOuQA/Did4SByCpnPlwAnBRpdq+WQKZHys6ESGYVrL4Xa0NOxxjlhyp9WBOqrN0HNT6pZqnSU0ALUUqnMuHjTCb031w0MZ1eCyiz6jUkSYWHxX4jyLXw8CyY9gDwNDlB8B5KeA9joY13HVoofP55SE6kHEBv+ix40EK+EewX8JIKYqseAaCasD5CWcJ6jygE360Kc0rTqCagLGG+1ULsASib0IvrLRpyoGxgVd+EpRQom9CNzjYBlgIoG9j1pcCBsgnVMeqCGr9sYDE+qbLybcNGFrn19EQ1oVyHBkGtoUpPqqwf7a0sq9ITmVWmaRL0HnFKT0TWsZrNx9t9HFBK8wO50g4OuTpx4dCyhqldEOVduwGyFoU+iqTQt6x+WJzTnyvrsVHY7iei0AO/Elg6dObf0CjYLNk4kz3C4CRspxPnuRfEjYL4Wv56FYUOKbjHtaheOcVGIZDw3fF4I4XFbHYPuOJXdo1lXRhWdCyro9/ZFSxxx0aPb8ccnpHAvNtBTehXyCnpd/UIjNUEVwDc390tZOibPN9xV2KfEelljdxF31kfR1LAn7mz+bW0z2Ejnigh9nrTyWSasVAKgUfFmd8nrDyuN2DFK0egBPoyd/rymKo0fFfsP/M/aiFT8JObpbESOtbTz9iuF99gtHstiy+Dq4tECbmMowXJlucHNffYL14M7xn7YWwmjBEZjhDH//K+d8ZMhNhnPFsODARIwvPCaBbsAIKzq4DMHTcKKSS3ytAN1CSwQQhgtH0jLAM+aJ7SEi5NbY1uoCYhsf3sf/sPhy25Pu/9/+EY0sYLjqtwidA1pI0fWXQVPkXoGtLG8r4KF2C+3V9pB18MaeNDjFfhEuG3IcR6h/nw5dvKYNd46mHamc8vFh6BJ0uyvlB4wUy+dFazoXORcI9hMTHgbv0JgsGUDEIbLav5ifthCPlqyF/27p81rSgMA3jUDh6O9JwtQtPJwUGdBIckDoUY/9yhUMjS65DFLUOmEpwC2bKJ4mTIEPwAJYsBp7tYHBzci/0K+QZ9z5VyW1u870Nrc03OQ4yC/nzvue85x8XkWrCtwCYaeUQ/p9XbL9jng1Lq8RUIqAgITBEQUBEQmCIgoCIgMEVAQEUwQPn2KSQrgIpcpNaGwGq8OQioCAhMEQZgFMEBfkj4oPHTCjcOnhrw5MOnN/D2+BLFNwF8m8E3MnyrhDdjdLu33yOLSsRKarvwt1pqHzFQ2YUqmJdD4PAABCJDBBx0/T1W4fpgs2OooWfJEHTQFazTFXAufUiCY6C+YcBvBAzQQ8IHjZ5WvHEbnRq1/7BErze+RA/xJbrZjcyQzW7G1Dl7XcutyGswFkQVNMYneyfjBhuMk8uMmeAs+SNnLNBLBplywF4yyB4DNJI/pxcOpr+AaTjoAQA4JGDQwGkFGgdMDWzyRWk9WPAvgE00EnYBldXnQy/Rsvq8BX8Dbm74IHdLL+50CN3mWMBTM3NhiVxqpjwWuFCdJeioCxaYKzU3wNyzgHlnA0wlHvDU0ICh8pigobyhUkNPNXgg+B+pMyYYXl5eKkW/hvxOmzHQ3QsDnpeL2op73gDe7m2iEceZlB3HdZxFnJUdkRl0RVuXxUJzQqCvdXugu3zgak0/Vw4b1OMDx9VtfgXRb4t6NwMAR5gbAPwgoJ6hGwLcvjgeOHxQ0/H6Qrt8QC+knzi/D22tywO9D4yhuy8mugKAck2INtwHHMCHhA8aOa0TZAHhjTvWVzQ1+uLrlJVg8t1LVoLpzQd+EOAvUQS4/ibAB8fxK9pm+mxg+uCaPjBB0Gn+GJabMRvEYpNyLObGYvf2e2RbFbWSsCuYWmCBBRZY8DKATTQSB7Ojwey8ARPFv/Z/IlA9bbVOq2xQLYnEaJQQpSoPHOUTWUnJJvJHHFDN36WlTJvbXb7KAKVmWmabQjSzMt0shYOiyMqsyFD8B8VQcJ6QsvmQojw0pUych4J3I5kWSyDSctQKBS0DSv5gfMA7pIJ5VPAPiTnoQrFYCAaNnFa4cejUQCcfOL0jteKeFOBbpQaDb/c20Yj8LZ9z6/InkFoXCyzYavCdvfMHjRoKA3iCCHmvEcUzdFAEPQfBJGpCY+L5J6fx4tHGHuIkCOdwKsUhiy6nToooujkILirSdlDBuliwKjiKg1NFKk6CUhTBRTe/973YVCW99wbx1Ptha9qX3/cn9xJK+5Lbpy1ET+gJf7ewaiGUHt1BZc9ECamzByvW+fbEnkrxE2209WG7BBAmELbVDtdrKwqFy/3artrEfGGitkvrv1wolEpPMEkm8PBPSqUFhBIkqdQmuDBRq0D40gKCCpDyYJlwATdVoEgofG7on3uyUOFzQzXO8OKM4V9vycCm59A4NZJRm3dYp7et6K9bXLDq/Su2TcM3i4X27cUrdpjT31+4aXPHisW328UCD9/Op0abJ5kTwkNAmAsY/sfJh0nmhKdLgKe5gOF/FDDJnPD4BfA4F7RiuLB9GbBdWBi9//rhsmUPX98fFRROw7XzyhX4dFpQONqXcVRAQI73IcfFJ9/RA319B45KzdZVq7r80Vw9Aendl/VXoEux+Zmc8G75cinh2XIQpMLLCJshPAri4TsLj6YYIzy8gDBGkBEMLyJMZQKEFxMukfIIAOEFhUlC8uoFS8LwMhlmZsWEsanJySnseVxIeEQyymIZnrNd8eMS7CAgQII7m5/Nzo4zSVAYY0MywhkcmwVEBJhDn+fGOwrP9WefCbn0WVQY4QeIzIgIOO8JcmZWRMB5PzMzOTNIPoPRUcgn5iTL0VnIJ+YMMN5JgPBiKHl4YQHDSwgYXkaA8FIChJcTenQHayTpxp/5eoKIsE4SRZekJ/ytwm5JuvEBlz1BRBiQROnRHeAbGXk0omeHNizILYowIaFJ5AXu2SF9IXKBkRI/hhzigl3lVQkLBo1tH6sSFLAqy4Ac4kKQOtQGQ1DAqoKwCVWJCUiDeBRyiAvNoEUDMMQExE3NFKoSFbCqKlYlLKR2gzbBEBMQt2U2YjCEBdoiDaxKWEijlKZgiAp4gphVqEpcoFUSUOPCkLiQxgFtUDCEBMT2TCcBQ1igDrGxKmGhmdgGViUkILaPVYkL1FMjrEpYsJMowaqEBCQITQdyiAvUMmMKfQgLRmS4bgpViQlI01SrUJW4QP0wMaAqYcGIjdgOoCoxAUlVtWVcuNF7v6yuYrUk3fgOE/+lcEgShUiiHJNEWSpJT/g9wmFJ5KfGIUm68QT6LwXpy32P7qALfzfzDwv37kkJAyd0/cSAuPBqgw5seCUo5Guf7wkJA+d1fdQ1DHdU188PdBZ2QzknKXISytrdQcByRpM4QWMUy1pIGBjK/vRNVMem1NWBoYFCAcsBBn3PMgnxI0MHoKxOgkGByCMkyIROJbkUsdVJXlLnpikneolNSx5W4ReOuufwhZObGrKTT3Z6S55AXXdO/9tCj+5guD5RQsjFSuUi4dsT9eFFBSiats3/eb23v03TCPGDxG2YBHCiJHIIYKax8n5YO1ifni9M1w9qw+/9gDKMlunEuOV6YcOglK33xiSZwMPDem/8XV815lbDSg1uOSCUeBIu8PDwTcO2CABKkrK6wmYCuxOi+IBZ21MnXCD1PTXTB1SSgV3kW8q2Odji6vwrGG/ZgUcYfjNKfdxybEUrQG0ZvNVFfgCP5aM0CPGO00IBdo9bTfj8qQ/YEoGcQPupsn+OYU0bzr+iSZW1GlB6o6/vGiGeC7s3TVK43tsnHNMK37zBrdBSWdPtdnt6R6W/7nPBr/dXdkzDNwkETVshAbZudVJH5WEabL03rNZW8/XeKqznhvXeWAO2qr5dyRqo8gLZeu/FNetyPjUuW7XFsN6blRxE8MlO7t6NgwQU1nikYPgfJx8mweCY5saGDVOEH+XIIgqE/3W9NySphgSxWh+eP59k3TstnzXtqarJ8B1/cLBMYMtzQt6h6cBxmXz5cmzs5ZcHXFc9BSYwDFsRvqpstiXYKusQWx0ZP6LrR8aHoBqsS2HdpDbbndWYxtAm+wgC9lIbdJO+bs2pU2vW6ZuonbJ9FQyJMTEkJoRWMSELefXmOuDmWED5sVUgUTVo+NnLElT5bPaaTY/38VVH7uCgCk2b+VzIMEOSEcJguVzeurV8vfx9UKGRx/6HeWlAWax9zJy1z1olW3caOO8gcUT5n9fYGcv+NR2b4lZcrca4QW2nuXIlDqYOO5QKb5XGHrYKBL7ZMrILho+Da9swGPPBUGEnoGs72QnoBj5W2ogifknyg3mDTRgEQQ4laYbou4ZbzS5u2RXGso04NbF9GHQIv9YorJvQiXkjDl7cANuy7OwaNm+QHRvFc7MBv2FkA1ZAkcBy4p8GXU9h1eDFDauhPLVvG4YNHeJgnA0mNIJBRZVE6dEd7NrrJZShbtS0jSpuJt7eXbQAdl+WiXOHX/lwDplw41ShkLL7srwkFxIP78sqFGj8EZNkAoTn92UVC5RCkkrtG3tnFhpXFcbxO8TIOXduMiozTh6mwmQKiSRNMgmmGbMYTSbTbCrRCq0+RNEgjbhRl0KFSovUoFVLShvrklqXFC2oRbHWShEfVKxL9SEWRKHWpyo+KOqL+M3Jnfkm98zJPZ/rjZ6f7Sz1/P7f2eaGSe6dtC8I7e51WUpBeV2WSlBel6UUmII/KrxXpCCorsuyF/gi7PJFQVB9nS4IfSNhYKSvKMDf8fyFU4VpzV8yNW4DrnCyL/zBB+G+kyjkxHVZuHDiuqycXdKlJ54o7dL4FMQv3hpQZGq82KW7agYHa+7CLkG8vPmgSLFLr9RwXvMKdknELxZEEexSXijpkq3E7dJChT5d4Ye+u8L794fv6vtBU3gv7PKelgDsu0i8Od1n61YYGemDd+UjI9oV9jhOQ4Pj7MEKfqxuAGW1jYIvLdu2tQT7U0j+l4IhGDhE6MJDb2+gCZynjr5AEwAoQxOgzEHNMtbzD3FAv4wVifz8G8cyGgLw9a/FMoexjFoAVtx3GMscd5x0MplWCI9FXIZ+TRXLzKcZUwnOve8UlBVfumWy6zsZ27RpTrU1Tny0uMwA74kyFv1pwzMKAcAyj315eIrzHsZ6eOqn4yoBePKjFa5y4y2/pYYZG+a8vvvwvEoQZbYI4bVzIlv2CKGyGZYTJk0liDIgJD6ORBj7LZVlIABH5yUBabh3y8ds6woQIls6WXdx1xyXBSyTYIlTjJ1KsLU//+auDZZBATnAXKBrW2BzYpmyQnpiMskEa88RE1da5gUUPPlYAygtU0ZIAgeAZJIlbowsgK8BIahpeK64ax4RZVBQ8vnQCiyjIQAnni4pA4IO3xY3Jwr+ZQgClkFBt8w/cPQ2BIMKIhYnYoSACC8TCeJv2TPC3yLcQiSIlx0aQUdIyJjPI1sOJIgEcfMZ4U8IySRRWLmSKGzcSBTSaYJwZGJiwnHg5ohuhZVpB0iXHYbihCcHoJzwdNIBThKEu0ZOnhy5iyJclD8Pa9mcjmSEZSoYgkEIzps5lmAaJI41QmOL51l1MfPl4lWiqdUh7kJYRBXvno9khXdzLOIXz3fnN99qLOIXv9rdrVjEJx4QglREEY+CVEQRj4JcRI5HoVAkVCwy1j0w0D1WjA9BvCxgke/XcMGa7zFeFrCIIJvlAMZLAhYRNEejzRzjVQJOVxdjXTg5SkEwK3o0Nib6NBv2FypEciol7ir0hJ5uDnT36AmzHBZgivMpWA6dLsGg62HEYtz1/oMW0zrQ3DXI+WBX8wBOq8/CIbhw9K1B33z07U1/AdFfovSDAP0wQz6QkQ+V5IMx7XBvziMLDrVEgniugxF0hKuIWKw88Tjt7XE0lYpShMr1nK+v1BeuSK3hfE3qCm0hzgVxXaGzngvqOzWFMe4ypifEuwtCd1xLmOJFprSEaGeRKJMgb40gbm8jaEA/3BuCQbUH5iHtwVdwPBjh/y6sXEkUNm6kCMlkMp2GG12hcBLc3CbtLm12gM2UMcBpc89QBj3pHDjgTBKEzdsZ207pUlLcBGxrGCFggnS4NwSDqIeQh6gHi3ngHpgHIwRbSKWIQn09SUhlGcumCEIlAyq1hexgNwO6B7OaQn20fj1j6+FOT5iKMpfolJYw3Owa0eZhzUFnmSCrPUtdlZXRaGVlF2XhKsWkkoTA7VYj/CmBfrg3BIMAfm/GCEYIjNBCEqD1ly+i5Cu07Nlm74M/X7boVlj9oA1se3apCh3IG/JDGYsXeej4Ue5y8IUUV2CtQ776SnokQz/r8aUiN/96Mz58SUXJGFLHDxfHMM9VWJlS7sY7FdLCAc/u0V64Zx+0V++zt+2jbL7Vz/7rrwdDMNhQlvlUqCy9TZZThg1HeXlaR+1ywvxDvCyNTfmtQYoXAiFeCJR4WZhPqeNR0IiP2ZIg4m9dKh4FjP/6flW8LMDS3nYPXEC6Wx2PgogPfR0RPKqMR0FMzqORFfcPzD4QiZQMpBfjUShMziOR+3dVNq/5OvKiJ14SxNzPQodmxxjLPhqJ3KaMF4I799+tiNw8Fr1s1wORryuU8ULgLudDy12D16+I7Mb4JQVoes8D58NF8BivFgQ33xMBzp/FeB+BV9x/z/k3Y7xaQO7HeD0B43UFjFcLhHgUMJ4iXArxWgLGUwSIJwginiJAPEXo7bcpWK2jMRKWIRg0eqjy0ODB4h68guPBCEYwghGMEASBfLg3BANb5g7mcoct86eEFprQsu/LB2nCHmcbrUvP7iNU+DtnKSWTLQjZlIzFZVDgMkbQEsIy1xSEa8IyRvh7BEdmriDMOTJG0BLSMijAE3MeWUBp8eB4SHqwbA9egXkwghGMYAQjBEEgH+4NwaBWwaACy1bAFZQKsRhRyGSIQns7TYiFQjFtob+pqelKzq+Eu34tYbSdu7SPanbp9hAHQrfrj2GcA+OEQbdyoFVfiDU2ZjKNjfpC06qcbedWNWkLbXinIyB/ubCMPkjOCEb4+wVDMAjg1jBCkeTkpk20ChPppKawPSluJyY2awpzK8XdppUsqSUknY3MZXNSR9jupF1zo5Ne6SNsTzsOXgg9OXfApwJeOL1ZPIH//Lt0wAEmGaMLPl3COUofOeBs1By0WC/oxpFn9Kd1IXJyE2HhANwaxM1H3t4Be8UZwXydDiIOESMY4b8sLINLxf4Xwg4iQfwaF0Ah6YP5vndA6RuhYcGn/zsU8qeQ9DUQBShCE0QRogBFCAIWIQlQhCYAdRUhX/ICUrOf+1EQsIieULP33UNYxF+Yue66mZm9WMRXuI7PhGcOFUfyrp9Qx/dDlb1+I0FhL4fGdXu1pgsF6BJyzeVMAXap7mVsf3WCqcBB19T5xwM4rXXv+scD0sJhvEpAMF5DwHiKAPEU4Yv3bA1Q+KHF1hMwniJAPEEQ8RQB4gmCiKcIP7SY66eXJWE18hem9HbmJ/Q5pWxnIJDag0BrDwKtPQi09iDQ2oNAaw8CrT0ItPYg0NqDQGsPAq09CLT2INDag0BrDwKtPQi09iDQ2oNAaw8CrT0ItPYg0NqDQGsPAq09CLT2INDag0BrDwKtPQi09iDQ2oOAx/N0nu3m+97LhCodxm9oaHB/FqYlPO84E5OM6QqZGxwH4lHQi0eBEs8mJyRh51Lxmx1HEhrOWiLecZ63FsfvfN55fudOZfwNd1ctFi54ynGcXz5TxkN1y9sjxzlLHQ94hLtv2HnDTnFfLr6ccBb8VcejgCjjVYIqHgVCPAr+8SjI8UyKVwlnLY5PYrwkKOOrJCxCPAoa8SgQ4lHQiEehfHymSiloxqOgGY+CZjwKmvEoUOJRwHh/gRCPAsQ3NMDSagmGYHD6VvdU5NC6RGJdyD1N+dbT6h8crT3WmLEBvo6xddwGMo3H1u5QCuOvJ07PQpGCAPGzpxOvjysFO7dbFCkIIn53bskffi0UWRAwXiWEAB4a5lwIcDcMTwGlsK7IDsZ24DOlwBTYSH8/TRjv7R3X7VIull+i3t784sRy3k94EoMu4p7T3RGzR3O5UTvW0RhbNK23Fqb11tJpzXSsaiqc3d2RKSzcqzsSixcusePVwsLFoL1rxHBrQHzp1sAi5M03bkOsCzwUIYXtjQJu7/7e3hwKud7efjEGBWRB2SWbhlqQp9VHUC+cEvXWUCNvPrWg3N62P/39Af8Z+39BMASDGJEg7qUACpxIEIU1RIJ43sz/UlhDJIibjyoE8SAQQCEWM58buiw5z8twqISKGi+ykOIlhMJejGAEIxjBCIEU/A73hmAQJRLE9w//irDjTIJdcglLnNmhJ5yuqnr4Q9v+8OGqqtNawhn48VCtbdfC3Zm/QohLXPvNscdfXbfu1cePfXNtXMLiEmMszgcYG+BxNqb1HqgrXt/TE4/39NTHu3QEoId1ct7JejjXEgYHejqvGBi4orNnYNBXoI+BLtC7RB90Fqc1qyUMRwtjiA6XEZpkjjVPTY2NTU01H2uSsewyfJLIjyHxif4bv9ozN910pnbZvBf9Lwjm/fQy5Wwi1uk7iFtjbeJDosDYE3cQBQZFaIIoQhEoRawoc1m/u1UHq5OV/JZjDUBAKgeIAot2EQQs4i9QihRmKX5ZUXnzpVVLUFiHnjEskrhKY+EGs6yES2qXFKK7uGDKrwhWGEtxPhhn+gIb5Lxbu0tAJW/u4VGM99189ZWM3RnXmlbawtG3Bn3z0bc3+QVEfonSDwL0wwzG/12HSoinQD7c07+gGJb5759uowmx/tbxNlKFJt6bIwltl7bnNX0hJv505Ciz1J+5nbdmMjFtIdbKOe9oo6xDB+dtlIXLNY6vup0i9I/adiZAe8kIf6mwmsg/8AE1LxIJ4rQGUDAEg3OJ/EMCJ/ylV0AXkO7lf7MU/67IQUGRL/8/SzxWcvSwYlq5qy2+e2jemfcWsaS6mP6C47wt/lWaJQQbH3eADeXGIMcf3HBw3hG8LY/c8k4QP/eg47Jhw0F47umU5XleE04ddtsfhKepcA3Go1DCTPiNc+exO2+EZ8pOKwYcCh+CQYByEJ/i/y2zcNfBZ5jkV+AoPkNwt6IDmTO82GAGCvi9gFIz4Zk3Fh6+AQ9TmCeNAY3wof3XXbf/UBjaywsn704OLfOAx9ULt8hL1YWBOhGv3EviFkdeB388WfLCofXuXvFXCkKBSw4ij4Ev/brkhT/KLnFVvtQleZCyjF1S5KMtr4Pcmv8VB2NDMMg0hkhYdlsv9UTM0VU0AbiJJgCZEFGAgZAEINZOE4AraQLQ1EgSgFwHUYCB0ATgdpoA9DcSBRgISQBirTQBGKcKH7IlkIXaSxhJuOMJRhKuSjCSAN2nCNB9knDHWkYSoPsk4VPGKELtE4wkQPdJAnSfItRC9ykCdJ8kQPdJwocJGpYhGLASUgLCKVVcYAQj/CEhiJf3BFAI4MIZ4T8gpATm88iWBY9fUEXC4o0XEgXOoQhNgCI0QRQhClCEIGARkgBFCAIWIQlQhCBgEZIARTSFngEsoiXEu3SKoDAcrfQdCQoDlUwwlioWufKspqYfm36UcSs0MzydLE9FXViBK6SijJX06d2asI+wizXH2aBvPArNWc67dmG8r+DpPUGAeIqA8WqBEI8CxlMEiNcTMJ4iQDxBEPEUAeIJgoinCBBPEwzBoLocJ05EIqFQdTnKC44TiXBuhL9YmNt86lRzVlsY2soEW4f0hOkENH7rLbhJTOsIQ4l861tuyd8mhjQE6A+0TohbtlUWHA9zjK3NN7yFiQdzvmcXHWFvTTP2wdAHIEy/xY5IQsTDKZbID7q6Gm7h0amIB4WQqK7+QCFwD82iS2yoekh0qdn3/XRWjJVtnd4qHmQlQTWtCZxW0sJRtwZ18xG3d6Becf9LYanDvSEYxGTaQi5XRGUsWybHXdYzGSMsVyEn0wRte3vhJn6ZjMXL0T6a/6RO/W8Bt9cK2rWFlqsYcFWLrjBrLwj2rKZQUT3NgOnqCt0uvT+U/9o+9L72GL6rnt66dbr6O18Bjferq98X7WXhMpl4fhz5/jflZCwms5675GwZIyxXISpzRcilzVw/HVycIoH5FcDLRjixZcsJbeHejz766J3I7+yda0wcVRSAZ11I7szOuotdhKqogAQUUNCIGB5BbFEKlQpiG1RQqRWtViFNfLTxxdYnPlofhSoqWJVa8dGWIFbbVAk1Wqs1Ra21Rq1ijPX1Q+MPNZ65O7t32WF27lFqZ+F+oTNT5n5zzzn37mx3u7PjeQtWN3IJYykenZQxvpC6g0I3bw67V3qAlbv5k77u1xtu+PU6/ir94ab8wS2sCAgruIVVAWHV5AiKgfUspPVcV7r4WdJ+LiFvE8REI9qUxyVAF+qTq1Y9qUIHXAIYm1Rgk1/hFUBZv95/qK4HipEvO4o5Qdx/OkYR30c2XYQkJJP2CamhIZzw+RFHfM4t9P0AHHGEtuzjEt7sO0Kn702+kIaCwhBvDukQEcSUzp/0m7cAbx6qT6odiUTyIBGCTYQUJJLAHoj7cEwX4WQkk/P8MNShPU93DPEK6e+/Lz//vPz+++mcwpDa369qf4Y4hX7178vvuuvyv9V+7h5edQGvqkPcOWR/5nJ9ls2bA3SRrVZXq9m8VQI6tlRXb+mYpOfpk5HYcXoLQXxv6BTGn4xDUvJ+cWHQ5pJ/D1KATnACcM8epACd4ATaCVKATnAC7QQpQCc4AfBnWiAZr1VG37Lo5DKZ4sjRcFgJrBPn089s/PFpp4XAOgEh2eVawidAJ/oHcbswwsYuV3ImKqSWC76CHLiTdjiXfHXZ0w7+soLxtNNhMQ74gfv6m6TogIC74nqcUFdPEAI9PEaAwyMEeniMAIdHCPTwGAEOjxDo4TFC3ZU+FJLAHlz50oUuDBIhBBycgHGogHGogHGYwByEwByEwByEwByEwBxT4aali3rX3W3lMOGEfFWFn6XR+2FCar66OVW7ef3mqLExYbO6nMaVnx81HyasU28iS3tvomti7jBhkZoKjTeTperiqHULFxZDzoujCg8c+D08pD4V8oC1eWu3282ShiItUm9KhaTNWwPjyrpOvRvKatqaMn7ggKXmrSkWU4O1NgrRI2ECpjUVMK2pgGlNBUxrKmBaUwHTmgqY1lTAtKYCpjUVBPYgDYkd38wRAo9wFBI7/veaEA6KcDsSO34bjBB4BCcSSWAP8pDY8RloKggH/84GTUgk78Qc9oTJDoPwcXNz80u3pXjk9JI/YfNjS6Gpt/stDyAD/dm9TVGFw44+zOvdD62P/NIjt6yW5cqH6S9NhTrF3/SSB2h5yCPf+SX0kX5Lk1+pQwuTExKj8YNg0jfrtbUQoJMHoaxV2+HwRtADh58aKhL09LbjQ3QqCOjTvcAenI5EciERwr8X9vT4/T17uIU97yiUdyZSpLMNXKUA99yjAFcZ9xpPxtvylJ4zlPXrlTN6lLxtHBdB+RVlrdqzbVuPulZR/NbCNgXorFbV6k4F2GYpnKH4Ozs7s1U1G1Z+5QxLAeLoqVYp1T0QHY/g3wcdQBf7aDrWIfWomzpVoHOT2gMhWSedd4/SqWZnq53KPXmQNE9Z89R9nZ371DyrsrKBW6t0diprJx64Ewx8m6ZAsmthkfatca9EjDzRGuXryqlgVHbt2LHriZi5YGIqCOK6rBjl9a1lgVsonnUKIadcoVBmbU1STJAayDdLCmdpQhYhWWcpwDkv1pIaU+HSx4p8FzkLTgsJiVec4isvlU0FJXHeRb6ix+SzCgLCpcVFvnvTC84xFxRl7oZvSMN2WRNytzeQ2koaoplQoJGzZPt2pyZUlZRUyHIu/MpUOCVEPCHx7G/oyz8nT8gKoYXE/qbvj3PrxAWFXECWK2bPrtKSdm7duiQnV0Pf7w7ByjortyrL17C9UBPkn8p9F22YyyIom3/sfFmGRVlQOOfU9OKiouLrE+lIF5zqgJF/bF5i2M005ZwcWBQGBcej5b4sOGZwapyW67zIV/7TmcGQ5petcbvXlM0PhRRP2l48RwmffCcXLvkmNPmOheiPpYuQsJXOAyYAl+ZsfT2Yw5pLtBwuWVPG+Qrl7eAXvbzNKcSd+PZ8t3v+2yfGcQpz3TpzOYX1J7spJ6/nFDapK+JgXqxQN3ELavZzz2Wr3IJ/XzVln9/GLy2FIO5rGTs4GNcrT8AdUloTHdGQZAYIhJDWRDkaQpg2wizG3ICgzIqGpIRDhWnw7RfYpNFltePUEII9BPTpXmAPys8tWDZDw6G9nnbQzWUF55bPMEHykaycT7Qtmb7K0rY+yckiPlPhkyRSXgGdBAU4fEU5SfrEVJhx/3baSVCgh99+/wxTAf5AJ0UVBQGhoKKIHt5ccAByelW6HBDopgMwE0xfT5sKxIRJE0xfT+v760IEBVlHTzqEvr+e6NSHl7XYl1SZGxByK5N8xWFlfaC8ocHna2gofyAkLNsa7ysNH7hSX/zWZUGBft9oEizKQlPjXu3w4VND6+TeT0wFOLxx8kEnpgI9/HiBdmIqzIhOEdEp4hRuLi4ubmiAxc2cwoZgSBs4hWVlAaFsGacABdAEKAynAHz/+uvfw4pXAFpbZ6AEQAj2EwT2wBGO9lyY6+B9PQ1QQY6KEIQwWYIdT2RYwY5lFcJ0ESY43YvX07FAYgSOCCzvwyFHQCIQghCEIAQh2EGwOt2L7zmxKeJ5WghCEIIQpoUgnqdjFHEfjukiHKr7cHT093dghH61t1ft5xc6VHX5clXt4Bb6++5evvzuvn5uYVWrdgFR6ypu4TKFchl/0qsUYBWmrIXz5hWalRUJemrYcXoLgUfw+cT3hsYk4vrp6SKcjSR27i8qhP8o9CCx4wVEQhDfczKFOQyJ5EUihIMjPIwE/yorF4kdz0vTUihEgp8aVyGRDkcihIMjnIREEtgDx0QQiuXnvRmEIk/EfxBK20qNAttlFGpJrZnAdjGhNKuG1GSVGgS2K0JoIxptBoHtiuyhFg5Ta+yB7ULmgK4Sehz+R8GObwzaULDhwB28hyj2AYR/iGJPAlPqIeqYCB9FfN7bztjwrgBCOCjCQiR2fMoSwkERliKx43v3QuAR8pFIAnuQisSOpxkh8AgnIDE7CYyNIc8ac+YghZQUfqF7bGzsKY/n2e6POIXsnR6dp3hDujHFA6zczZsDGFr7jxBJ06C6EcLKlbt3r9zJL+yekw25z5m4ShciseM7ukIQ73tPYRxI7HiztkMkpFMQQk18TUN8DUIoJUApp1BSUVVyLgHOLamqKOEQfPFt5FFoD4u2eB+HAOHUVhCgohbC4gmJkKxKAlRmEcIRUlY5IUU1BKgpIqQ8y1JIIuNIikUhq0bjr0WL/qIb0ZNmXP3881fLFF5hyxYzIWlCflPV33Cf9163zmTHoRLW5as4oU9FCkv7+pbH0D/Wxee9YxR3gMKysjX65rHRODEo5MgyCNZcciiEEx3RcE4gyNFwSm8HgO2cwNYaC0GOBC3Mt0i6MIAWUmDrRBuOQ/SkbSzwcokdBRmH046CDcs6FcbBgUPcf9oupCOJmVe7MS6ce29t2ykl3EJFEqE0lPAJs30kSDGPUFFEGI9yCG0kjPJ0S6GSMLjeRCgdL7SZC+npVVVVlZWnjBfiZ8+eXUJ5lFJKkQgjy/DmwARI5q+diy0FX5SX4kwwrUsFsRaKKmVGPIdAapjRRngEUqRPiNnx3C/8ymvvLc6qia3/OJqWgsAe/Nfrsq5p19fXBNbtgTUjUhht0tejgXXTqIXQ3m5cG4WXRs/noOmRkDDnpDHVkmcPn8OEww+/b1SNyhi0CReAZ3tVU7p3QoPxAmAaV/4FsNcoADtHTaIxEVhchmhMBRYXiya6oNfr/MHB82F1I+yxEoALFg16P/7YO0ijMRNuvTV8T3t7U1N7O/zaXNit3sX2PDKoAoOPRBNuXTR4HxO8zara7I0mQHXOC9/TNDraRFPjTbrZ621mSU9mWSG0fDWMbDZw2KmBn3z46Y1/AOEforiTwAUgIE8z707KxZlNg4H1YHDdZCE0N0+4ZuBP9wJ7cBwSOwoJSKRSJNJMJP9CSJ1JZiIW/yYkQn9ABojVDwiMvdbHJ5qQGjx8Bt3QD8U22DKiSiMZI+MOZtigmhT4zeKRkZG97+2F5WJ2NH1NCxTKlPYAwnsZC2C1IOO9xYawDeOgZ3wHLO7YyypFF0GF5STRbWpMWCcSLLdxamQsGFmwgBWFboQsVjJJX0ON9s7cy+pEgmVhWkQPe7W2I3sDh9IVlgAbaon1bSwNYaqhh9TQD6sKi4oNOJt8DDYRx/VNxvfAKh8ZBmHzWc8BB/4kkIDEjqdKtCCwB/h3TtJQaIKC4FAKO3bghB2E7EAI0P7AATC4hTpywO0+QOp4hbT6b93At/VpnMKuY37XhN+P2cUntEJAlAOklUvYVe/Wqd/FJdQfcK/9BVjrPlDPI6SRD91xe1yuPXHuD0kah9BKIOW4d9+Ng7RJK5eQCDu8Xvh9IpeQRmYEhRkkjSvpr4PC1/V8ZX0gKDywi3PgXvio2+vt/ugF0so5NVJ785ub83tTd3FPvhNU4IT6NP7pvVlVN5M6zANo+XKyA/sQxZ4EbHdeiiagEO97xyzHRuCIIHK/5I5AjiByvxCmkOBsccr6ik/oOmO1E9qvPqOLT3jF5bp9tdO5+naX6xUuocu1sWU10LLR1cUlJLuGnWC0OIddydzCaoBXgJAy4fjQRyZnSMMu14oWp7Nlhcs1zFfWTJcrc3hYW/IOHLTVyOQdOIgqMzk5c9hGk08I/1nAn+4F9oBEMv7/slyRWAiqEIQgBCEIIQaFbKMgsAepkWRHx2KkjQjBbkI7UmgfQAoDHqTwgcfLLbQ3Njbu93gWNgJcwjEDHp0UL2dIjR7KwmNg2xUdPQcvbU8It7CfBsQvQI0GvCkeL7dQr2V7zMIBbqG9nq54e2AIIXaEYyIZv188T9uVIzOPRyF5brjsNYwjtX/geSgh4ZkubmHmzMaU24bggxjDybzCzCsXpox92pGQID+ezCUA+z07M9Qt4KQ/7uIRoJMPbvs5I+BcvNFlLQADKS9nAAEnM6owEjDaU3ZmUK7eIickvNZlKjAWrrw2Q3f6E1ipjcJIsJf9NCzmTFRqSQ8oGNZbCzJCvN/PSm0MCUQWFnPepKU2CCNs2ZjyVMY4ngfHyUot6Y0Z7R8EwloQ5gyxUrMqjYQWAxBWJNrUobOaVYmxECYKQHth9NMCgMAAjVYqWFzmQPKyXmKWg74e8Lz1c7AhK+9wV0RZgxY8nIJFYgPIhpzloLPfw/INTCvI1GTg6BwPZatPXFpLU6HRE5at+mnHxRu/MJ/etJi3/cyqzsbWKOjTDrINzgU2e0yFAchWL7jFqUDSiwnzRyu4PjwWwn6a7dXQmuN0JkExIVsoIefJT2qEL8nb0vEa/6nSs/IV1MkYf7oX2IM0JHa8P5AQ/idh7jkhErmEK+QQV3ALj3d1PY4RHGcmJ5/piCKkhbNBlucpf/6pzJPlDa3fhaj7rk5D8hp4TJZnfdfU9N0sWX7MuHdi4cy00dG0M/kFx1e/JCf/8pWDVxhOdlGSh/mEN8KIjdvBCWFSBHFd1hThWCSSG4kQbCKciOQf9s4vpq0qDOD3yprcc3tHibQrD+sS5AFWSjdoBLoCQgMdBHBL1ZksjKABM0KiiAjB+SfGNSLLQqKpY8yYzhoTYpbMbSZL9rTEB/ewGJ3xbXNz8XHvPvrd07LLein3+2I3T8f5BdoL5/zO933n3t7+v1dhdkLWgh27EFpd7Wac7tXVEEY4tmdd2HMMI7DVVRU06KqurmJS4rS/+mo77QA1x44xtBAyx+YHr2sPYYTuvcfMzqZ0bG83JsLeYw/z2otLKaQyjhraLKW9RETcvKWAwHF3Lz9HJigCHgLnaRZiMZLg7WT9JKGPsTRFOMrwgtcLFy6CkBxccmneOsb2eff1dc44C0sweOJQkiW8UAdozhEYMBBzuWYYJ+ZYQ39+4H2Q1mBX0kkAoyPRl+QLfr8XOa3eZJ/LNZCAMCiBZ9XlYnCBFLrMtXCIAXGUwOcpqZmz6sIIsYHcAdjig9gIsYYlvoJnWAfxBpQU7CYqBfm9LPHwEhFxW5ICRvATKYejq0qhJEI9EcVNRAqCCDVEFIkY6BaH1UPmM7KQvhWPCEwKUrCEVovunMBat0JhG8gLWyLiwx+qQC6aPK0ibhpSEE9QMYJEDJ4lIoVyFT4korDNUVXS87imiK5HmvBCkz4cDg/rTWgh4puORKZ9Eayg6mPDuj48pqtkgZ4SvejST6u14uTz6e0uyOfTZcozRET8EKMUpFAiQcRXpaUghVIJKhFFIgY1RER8kLgthWy2xn0xe9Z9Llvvrs/CUTOz59w12azbbTacg4bLvOEcNFw0GxTGLtePsHP1V9lPcDjIbP05NlJ/man19Wq+IcsbruYaSrTXGOzqZ+k06+8aRAoJrYHF46xBSyCFOs1vCn6tDimweKwuHq+LxRlWWNI64vEObQktDMbMD93FBtECS8Q1LZ6g7IzrOjvrSre7n/EnWIO/k3X4u1infx/r9ydZnd9fx5L+frYPGrr8HdDQwBL+GRDSaa/WkT6qNaT9mj+d1A6ll7RYukvTutIxbSl9SEvyhgbtaLpD86bTIr7/sC0FLxFFIgby+fR2EQ4QKcH99IM2BqQmM3B5cfKBo3CvspIBbZVXTa3ynqMQrLxIEirgvIrBYFsFWhgJmlSmTCEYdBbUjMmDysm2yosVppCq2Fq4WMkxhcpU0Fxq21rITuZIpSYnL7bxJZtARNlFRPEQkYIgQoCIIhGDmgLUAmxvc7oLYAVIQQpSkIIURBTIu3uJGKhE6A/Wq4mIKDz2WSqZ0NREFE6fpgkt1dUtaKHl0qVLJwC4akEJl6pPVFefMH+rL6EE9cTp6h7GeqpPn1BxNbRWn+Z1V7cyskBOiVw0eVpJK466aZA3vjJ651XA3QxVkO9PbxtqCmAFeAtwfAinFSAFKUhBClIQQXB6Pi3fnxaURuADN4oPGgHFMLle49y95jrvqlzhVxDEcXje8YoS+MBABIHhOR8EFI/nHSuI0/Dv5N7WsYI4De/JCbYgRYfPC7YgRYe3BHsQ+/CWkMcKYh/eA1iCPYh9eLtgD2If3hLsQQqGtwn2IAXD2wRbEGt4J4EHsQ1PFegp0YumTyt9xdE3DfrGR9+86Tcg+k2UvhMg72bIOzLyrpK8M6bv7iViUD6v6Ja90Jk86vUeTXYihYRLy+NKYIRO78bjjToLCbO/ZSQcBZ6PhctJ6NQK6HQQZgqFGQchXijEHQRvoeAlC+SUyEWTp5W64sibBnXjo27exBuQQLfpchPk695lyuh8gISivTLuoaDw8/kSBQhCFCAIVYAgRAGCBIgCBKEJPAhRgCA0AfhqlwOFghbrIh8tzD+AEWYwQSxhqWOgwe8cxBL2Fd5/eru2FFyD/J4HKwBxVpf24lMCGmJJ2/Almtb/vOL+uF2/NY8Ku192O/GI8OIRN0Hgw1MEGJ4g8OEpAgxPEPjwFAGGJwh8eIrw4vPyOCdliYDndJHCQ+bghyLsMD7/3NiBFlKplAHAFVKIGnmiSGHudYPz+hxOSBkPSeEi3FqPcAubkpEHk9KOHTt2zs3NGY2NBlyZfzoIkM3Qnp07h6LRoZ079wxBXg7CHPT5Z8/OWzvhZ88/YM851vA19PrcXPgc3K8RRUcbodzG11/nV1FnAXL5zsjz3S3kelgXcOsBiH7HiQp1i5PCo4JEDAJERPxSoMfG3TO7PJ75eY9n15m7GGGeseOe+TffnPccZ2weE+EMY8t/M/b3MmNncCkx9tUXjH3xFWObpfSWncyXVaZQ9WVmk0aF2el/puoAYweqnulndpT37PxalROqft2kUamyMTq+LoyPor7SPW4J4yghYAkBlOCxBA9GGN0ojJIFakrkokswreQVR9406Btfys7Ilznhy5GUHaXSxiTcFr7I/U7aWzcRHjB240/G/rzB2AOMwPsFM5kgNzERJh9AJsFgbgEh2HjiQpCIIhEDAY+Z878J165RhLW1NcOAC7Sw0GwAzQtoAQzeHy2Asbi4QCq6Fn5IwtrCwhpeqF3Qmr/5pllbqMUKzblZasYJwDWDc23TlPoavBrgSifSfg3wNvQNXLhpADcvDOQb/dDoyjcqjA0kva5OZtLn8iYH+NKFmzcvMIA39vGlzlyjEm5nJurhyHSIL7VHe1sYp6U3mmsMTUcOq7nGsKLr4SYWmhjWdd13uBu660CkVVVbIzoASvdhHywMT4RYUzh/7gSfzrGWLGyNSk+vbjI83TINUYDeiZaozom2TNgae6Dopl7dx1NUIbFIKwO6QYl2M6A1AsnwRkistwmKPhyCUlRoiUJXtd3UxtpBge7tYxNqQWPosKL7JlQeReejqz0QG0bnUSCZHmjk5cPoMJaPF+3rhU6c4d71EiPQCbA3KtH8373Tvfke4bFIXhoL+woah6MKj6OH2/Ol+qAmngRPEHL25ctvD+s8ewX+HWoxq+wxy+wJQT0tZt5mPS1N0NjzsLEFGlsVqIavfBhprJvx8qFUBkD5ucbuMRh8OpRrVKxczfStXK3aoNGqDQQKRQR5Ho5yQCcihScn+MaiPl90zIcTDk4c1FtadPg1Fx0EXzjqi4Rg/zusm7+w6IuGfVtFaG3Vh33Qm8MX4T9bCQchB9t/MLO0v+0kbVq/NYb2U4T9K4ZxHS+c/HbIAG7/jBWuGHmunMQJt9eF69gazueFk+iiv4fejYbxGVqAMlY+u9Km44U2A+ZWJwjnbwt2i5OCvJ8Wk3fcNSQUTyDopqCYX5egChCEKEAQogBB7hAFCEITgPk7RAGCUAUIQhOAG/UOFAq7mANSeEqEF/wOPCr88ormxCPCfU2jCL98opGEH3drFOGXKg2HYg1PEAIwPEWA4QkCH54ijO+Wx/cuS8rnVeltKNTyC4Lw/jVNu/Y+QZg1FheNWaRQuzhVO7s4NbU4Wzu1WIuJsGbM5mqYNdZQKS28UatNzc5OabVvLGAEyEmrXWtuXqvVICNnYWHWmDIts++UMbuAE2bNaZ3lAi6lqdrFxdopSAldtPb++xovmjqtlBV3ja840qZB3vjIm7dQtzgpFAgSMdhNRMRtSQoY4QUiir4Z/ETJlNfuJxgw4UML0J8bWGGY5RlGCuF1IUwWyClRiy7JtNJX3AtERNy8pYCAvruXiIE8X9Z2EQ4QEfEwDVJ4LMIBIiJu3lJAQN/dS8TAS0TEB4lSwAh+IiW7fxgZIQr19TThqtt9lSScdbvPUoSsG8gSBAgAIfCCOjJy9uzIiEqZpcuXS3Y/7Sci4uYtBXn+6acYHxERP5MoBYwQJqKwzXntNdr9Q4XHUyGYkPF4MhQhs+zxLGfQAu/PDaxwPGAKgeNYAQwzpeOUolkmU2zF1RNR3ESkIIhQUyOPR1aW6EUgC64iFBW0IvwnobdXtxgswkZhYkK3YEVYF3wHDx7s7oYLHzbCtMoAdRpfQ8T8UmmEUrQpWH/Fi7AhQigcDkWwRQPm+5oHw1jBTmcRnsCm8VcRZorwBF5k3kfkCTzL6iBSvOin+Sl+H5EnMEsxIvKDZ+WK/BzZdhFGiZToQHLLb721TBHeYh/fXQ7ghWX2sQe4ixUgwC5TO/5gmSwQU6IWXbJpJaK8Q0TEI21J4bEIEjEQ8AVa4YX9Kydpwoph7CcJ543blAi3h1aMlSsrP2OFb40cK1jhe6qwfygnnEfXsDLE+fkxrLjnNvJ2IS9tRMQHWFKQgvxe1jankYhiEJGCIMK7RER8e00Kj0V4kYiIdyhSkN/LeoqRn/feLoKfiIhfIJLCYxH2EhHxxE5SwAh7iCgSMRDwLZHyEYJBmnDqhx9O4YU7MPqnn0KUOzjhzm9H4AI6H/ntDkoIfnQqV8Opj4IIIZi7vHo1v+AknPr0iHmVYixlXh/59JST8DsfM8NYhgf43UnIM8LYCH5ab6TumRHupW7ghJTK8qgpjBCsYA+pCGIi3MjC2G1tECd7AxGBK5NBiDQJ3VEpTW4giBEyVg0ZhADGBpA1tN3jtDnXYBnZ7L02wXYCT7cgEYO6QrzaliisEClI4SkWatxbIgUplJGgFuIkSMSgLE4nbTIOPyRhFE67SxDuv7Jb03a/ch8tBKA/GAGsELg/yrkf+H+mdZyIiK/dS+Ff9s4ltIkgDMCuD9iZjCIhi14U1IOPPGwSjAn1kWg0iEYTlRZ8sJUQ8SC1CKK3QiOEqgcR3140ggf1olUqXoogKHhSai7agiBSEAVPXjz47yZtYrJj/kGrY52v2jbd+f79/52ZbZvsTidFOC+IjL/4KUH9Pj2FMThoHKZRDoTDLwn9bSJC24iXPVndj74Nt+0Be2K1RgsjbFubtRu0sI2tBusJe3IDJzxnDFquZoz1I4v2sju0f4SxbauRwmX7jyc+GBmhSKHfy6BtG7whBXryAXuw+g6+HyD6yTs32oTvn/6DAr9oP4e/93KzjD8JiAoyvoq/RBAZD6taj+wfRcKxpITDux04/BNhu8uB7Rhh/tJrA1cEhKUziHbz2sB8rDBAyKP5AinN18g+aI8XYAcDQkU/JeTK5Ar4lPBF4w8rvuPEh4b44MMP739riv4vgkIOVjXAGljUQNNNH42C3oASlKAEJShBBkH4dK+QA40D94kQwkHn8BuE7ksHJlOA5gAoooJMNdgoQQlKUAJf0Dio570lh6Iw8pqFb6QPJxgRYnHAdLtRQjhOLC73uXFCTCNAN4RHCUaCWNyC8E5CLJDO03rS/onwwO3nPwrhcF6LR1NJOkHSVxfevEFpg0Bseug4PXb4D3bzviOUNgqpuC0ExtMP1YX/2kZtweHwEV+soket8N+qyTuv5VUxwtQi4JsIb56k1EmANtBIiycokIHm17+NJ88RDJqJR/zUqAwGCF9NnicAyTSNVauB8LXkawJ3MLzrqyaPEBJW+GryCCHtr4Tvg+QxAgyGGd+qyWOEHju8nTxGMEIQvpI8SoDB8M60k8cJAR+Et5PHCRnyyXR/gORxghGB8CYkjxTC8U9m35E2ihViEN6qFSskPpm3+ynFCmn/N2t+o4XkIatWvND1DZLHC8a5r9BRAsJZSF5IUMgBdSKtAWmBpRsNAhi/WYhFQ/mkoxCwtjQLIQIEnIQ8AWJNghEI5EnIMaVkIEMizUIm6iN5RyETjZNQk5CBJn7DSeiytqSbBD/pSqUdhRDpCacNxz2QCG8PJNpcQz4ajSaca4AtkT/Y04YTKQKkDCdkvLpIVBAu+g/OuIA/kQk7CknYwptxSe6MCzjMuFjCecbBljxxGHw9/jhnxnX5uTMuzZsP0ZTjjDO4M84wmoQ8d8b1cGZcIu7zOZ9m8rDlD864n53u1fdpmZHwVgAl1BgdFRR6e0WEFR0dxWJHxwqsAPEZ0CuSEhi9uJSqy5ocGx4+Vv8FvjBcLWLOnGoJwy0Eb0PE094WQvHV6I9LyRRbCL2suKLu+BZZb6uiGYP1aap0vGKsRdFQJGPsWMcoZNNRhE+HWy9QA1FrvFrRUoA669qPotY5uceq3MOuczLaO1wsDveOyjXjlKDuy5KQRYLIeE3iVBDoD0j4x0f+E0HChdn/S0HCVdD/S0EhB64GljTQ8hJD0oASprjw9q2Y8NbtfosWPron+IgSzmTdVbJnMELtKoW+W8ganrpso8/1FCnsc606Aaxy7UMKZKnLZinBCtqACxjQ0AJk9fTpPtnGkhL+srCkAXVflqRIuFb8FBYWLhQUOjuFhOVxTYsvxwtgELJcKKXOq1c7hYSF8A8rLOc84Arx5Z3V4As7l8dbCvs7NXJ1/MFVonXuFxZEUxIvGn9YxTtOdGiID75JHN7A/oXSzempLSjkgDbiZXUE9UaU8J8LY273GFoIjo2NuQH4EEQJ0HqcMVxKQfcbHXjjDmJrGKsIY/iiL1cWcptEwXuH0jtetAC8MM0XTET4CE9RSDaWlCC9oJADCV+qVYISfq/gqdBuscFij8UOYFaFeRWOHpXxAnElKOF3CZog0xRyML2RxbSOxU2bp81t5EehabMSJlcoCAqF1wURAdozMET2kDMHBVMqFwSFg4JCuVwWEw6ykohQys09PLccxAvBnMnMHBMRoB/EhAK8CQlmVmgPg+VBc/CwKdl8UMJPBPHTvUIOmCDiQlYQGHxiTGUh+1pEyOWyjGVzObQwyGwG8XvI2uQmsWj4rl0oiwhZViqx1wJCkAElpFCofxq7gNlDrjQulHK4lArs8nPgMiug+6HoAor4fjC9G12ujV4TK5RZsFwsloOsjBPAKOcYy5XLAkPDLJVM2Wbc3xSygvyBs7dCDh4PxWMGBRIrdX1lntokh+ZRDtP26O+7o0lLWKbryxIUSN3dqe/gCl0X2z17Z0TCE4KRX+nZsI5wBWpk9nraL5JEpCJ0rWn3nFoSSXEF+J++/17f84xYgv/ZHn3nFitFrhCx8HU/ezbDErauXbuZED98iSusnGCWrs+qPeIKOoffJyybwEqp9ogr+AFCNm/atNUqesbQULfPb0ErzJxdZWbtsCb9W5d59jyLWgL5vMGz936aAjwhFVqypr19TY9h93QkpEHPX8wY9cKXL/WCdmGDZxnEHB8aYf+MvZ4Nn2M14cuCBV/qhFn60bspWj/4AtHu9/oOvjAE46BeALp8Q4+5KdGfIi7sevny5fHj8G4XVoAT9sOH8A4rLF4/12b9YqQARrU9VoCs1q/fJfcNdUrACWo9sn8SaV9TnJLCd/bOJbSJKArDSUWY2wlNFomVUBGMpeKjhka06UNjaTWtOr5qFqVoBTU+ErGKBLoKtJu6C4pYUOILXEgTQUWEbsxKRUZcGNwUFFHBTVZuxTMnmUxtMjP3gI9R5mtDJvR+/z3n3ukiQzpNJIhCLkcUYjGaEBfFOEnIxWI5khDL5WJ8gjSsEBNj8I2HkpGAhigOKwUpj2FRlMxLig+LEjQAbUjicJyrh5woJmDrRBE0DgGNWDweg/G8ArQritA6rxAXJUWQcO/4esCS+HvA6rETPiEeSwiIFIvzCS3qUUvcSr+itmB/jsyCvFxLw+FpGGqioFz9eUkVYBKiAJPQBJyEJOAkNAEnoQjIHEnASa68MEMRHsMjAY/DcNA1yIwB4Zj7NVwbT3gOr3B/hEmunjTE4YGBYJx4gk8Kj91GgKAYx1yf1fHw+rWxUCxKK9yFjPtYsQidGE+CQmK/60bG7S64XHCJ1WwSLKmLnU253cucAQ+vAOOXwfcuOOYpyfMpBfGKxNU0LtKyp9Ho9xTXsuLGpY9MQu9vKxt31BA8NaTKucd3aixk8ts9M34SirddpiwQJo+4OHBQ4lGgxKNAiUeBFI8CxhMEjKcIxdunSThsrME6Ila8d9GvEt69Iwqzs0QhEKAJ9xi7RxJmGZvVES7WJcBYoP5PHGI9ZhgwQ7jZ0QMGPDAX2u5UWMKAJeqrNj0B7/JRg/OhUUkzo2wRozMmPWD5Gg/Mm26DBlSWtPGs0vLRajnL+ZZVE/j2YYZVmakjSDVMaMKEVINDqCEKIwMHDgTgKcrzPq5PGTgiCCOK2MchrGGsxysA3h7G1nAIA4PN6mHz4IC50Nfbrb3o7u0zFbyLXv4Lb49biDhsrEEjD6FOp3NiskGBR/AdZ2xHl6cMh9DfydhEg0cVKPEAlMQbj1yOLhBu3W+cD9aJv6zFX2WsKkwH77uuuaaCz43iGftQFe668K9jXdNG8aOnmrSSdrsUrmnxkdr4tU1V4dYjV5ln09X4aE08oJW0uzx+yige0Jpeh8Ijg/ifhftbrsH4+fkpo3hNwKIeTe2e1o+vFaaDjZX4q3rxqqDh264fXyuYxqNgHH9TjdcESjwKlHgUKPEo1I2f0IlHgRCPAiUehZr4HRivL1DiUaDEo0CJR0GL7zKNR4ESjwIpHktSmJxwOm+esu/v/S/RWMFCH12wBVvQEbYQ+f3XZsgl/dFlDff3hwlCKNzhdHaEQ9yCL8KAiI9X8I2VhTEf7wzhshAml8TfdHsH/Der9hBxWS3x+6Ae2J8j+99pjzhJOBqDxxkFx6pDB0MbSIIgbFs1tp4kCC2v9nRQBOD6eHuEIgBvgvsIgtcrCNg8p9Ac7V0qKM2H13MJ3VHGegS+5lHYxYCtleb7O82FHgYs1Zp3mvawcaC3WagAze/cYCzUsG0cmqcI0Lxvu4GAIxYxDhdBjE+NVf3bF9HhNCzp0Pg+yrmExhi/MNLXDH0cbHdyCs2XBtn5EUE42L+eTzgPz7u8MNOrUIRDwHOvcva92RnhnqG7vMl7OjmEvQcGBkf6hLIR3MyxSt3eEUHlerDDXNDATT9OEXALz1EEoGU8TBNw0ykC8Ep30x0+nUuUoYh9nxNL00DEin92aAs8QhcRK95OyRZ+i9BOxIpv/GyBR/ARcdhYg01ELC/4FbgF/4VsspQvJbPv/TzCl0KyFciXSq2tyaEvpoI/24oU0viU9ZsI/nwrkk5VDvJ+A0HLTxbwAOfQE1YryK0qKCDy6rqgMIf9YgupgnqYlPSFK+qgUiaVKqkvrugKZ6p1yNlMVq5WpytIWkWyLA8Z1oTCHFaB5OV89bg0pye8xJ9rTavMccyQTWc5ZkgktZIKWknJovkqDWUKGW2VzpjvQzoPX9o+mO+0LKdkWa0oUV9YqVBQ+wRBXYGmlXUpC1+zamw6qXbwVVdAI18eL6flspGH8XqCNkc+pZDXz0dBNQpJZTwaycJKwFBA5UI6A8Mz6QsQzyGgA+BoXgH564KNNfjB3hmjIAxDYVg3pZ2cHMQhGcRBr1A8Q3H0DuYC3sDdwc1CJ6+QEzSD5+gidOloTQcxDr5fCj7lfRSy9KN5aUhpC3+ec05WHHNOtp/knCwk56QJtCDnnHhUmpimoeWceIqBF0g5Jx6jfJ9oOScPCDknnlS1dRhizkmx9hWr44UaKjJJ2lYRBaMM/7cswjkqxQSTHAvsCslEYUJqDLdR+j9B4MEUhOPeayJQhDlIR99btc1zq+mCdnFdx06TBRufN5tzbMlC7k5ZdnI5IGTXawYI9rBfLvcHixTtmkN3NKwg8NTgOL1FIIAv9wIPRiAi/KqwA/nWj1RdlWWlAaEaNVSAUN6FEhbgLnVVNAguzEB6EYgITIQxSE/gwTigH/By46KAYUAUIIIIIoggAgfh3XIvz+kbO2eI4zAMRFEVVBrjbynEJMqCAa32AK2qKiBqtUfyHqCkNykyKG5PEVQS3EPsrEdKVDDGAXkoA97/kTXUnintKSHTMBE3yKRTa94X9cTHCMH9Cw5CPDJ5U7hW1HYpC5dLFlLXUnU1BeChJY7rmp3GP4CCACnZdUl/KXU7iUdBWAmu+WmcCvlzJZjC98gduE+TKZBQf9VEYXi9hqCDUBTol0TA84mgQ0ngkfcwvKfJFNwIh8DTVDrWfu+r81ZPaXuu/L4HYAvxtvaHTQ8V0G8Ofn2LtqDxcVqNqCWmoPGCrgYALTGFHP+xrVoyv8fwFmERZigs/LFzxyYAxCAUhjlSuoAbuJSLhZQuEEjjABnsELne1xwpYvU3XyvYeMbce/pPoAqCMUDQOwYaUYPAJJoQECJBQItqANhRGwASJXXwcBQ/ZWCZVgYrc5UBZ3IV+NdeBOpuROauRRAmH5qeBE5cAveeftk5Qx2IQRiAqiU8z4UPmJm7D+hGcksgITjkfdI8/3tMnG+TiYk9gXuiUGqgfTDzMnLHP4lm4WPE/uL3NnLBaF/xFkFijSUvaiEUCCsk0Ql7heomYNMJGxCdK0DTCLKKnCF7kW/UCBNp/8dSdQJ1coMDVIIAwQ0iJGXQs3djHkmAptzW7jtz83XTHtyRAfoqhtSAvFybfEbsFwgj5iJwx0J2Lk//9I8cM7ZtIIahaEoWXIKAFtBSbNReQ0ADaI6rpBluuVj6ROSYOdwAeZVs4JMU9UkD/g8QycGOCoHELxIBUXYO8YlrmUElYPzCCFQGue0Rtc4gEZjnnW3RjSAA1aN4WGVWT5Z3cgicdCIOPg3mgRNynyluDRlvkeo+TIb8uWYunpTVBuZ1xcKT624vFZ3ZZZ4glFmnFoqCXRaKF+apGygnCjYto4KcUWNuT6vSdFVjtupSowfBckoja82oTS8EQe7Hlex3Eqpo8MfX6Tp6/mKgo7Yiu7/v3ZTS6lAGLnBWOqHsnzzo0/98l7AjSHUvQI60M6QZPwjiLQ6fl3ADCGKfRDF/sUcvQQmtTmp0jXGRaQqPVOLDVRgVlq2Pv6LW4b7e4b1uQRC8pwK34i653QlgI58gw9IoWC53gqIwxJ44mERLFGwHDZxdSMNdFQW+A05/up9nOxFGPgXlm72zi4mjigLwTlaSuTsXa+KsbGIhwSWhsFsaIFWQQrf8SqBFUSFpQLFKtWC0Eq3Wf2PQhuBPSKouaG1oQ2tik1aiLjGtTYsPTcSfFpvaxKRGffChpoma+GLimbusszvdmTlHSx3q/Up3lvZ+55w79+5sdnd27mTGkWw/7J+M49jkYKbwtOVYWW7MpKz/5cs4Uu7Pdmzdn36sFEJROTcPlGYdgyn77/8uEkKhyCnYYe4wc9eIfZwqq1Cua+kVPPjdgStXKCjp7SUI4zEGRLsLcEKJaC6UXoxQEmWsqru3t/s4KL3uQgHE784t6O8vyO0Go8BVGDfa537w0EMf5BrGuJtQwNhx2PT7/f2wOc6iCKEkt7t7HGJ3d+eWwG8uQjeUbfQDiMEdd6Ek2U8wYrBBCL3JJgqQ1EtQnS6J3XNPrATRaWDcCNr7wQMPvN8LCcB2E3qjLFqS+z4IMOaYgRPjO/4AALkgmasgDMUQFKZ046Z3wfGYIfjHe9EPoBJD6KU84nq3bu312EFgaQkSb6CarAobJ1+tbFWdyBCYENqkIAVDqDVpTgqs1gkfSycpOOK7logXBWqnybvVi1NDCt4TEId7+XraK6gXUx92IJuwkTngfWGjWk8SRsI723IoQh38yxBFWMNYmJihKZxH6nQH/FH1Tge8uHyuFC6XsHyDA9mE+zUHpLBUBYk3UNIoReBjaVyNQAr/Ttjy/fdbjG3pCZSwZTe7CTaGsPvE8BZXYZhB+yQnFLbHNcNNjH2fuutnLFHqIpRCI7Py8+eHh10ESJBIKw9cF+EgYwfNJlCPm5Bg7DxpHHYz1kMS9sD9LWk1uQrDLGNX3uQqnGCmAbqbAHzPgN3fGcqW8wnEXCpNMAMlkfAzP2rylZ5nCySgvbsgSlGM5lA/ThAPhBOl3nqILiGBfLiXeAMPfiQihX8kVE9tat80VY0WhnmSYaSwi6fYhRK2cZMxjNDOTSIIoZqns81dGMsQxsgCuSRqp8m7lTpw1KlBnXxeejxIQX4+feVw1+P5JHzqnfcto2C81XIXVYAkRAGSUAVIQhQgST5RgCQ0QSQhCpCEJgBvX+cCCJnU1DFG/Pwhr5UoQBKaIJKQBECvIwuLWRKEX8TdSh+4098VO5MpLL9DcyND2NClEQQRniJAeIIgwlMECE8QRHiKAOEJgghPETasltcNXZIoNug2+JgNqg3/SlAUolBRQRTKygiCEo1Gg0G4UZBCVUtA0FKFLUnpCwB9CqEPwUAgSOn0jYHGxsCNBKHvVsZu7SMIMXFDnhpeEAI2MBu8IbS1EYWdO4nC0BBBaGttbdV1uGlDCs0dqqCjGVtSeIUKrAjj+xDWVVUPEzpdq+blqbUEoXOEsZFOgtAsbi7nXAraoNjgk3iDL++6hoRv2bIfqMIySEITIAlRsE9yb1bBJsmLp1+8l7+YTbBJsplPTnI+efeDNoI1yYM8xWmrYJPkG57kY5sM1iQfl3ODcojvIJhJHtzMk9x2r51gTXKbSMBvg5qcBDPJN9D8wWvKP76XP+goAB8mB03sn/J74cdRMJNMGrVsuMZFePzc30kWKjntWNK58/ecM5MkhbsdO/3mA2ZPTGyE/HwoSdyYSZyE1x5++DXRjZdeh61I4iw8vvuefJHoAT+kMJPYCvkvvZS889JL+eaY2AumaBkTN+G6F6wD7yK8di7LwNsL566zmV12I73bf85mdtlkeP11uLFPAgIWSEIUIAlREEl8+TQ+9Em8gU5kiZyuKoWLhDwil2adpkQPA3oSWEEJxRkQDylIIaFNsJkZNqElkMKslpiZm5tJaLOEDEeOEDIo8VACtFAc2wdoq8XjGlhYgfmn4/Fp/yVaL6uMiBevtCUFeT2yKxjdgmLB9Xna7R1FKUhBClKQghcE8uFe4g0q1gdJ+FisMUDBxxhbF6QJh1msjCCEDw+coSTxsRlDgCSUkgB0EhAEIglNACqCRAGSYIXwAcYOJJPghBl++AgPY5II4cjhAxw4fMBM4iJwQCjuPRFCeIAL5sQv7LBTEp/R4Tm+wD5IMbpvbgaSEIXWPNWG7CXV6aod2ToN4e3JslshvAMZA+caHrBODQiPEgAzPF6A8ARBhEcJM/jwQOog0AzhUYjDjBkeVdLhsAiPFkR4iiDCE4S6Gt0R+TztURgRKUjhShY8+IGFFKRwqQRdl8/TSxLtIjaoTkjhChFWP9ZevvnpQrTQEDFXM8EIDTzFdpSwOsKTxWzn+1ECJEgJfBAjHDKEVbWdhrADLdSxEbTQYFSSU7tRLYI7yE4/urBMxH70boVBM5ay2E4YuHIxcMSp4aXZKoVFE+R1Q5cCt9+vk/AFblirEhDfdLn9TqIASWiCSEIUIAlNAJ56cg0GEFIEKxgCEEzKokQBkqCFllSSGFLorzSToITYrYEUr3za5MCCUMmq4BYzJiCUAVBHH2ygLreB96V9JY6tC7onMUoK9jODaBncxwjAOgY0wh1USYAoaiuy00ALizVuZSvxu3VrBfS2MtaCHrhk9cEW5NSgTz769KY/gOgPUdj3i3mYgfCLeKgkH4zhcC9fTy9JmIWHPrreEVMwla9pAqQgCKI5Sfjla6LAFFCInfbTOh2mZKD3gb6XhLKoI02fS0fh30gC7FWEQFHoAnEq0TstH6KX5yGqyIdoFkHiDYIWXE8ADFhwO8VQClKQghSk4AUhaEGe771ECFjgFlQLUpCCFKQghf+HIPEGUSJePEdXChihgogXL9MghUUR1hLx4pnMUsAIy4n4JN7Ag0u0/MfC1KltYwRh26lNmyJT1dVoYZgL8MI2brDpFFYYi/CkUY3NUJ1sj+/01CbI0R4ZQwtX5f6xa9MwbPDjMJZ7atvlnxqciBRQwjNEfFcTkQJK+IyIT+INbrCBvFDBogh9NGH9jQoYlYQMWytagn1VfVihJRCEP2VKGU4Ilq2sDsK2MliJzFDGqml7qXJ9ZTJTECmI1tWB4EqC0LIyWkYbuP70i494Yy5lsJReA0lBCosoyO9lLQUUIl58R5dlJxymCaNzc6Mk4QDnByjCzMyZMzMzeOEM5wMDnJ/BCqN8gVGUYF5HayCMEiZ6RlPCaM+Eu+APhfbx9qnh4al2vi8U8rsKs9pZHhHvG5yK8LParKswoTXwXalVlhu0iewCTNvoAsXaIT6cel/jkFZ8/G/GBb5cCxcyhQuur9j3gvBW/MLevRfib4GwFyE08Jc1wcu8ASH8pq3m0BBo4Hy19puLAHwLNfFDZ88at9q3ua4CpNAe44LHNEjgLkAvtLOPtbc/dlaDHiAEYQigPUYArrqgAd9elYsVYPQuwE8uXti71/jryff55PrT/2c2dK0mQV/ylL6oKiCSLObCsGaSxVrclpSEvkAvfQngTE4/1+CMVRAX13ACBCtFk0TBTDJvbhwEM8nJ57nBO8fcBUgC7Z5fduyLiNi8ixH4fP6y5yNicyyCKulk/rHnjYryjx3DdXr+Hf6EsTkJm3+xW8kDR54acv3pJbv+NPVwL/EGGhEpeFSYVaYnlOkepVjpCRk/iqvApg+y6R5WzHpCTAkxhhImaMI0UxhTCEIoYbQHwd+DEKAYTYuHQhMsAb9BYS5CD/OHpvfsKZ5mbNpozyZcBOaPaweh2QSbhd+m2Z6Qi1AMDeLTsJhVXAPgdhGmxmxPGnsQQsbCXQlMSaG4YJYBiAxmpoSi9MS98HiQwiURJN7gaisRnka5akUKV5gQiRCF+Xmi0NVFEyKlpRG08PL8/PxzV1/9HGxeRgmRrtTdrgiypOdKjTulz+H7cMi4c4jQ6S5REEEoLZ2fLy3FC/Nd7Zy3d82jhZNccNJbs1UKiyrIz6e9ynIiXjzX4T8QBosoQqE6WM6LYIMVdmwu55zvfxovcIGTsDaN5er2TwSDqrrWBl8gjTshgm78AAEbrEJHW3NTOA8t6Pqq5HJHOlLoYAsMYUuqaWUGHeg+FP46ylj410Kk8Hbhe3xfG/uVby68EyV8vX2yfHBnc+Hm8sG1KOERdftgPWN5hYPqIwgBuF1V82qbOlX184CtUJHB0RoV0I9W2HLRdeHWdGwcafPkSSpSSIf+NVyJNwhmo3HAyp921yMTBDfxTMpznE+5HeaZPFuvOgqv8Ex+11VHYb2loD/dzgKe4ulMdqguws+Z5deoLsL6dkv5bsIuS/luwrbM8l2FlkhG+e7CHxnluwtjNuWb6BlCpWP5QP1Iq8865+zL14dqjeNStjn3u3oxG0daGcsUGs3yswc3BbMgUb5NcKswlbV8CN7EgIuFn7OWv3ENBL9YMOfcn7bBrcIua/kQvI0xW2GbWb5tcIHiM+ecWX5H1uD+PRPFcc2XmnPlfzoE74G2IU0ghDEof2P24EpidjqebGsKlany9c6mjLYHp+OaFRCCf0D5ZnCz3KyAMAzlm8F7ZlPl2gmNUD4Et5RrLwR/r++8Ja0EV+GFN6BtCI9P4g1CRLz4GYoUMEIxES++HJDCogglRLx4YrIUMEIBEZ/EG+hELuObzHlrVtWoqo4W6lgnNF9VV4MUOtkaI/yqOlXHCW2sRs2r69D1+rohjFDPWqEXzUb0phVoQTfKgT2NLgler9XXj3Tg+rDC6HReW73evIKwW2ugnJoa9MDVrarx6gcWLnjxWVQKUrhUgkLEJ/EGdTrx82nWnEc+8tXpRIG15tEEkYQoQBKaIJIQBUhCE0QSogBJCMLo3MBhkQQnrMjpKCoqysmBJDghR00ieoITcoGf1GRPcMJ4NCmIJAihIMpKhCCS/Pi2ydp0ksIBPqgWMNb9k7rw5fVYWcCGpDDDd6ivlJQU3FnIjzCgIhhwFsID+9XlX73yqvoJnzHD2wqipvcKVRXanxHh3QV2hE9+smM/3xcW4RECmzkzN7DvgAiPE8ydQxAgPEEQ4SkChCcIIjxFgPAEQYSnCLD4KkWINQYo+CA8TZB4gyv4Oif/I6EpZ4Gd9kJfGtGdxqdsOXAzwvps8AXSqDKENbW6IQRsuEhohbQ6RcjZ2ZRHydAxVHvLUA5BWBNmLFxLKUk9+ouKLmnlLap6O5zstVzdGUUJ/eyrgOCp1htRwnqlar2xDd7IGhECUMZi1XBbxbYGbIWPMjjqZ7EYazv6kS0+1cIQnKmmL7F3Tv6Xgq7L9aeXJPJ5mixUNCYpwwq3pg6yiyoEXYSKdEAoi8JLg0rsOhz96/ohSFV1FXb9h60sCVpYHzP7ghCARmGsC2AFyLEutrJ6qa2SsfjCzUS8+AwkBfk8/Rc797PiNBSFATxVBFOD1j8RUVpQXKitYi1oiwhZCHZh0SroxlpqcUAIbXddawsyiHTWFaSKu9mJ0LWI4AuYjeg7+Aae3CRNE5Ob8wlqlHybmPH8zk1yb+5ipjP/cfLsbL4vU/hgu6zZ8YDecrdKPa69RvFB7ebDq2IzfnizJmmvPX3mgpZRuWYfr1WMlqQ9/bKtC/Sbo5aAo5u6pP1eD7jDkJG3D4JzFy6cy8vah4FuGLq8fRg0GrqkfQhcq7nP95qsvQ/OXbzYsI+NixdX93Ep0D48glFxjhVD1t4H+tWaMw+1q7qkvQCMZy8D0vYCIO0FQNoLENO+TO2jAdJeAKR9GFzSZO09gLQXAGkvANJegGD7b3s5YBqaWjlA2guAtBcAaS8A0l6AMoWePR9kSUdS+JnE/xh0OiCYz0FgGBjoqGoHAnNVnUPAUFWDB05/EFEpzr9OywGJnLqW3OnkSyrV/fp6iXUPc69+zr3puVfPBYYDDC4o2Xdr33uJCe5S806HhrnLBHV17txJnQdKldPulFRKLNAprWgnTa9oBrK/753CHHHzgr6n3bzM+EbIyz1uXtg/F2V8GlvDBAFMEACF8gAUyhgUyr6fRfOQFGCCQKTYFRsCEUISApQiWxCIEvfiQyAs5CEACQKQwAF+SfBNw48VnziwXo1efPWrtbgokfW65FvxWD0BrJ4AVk8AqyeA1RMI1p+l+gQA1VMC2329pSdGyZKO7AfzD4DBMHg+HMjBYDwbBM5n45wMUH1vPFzrP+493p+LB6J+3NvyzrfobPF4PIgFQ1E/Ky6c00VxNrDPh5JLEvU975TGoq8MZDc9dOqbt27cuNW0L2rWG8of67Zdf8r97S4ao7idNHELUb8SC8ZMN3ev0mQtjVs+uMUCN3xwgwUO5lc5yALPffCcBT744AMD0HMcefUjccqYOFeM3IljLI16o1Zr1BlLY0DLObj4dkoX33BG78tifXnv3P+YlrfsBdq5FXyBtvbTC4S+osgmsKBNAN1m/vrO9xtAlnTk6LgIRcmf+L4PiUK7w1EU0CAgoEFQQIOAgAZBAQ0CAhoEBTTILCkEAjlnqPK44PxK6G+vSOOCzUv+ILfvFyTxgDbNb77y7uQYB1x/V97kDCLAq6/2H+Z6I2q9QaRgigJxSdeBSyJQnuanb5Cb3gYea3jimtLASyMIzr96lJQA+PRxb2LWX6DDdA4Aao+A89QeAdQeAKI9Aqg9AER7BHw6g0XJko4cB5PGDzFmgANOglE0MBn4V8FJMGlc3hlgBN/us6Qjf2LXuONm+cTJF+31640dETFftx2wx8nygBMCWrUQEZP+IxpsmGYhUphxoBCTHTIwAcGyCgINBJNfBZMNkw/63W63rXULEyfJoKvZ6Vp9S2TCBpYpwh6h4NQvk4G1/EygvXTS5TylpbaWPgra8pmu2qC/DpZSQM0tq7+xDkwpoOah0BflwF1Ln+lSKFXNSgDWZxc4xyoxKfBitrviUO3zAL3ENrBoFrgjmBN7kdNBAHwTwLcZfCPDt0owOMiSjuih5EI5FIqSD0UNZXcoGchABjKQgR/snU+IElEcx+exh/yV4CUThBZCgpa0aIUw0qilP4ZBYQdBCQqxkYI1O7S1BOXFw16mFlIwoo1YilqopEPMIakNFoLAW9HJJBg8RHRMIfrNc2ae+2rqTbAg5Oew7Izz+f5+v+fTk6PDIPzt7X50//SQIicTsKT5/Z2YLMvRuh9pzso+zW+DFDt+/BDsbzNBq16Uo1C0FbSlpDxHoG4K7ZUpNQ4R+wrYwa0p9TCQvlBPyjsDgIXsK2ha+4xPjQEVDvvUQ0A6mmYvgAkVwOAPM0yZyDrW0UlbQf49/y4U281Op1lkgmqBl6WtA0No/nhw7tj2bvfdy7wpBBECAAFj6EAiAHjKWKZ8t7v1+4ut3W73g2YIetUQHFa3UYHA0YvyXAdPWkL3eSD+apXQDMI+2TdNhXqH4IG6pFkC8uTrVibg1tBDZ5vm1qDl5Fnj4S+3dd68uX37R9EQ9kNsSm0UB3bre4CouUr5R/OpWihSC6XumxUilXTmvb4eK+l0epZ23w5FGsbD9ezbx4bANt+f6GSzr3UhIioUH2VfP969+1LrXlVEQD5lsy3l28xMuS0otG8UwuFer7fkFxKQ+R369fOaoIB05nu9quYXFRCtg/0LCYyRsObCOodII4aDDUI8237nuociJHw85l7c7BEXnrlpPBPE4pkgHo/clRzFX7/jlhzFu8+elxzFX3W5JEfxLhQcxXMCH9/yeBQPZbMRzwl8/I1SddOqeF7guy8AKFY8J3Dxd/Xuy/nEQl5h8UywXZxSi8XzAh9PaXHxnMDFs+45gY/f1Npc4NaeE7j4GbJwg4vnBK77xwD5GRbPI/HdK+XSdKHMxfMCi6dKgY/nBX5xbi5y8ZxA4z0MPp4X+LXn43lBMJ4JgvFMEIxnwqr4hxgvJLB4AYHFX3EJCxi/6+oWl5AwYjgYwlvrRwJjYsKhsLy81t9zMjZWcyKMQ6kE4w6EFLRakHIgBKuKUg2KCxNQVpQyTAgLy2eUxUXlzLKocAoKl93uywU4JSjUFq65kWsLNTFhnDx3U56TcSEh9cBt8CAlJDz9bvF0mF4PI2H0PSf/JWqDELL7yHpGmBAXhZDw+kG8e/bHfZLL9XkagOS8TADoCwCrhHDoaLL/mcSNmTGA4AXvH4Ujk4mdG10orKTx794K/bEZe8GbI/QXLNMxKUcq9L8VVEIHbYTTwRjN3QcgYa2xjF5LbaAyeeQ3wg6cVe98ZwI7l+g005/xBJ0ecl5OOKjPiiSP0rWR+hmRhmpNf2BAsGb1xY36ktWlMT0BYMLBHInqEx6P6RNiPVNAvGx6JoA5K1tD6YTFJCQqGaTBhPgcEg0ANpozrpLgV5jwGxwLw/iB2CEU1v55ONEnF8SDQHQOiTOhkUEqCZg8YSEN3L9lvAgHK5hbmL1HUCEcsjZmlOR+snf2IE8DcRgPvFlK/QroqSDU6UCrgkoVR6mgHO1gUVp0UBBx8YwYRDo4WAc5N0UXXTvf6VoEp4ZCx6CQCh1chIxdXXzumsQav3KDUvF9bGiaPr//1/Ui+GLfM6slZR/hQ1dzAHsEb2SbEHtkZcedRqHZBk4/3w72QaWSbcLDZwo3gV3XESzbwGYHOYiRbUIdowCk+bMNjPxO3mtaZQEwd4HV7p10E+ZzKAL5DNPunbzXX91bd93Ou3dMr3jjl4C5Ryy7d9DrqV3f6Hj2Q2nc7lcunz2BvxfejpxNrYdqNdnvP/ae9/tvajX6eznjWo0ZQNZq4zJAn8EIQD/1f2D4TI3EV0CHfum91IlWAYIHU1wJOiEkngc5gP8CeuvEhlc5cQtnbmr254pRmpCYMEEFU0qRHPBWZQDjYIEQ+oyRCa5MmBBJCnQ6nQdPT3gbT5/ibAloRzAhjLXJkyAICE0o8xnLergx1j3cQs838h6CMZMSRkCSTYK5kpJlJd3Yj5XAlLAKtTdZw1xxTtoBKKUSpfRT3gN8N/oATKb0our1enPKOOfTKRMcr7igRCAzgDi+0xk9r5wbdTpxCiTakcAITclcPykqpj3MGIDveRs4KgRDSmcX6wQCRuM0HEmzAqh4K3+M39RCEhi1B+l0PiowAWHW4daDireBo/Jgw1uO1B8HLCE9ozg2eYRZHtM0jCgmPUwHlBBGgjgFmG5EtcfzuRQGQHQvhSoamOAhuWIpwAAopQQGyyYGOAa7PmD3jmFwgmKCeJfoyJzP4x7OsYA8XWon7wDAAxRKCKEwc8LhkkomU+YnVCquKJSOleixAvAphHp0dBWQWNBAJmwuiNKTTQF4vfygUJsobiYjiSBUBERK/dokKIz1FgAtITkscsrNp4hzHV+KDBiNLo3yg2aEUrBBrAeBl4plwN6Le/eG5gHl20EhB/8qyad8jmoNsHcQDsIwHHwA86n96SNp04lAH74Ec/++6smhL3v+ENtp6E/aAEKu+GAwDQFEw9vUHYqhG330I3cometG8ZDSaHgE182JBj5MwzeDEHnSkvKN6i7odwJw8WJ+GNOBqLuIcOIuul2wB150uwsdw+0ugYfh3g/oASmypqNl+AiubveF8eqrCzyZKU0HcgDBn5V0oBtRhAUBLZBu0cXLvCR0PQhBfNAArCaJLsb4dXG4mHdmmv6AusxSaANKhtvUsFi4iKx7iVw3b3pVtCA3SkcVRfmUNrUecgvaUlCjIGdrQUWgWtAm8NeA1qOl91GrJDBr1LW/3piVA15Xq00NNPHTwzJAq4HLj1AQnhqtEsCsqp31uuaqsxJAc2lcgs0SgAndqtdbJlGZpu/qZptN3fzdcmNtzgDBPGuWXId6S5fVwFM5ADKNI35poGFGawFg0bB4FgBqQkU2AO4ulvvh0aO12nH/HGB9u9/UeujZjZ1Wcraxm3b/bIevwXm2zxJAEjvAJLEEkMQOMEksASSxA0wSSwBJ7ADowmj3r5UBuQ6+qvxSAIo6uWEJIIkdYJJYAkhiDfzJkhD+T47VfuHIb1QA7m3/nb4BAlywABDeCkB4GwDhrQCEtwEQ3gpAeBsA4a2AwPbrJze1HtpjKadqqf8TWMPfoX3ZUs4OS/0UeGgJvL9mCVx5ZwPcfHf+6Jbz52+Wz/AQ34gCf2nAfMHJO6sevrB3Lq9NBGEAT6kLGV0jlI3xYA66gtJaHy2ahk1KDSYmbUO04CX04APUoqAEnyA+8F0E66GoiPiIWlQEhR4qVkHpwQp6EJUe2oMXb/4JBb9MkybZ7O7Mh1Yn7fy0TbbM79tvZr6ddJN0s+37gW0o4Rz9shaQoEtDxPIWcBEQUEAv9xIxmF9CAwXxIfQqRQpSAPCCiJfQFFAQcOKkMAsEruVeIgYCvr+1SgQtQ9G4hQihROaIoBk5UoSSohuao5AhFWSkwDOs1VYafyigD1GBVo1qEyRioCERsZakwCP4kPyF5yqHTBtM4VYNmabmFkvo7s4uGOnuLmyMLMjChpOQXQLP/S0ZIZQRupF1TqkWGk3H7Ib2tc4pQZuVC6ZjZmGjmyGMZMnQbZLn9hDJjvz754wXI3EtQiIFQQS/X74+XZUst8F2uZ9vw0wIm5LJTfyC1zu/raWlDW45heTqlsZgsLFldZI3pUONyaamZOMhzpS8O9qCTYQ0Bdt2ePmEQwXhkJc7pS0bN27hTAnwQqfXrIFOe2dqWIGmZLKpuCVELZVTTb9gSUEK8nx6jiPPp+eK8LfOp3UddR6nk7dvic4vPB8jV6+Sseecgk6uviLAq6tE5xLG3pA8b8bYAo2c7zTsiS3QpvA1MDB1yyHA+JCBT6r6aYDeZwowPiCowAC9zxaoRLGeh5VIRHyHlBTk+8hmMQvY0EvzFi4azSNseKkWL57rwoSnAiY8FVDh4eK2LlT4u6rqYoW/WxpeVR+7UOF3HV3oQoWftxAETHjAhQlPBUx4KmDCUwETngqI8FbChiNO4alQGX6RbXgq2If3V4SngnN4aGEWMOGpgAlPBUx4KmDCU8E6fHChrYAJTwVMeCpgwlMBE54KNuHZgv8RDc8WEOGLAmTf0LDrqLxuaDUxJ8+nY0hE/DsUtNCMxDUfiRSqVWhGImJ5o4UYEhEXMrSgMZCfaykoe7Ez7d+NFBb5n+7HCXCic3IZRgA+79mPEYD3DYeXIQTgzJcHKxACcP2O+mQZvwD4v6rrLyME4LiqPjmBEOh55PrXCAGGV1XhI3k4hIu0E3R4QTnJFvrO+hfvyw8vGDCNrD2QWnJwengBmEYn4doNQsixwvD+VAGYRnvh4j0C/DrGLUCjnbUH+/q4UwLOQmtEpyErmg9jWHEThy8NfPHhyxt/AOEPUfwigF9m8AsZfqnEL8Z75evT1cnSStrrHXC5K2n3OPAvBQ0rhJCCpqcLd4+fdmBayJC1hbt7VAeokA6FQnESg+8KjwAoCZKjI8O3B8AIQ/t4hDcloB+EqJtf0PREJk7ye/h2yYG84OvX3FpoFf88pKe+C1Z8MyZ8q+SSEyL+DfjMC6eRuDxIZoVQj8QlEQMBn4Ur29qCFIKNQa9Nu3WWwmYStGl/P2ApNCebrcPfVD9gOn2/U71p7kOytEHSHF5VH5qE5qbmYm/hTd/l4YEPJmEHKW2zKVgMP6Hm6DQP6+bNmy2zP9+pUm7yzTQNT5ngEs4PqighoFJ4U/rwTi2hkyk87FTLuOIsQG9NBKwEr6m3ZTlZVOuWrTumDodnDWolFtWabGvx5kvHgoYrFYI3GMzPrSWD6yw7/Uy15d06s0DTcWDwilm4Mqg60vDQLJxnsa5MuH+TyUSZEOhk8k7MVzgqfySvc1IVJGzAfcoeIIQQVZQoSgi73WGEEA33ut294Si3oLgpClpApzRjnQaiqVRUsJn+Q6GaXlOUghTk32XNcYy4rvf5p+jT9ViaOdNGjJDCq2t9hCTSzNKIYAwQKo0UQwAjUWZ0pBhCpaEwyzvNa4BgaegKQ6g0fM4CkOpgG1TAGSDYGiTjLACK2WAIYOjlho8lmA3d5ywAPoYBAs4AgWUoDAEMYjKcBSBDHCoRBLaRYgnQDzsDBJwBApeRSDsLgGI2WAJUopUBArcRYQnm4yMWYQhgJEyGswCkKwwQUIYBAsOIlT0axA2XRAzcFKF+hZutghKKJxLxkMIpRMIkTzjCIdAjP9G6dm1r7jbFFiLQLqTBnbSvH4wIUwjTx06tV4eUOiArlqBAfGgfh+CEojCEEElAPr0E9qNTIcQQ4qQVvkMuxMh0ZeAmzhA6yFroL9H7M263kcj1Ay2gU+LvNKGE+IY1WhxW7MShSwNbfNjyRh5AAh3Ts16QiIGApSEFtKC0xjpirSleQcs9LER7M10pTiEMC3wXIqWu0vPhCFvQOghpLe7NgJ84C76yE+54OBR1FmhGRn5nvlad6Ck3WkCnhO40alhRE4cvDWzxiXQ8SEE+Ts8uPFO0c731FPi/wuiFek99j4NwwigRei54RmsmPJ7Ai3obwXhSR/q1aeFCbU/9aK5t9peNMHnq1Pj45LRAc+l5AbsgAWshlSB1dSvKhcC9Hk8P+WHTB6PrZMRdTKl71AP/QCIv7Dp97lx5pwPdub28IBeshe3twHYqFBzIBTKqGbUWhj3D8N88cYEa2IFNSsPt7cM0pZKZu0eGeuwnbunSitKop7PmsAdMLR3wfPzoOTADAjsldqf/fA+YiaMwS8OMU/FhhMjJLgMjrKirI4kUQpgcHz91ahIhaP2k7omB6rRxQvil8i8JEjH4zd75hcgUxXH8jkvNjxHDDBJSmkFm/Llq2ska1p+d1Sp/UsZuoaspre4QhZrmYR4oWpHyp5Sk8MDYSIkwXrQP8jRJatokySqmlFI8+J4798/MmGPu9ffS/djuzN17Puec3/lzD+Ps3rvF5dUN0h34gG9BWtsDXZzM3QDY432VaVvFBPwkzZyO0SB5baN3HVfYfnpJoFeMLTaEYHpBYEWCuMLo4PrewJLT1BGrCtvbl+Azu1iSL2Bn681X3p5BYkJ0sMe7cQ2rIleIMSKZwUGRCd1Ll3YSRfEtrrDAYBT+/WCecQUvh18nzDFgVTLPuEIUEHWuXt3NghaLxUwkytCu3zI23JrNuiraPSfQM9jGBHq/ItB709yDDuHNGyS/vcgQktKs9iVL2vcE1Z6OSR70/On1QUN4M2ECHvw8fpsheE6tCMxBnvrQWBwVewMr3sfrhIvjNxjCKO/ea8nRtYNvflvmlXedUaUJj331QhHjoFYA2yPFu4awyAfh6UUzaB5mK+3ahYMNYe2mTWutC9gqfmPMmBvY525ROLLWt3LMmJW+tUesCTBuaRurrQlg4dVbt64udPTGZFdw93v/x2Cd3m6u0x3GOj2WA3ed5gncdZonmOu0VL9O84Sm63QUVeQJ3HWaJ3DX6W9SntQEL4fG9Jfnxe0J8f3VV+46zYuBu07XZn5ybOlk3GzWxU3X6Rrh0Np4fN4hXeCs07XCSFQ/rp9w1+kaQdM0gbdON6YvXa52BHedHtvIp0NVYWwLRpaqBYwdOcOaIF9m1uXz8KwIegccQn0sCGbHActCiXWcDYE1zn6LJZjNb11gbWNHuPypZE84echeCcAV3N8b6iD8NvmXBPquUJbL5foUcqoi1qcUy7JMhpBKhVJvTIdkRQnJtanlClJUjBK6UgwlVZHLIjGh63UoVKn6IrLGJRDSBSAqTFBYQSmZGalQKJVhFyp4x64AmXQBiBtSjBCuhsoIAW/UBJXQY7xVkM/jMtW1UifLXFGFnCimQsoA6kT5Cs5Dj1nRcmOz0kdWK5bxy6mTJk0F+3BMqDXChYzZrJnwZz99Dov+8uuUgnLKSGeQk1GhlCKjjTeHN2slfAgThT/4/UOZsgIjVCsoSK+8FjfH/P5YOKYJeIcvordDGfE1OiC3LI8/D7dsebgs/xgtlLiJLGsFZI/viG/fPnqeL6P8j5M7V3ROPjVnzqnJCUVRKh8+h0t+0RRQpxKrUX7fzEc5P5XlgR5D+FiRu2LhEqgV8Ja9p7dvZ87MsH6/Zwi56tXPyLBWoHAYR/HR0MyhPM5eK7rwUelCws8ogOoEMRwmvOSez3z7/JwfA+9jVdiLRuv0l8IlDDDWrOtVwUR8/gjGELpJ3MKEnIhRV6HwZ+JMIIIwcyilvC6TfH3LqesDeFVCN54Tf8bl8rmBG+SniqIMDAwoStlPuQGFLwAqD2X8nQpIKYhlczgcPtdiTtPMHMlsiEDIfIAQ4wimkWcjFwJqFINAfMGERauIaHs2KiwIQCxXzUzMMXe+Xye4OIPpNnHiQ1VtC5ds4sTfv2Rb2NGcL184F5o/eT8xK0PUbvnJ+4FOuqr+TEjAopAg2s0ESlgTAkTi4XFnCAQsCevUH1A64cHLuibCuG94gZTHx407sJPohaXBN50QA14nEU23IIA8jPyBdxcob3F4T0cnZJB/Zro1AUaeLmQoj/RNhIPNOXuWc8GJw9v+fLCJE3d52Ram2URwcQYjbeLEz2ZcwRV+keDEBcUVXOGvCS7OYEQDU1ogjG9gTAtcwaHC7BZ8I1ALXOF/ESa14BthXAtcwSHC1gamt0BwcQZ3ix6Pp24v9WKPx6vi8SweXUswvrxrsuDFPjIiTzpoCkRVgahOWBxds7H62Qz2kRFF9gS/KySl7gUBL4TBHhyxj4xo+Xy+EEx7EkvwrZ6lQtpzWn03CCW6iiNsjyxV800QCShL7GVl3S1CkZJNhPmIldV8QTdqLqjRYMMSYNFTOtggrGKxgo1r1LYRqnm0Fe8a0XfUCEask7u08gWjllr0HiJTWJX2tLMI1y1lEaI8XQBBM3pTID1Wsw2F9QYSdZ/uBUVT6DoK2mcRKprWUgnUBF1ohm3BiR8MOlD4/f2g9Xg6gpNZ7UdBlykUe8HpbpLWGwijtTmC9NokrC1BH8LmPQICm0HGwGz3pFcZAtCHcGS7KSQlXNAnoZSsnaIdqKg+gbXxLWAeEOmTMLqq4SYQTBORPoExgyAgD30SsjwaBK18fQKjfMGIldWyicDuArXRC9okZO3AEbQ21KIXjFhBcwEE9xjRC2qsuMATzHtENXoBscaDdeB2H1DB7T5okoxhXSjeFVycQZaDh4MwkQNx+CHh2DBL8cw4DB/7vpBtW44UEkEbJgn+8rbsxIncOx/LluU7PJyFOzysn/OFZrQQssfUmhuHY9nvC9lYG4ybERZD5CbSt8Vg8INGWonlLbEYJFaEdPPX9gPINh5a9EOHhBieRVkM0WeIQepo0Q9SlDX+chbDctYFUalVs2bVemS1A85/ZcfZb6Uohz/yZOX/968/Dnxg9SybOLFZ3edP/6NEOMzgIBCHsRx+RujHly2h786dPjLYzEEX7vT3+/r6fP39dyzO6YKvzwf6fAWLAj3xqTwha0L/AxTA6HvQb0m4jwK0Iu6TSsuOu+JTuWK1We/4NO5YFAqF+z5wv1CwJoBZvkLBN4t05nIwBSrgyxF3b9vCZg68oJ34v/gzbOLEfrDfcTb5LzrO5Wt79/faNBQFcHxlL429tUOMvpiA1pepiHUgFkRQrL9QRFAKgr/wB6UFFVRMIOiIoMMWJCAUChIpyKow34aIbA/tm+CEUcEHEUHYPyCivnkSb6cL3uUcmHI373eCrfQz70luM5Guk6OF2BomDRQ75k/WSDfMhhkLTibM3i34MONBoxP+Zg6axXTRLBJAGkB6ELOkk+lgJfwDMfRgBz55cbBhdtIdswH6nz9Fk8T6jhCT8dr6X4LdxOhb4xixvhQxBSQBKjmafmYMkF6o7z08bXyiPKczhnXUG19DAJnMVPPBm+N4AA1PnzMG8ADyujAIAUCPjw6fX0MAfBAKgEGeGgN4ABndt94nCoBBpmEQPIAONl8ZtzHAaA//GuQU4sRtZGyGDzLz1huPBVbXGD40xZflT7ffjIsLwcxM27esDK/dfP5UHN9LzO/6s+DQLUscH9rzmfdrSd5VcQCC2MZ2b+jr3tXUPHHQNnqH9ZaxPIUAvIMbq8aHFB7A1vBSMc3ZfN0bsHwsgOVbxoYUHkwdmroBy0cDWP79FKbeRaBrwPIx8a3xGJaPBrD8g7B8NDCsu7AZ0MHFuAubgQCC5auv04swJigrSAg0QQosRfCotCn4T/caFpyt10tarczKY0hQqtfrZ0fh9iQS9JcuXfrGXkyOEoaeYN/7tSwawADvSiX8URorl19n+2HyfhyoscnRUS1RP1sq4cFrCtAmWXkiPBuPsENnw+OTkGnzKbAAAHm5V8lRjpiM3+P3X4ItxBbqvYB1+EUBe7bq+tY9WLA5v2zogq5fGFqW34wCV3bpfF27rsSDw/m59/OHY8DQ9iHBXdGSDkfvzgv0/L7oA/bldSGAtp2JgjPb5l2Szj+d+E/oW2MdMRlfUqWA+nlZiycJt8YSBpUKETgOETSbNFBhrEICDmMOCVxk7CIOjDwJY9DPWyNiwEWO/VZuJH5JdovN1rJRMziM52CHdnqPx4IWXxAW2MG0wew2EryEk2DbcCpeIkGLXVubTK69xlo4YOfWJ8PW52wUqNiztCLTU1QB9XVawvRIiUgrI/Uti6RFSkZSQAEFFFBABhB3uVfflyVpK4nJ+G8+BTBgNTEZX8mswF8Bq4jJ+J79CmCAEUm9H9kiaTkxBRYVqLpuFQ0syF2xwrUgFPDdFTzXxy2p2gNV7AzV8O9wq/ih/dOue9r/S4c1GeRlIC+cQwEFljJQyVGCd9m4k8LUp/W6nLlDAFwQABcEwEU1LgBzxFcWEwCSAEATAAQCDUA8OD5PHEQE5i2hsjsFQgDesZG9KMFBrcycHXNWNSAoBHsL7z+zJ0cKhcLeWfEx8+dCcGB10mE5p5I8sV+LE3xJO1jQzayGBWMhqEUfLwY1BrUO/Db0KUEc7F//ZeJzZQf+sO4sBAfrHuLEkbcGefPRtzfx8fSnKPkiQL7M0C9kxMfTL8bky/0Pn2dx6HfvHYYAAAAASUVORK5CYII=");\n  background-size: 24px 4716px;\n  width: 24px;\n  height: 16px;\n  overflow: hidden;\n}\n\n.vf-phone-flag-placeholder {\n  opacity: 0.6;\n}\n\n.vf-phone-country {\n  margin-left: 0.75rem;\n  font-weight: 600;\n  font-size: 15px;\n  display: flex;\n}\n\n.vf-phone-number {\n  margin-left: 0.5rem;\n  color: var(--vf-color-muted);\n}\n\n[dir=rtl] .vf-addon-options-wrapper {\n  margin-left: 0;\n  margin-right: var(--vf-px-input);\n}\n\n[dir=rtl] .vf-addon-options-wrapper.vf-addon-options-wrapper-sm {\n  margin-left: 0;\n  margin-right: var(--vf-px-input-sm);\n}\n\n[dir=rtl] .vf-addon-options-wrapper.vf-addon-options-wrapper-lg {\n  margin-left: 0;\n  margin-right: var(--vf-px-input-lg);\n}\n\n[dir=rtl] .vf-phone-country {\n  margin-left: 0;\n  margin-right: 0.75rem;\n}\n\n[dir=rtl] .vf-phone-number {\n  margin-left: 0;\n  margin-right: 0.5rem;\n}';
    styleInject(css_248z$s);
    script$U.__file = "themes/vueform/templates/elements/PhoneElement.vue";
    var script$T = {
      name: "RadioElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            input: "",
            text: ""
          }
        };
      }
    };
    const _hoisted_1$j = ["value", "name", "id", "disabled"];
    const _hoisted_2$d = ["innerHTML"];
    function render$o(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createBaseVNode(
              "label",
              {
                class: normalizeClass(_ctx.classes.wrapper)
              },
              [
                withDirectives(createBaseVNode("input", mergeProps({
                  type: "radio",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value = $event)
                }, _ctx.aria, {
                  value: _ctx.radioValue,
                  class: _ctx.classes.input,
                  name: _ctx.inputName,
                  id: _ctx.fieldId,
                  disabled: _ctx.isDisabled,
                  ref: "input"
                }), null, 16, _hoisted_1$j), [
                  [vModelRadio, _ctx.value]
                ]),
                createCommentVNode(" If label is HTML "),
                _ctx.Text ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: normalizeClass(_ctx.classes.text),
                  innerHTML: _ctx.Text
                }, null, 10, _hoisted_2$d)) : (openBlock(), createElementBlock(
                  Fragment,
                  { key: 1 },
                  [
                    createCommentVNode(" If label is slot "),
                    createBaseVNode(
                      "span",
                      {
                        class: normalizeClass(_ctx.classes.text)
                      },
                      [
                        renderSlot(_ctx.$slots, "default", { el$: _ctx.el$ }, () => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots.default), { el$: _ctx.el$ }, null, 8, ["el$"]))
                        ])
                      ],
                      2
                      /* CLASS */
                    )
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                ))
              ],
              2
              /* CLASS */
            )
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$T.render = render$o;
    script$T.__file = "themes/blank/templates/elements/RadioElement.vue";
    var script$S = {
      name: "RadioElement",
      render: script$T.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "vf-radio-wrapper",
            wrapper_sm: "vf-radio-wrapper-sm",
            wrapper_md: "",
            wrapper_lg: "vf-radio-wrapper-lg",
            wrapper_left: "vf-radio-wrapper-left",
            wrapper_right: "vf-radio-wrapper-right",
            input: "vf-radio",
            input_enabled: "",
            input_disabled: "",
            input_danger: "vf-radio-danger",
            input_sm: "vf-radio-sm",
            input_md: "",
            input_lg: "vf-radio-lg",
            input_left: "vf-radio-left",
            input_right: "vf-radio-right",
            text: "vf-radio-text",
            text_left: "vf-radio-text-left",
            text_right: "vf-radio-text-right",
            $wrapper: (classes2, { Size, align }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`],
              align === "left" ? classes2.wrapper_left : null,
              align === "right" ? classes2.wrapper_right : null
            ],
            $input: (classes2, { isDisabled, Size, isDanger, align }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : classes2.input_enabled,
              !isDisabled && isDanger ? classes2.input_danger : null,
              align === "left" ? classes2.input_left : null,
              align === "right" ? classes2.input_right : null
            ],
            $text: (classes2, { align }) => [
              classes2.text,
              align === "left" ? classes2.text_left : null,
              align === "right" ? classes2.text_right : null
            ]
          }
        };
      }
    };
    var css_248z$r = "/* Some styles are contained in Vueform.vue */";
    styleInject(css_248z$r);
    script$S.__file = "themes/vueform/templates/elements/RadioElement.vue";
    var script$R = {
      name: "RadiogroupElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: ""
          }
        };
      }
    };
    const _hoisted_1$i = ["aria-labelledby"];
    function render$n(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_RadiogroupRadio = resolveComponent("RadiogroupRadio");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.classes.wrapper),
              "aria-labelledby": _ctx.labelId,
              role: "radiogroup"
            }, [
              (openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(_ctx.resolvedOptions, (item, index2, key) => {
                  return openBlock(), createBlock(_component_RadiogroupRadio, {
                    items: _ctx.resolvedOptions,
                    index: index2,
                    item,
                    value: item.value,
                    key,
                    attrs: _ctx.aria
                  }, {
                    default: withCtx((scope2) => [
                      renderSlot(_ctx.$slots, "radio", mergeProps({ ref_for: true }, scope2, { el$: _ctx.el$ }), () => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots.radio), mergeProps({ ref_for: true }, scope2, { el$: _ctx.el$ }), null, 16, ["el$"]))
                      ])
                    ]),
                    _: 2
                    /* DYNAMIC */
                  }, 1032, ["items", "index", "item", "value", "attrs"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ], 10, _hoisted_1$i)
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$R.render = render$n;
    script$R.__file = "themes/blank/templates/elements/RadiogroupElement.vue";
    var script$Q = {
      name: "RadiogroupElement",
      render: script$R.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "vf-radiogroup-wrapper",
            wrapper_sm: "vf-radiogroup-wrapper-sm",
            wrapper_md: "",
            wrapper_lg: "vf-radiogroup-wrapper-lg",
            $wrapper: (classes2, { Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$q = ".vf-radiogroup-wrapper {\n  cursor: pointer;\n}\n\n.vf-radiogroup-wrapper .vf-radio-container {\n  padding-top: 0;\n}";
    styleInject(css_248z$q);
    script$Q.__file = "themes/vueform/templates/elements/RadiogroupElement.vue";
    var script$P = {
      name: "RadiogroupElement",
      render: script$R.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "vf-radiogroup-tabs-wrapper",
            wrapper_sm: "vf-radiogroup-tabs-wrapper-sm",
            wrapper_md: "",
            wrapper_lg: "vf-radiogroup-tabs-wrapper-lg",
            $wrapper: (classes2, { Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$p = ".vf-radiogroup-tabs-wrapper {\n  display: grid;\n  grid-auto-flow: column;\n  box-shadow: var(--vf-shadow-input);\n  border-radius: var(--vf-radius-large);\n}\n\n.vf-radiogroup-tabs-wrapper.vf-radiogroup-tabs-wrapper-sm {\n  border-radius: var(--vf-radius-large-sm);\n}\n\n.vf-radiogroup-tabs-wrapper.vf-radiogroup-tabs-wrapper-lg {\n  border-radius: var(--vf-radius-large-lg);\n}";
    styleInject(css_248z$p);
    script$P.__file = "themes/vueform/templates/elements/RadiogroupElement_tabs.vue";
    var script$O = {
      name: "RadiogroupElement",
      render: script$R.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "vf-radiogroup-blocks-wrapper",
            wrapper_sm: "vf-radiogroup-blocks-wrapper-sm",
            wrapper_md: "",
            wrapper_lg: "vf-radiogroup-blocks-wrapper-lg",
            $wrapper: (classes2, { Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$o = ".vf-radiogroup-blocks-wrapper {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  box-shadow: var(--vf-shadow-input);\n  border-radius: var(--vf-radius-large);\n}\n\n.vf-radiogroup-blocks-wrapper.vf-radiogroup-blocks-wrapper-sm {\n  border-radius: var(--vf-radius-large-sm);\n}\n\n.vf-radiogroup-blocks-wrapper.vf-radiogroup-blocks-wrapper-lg {\n  border-radius: var(--vf-radius-large-lg);\n}";
    styleInject(css_248z$o);
    script$O.__file = "themes/vueform/templates/elements/RadiogroupElement_blocks.vue";
    var script$N = {
      name: "SelectElement",
      components: {
        Multiselect: script$_
      },
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            input: "",
            inputWrapper: "",
            inputPlaceholder: "",
            inputCaret: "",
            select: {
              container: "",
              containerDisabled: "",
              containerOpen: "",
              containerOpenTop: "",
              containerActive: "",
              singleLabel: "",
              singleLabelText: "",
              search: "",
              placeholder: "",
              caret: "",
              caretOpen: "",
              clear: "",
              clearIcon: "",
              spinner: "",
              dropdown: "",
              dropdownTop: "",
              dropdownHidden: "",
              options: "",
              optionsTop: "",
              group: "",
              groupLabel: "",
              groupLabelPointable: "",
              groupLabelPointed: "",
              groupLabelSelected: "",
              groupLabelDisabled: "",
              groupLabelSelectedPointed: "",
              groupLabelSelectedDisabled: "",
              groupOptions: "",
              option: "",
              optionPointed: "",
              optionSelected: "",
              optionDisabled: "",
              optionSelectedPointed: "",
              optionSelectedDisabled: "",
              noOptions: "",
              noResults: "",
              fakeInput: "",
              spacer: ""
            }
          }
        };
      }
    };
    const _hoisted_1$h = ["name", "id", "disabled"];
    const _hoisted_2$c = ["value"];
    function render$m(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ElementLabelFloating = resolveComponent("ElementLabelFloating");
      const _component_Multiselect = resolveComponent("Multiselect");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            _ctx.hasFloating && !_ctx.empty ? (openBlock(), createBlock(_component_ElementLabelFloating, {
              key: 0,
              visible: !_ctx.empty
            }, null, 8, ["visible"])) : createCommentVNode("v-if", true),
            createCommentVNode(" Native select "),
            _ctx.isNative ? (openBlock(), createElementBlock(
              "div",
              {
                key: 1,
                class: normalizeClass(_ctx.classes.inputWrapper)
              },
              [
                withDirectives(createBaseVNode("select", mergeProps({
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value = $event),
                  class: _ctx.classes.input,
                  name: _ctx.name,
                  id: _ctx.fieldId,
                  disabled: _ctx.isDisabled
                }, {
                  ..._ctx.attrs,
                  ..._ctx.aria
                }, { ref: "input" }), [
                  (openBlock(true), createElementBlock(
                    Fragment,
                    null,
                    renderList(_ctx.resolvedOptions, (option, index2) => {
                      return openBlock(), createElementBlock("option", {
                        value: option.value,
                        key: index2
                      }, toDisplayString(option.label), 9, _hoisted_2$c);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ], 16, _hoisted_1$h), [
                  [vModelSelect, _ctx.value]
                ]),
                _ctx.placeholder && _ctx.empty && !_ctx.isDisabled && _ctx.type == "select" ? (openBlock(), createElementBlock(
                  "span",
                  {
                    key: 0,
                    class: normalizeClass(_ctx.classes.inputPlaceholder)
                  },
                  toDisplayString(_ctx.placeholder),
                  3
                  /* TEXT, CLASS */
                )) : createCommentVNode("v-if", true),
                createBaseVNode(
                  "span",
                  {
                    class: normalizeClass(_ctx.classes.inputCaret)
                  },
                  null,
                  2
                  /* CLASS */
                )
              ],
              2
              /* CLASS */
            )) : (openBlock(), createElementBlock(
              Fragment,
              { key: 2 },
              [
                createCommentVNode(" @vueform/multiselect copmonent "),
                createVNode(_component_Multiselect, mergeProps(_ctx.fieldOptions, {
                  modelValue: _ctx.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.value = $event),
                  classes: _ctx.classes.select,
                  id: _ctx.fieldId,
                  name: _ctx.name,
                  options: _ctx.resolvedOptions,
                  disabled: _ctx.isDisabled,
                  placeholder: _ctx.Placeholder,
                  attrs: _ctx.attrs,
                  aria: _ctx.aria,
                  locale: _ctx.form$.locale$,
                  onSelect: _ctx.handleSelect,
                  onDeselect: _ctx.handleDeselect,
                  onSearchChange: _ctx.handleSearchChange,
                  onTag: _ctx.handleTag,
                  onOpen: _ctx.handleOpen,
                  onClose: _ctx.handleClose,
                  onClear: _ctx.handleClear,
                  onPaste: _ctx.handlePaste,
                  ref: "input"
                }), createSlots({
                  _: 2
                  /* DYNAMIC */
                }, [
                  renderList({
                    option: "option",
                    noresults: "no-results",
                    nooptions: "no-options",
                    afterlist: "after-list",
                    beforelist: "before-list",
                    placeholder: "placeholder",
                    grouplabel: "group-label",
                    caret: "caret",
                    clear: "clear",
                    spinner: "spinner",
                    default: "default"
                  }, (slotName, slotKey) => {
                    return {
                      name: slotKey,
                      fn: withCtx((props) => [
                        renderSlot(_ctx.$slots, slotName, mergeProps(props, { el$: _ctx.el$ }), () => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots[slotName]), mergeProps(props, { el$: _ctx.el$ }), null, 16, ["el$"]))
                        ])
                      ])
                    };
                  }),
                  _ctx.fieldOptions.mode == "single" ? {
                    name: "singlelabel",
                    fn: withCtx(({ value }) => [
                      renderSlot(_ctx.$slots, "single-label", {
                        value,
                        el$: _ctx.el$
                      }, () => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots["single-label"]), {
                          value,
                          el$: _ctx.el$
                        }, null, 8, ["value", "el$"]))
                      ])
                    ]),
                    key: "0"
                  } : void 0
                ]), 1040, ["modelValue", "classes", "id", "name", "options", "disabled", "placeholder", "attrs", "aria", "locale", "onSelect", "onDeselect", "onSearchChange", "onTag", "onOpen", "onClose", "onClear", "onPaste"])
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            ))
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$N.render = render$m;
    script$N.__file = "themes/blank/templates/elements/SelectElement.vue";
    var script$M = {
      name: "SelectElement",
      render: script$N.render,
      components: {
        Multiselect: script$_
      },
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            input: "vf-input vf-native-select",
            input_enabled: "",
            input_disabled: "",
            input_success: "vf-input-success",
            input_danger: "vf-input-danger",
            input_sm: "vf-input-sm",
            input_md: "",
            input_lg: "vf-input-lg",
            inputWrapper: "vf-native-select-wrapper",
            inputWrapper_sm: "vf-native-select-wrapper-sm",
            inputWrapper_md: "",
            inputWrapper_lg: "vf-native-select-wrapper-lg",
            inputPlaceholder: "vf-native-select-placeholder",
            inputPlaceholder_sm: "vf-native-select-placeholder-sm",
            inputPlaceholder_md: "",
            inputPlaceholder_lg: "vf-native-select-placeholder-lg",
            inputCaret: "vf-native-select-caret",
            inputCaret_sm: "vf-native-select-caret-sm",
            inputCaret_md: "",
            inputCaret_lg: "vf-native-select-caret-lg",
            select: {
              singleLabel: "vf-multiselect-single-label",
              singleLabel_sm: "vf-multiselect-single-label-sm",
              singleLabel_md: "",
              singleLabel_lg: "vf-multiselect-single-label-lg",
              singleLabel_noClear: "vf-multiselect-single-label-no-clear",
              singleLabel_noCaret: "vf-multiselect-single-label-no-caret",
              singleLabelText: "vf-multiselect-single-label-text",
              singleLabelText_truncate: "vf-multiselect-single-label-text-truncate",
              container: "vf-multiselect",
              container_enabled: "",
              container_disabled: "vf-multiselect-disabled",
              container_success: "vf-multiselect-success",
              container_danger: "vf-multiselect-danger",
              container_sm: "vf-multiselect-sm",
              container_md: "",
              container_lg: "vf-multiselect-lg",
              containerDisabled: "",
              containerOpen: "vf-multiselect-open",
              containerOpenTop: "vf-multiselect-open-top",
              containerActive: "vf-multiselect-active",
              containerActive_enabled: "",
              wrapper: "vf-multiselect-wrapper",
              wrapper_sm: "vf-multiselect-wrapper-sm",
              wrapper_md: "",
              wrapper_lg: "vf-multiselect-wrapper-lg",
              search: "vf-multiselect-search",
              search_sm: "vf-multiselect-search-sm",
              search_md: "",
              search_lg: "vf-multiselect-search-lg",
              placeholder: "vf-multiselect-placeholder",
              placeholder_sm: "vf-multiselect-placeholder-sm",
              placeholder_md: "",
              placeholder_lg: "vf-multiselect-placeholder-lg",
              caret: "vf-multiselect-caret",
              caret_sm: "vf-multiselect-caret-sm",
              caret_md: "",
              caret_lg: "vf-multiselect-caret-lg",
              caretOpen: "vf-multiselect-caret-open",
              clear: "vf-multiselect-clear",
              clear_sm: "vf-multiselect-clear-sm",
              clear_md: "",
              clear_lg: "vf-multiselect-clear-lg",
              clearIcon: "vf-multiselect-clear-icon",
              spinner: "vf-multiselect-spinner",
              spinner_sm: "vf-multiselect-spinner-sm",
              spinner_md: "",
              spinner_lg: "vf-multiselect-spinner-lg",
              infinite: "vf-multiselect-infinite",
              infinite_sm: "vf-multiselect-infinite-sm",
              infinite_md: "",
              infinite_lg: "vf-multiselect-infinite-lg",
              infiniteSpinner: "vf-multiselect-infinite-spinner",
              dropdown: "vf-multiselect-dropdown",
              dropdown_sm: "vf-multiselect-dropdown-sm",
              dropdown_md: "",
              dropdown_lg: "vf-multiselect-dropdown-lg",
              dropdownTop: "vf-multiselect-dropdown-top",
              dropdownTop_sm: "vf-multiselect-dropdown-top-sm",
              dropdownTop_md: "",
              dropdownTop_lg: "vf-multiselect-dropdown-top-lg",
              dropdownHidden: "vf-multiselect-dropdown-hidden",
              options: "vf-multiselect-options",
              optionsTop: "vf-multiselect-options-top",
              group: "vf-multiselect-group",
              groupLabel: "vf-multiselect-group-label",
              groupLabel_sm: "vf-multiselect-group-label-sm",
              groupLabel_md: "",
              groupLabel_lg: "vf-multiselect-group-label-lg",
              groupLabelPointable: "vf-multiselect-group-label-pointable",
              groupLabelPointed: "vf-multiselect-group-label-pointed",
              groupLabelSelected: "vf-multiselect-group-label-selected",
              groupLabelDisabled: "vf-multiselect-group-label-disabled",
              groupLabelSelectedPointed: "vf-multiselect-group-label-selected vf-multiselect-group-label-pointed",
              groupLabelSelectedDisabled: "vf-multiselect-group-label-selected vf-multiselect-group-label-disabled",
              groupOptions: "vf-multiselect-group-options",
              option: "vf-multiselect-option",
              option_sm: "vf-multiselect-option-sm",
              option_md: "",
              option_lg: "vf-multiselect-option-lg",
              optionPointed: "vf-multiselect-option-pointed",
              optionSelected: "vf-multiselect-option-selected",
              optionDisabled: "vf-multiselect-option-disabled",
              optionSelectedPointed: "vf-multiselect-option-selected vf-multiselect-option-pointed",
              optionSelectedDisabled: "vf-multiselect-option-selected vf-multiselect-option-disabled",
              noOptions: "vf-multiselect-no-options",
              noOptions_sm: "vf-multiselect-no-options-sm",
              noOptions_md: "",
              noOptions_lg: "vf-multiselect-no-options-lg",
              noResults: "vf-multiselect-no-results",
              noResults_sm: "vf-multiselect-no-results-sm",
              noResults_md: "",
              noResults_lg: "vf-multiselect-no-results-lg",
              fakeInput: "vf-multiselect-fake-input",
              assist: "vf-assistive-text",
              spacer: "vf-multiselect-spacer",
              spacer_sm: "vf-multiselect-spacer-sm",
              spacer_md: "",
              spacer_lg: "vf-multiselect-spacer-lg",
              $container: (classes2, { Size, isDanger, isSuccess, isDisabled }) => [
                classes2.select.container,
                classes2.select[`container_${Size}`],
                isDisabled ? classes2.select.container_disabled : null,
                !isDisabled && !isSuccess && !isDanger ? classes2.select.container_enabled : null,
                !isDisabled && isDanger ? classes2.select.container_danger : null,
                !isDisabled && isSuccess ? classes2.select.container_success : null
              ],
              $containerActive: (classes2, { Size, isDanger, isSuccess, isDisabled }) => [
                classes2.select.containerActive,
                classes2.select[`container_${Size}`],
                !isDisabled && !isSuccess && !isDanger ? classes2.select.containerActive_enabled : null
              ],
              $wrapper: (classes2, { Size }) => [
                classes2.select.wrapper,
                classes2.select[`wrapper_${Size}`]
              ],
              $search: (classes2, { Size }) => [
                classes2.select.search,
                classes2.select[`search_${Size}`]
              ],
              $placeholder: (classes2, { Size }) => [
                classes2.select.placeholder,
                classes2.select[`placeholder_${Size}`]
              ],
              $caret: (classes2, { Size }) => [
                classes2.select.caret,
                classes2.select[`caret_${Size}`]
              ],
              $clear: (classes2, { Size }) => [
                classes2.select.clear,
                classes2.select[`clear_${Size}`]
              ],
              $spinner: (classes2, { Size }) => [
                classes2.select.spinner,
                classes2.select[`spinner_${Size}`]
              ],
              $infinite: (classes2, { Size }) => [
                classes2.select.infinite,
                classes2.select[`infinite_${Size}`]
              ],
              $dropdown: (classes2, { Size }) => [
                classes2.select.dropdown,
                classes2.select[`dropdown_${Size}`]
              ],
              $dropdownTop: (classes2, { Size }) => [
                classes2.select.dropdownTop,
                classes2.select[`dropdownTop_${Size}`]
              ],
              $groupLabel: (classes2, { Size }) => [
                classes2.select.groupLabel,
                classes2.select[`groupLabel_${Size}`]
              ],
              $option: (classes2, { Size }) => [
                classes2.select.option,
                classes2.select[`option_${Size}`]
              ],
              $spacer: (classes2, { Size }) => [
                classes2.select.spacer,
                classes2.select[`spacer_${Size}`]
              ],
              $noOptions: (classes2, { Size }) => [
                classes2.select.noOptions,
                classes2.select[`noOptions_${Size}`]
              ],
              $noResults: (classes2, { Size }) => [
                classes2.select.noResults,
                classes2.select[`noResults_${Size}`]
              ],
              $singleLabel: (classes2, { Size, canClear, caret }) => [
                classes2.select.singleLabel,
                classes2.select[`singleLabel_${Size}`],
                !canClear ? classes2.select[`singleLabel_noClear`] : null,
                !caret ? classes2.select[`singleLabel_noCaret`] : null
              ],
              $singleLabelText: (classes2, { truncate }) => [
                classes2.select.singleLabelText,
                truncate ? classes2.select[`singleLabelText_truncate`] : null
              ]
            },
            $input: (classes2, { isDisabled, Size, isDanger, isSuccess, caret }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : null,
              !isDisabled && !isSuccess && !isDanger ? classes2.input_enabled : null,
              !isDisabled && isDanger ? classes2.input_danger : null,
              !isDisabled && isSuccess ? classes2.input_success : null
            ],
            $inputWrapper: (classes2, { Size }) => [
              classes2.inputWrapper,
              classes2[`inputWrapper_${Size}`]
            ],
            $inputPlaceholder: (classes2, { Size }) => [
              classes2.inputPlaceholder,
              classes2[`inputPlaceholder_${Size}`]
            ],
            $inputCaret: (classes2, { Size }) => [
              classes2.inputCaret,
              classes2[`inputCaret_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$n = `.vf-native-select {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
}

.vf-native-select::-webkit-search-decoration, .vf-native-select::-webkit-search-cancel-button, .vf-native-select::-webkit-search-results-button, .vf-native-select::-webkit-search-results-decoration {
  -webkit-appearance: none;
}

.vf-input.vf-native-select {
  padding-right: calc(var(--vf-px-input) * 2);
}

.vf-input-sm.vf-native-select {
  padding-right: calc(var(--vf-px-input-sm) * 2);
}

.vf-input-lg.vf-native-select {
  padding-right: calc(var(--vf-px-input-lg) * 2);
}

.vf-native-select-wrapper {
  position: relative;
}

.vf-native-select-wrapper.vf-native-select-wrapper-sm:before {
  width: var(--vf-min-height-input-sm);
  height: var(--vf-min-height-input-sm);
}

.vf-native-select-wrapper.vf-native-select-wrapper-lg:before {
  width: var(--vf-min-height-input-lg);
  height: var(--vf-min-height-input-lg);
}

.vf-native-select-placeholder {
  position: absolute;
  top: 0;
  left: var(--vf-px-input);
  bottom: 0;
  display: flex;
  align-items: center;
  margin-left: 1px;
  font-family: inherit;
  font-size: inherit;
  font-weight: inherit;
  line-height: inherit;
  color: var(--vf-color-placeholder);
  cursor: default;
  pointer-events: none;
}

.vf-native-select-placeholder.vf-native-select-placeholder-sm {
  left: var(--vf-px-input-sm);
}

.vf-native-select-placeholder.vf-native-select-placeholder-lg {
  left: var(--vf-px-input-lg);
}

.vf-native-select-caret {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z'%3E%3C/path%3E%3C/svg%3E");
  mask-position: center center;
  -webkit-mask-position: center center;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  background-color: var(--vf-bg-icon);
  position: absolute;
  right: 0;
  top: 50%;
  width: 0.625rem;
  height: 1rem;
  padding: 1px 0;
  box-sizing: content-box;
  display: inline-block;
  pointer-events: none;
  transform: translateY(-50%);
  transition: transform 150ms ease-in-out;
  margin-right: var(--vf-px-input);
}

.vf-native-select-caret.vf-native-select-caret-sm {
  margin-right: var(--vf-px-input-sm);
}

.vf-native-select-caret.vf-native-select-caret-lg {
  margin-right: var(--vf-px-input-lg);
}

/* @vueform/multiselect styles */

.vf-multiselect {
  position: relative;
  display: flex;
  width: 100%;
  margin: 0 auto;
  align-items: center;
  justify-content: flex-end;
  box-sizing: border-box;
  cursor: pointer;
  outline: 0px solid var(--vf-ring-color);
  outline-offset: 0;
  transition: box-shadow 0.2s ease-in-out, color 0.2s ease-in-out, background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
  font-size: var(--vf-font-size);
  line-height: var(--vf-line-height);
  letter-spacing: var(--vf-letter-spacing);
  background-color: var(--vf-bg-input);
  color: var(--vf-color-input);
  border-color: var(--vf-border-color-input);
  box-shadow: var(--vf-shadow-input);
  min-height: var(--vf-min-height-input);
  border-radius: var(--vf-radius-input);
  border-width: var(--vf-border-width-input-t) var(--vf-border-width-input-r) var(--vf-border-width-input-b) var(--vf-border-width-input-l);
  border-style: solid;
}

.vf-multiselect.vf-multiselect-open {
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
}

.vf-multiselect.vf-multiselect-open-top {
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}

.vf-multiselect.vf-multiselect-disabled {
  cursor: default;
  background-color: var(--vf-bg-disabled);
  color: var(--vf-color-disabled);
  pointer-events: none;
}

.vf-multiselect.vf-multiselect-success {
  background-color: var(--vf-bg-input-success);
  color: var(--vf-color-input-success);
  border-color: var(--vf-border-color-input-success);
}

.vf-multiselect.vf-multiselect-danger {
  background-color: var(--vf-bg-input-danger);
  color: var(--vf-color-input-danger);
  border-color: var(--vf-border-color-input-danger);
}

.vf-multiselect:hover {
  box-shadow: var(--vf-shadow-input-hover);
}

.vf-multiselect:hover:not(.vf-multiselect-success):not(.vf-multiselect-danger) {
  background-color: var(--vf-bg-input-hover);
  color: var(--vf-color-input-hover);
  border-color: var(--vf-border-color-input-hover);
}

.vf-multiselect.vf-multiselect-active {
  box-shadow: var(--vf-shadow-input-focus);
  outline: var(--vf-ring-width) solid var(--vf-ring-color);
}

.vf-multiselect.vf-multiselect-active:not(.vf-multiselect-success):not(.vf-multiselect-danger) {
  border-color: var(--vf-border-color-input-focus);
  background-color: var(--vf-bg-input-focus);
  color: var(--vf-color-input-focus);
}

.vf-multiselect.vf-multiselect-sm {
  min-height: var(--vf-min-height-input-sm);
  border-radius: var(--vf-radius-input-sm);
  font-size: var(--vf-font-size-sm);
  line-height: var(--vf-line-height-sm);
  letter-spacing: var(--vf-letter-spacing-sm);
}

.vf-multiselect.vf-multiselect-lg {
  min-height: var(--vf-min-height-input-lg);
  border-radius: var(--vf-radius-input-lg);
  font-size: var(--vf-font-size-lg);
  line-height: var(--vf-line-height-lg);
  letter-spacing: var(--vf-letter-spacing-lg);
}

.vf-multiselect-wrapper {
  position: relative;
  margin: 0 auto;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  box-sizing: border-box;
  cursor: pointer;
  outline: none;
  min-height: calc(var(--vf-min-height-input) - var(--vf-border-width-input-t) - var(--vf-border-width-input-b));
}

.vf-multiselect-wrapper.vf-multiselect-wrapper-sm {
  min-height: calc(var(--vf-min-height-input-sm) - var(--vf-border-width-input-t) - var(--vf-border-width-input-b));
}

.vf-multiselect-wrapper.vf-multiselect-wrapper-lg {
  min-height: calc(var(--vf-min-height-input-lg) - var(--vf-border-width-input-t) - var(--vf-border-width-input-b));
}

.vf-multiselect-single-label,
.vf-multiselect-placeholder {
  display: flex;
  align-items: center;
  height: 100%;
  position: absolute;
  left: 0;
  top: 0;
  pointer-events: none;
  background: transparent;
  box-sizing: border-box;
  max-width: 100%;
  padding-left: var(--vf-px-input);
  padding-right: calc(var(--vf-px-input) * 2.5 + 20px);
}

.vf-multiselect-single-label.vf-multiselect-single-label-no-caret, .vf-multiselect-single-label.vf-multiselect-single-label-no-clear {
  padding-right: calc(var(--vf-px-input) * 1.5 + 10px);
}

.vf-multiselect-single-label.vf-multiselect-single-label-no-caret.vf-multiselect-single-label-no-clear {
  padding-right: var(--vf-px-input);
}

.vf-multiselect-single-label.vf-multiselect-single-label-sm {
  padding-left: var(--vf-px-input-sm);
  padding-right: calc(var(--vf-px-input-sm) * 2.5 + 20px);
}

.vf-multiselect-single-label.vf-multiselect-single-label-sm.vf-multiselect-single-label-no-caret, .vf-multiselect-single-label.vf-multiselect-single-label-sm.vf-multiselect-single-label-no-clear {
  padding-right: calc(var(--vf-px-input-sm) * 1.5 + 10px);
}

.vf-multiselect-single-label.vf-multiselect-single-label-sm.vf-multiselect-single-label-no-caret.vf-multiselect-single-label-no-clear {
  padding-right: var(--vf-px-input-sm);
}

.vf-multiselect-single-label.vf-multiselect-single-label-lg {
  padding-left: var(--vf-px-input-lg);
  padding-right: calc(var(--vf-px-input-lg) * 2.5 + 20px);
}

.vf-multiselect-single-label.vf-multiselect-single-label-lg.vf-multiselect-single-label-no-caret, .vf-multiselect-single-label.vf-multiselect-single-label-lg.vf-multiselect-single-label-no-clear {
  padding-right: calc(var(--vf-px-input-lg) * 1.5 + 10px);
}

.vf-multiselect-single-label.vf-multiselect-single-label-lg.vf-multiselect-single-label-no-caret.vf-multiselect-single-label-no-clear {
  padding-right: var(--vf-px-input-lg);
}

.vf-floating-wrapper ~ .vf-multiselect-single-label,
.vf-floating-wrapper ~ div .vf-multiselect-single-label {
  padding-top: calc(var(--vf-py-input) + var(--vf-floating-top) / 2);
  padding-bottom: calc(var(--vf-py-input) - var(--vf-floating-top) / 2);
}

.vf-floating-wrapper ~ .vf-multiselect-single-label-sm,
.vf-floating-wrapper ~ div .vf-multiselect-single-label-sm {
  padding-top: calc(var(--vf-py-input-sm) + var(--vf-floating-top-sm) / 2);
  padding-bottom: calc(var(--vf-py-input-sm) - var(--vf-floating-top-sm) / 2);
}

.vf-floating-wrapper ~ .vf-multiselect-single-label-lg,
.vf-floating-wrapper ~ div .vf-multiselect-single-label-lg {
  padding-top: calc(var(--vf-py-input-lg) + var(--vf-floating-top-lg) / 2);
  padding-bottom: calc(var(--vf-py-input-lg) - var(--vf-floating-top-lg) / 2);
}

.vf-multiselect-placeholder {
  color: var(--vf-color-placeholder);
}

.vf-multiselect-placeholder.vf-multiselect-placeholder-sm {
  padding-left: var(--vf-px-input-sm);
  padding-right: calc(var(--vf-px-input-sm) * 2.5 + 20px);
}

.vf-multiselect-placeholder.vf-multiselect-placeholder-lg {
  padding-left: var(--vf-px-input-lg);
  padding-right: calc(var(--vf-px-input-lg) * 2.5 + 20px);
}

.vf-multiselect-single-label-text {
  overflow: hidden;
  display: block;
  white-space: nowrap;
  max-width: 100%;
}

.vf-multiselect-single-label-text-truncate {
  text-overflow: ellipsis;
}

.vf-multiselect-search {
  width: 100%;
  height: 100%; /* for FF */
  position: absolute;
  top: 0px;
  bottom: 0px;
  left: 0px;
  right: 0px;
  outline: none;
  box-sizing: border-box;
  border: 0;
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  font-family: inherit;
  background: transparent;
  font-size: var(--vf-font-size);
  line-height: var(--vf-line-height);
  letter-spacing: var(--vf-letter-spacing);
  border-radius: var(--vf-radius-input);
  padding-left: var(--vf-px-input);
  padding-right: calc(var(--vf-px-input) * 2.5 + 20px);
  color: var(--vf-color-input);
}

.vf-multiselect-search::-webkit-search-decoration, .vf-multiselect-search::-webkit-search-cancel-button, .vf-multiselect-search::-webkit-search-results-button, .vf-multiselect-search::-webkit-search-results-decoration {
  -webkit-appearance: none;
}

.vf-multiselect-search.vf-multiselect-search-sm {
  border-radius: var(--vf-radius-input-sm);
  padding-left: var(--vf-px-input-sm);
  padding-right: calc(var(--vf-px-input-sm) * 2.5 + 20px);
  font-size: var(--vf-font-size-sm);
  line-height: var(--vf-line-height-sm);
  letter-spacing: var(--vf-letter-spacing-sm);
}

.vf-multiselect-search.vf-multiselect-search-lg {
  border-radius: var(--vf-radius-input-lg);
  padding-left: var(--vf-px-input-lg);
  padding-right: calc(var(--vf-px-input-lg) * 2.5 + 20px);
  font-size: var(--vf-font-size-lg);
  line-height: var(--vf-line-height-lg);
  letter-spacing: var(--vf-letter-spacing-lg);
}

.vf-floating-wrapper ~ .vf-multiselect-search-lg,
.vf-floating-wrapper ~ div .vf-multiselect-search-lg,
.vf-floating-wrapper ~ span .vf-multiselect-search-lg {
  padding-left: var(--vf-px-input-lg);
  padding-right: var(--vf-px-input-lg);
  padding-top: calc(var(--vf-py-input-lg) + var(--vf-floating-top-lg) / 2);
  padding-bottom: calc(var(--vf-py-input-lg) - var(--vf-floating-top-lg) / 2);
}

.vf-multiselect-spinner {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M456.433 371.72l-27.79-16.045c-7.192-4.152-10.052-13.136-6.487-20.636 25.82-54.328 23.566-118.602-6.768-171.03-30.265-52.529-84.802-86.621-144.76-91.424C262.35 71.922 256 64.953 256 56.649V24.56c0-9.31 7.916-16.609 17.204-15.96 81.795 5.717 156.412 51.902 197.611 123.408 41.301 71.385 43.99 159.096 8.042 232.792-4.082 8.369-14.361 11.575-22.424 6.92z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M456.433 371.72l-27.79-16.045c-7.192-4.152-10.052-13.136-6.487-20.636 25.82-54.328 23.566-118.602-6.768-171.03-30.265-52.529-84.802-86.621-144.76-91.424C262.35 71.922 256 64.953 256 56.649V24.56c0-9.31 7.916-16.609 17.204-15.96 81.795 5.717 156.412 51.902 197.611 123.408 41.301 71.385 43.99 159.096 8.042 232.792-4.082 8.369-14.361 11.575-22.424 6.92z'%3E%3C/path%3E%3C/svg%3E");
  mask-position: center;
  -webkit-mask-position: center;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-size: contain;
  -webkit-mask-size: contain;
  background-color: var(--vf-primary);
  width: 1rem;
  height: 1rem;
  margin: 0 var(--vf-px-input) 0 0;
  animation: multiselect-spin 1s linear infinite;
  flex-shrink: 0;
  flex-grow: 0;
}

.vf-multiselect-spinner.vf-multiselect-spinner-sm {
  margin: 0 var(--vf-px-input-sm) 0 0;
}

.vf-multiselect-spinner.vf-multiselect-spinner-lg {
  margin: 0 var(--vf-px-input-lg) 0 0;
}

.vf-multiselect-inifite {
  display: flex;
  width: 100%;
  justify-content: center;
  align-items: center;
  height: var(--vf-min-height-input);
}

.vf-multiselect-inifite.vf-multiselect-inifite-sm {
  height: var(--vf-min-height-input-sm);
}

.vf-multiselect-inifite.vf-multiselect-inifite-lg {
  height: var(--vf-min-height-input-lg);
}

.vf-multiselect-inifite-spinner {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M456.433 371.72l-27.79-16.045c-7.192-4.152-10.052-13.136-6.487-20.636 25.82-54.328 23.566-118.602-6.768-171.03-30.265-52.529-84.802-86.621-144.76-91.424C262.35 71.922 256 64.953 256 56.649V24.56c0-9.31 7.916-16.609 17.204-15.96 81.795 5.717 156.412 51.902 197.611 123.408 41.301 71.385 43.99 159.096 8.042 232.792-4.082 8.369-14.361 11.575-22.424 6.92z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M456.433 371.72l-27.79-16.045c-7.192-4.152-10.052-13.136-6.487-20.636 25.82-54.328 23.566-118.602-6.768-171.03-30.265-52.529-84.802-86.621-144.76-91.424C262.35 71.922 256 64.953 256 56.649V24.56c0-9.31 7.916-16.609 17.204-15.96 81.795 5.717 156.412 51.902 197.611 123.408 41.301 71.385 43.99 159.096 8.042 232.792-4.082 8.369-14.361 11.575-22.424 6.92z'%3E%3C/path%3E%3C/svg%3E");
  mask-position: center;
  -webkit-mask-position: center;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-size: contain;
  -webkit-mask-size: contain;
  background-color: var(--vf-primary);
  width: 1rem;
  height: 1rem;
  animation: multiselect-spin 1s linear infinite;
  flex-shrink: 0;
  flex-grow: 0;
}

.vf-multiselect-clear {
  margin: 0 var(--vf-px-input) 0 0px;
  position: relative;
  opacity: 1;
  transition: 0.3s;
  flex-shrink: 0;
  flex-grow: 0;
  display: flex;
}

.vf-multiselect-clear:hover .vf-multiselect-clear-icon {
  opacity: 1;
}

.vf-multiselect-clear.vf-multiselect-clear-sm {
  margin: 0 var(--vf-px-input-sm) 0 0px;
}

.vf-multiselect-clear.vf-multiselect-clear-lg {
  margin: 0 var(--vf-px-input-lg) 0 0px;
}

.vf-multiselect-clear-icon {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  mask-position: center;
  -webkit-mask-position: center;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-size: contain;
  -webkit-mask-size: contain;
  background-color: var(--vf-bg-icon);
  width: 0.625rem;
  height: 1.125rem;
  display: inline-block;
  transition: 0.3s;
  opacity: 0.5;
}

.vf-multiselect-caret {
  transform: rotate(0deg);
  transition: 0.3s transform;
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z'%3E%3C/path%3E%3C/svg%3E");
  mask-position: center;
  -webkit-mask-position: center;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-size: contain;
  -webkit-mask-size: contain;
  background-color: var(--vf-bg-icon);
  width: 0.625rem;
  height: 1.125rem;
  margin: 0 var(--vf-px-input) 0 0;
  position: relative;
  flex-shrink: 0;
  flex-grow: 0;
  pointer-events: none;
}

.vf-multiselect-caret.vf-multiselect-caret-open {
  transform: rotate(180deg);
  pointer-events: auto;
}

.vf-multiselect-caret.vf-multiselect-caret-sm {
  margin: 0 var(--vf-px-input-sm) 0 0;
}

.vf-multiselect-caret.vf-multiselect-caret-lg {
  margin: 0 var(--vf-px-input-lg) 0 0;
}

.vf-multiselect-dropdown {
  position: absolute;
  left: calc(var(--vf-border-width-input-l) * -1);
  right: calc(var(--vf-border-width-input-r) * -1);
  bottom: 0;
  transform: translateY(100%);
  border-width: var(--vf-border-width-dropdown);
  border-style: solid;
  border-color: var(--vf-border-color-input);
  margin-top: calc(var(--vf-border-width-input-t) * -1);
  max-height: 15rem;
  overflow-y: scroll;
  -webkit-overflow-scrolling: touch;
  z-index: 999;
  background: var(--vf-bg-input);
  display: flex;
  flex-direction: column;
  border-radius: var(--vf-radius-input);
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  outline: none;
  box-shadow: var(--vf-shadow-dropdown);
}

.vf-multiselect-dropdown.vf-multiselect-dropdown-top {
  transform: translateY(-100%);
  top: 0;
  margin-top: 0;
  bottom: auto;
  border-radius: var(--vf-radius-input);
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
}

.vf-multiselect-dropdown.vf-multiselect-dropdown-hidden {
  display: none;
}

v .vf-multiselect-dropdown.vf-multiselect-dropdown-sm {
  border-radius: var(--vf-radius-input-sm);
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}

v .vf-multiselect-dropdown.vf-multiselect-dropdown-sm.vf-multiselect-dropdown-top-sm {
  border-radius: var(--vf-radius-input-sm);
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
}

.vf-multiselect-dropdown.vf-multiselect-dropdown-lg {
  border-radius: var(--vf-radius-input-lg);
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}

.vf-multiselect-dropdown.vf-multiselect-dropdown-lg.vf-multiselect-dropdown-top-lg {
  border-radius: var(--vf-radius-input-lg);
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
}

.vf-multiselect-options {
  padding: 0;
  margin: 0;
  list-style: none;
  display: flex;
  flex-direction: column;
  color: var(--vf-color-input);
}

.vf-multiselect-group {
  padding: 0;
  margin: 0;
}

.vf-multiselect-group-label {
  font-weight: 600;
  color: #374151;
  cursor: default;
  display: flex;
  box-sizing: border-box;
  text-decoration: none;
  align-items: center;
  justify-content: flex-start;
  text-align: left;
  font-size: var(--vf-font-size-small);
  line-height: var(--vf-line-height-small);
  letter-spacing: var(--vf-letter-spacing-small);
  padding: calc(var(--vf-py-input) * 0.5) var(--vf-px-input);
  color: var(--vf-color-input);
  background: var(--vf-bg-selected);
  filter: brightness(0.9);
}

.vf-multiselect-group-label.vf-multiselect-group-label-pointable {
  cursor: pointer;
}

.vf-multiselect-group-label.vf-multiselect-group-label-pointed {
  filter: brightness(0.95);
}

.vf-multiselect-group-label.vf-multiselect-group-label-selected {
  background: var(--vf-primary-darker);
  color: var(--vf-color-on-primary);
  filter: brightness(1);
}

.vf-multiselect-group-label.vf-multiselect-group-label-disabled {
  background: var(--vf-bg-disabled);
  color: var(--vf-color-disabled);
  cursor: not-allowed;
}

.vf-multiselect-group-label.vf-multiselect-group-label-selected.vf-multiselect-group-label-pointed {
  opacity: 0.9;
}

.vf-multiselect-group-label.vf-multiselect-group-label-selected.vf-multiselect-group-label-disabled {
  opacity: 0.5;
}

.vf-multiselect-group-label.vf-multiselect-group-label-sm {
  font-size: var(--vf-font-size-small-sm);
  line-height: var(--vf-line-height-small-sm);
  letter-spacing: var(--vf-letter-spacing-small-sm);
  padding: calc(var(--vf-py-input-sm) * 0.5) var(--vf-px-input-sm);
}

.vf-multiselect-group-label.vf-multiselect-group-label-lg {
  font-size: var(--vf-font-size-small-lg);
  line-height: var(--vf-line-height-small-lg);
  letter-spacing: var(--vf-letter-spacing-small-lg);
  padding: calc(var(--vf-py-input-lg) * 0.5) var(--vf-px-input-lg);
}

.vf-multiselect-group-options {
  padding: 0;
  margin: 0;
}

.vf-multiselect-option {
  padding: calc(var(--vf-py-input) + var(--vf-border-width-input-t)) var(--vf-px-input) calc(var(--vf-py-input) + var(--vf-border-width-input-t));
  cursor: pointer;
  display: flex;
  box-sizing: border-box;
  text-decoration: none;
  align-items: center;
  justify-content: flex-start;
  text-align: left;
}

.vf-multiselect-option.vf-multiselect-option-pointed {
  background: var(--vf-bg-selected);
  color: var(--vf-color-input);
}

.vf-multiselect-option.vf-multiselect-option-selected {
  background: var(--vf-primary);
  color: var(--vf-color-on-primary);
}

.vf-multiselect-option.vf-multiselect-option-disabled {
  background: var(--vf-bg-disabled);
  color: var(--vf-color-disabled);
  cursor: not-allowed;
}

.vf-multiselect-option.vf-multiselect-option-selected.vf-multiselect-option-pointed {
  opacity: 0.9;
}

.vf-multiselect-option.vf-multiselect-option-selected.vf-multiselect-option-disabled {
  opacity: 0.5;
}

.vf-multiselect-option.vf-multiselect-option-sm {
  padding: calc(var(--vf-py-input-sm) + var(--vf-border-width-input-t)) var(--vf-px-input-sm) calc(var(--vf-py-input-sm) + var(--vf-border-width-input-t));
}

.vf-multiselect-option.vf-multiselect-option-lg {
  padding: calc(var(--vf-py-input-lg) + var(--vf-border-width-input-t)) var(--vf-px-input-lg) calc(var(--vf-py-input-lg) + var(--vf-border-width-input-t));
}

.vf-multiselect-no-options,
.vf-multiselect-no-results {
  padding: var(--vf-py-input) var(--vf-px-input);
  color: var(--vf-color-muted);
}

.vf-multiselect-no-options.vf-multiselect-no-options-sm {
  padding: var(--vf-py-input-sm) var(--vf-px-input-sm);
}

.vf-multiselect-no-options.vf-multiselect-no-options-lg {
  padding: var(--vf-py-input-lg) var(--vf-px-input-lg);
}

.vf-multiselect-no-results.vf-multiselect-no-results-sm {
  padding: var(--vf-py-input-sm) var(--vf-px-input-sm);
}

.vf-multiselect-no-results.vf-multiselect-no-results-lg {
  padding: var(--vf-py-input-lg) var(--vf-px-input-lg);
}

.vf-multiselect-fake-input {
  background: transparent;
  position: absolute;
  left: 0;
  right: 0;
  bottom: -1px;
  width: 100%;
  height: 1px;
  border: 0;
  padding: 0;
  font-size: 0;
  outline: none;
}

.vf-multiselect-fake-input:active, .vf-multiselect-fake-input:focus {
  outline: none;
}

.vf-multiselect-spacer {
  display: none;
}

[dir=rtl] .vf-input.vf-native-select {
  padding-right: var(--vf-px-input);
  padding-left: calc(var(--vf-px-input) * 2);
}

[dir=rtl] .vf-input-sm.vf-native-select {
  padding-right: var(--vf-px-input);
  padding-left: calc(var(--vf-px-input-sm) * 2);
}

[dir=rtl] .vf-input-lg.vf-native-select {
  padding-right: var(--vf-px-input);
  padding-left: calc(var(--vf-px-input-lg) * 2);
}

[dir=rtl] .vf-native-select-placeholder {
  left: auto;
  right: var(--vf-px-input);
}

[dir=rtl] .vf-native-select-caret {
  right: auto;
  left: 0;
  margin-right: 0;
  margin-left: var(--vf-px-input);
}

[dir=rtl] .vf-native-select-caret.vf-native-select-caret-sm {
  margin-right: 0;
  margin-left: var(--vf-px-input-sm);
}

[dir=rtl] .vf-native-select-caret.vf-native-select-caret-lg {
  margin-right: 0;
  margin-left: var(--vf-px-input-lg);
}

[dir=rtl] .vf-multiselect-single-label {
  padding-left: calc(var(--vf-px-input) * 4);
  padding-right: var(--vf-px-input);
  left: auto;
  right: 0;
}

[dir=rtl] .vf-multiselect-single-label.vf-multiselect-single-label-no-caret, [dir=rtl] .vf-multiselect-single-label.vf-multiselect-single-label-no-clear {
  padding-left: calc(var(--vf-px-input) * 2);
  padding-right: var(--vf-px-input);
}

[dir=rtl] .vf-multiselect-single-label.vf-multiselect-single-label-no-caret.vf-multiselect-single-label-no-clear {
  padding-left: var(--vf-px-input);
  padding-right: var(--vf-px-input);
}

[dir=rtl] .vf-multiselect-single-label.vf-multiselect-single-label-sm {
  padding-left: calc(var(--vf-px-input-sm) * 4);
  padding-right: var(--vf-px-input-sm);
}

[dir=rtl] .vf-multiselect-single-label.vf-multiselect-single-label-sm.vf-multiselect-single-label-no-caret, [dir=rtl] .vf-multiselect-single-label.vf-multiselect-single-label-sm.vf-multiselect-single-label-no-clear {
  padding-left: calc(var(--vf-px-input-sm) * 2);
  padding-right: var(--vf-px-input-sm);
}

[dir=rtl] .vf-multiselect-single-label.vf-multiselect-single-label-sm.vf-multiselect-single-label-no-caret.vf-multiselect-single-label-no-clear {
  padding-left: var(--vf-px-input-sm);
  padding-right: var(--vf-px-input-sm);
}

[dir=rtl] .vf-multiselect-single-label.vf-multiselect-single-label-lg {
  padding-left: calc(var(--vf-px-input-lg) * 4);
  padding-right: var(--vf-px-input-lg);
}

[dir=rtl] .vf-multiselect-single-label.vf-multiselect-single-label-lg.vf-multiselect-single-label-no-caret, [dir=rtl] .vf-multiselect-single-label.vf-multiselect-single-label-lg.vf-multiselect-single-label-no-clear {
  padding-left: calc(var(--vf-px-input-lg) * 2);
  padding-right: var(--vf-px-input-lg);
}

[dir=rtl] .vf-multiselect-single-label.vf-multiselect-single-label-lg.vf-multiselect-single-label-no-caret.vf-multiselect-single-label-no-clear {
  padding-left: var(--vf-px-input-lg);
  padding-right: var(--vf-px-input-lg);
}

[dir=rtl] .vf-multiselect-placeholder {
  padding-left: var(--vf-min-height-input);
  padding-right: var(--vf-px-input);
  left: auto;
  right: 0;
}

[dir=rtl] .vf-multiselect-placeholder.vf-multiselect-placeholder-sm {
  padding-left: calc(1.25rem + var(--vf-px-input-sm) * 3);
  padding-right: var(--vf-px-input-sm);
}

[dir=rtl] .vf-multiselect-placeholder.vf-multiselect-placeholder-lg {
  padding-left: calc(1.25rem + var(--vf-px-input-lg) * 3);
  padding-right: var(--vf-px-input-lg);
}

[dir=rtl] .vf-multiselect-search {
  padding-left: 0;
  padding-right: var(--vf-px-input);
}

[dir=rtl] .vf-multiselect-search.vf-multiselect-search-sm {
  padding-left: 0;
  padding-right: var(--vf-px-input-sm);
}

[dir=rtl] .vf-multiselect-search.vf-multiselect-search-lg {
  padding-left: 0;
  padding-right: var(--vf-px-input-lg);
}

[dir=rtl] .vf-multiselect-spinner {
  margin: 0 0 0 var(--vf-px-input);
}

[dir=rtl] .vf-multiselect-caret {
  margin: 0 0 0 var(--vf-px-input);
}

[dir=rtl] .vf-multiselect-clear {
  padding: 0 0 0 var(--vf-px-input);
}

@keyframes multiselect-spin {
  from {
    transform: rotate(0);
  }

  to {
    transform: rotate(360deg);
  }
}`;
    styleInject(css_248z$n);
    script$M.__file = "themes/vueform/templates/elements/SelectElement.vue";
    var script$L = {
      name: "SignatureElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            inputContainer: "",
            input: ""
          }
        };
      }
    };
    const _hoisted_1$g = ["tabindex", "aria-label", "id"];
    const _hoisted_2$b = ["src", "alt", "title"];
    const _hoisted_3$9 = ["title", "tabindex", "aria-label"];
    const _hoisted_4$6 = ["title", "tabindex", "aria-label"];
    const _hoisted_5$3 = ["value", "disabled", "readonly", "aria-label"];
    const _hoisted_6$2 = ["innerHTML"];
    const _hoisted_7$1 = ["tabindex", "aria-label"];
    const _hoisted_8 = ["accept"];
    const _hoisted_9 = ["width", "height"];
    const _hoisted_10 = ["width", "height", "tabindex", "aria-label"];
    const _hoisted_11 = ["tabindex", "aria-label", "aria-selected", "onClick", "onKeydown"];
    const _hoisted_12 = ["fill"];
    const _hoisted_13 = ["tabindex", "aria-label"];
    function render$l(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ElementAddonOptions = resolveComponent("ElementAddonOptions");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.classes.wrapper),
              style: normalizeStyle(_ctx.wrapperStyle),
              tabindex: _ctx.isDisabled ? void 0 : 0,
              "aria-label": _ctx.wrapperAriaLabel,
              id: _ctx.id,
              onKeydown: _cache[11] || (_cache[11] = withKeys((...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args), ["tab", "escape"])),
              onMouseleave: _cache[12] || (_cache[12] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
              ref: "input"
            }, [
              createCommentVNode(" Line "),
              withDirectives(createBaseVNode(
                "hr",
                {
                  class: normalizeClass(_ctx.classes.line),
                  style: normalizeStyle(_ctx.lineStyle),
                  "aria-hidden": "true"
                },
                null,
                6
                /* CLASS, STYLE */
              ), [
                [vShow, _ctx.showLine]
              ]),
              createCommentVNode(" Loaded preview "),
              withDirectives(createBaseVNode(
                "div",
                {
                  class: normalizeClass(_ctx.classes.loadedWrapper)
                },
                [
                  createBaseVNode("img", {
                    src: _ctx.value,
                    alt: _ctx.imgAltText,
                    title: _ctx.imgTitleText,
                    class: normalizeClass(_ctx.classes.loadedImg)
                  }, null, 10, _hoisted_2$b)
                ],
                2
                /* CLASS */
              ), [
                [vShow, _ctx.uploaded]
              ]),
              createCommentVNode(" Not loaded actions "),
              withDirectives(createBaseVNode(
                "div",
                {
                  class: normalizeClass(_ctx.classes.innerWrapper)
                },
                [
                  createCommentVNode(" Actions "),
                  createBaseVNode(
                    "div",
                    {
                      class: normalizeClass(_ctx.classes.actions)
                    },
                    [
                      createCommentVNode(" Mode "),
                      withDirectives(createVNode(_component_ElementAddonOptions, {
                        options: _ctx.resolvedModes,
                        placeholder: "",
                        position: "bottom",
                        relaxed: "",
                        aria: _ctx.modeSelectorAria,
                        onSelect: _ctx.handleModeSelect,
                        ref: "mode$"
                      }, null, 8, ["options", "aria", "onSelect"]), [
                        [vShow, _ctx.showModes]
                      ]),
                      createCommentVNode(" Fonts "),
                      withDirectives(createVNode(_component_ElementAddonOptions, {
                        options: _ctx.resolvedFonts,
                        placeholder: _ctx.fontText,
                        position: "bottom",
                        relaxed: "",
                        aria: _ctx.fontSelectorAria,
                        onSelect: _ctx.handleFontSelect,
                        ref: "font$"
                      }, null, 8, ["options", "placeholder", "aria", "onSelect"]), [
                        [vShow, _ctx.showFonts]
                      ]),
                      createCommentVNode(" Undos "),
                      withDirectives(createBaseVNode(
                        "div",
                        {
                          class: normalizeClass(_ctx.classes.undosWrapper)
                        },
                        [
                          createCommentVNode(" Undo "),
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.classes.undo),
                            title: _ctx.undoText,
                            role: "button",
                            tabindex: _ctx.undosLeft ? _ctx.tabindex : void 0,
                            "aria-label": _ctx.undoText,
                            onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleUndo && _ctx.handleUndo(...args), ["stop"])),
                            onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.handleUndo && _ctx.handleUndo(...args), ["prevent"]), ["space", "enter"]))
                          }, null, 42, _hoisted_3$9),
                          createCommentVNode(" Redo "),
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.classes.redo),
                            title: _ctx.redoText,
                            role: "button",
                            tabindex: _ctx.redos.length ? _ctx.tabindex : void 0,
                            "aria-label": _ctx.redoText,
                            onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleRedo && _ctx.handleRedo(...args), ["stop"])),
                            onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.handleRedo && _ctx.handleRedo(...args), ["prevent"]), ["space", "enter"]))
                          }, null, 42, _hoisted_4$6)
                        ],
                        2
                        /* CLASS */
                      ), [
                        [vShow, _ctx.showUndos]
                      ])
                    ],
                    2
                    /* CLASS */
                  ),
                  createCommentVNode(" Input "),
                  withDirectives(createBaseVNode("input", {
                    value: _ctx.text,
                    type: "text",
                    spellcheck: "false",
                    class: normalizeClass(_ctx.classes.input),
                    disabled: _ctx.isDisabled,
                    readonly: _ctx.readonly,
                    style: normalizeStyle(_ctx.inputStyle),
                    "aria-label": _ctx.inputAriaLabel,
                    onInput: _cache[4] || (_cache[4] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
                    onSelect: _cache[5] || (_cache[5] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
                    ref: "input$"
                  }, null, 46, _hoisted_5$3), [
                    [vShow, _ctx.showInput]
                  ]),
                  createCommentVNode(" Placeholder "),
                  withDirectives(createBaseVNode("div", {
                    class: normalizeClass(_ctx.classes.placeholder),
                    innerHTML: _ctx.placeholderText
                  }, null, 10, _hoisted_6$2), [
                    [vShow, _ctx.showPlaceholder]
                  ]),
                  createCommentVNode(" Upload container "),
                  withDirectives(createBaseVNode(
                    "div",
                    {
                      class: normalizeClass(_ctx.classes.uploadContainer),
                      ref: "upload$"
                    },
                    [
                      createCommentVNode(" File upload "),
                      withDirectives(createBaseVNode(
                        "div",
                        {
                          class: normalizeClass(_ctx.classes.uploadWrapper)
                        },
                        [
                          createCommentVNode(" DnD text "),
                          _ctx.droppable ? (openBlock(), createElementBlock(
                            "div",
                            {
                              key: 0,
                              class: normalizeClass(_ctx.classes.dndText)
                            },
                            toDisplayString(_ctx.dndText),
                            3
                            /* TEXT, CLASS */
                          )) : createCommentVNode("v-if", true),
                          createCommentVNode(" Select button "),
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.classes.uploadButton),
                            tabindex: _ctx.tabindex,
                            role: "button",
                            "aria-label": _ctx.uploadButtonText,
                            onClick: _cache[6] || (_cache[6] = (...args) => _ctx.handleSelectClick && _ctx.handleSelectClick(...args)),
                            onKeydown: _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.handleSelectClick && _ctx.handleSelectClick(...args), ["prevent"]), ["space", "enter"])),
                            ref: "uploadButton$"
                          }, toDisplayString(_ctx.uploadButtonText), 43, _hoisted_7$1),
                          createCommentVNode(" Hidden file input "),
                          withDirectives(createBaseVNode("input", {
                            type: "file",
                            accept: _ctx.fileAccept,
                            onChange: _cache[8] || (_cache[8] = (...args) => _ctx.handleFileSelect && _ctx.handleFileSelect(...args)),
                            ref: "file$"
                          }, null, 40, _hoisted_8), [
                            [vShow, false]
                          ])
                        ],
                        2
                        /* CLASS */
                      ), [
                        [vShow, _ctx.showUpload]
                      ]),
                      createCommentVNode(" Preview "),
                      withDirectives(createBaseVNode("canvas", {
                        width: _ctx.uploadWidth,
                        height: _ctx.uploadHeight,
                        class: normalizeClass(_ctx.classes.uploadPreview),
                        ref: "preview$"
                      }, null, 10, _hoisted_9), [
                        [vShow, _ctx.showPreview]
                      ])
                    ],
                    2
                    /* CLASS */
                  ), [
                    [vShow, _ctx.showUploadContainer]
                  ]),
                  createCommentVNode(" Pad "),
                  withDirectives(createBaseVNode("canvas", {
                    width: _ctx.padWidth,
                    height: _ctx.padHeight,
                    style: normalizeStyle(_ctx.padStyle),
                    class: normalizeClass(_ctx.classes.pad),
                    tabindex: _ctx.tabindex,
                    "aria-label": _ctx.padAriaLabel,
                    ref: "pad$"
                  }, null, 14, _hoisted_10), [
                    [vShow, _ctx.showPad]
                  ]),
                  createCommentVNode(" Colors "),
                  withDirectives(createBaseVNode(
                    "div",
                    {
                      class: normalizeClass(_ctx.classes.colors),
                      role: "listbox"
                    },
                    [
                      (openBlock(true), createElementBlock(
                        Fragment,
                        null,
                        renderList(_ctx.colors, (c2) => {
                          return openBlock(), createElementBlock("svg", {
                            width: "12",
                            height: "12",
                            class: normalizeClass(_ctx.classes.color(c2)),
                            role: "option",
                            tabindex: _ctx.tabindex,
                            "aria-label": `${_ctx.colorAriaLabel} ${c2}`,
                            "aria-selected": c2 === _ctx.color,
                            onClick: ($event) => _ctx.handleColorSelect(c2),
                            onKeydown: withKeys(withModifiers(($event) => _ctx.handleColorSelect(c2), ["prevent"]), ["space", "enter"])
                          }, [
                            createBaseVNode("circle", {
                              cx: "6",
                              cy: "6",
                              r: "6",
                              fill: c2
                            }, null, 8, _hoisted_12)
                          ], 42, _hoisted_11);
                        }),
                        256
                        /* UNKEYED_FRAGMENT */
                      ))
                    ],
                    2
                    /* CLASS */
                  ), [
                    [vShow, _ctx.showColors]
                  ])
                ],
                2
                /* CLASS */
              ), [
                [vShow, !_ctx.uploaded]
              ]),
              createCommentVNode(" Clear "),
              _ctx.showClear ? (openBlock(), createElementBlock(
                "div",
                {
                  key: 0,
                  class: normalizeClass(_ctx.classes.clearWrapper)
                },
                [
                  createBaseVNode("div", {
                    class: normalizeClass(_ctx.classes.clear),
                    tabindex: _ctx.tabindex,
                    role: "button",
                    "aria-label": _ctx.clearAriaLabel,
                    onClick: _cache[9] || (_cache[9] = (...args) => _ctx.handleClear && _ctx.handleClear(...args)),
                    onKeydown: _cache[10] || (_cache[10] = withKeys(withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["prevent"]), ["enter", "space"]))
                  }, null, 42, _hoisted_13)
                ],
                2
                /* CLASS */
              )) : createCommentVNode("v-if", true)
            ], 46, _hoisted_1$g)
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$L.render = render$l;
    script$L.__file = "themes/blank/templates/elements/SignatureElement.vue";
    var script$K = {
      name: "SignatureElement",
      render: script$L.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "vf-signature",
            wrapper_sm: "vf-signature-sm",
            wrapper_md: "",
            wrapper_lg: "vf-signature-lg",
            wrapper_disabled: "vf-signature-disabled",
            wrapper_enabled: "",
            wrapper_readonly: "vf-signature-readonly",
            line: "vf-signature-line",
            loadedWrapper: "vf-signature-loaded-wrapper",
            loadedWrapper_disabled: "vf-signature-loaded-wrapper-disabled",
            loadedWrapper_enabled: "",
            loadedImg: "vf-signature-loaded-img",
            innerWrapper: "vf-signature-inner-wrapper",
            innerWrapper_disabled: "vf-signature-inner-wrapper-disabled",
            innerWrapper_enabled: "",
            input: "vf-signature-input",
            input_invert: "vf-signature-input-invert",
            placeholder: "vf-signature-placeholder",
            uploadContainer: "vf-signature-upload-container",
            uploadContainer_dragging: "vf-signature-upload-container-dragging",
            uploadContainer_not_dragging: "",
            uploadWrapper: "vf-signature-upload-wrapper",
            uploadWrapper_processing: "vf-signature-upload-wrapper-processing",
            dndText: "vf-signature-dnd-text",
            uploadButton: "vf-btn vf-btn-secondary",
            uploadPreview: "vf-signature-upload-preview",
            pad: "vf-signature-pad",
            pad_invert: "vf-signature-pad-invert",
            colors: "vf-signature-colors",
            color: "vf-signature-color",
            color_invert: "vf-signature-color-invert",
            color_active: "vf-signature-color-active",
            color_inactive: "",
            actions: "vf-signature-actions",
            undosWrapper: "vf-signature-undos-wrapper",
            undo: "vf-signature-undo",
            undo_enabled: "",
            undo_disabled: "vf-signature-undo-disabled",
            redo: "vf-signature-redo",
            redo_enabled: "",
            redo_disabled: "vf-signature-redo-disabled",
            clearWrapper: "vf-signature-clear-wrapper",
            clear: "vf-signature-clear",
            $wrapper: (classes2, { isDisabled, readonly: readonly2, Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`],
              isDisabled ? classes2.wrapper_disabled : classes2.wrapper_enabled,
              readonly2 ? classes2.wrapper_readonly : null
            ],
            $loadedWrapper: (classes2, { isDisabled }) => [
              classes2.loadedWrapper,
              isDisabled ? classes2.loadedWrapper_disabled : classes2.loadedWrapper_enabled
            ],
            $innerWrapper: (classes2, { isDisabled }) => [
              classes2.innerWrapper,
              isDisabled ? classes2.innerWrapper_disabled : classes2.innerWrapper_enabled
            ],
            $input: (classes2, { invertColors, color }) => [
              classes2.input,
              invertColors.indexOf(color) !== -1 ? classes2.input_invert : null
            ],
            $uploadContainer: (classes2, { dragging }) => [
              classes2.uploadContainer,
              dragging ? classes2.uploadContainer_dragging : classes2.uploadContainer_not_dragging
            ],
            $uploadWrapper: (classes2, { processing }) => [
              classes2.uploadWrapper,
              processing ? classes2.uploadWrapper_processing : null
            ],
            $pad: (classes2, { invertColors, color }) => [
              classes2.pad,
              invertColors.indexOf(color) !== -1 ? classes2.pad_invert : null
            ],
            $color: (classes2, { color, invertColors, mode }) => (c2) => [
              classes2.color,
              c2 === color ? classes2.color_active : classes2.color_inactive,
              invertColors.indexOf(c2) !== -1 && mode !== "upload" ? classes2.color_invert : null
            ],
            $undo: (classes2, { undosLeft }) => [
              classes2.undo,
              undosLeft ? classes2.undo_enabled : classes2.undo_disabled
            ],
            $redo: (classes2, { redos }) => [
              classes2.redo,
              redos.length ? classes2.redo_enabled : classes2.redo_disabled
            ]
          }
        };
      }
    };
    var css_248z$m = `.vf-signature {
  position: relative;
  font-family: inherit;
  transition-property: box-shadow, color, background-color, border-color;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 200ms;
  border-style: solid;
  border-width: var(--vf-border-width-input-t) var(--vf-border-width-input-r) var(--vf-border-width-input-b) var(--vf-border-width-input-l);
  background-color: var(--vf-bg-input);
  color: var(--vf-color-input);
  border-color: var(--vf-border-color-input);
  font-size: var(--vf-font-size);
  line-height: var(--vf-line-height);
  letter-spacing: var(--vf-letter-spacing);
  border-radius: var(--vf-radius-large);
}

.vf-signature:focus {
  outline: var(--vf-ring-width) solid var(--vf-ring-color);
  border-color: var(--vf-border-color-input-focus);
}

.vf-signature.vf-signature-sm {
  font-size: var(--vf-font-size-sm);
  line-height: var(--vf-line-height-sm);
  letter-spacing: var(--vf-letter-spacing-sm);
  border-radius: var(--vf-radius-large-sm);
}

.vf-signature.vf-signature-lg {
  font-size: var(--vf-font-size-lg);
  line-height: var(--vf-line-height-lg);
  letter-spacing: var(--vf-letter-spacing-lg);
  border-radius: var(--vf-radius-large-lg);
}

.vf-signature.vf-signature-disabled {
  background-color: var(--vf-bg-disabled);
  color: var(--vf-color-disabled);
  cursor: not-allowed;
  pointer-events: none;
}

.vf-signature.vf-signature-readonly {
  pointer-events: none;
}

.vf-signature-line {
  position: absolute;
  top: 50%;
  left: 1.5rem;
  right: 1.5rem;
  border-color: var(--vf-border-color-signature-hr);
}

.vf-signature-loaded-wrapper {
  position: absolute;
  left: 2.25rem;
  right: 2.25rem;
  top: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

.vf-signature-loaded-wrapper.vf-signature-loaded-wrapper-disabled {
  opacity: 0.5;
}

.vf-signature-inner-wrapper.vf-signature-inner-wrapper-disabled {
  opacity: 0.5;
}

.vf-signature-input {
  background: transparent;
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  transform: translateY(-50%);
  padding: 0 2.25rem 0 0;
  text-align: center;
  text-indent: 2.25rem;
  transition-property: box-shadow, color, background-color, border-color;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 200ms;
  height: 8.5rem;
}

.vf-signature-placeholder {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 50%;
  transform: translateY(50%);
  pointer-events: none;
  color: var(--vf-color-placeholder);
  text-align: center;
}

.vf-signature-upload-container {
  position: absolute;
  left: 2.25rem;
  right: 2.25rem;
  bottom: 50%;
  transform: translateY(50%);
  transition-property: opacity;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 200ms;
}

.vf-signature-upload-container.vf-signature-upload-container-dragging {
  opacity: 0.5;
}

.vf-signature-upload-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.vf-signature-upload-wrapper.vf-signature-upload-wrapper-processing {
  opacity: 0.6;
  pointer-events: none;
}

.vf-signature-dnd-text {
  color: var(--vf-text-700);
}

.vf-signature-upload-preview {
  width: 100%;
  margin: 0 auto;
}

.vf-signature-pad {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  top: 0;
}

.vf-signature-colors {
  position: absolute;
  bottom: 1.25rem;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: row;
  gap: 0.5rem;
}

.vf-signature-color {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 200ms;
  cursor: pointer;
  outline: none;
  border-radius: 50%;
}

.vf-signature-color:hover, .vf-signature-color.vf-signature-color-active {
  transform: scale(1.4);
}

.vf-signature-color:focus-visible {
  outline: var(--vf-ring-width) solid var(--vf-ring-color);
}

.vf-signature-actions {
  position: absolute;
  top: 0.5rem;
  left: 0.75rem;
  right: 0.75rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  opacity: 0.5;
  transition-property: opacity;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 200ms;
  z-index: 1;
}

.vf-signature-actions:hover {
  opacity: 1;
}

.vf-signature-undos-wrapper {
  position: absolute;
  right: 0.75rem;
  top: 0.75rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.75rem;
}

.vf-signature-undo,
.vf-signature-redo {
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-position: center center;
  -webkit-mask-position: center center;
  mask-size: contain;
  -webkit-mask-size: contain;
  background-color: var(--vf-bg-icon);
  cursor: pointer;
  width: 0.75rem;
  height: 0.75rem;
}

.vf-signature-undo:focus-visible,
.vf-signature-redo:focus-visible {
  opacity: 0.8;
}

.vf-signature-undo {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z'%3e%3c/path%3e%3c/svg%3e");
}

.vf-signature-undo.vf-signature-undo-disabled {
  cursor: not-allowed;
  opacity: 0.5;
}

.vf-signature-redo {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z'%3e%3c/path%3e%3c/svg%3e");
}

.vf-signature-redo.vf-signature-redo-disabled {
  cursor: not-allowed;
  opacity: 0.5;
}

.vf-signature-clear-wrapper {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  right: 1rem;
  font-size: 14px;
}

.vf-signature-clear {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  mask-position: center;
  -webkit-mask-position: center;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-size: contain;
  -webkit-mask-size: contain;
  background-color: var(--vf-color-input);
  width: 0.75rem;
  height: 1rem;
  padding: 1px 0;
  box-sizing: content-box;
  display: inline-block;
  cursor: pointer;
}

.vf-signature-clear:focus-visible {
  opacity: 0.8;
}

.dark .vf-signature-input-invert,
.dark .vf-signature-pad-invert,
.dark .vf-signature-color-invert {
  filter: invert(1);
}

.dark .vf-signature-dnd-text {
  color: var(--vf-dark-200);
}

.dark .vf-signature-undo,
.dark .vf-signature-redo {
  background: var(--vf-dark-300);
}

[dir=rtl] .vf-signature-input {
  padding: 0 0 0 2.25rem;
}

[dir=rtl] .vf-signature-undos-wrapper {
  right: auto;
  left: 0.75rem;
}`;
    styleInject(css_248z$m);
    script$K.__file = "themes/vueform/templates/elements/SignatureElement.vue";
    function isNullish(val) {
      return [null, void 0, false].indexOf(val) !== -1;
    }
    function useValue$2(props, context, dependencies2) {
      const { value: baseValue, modelValue, min: min2 } = toRefs(props);
      let value = modelValue && modelValue.value !== void 0 ? modelValue : baseValue;
      const initialValue = ref(value.value);
      if (isNullish(value.value)) {
        value = ref(min2.value);
      }
      if (Array.isArray(value.value) && value.value.length == 0) {
        throw new Error("Slider v-model must not be an empty array");
      }
      return {
        value,
        initialValue
      };
    }
    function useClasses$1(props, context, dependencies2) {
      const {
        classes: classes_,
        showTooltip,
        tooltipPosition,
        orientation
      } = toRefs(props);
      const classes2 = computed(() => ({
        target: "slider-target",
        focused: "slider-focused",
        tooltipFocus: "slider-tooltip-focus",
        tooltipDrag: "slider-tooltip-drag",
        ltr: "slider-ltr",
        rtl: "slider-rtl",
        horizontal: "slider-horizontal",
        vertical: "slider-vertical",
        textDirectionRtl: "slider-txt-dir-rtl",
        textDirectionLtr: "slider-txt-dir-ltr",
        base: "slider-base",
        connects: "slider-connects",
        connect: "slider-connect",
        origin: "slider-origin",
        handle: "slider-handle",
        handleLower: "slider-handle-lower",
        handleUpper: "slider-handle-upper",
        touchArea: "slider-touch-area",
        tooltip: "slider-tooltip",
        tooltipTop: "slider-tooltip-top",
        tooltipBottom: "slider-tooltip-bottom",
        tooltipLeft: "slider-tooltip-left",
        tooltipRight: "slider-tooltip-right",
        tooltipHidden: "slider-tooltip-hidden",
        active: "slider-active",
        draggable: "slider-draggable",
        tap: "slider-state-tap",
        drag: "slider-state-drag",
        // Unimplemented
        pips: "slider-pips",
        pipsHorizontal: "slider-pips-horizontal",
        pipsVertical: "slider-pips-vertical",
        marker: "slider-marker",
        markerHorizontal: "slider-marker-horizontal",
        markerVertical: "slider-marker-vertical",
        markerNormal: "slider-marker-normal",
        markerLarge: "slider-marker-large",
        markerSub: "slider-marker-sub",
        value: "slider-value",
        valueHorizontal: "slider-value-horizontal",
        valueVertical: "slider-value-vertical",
        valueNormal: "slider-value-normal",
        valueLarge: "slider-value-large",
        valueSub: "slider-value-sub",
        ...classes_.value
      }));
      const classList = computed(() => {
        const classList2 = { ...classes2.value };
        Object.keys(classList2).forEach((className) => {
          classList2[className] = Array.isArray(classList2[className]) ? classList2[className].filter((c2) => c2 !== null).join(" ") : classList2[className];
        });
        if (showTooltip.value !== "always") {
          classList2.target += ` ${showTooltip.value === "drag" ? classList2.tooltipDrag : classList2.tooltipFocus}`;
        }
        if (orientation.value === "horizontal") {
          classList2.tooltip += tooltipPosition.value === "bottom" ? ` ${classList2.tooltipBottom}` : ` ${classList2.tooltipTop}`;
        }
        if (orientation.value === "vertical") {
          classList2.tooltip += tooltipPosition.value === "right" ? ` ${classList2.tooltipRight}` : ` ${classList2.tooltipLeft}`;
        }
        return classList2;
      });
      return {
        classList
      };
    }
    var wNumb = { exports: {} };
    (function(module2, exports2) {
      (function(factory) {
        {
          module2.exports = factory();
        }
      })(function() {
        var FormatOptions = [
          "decimals",
          "thousand",
          "mark",
          "prefix",
          "suffix",
          "encoder",
          "decoder",
          "negativeBefore",
          "negative",
          "edit",
          "undo"
        ];
        function strReverse(a2) {
          return a2.split("").reverse().join("");
        }
        function strStartsWith(input, match) {
          return input.substring(0, match.length) === match;
        }
        function strEndsWith(input, match) {
          return input.slice(-1 * match.length) === match;
        }
        function throwEqualError(F2, a2, b2) {
          if ((F2[a2] || F2[b2]) && F2[a2] === F2[b2]) {
            throw new Error(a2);
          }
        }
        function isValidNumber(input) {
          return typeof input === "number" && isFinite(input);
        }
        function toFixed(value, exp) {
          value = value.toString().split("e");
          value = Math.round(+(value[0] + "e" + (value[1] ? +value[1] + exp : exp)));
          value = value.toString().split("e");
          return (+(value[0] + "e" + (value[1] ? +value[1] - exp : -exp))).toFixed(exp);
        }
        function formatTo(decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input) {
          var originalInput = input, inputIsNegative, inputPieces, inputBase, inputDecimals = "", output = "";
          if (encoder) {
            input = encoder(input);
          }
          if (!isValidNumber(input)) {
            return false;
          }
          if (decimals !== false && parseFloat(input.toFixed(decimals)) === 0) {
            input = 0;
          }
          if (input < 0) {
            inputIsNegative = true;
            input = Math.abs(input);
          }
          if (decimals !== false) {
            input = toFixed(input, decimals);
          }
          input = input.toString();
          if (input.indexOf(".") !== -1) {
            inputPieces = input.split(".");
            inputBase = inputPieces[0];
            if (mark) {
              inputDecimals = mark + inputPieces[1];
            }
          } else {
            inputBase = input;
          }
          if (thousand) {
            inputBase = strReverse(inputBase).match(/.{1,3}/g);
            inputBase = strReverse(inputBase.join(strReverse(thousand)));
          }
          if (inputIsNegative && negativeBefore) {
            output += negativeBefore;
          }
          if (prefix) {
            output += prefix;
          }
          if (inputIsNegative && negative) {
            output += negative;
          }
          output += inputBase;
          output += inputDecimals;
          if (suffix) {
            output += suffix;
          }
          if (edit) {
            output = edit(output, originalInput);
          }
          return output;
        }
        function formatFrom(decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input) {
          var inputIsNegative, output = "";
          if (undo) {
            input = undo(input);
          }
          if (!input || typeof input !== "string") {
            return false;
          }
          if (negativeBefore && strStartsWith(input, negativeBefore)) {
            input = input.replace(negativeBefore, "");
            inputIsNegative = true;
          }
          if (prefix && strStartsWith(input, prefix)) {
            input = input.replace(prefix, "");
          }
          if (negative && strStartsWith(input, negative)) {
            input = input.replace(negative, "");
            inputIsNegative = true;
          }
          if (suffix && strEndsWith(input, suffix)) {
            input = input.slice(0, -1 * suffix.length);
          }
          if (thousand) {
            input = input.split(thousand).join("");
          }
          if (mark) {
            input = input.replace(mark, ".");
          }
          if (inputIsNegative) {
            output += "-";
          }
          output += input;
          output = output.replace(/[^0-9\.\-.]/g, "");
          if (output === "") {
            return false;
          }
          output = Number(output);
          if (decoder) {
            output = decoder(output);
          }
          if (!isValidNumber(output)) {
            return false;
          }
          return output;
        }
        function validate(inputOptions) {
          var i2, optionName, optionValue, filteredOptions = {};
          if (inputOptions["suffix"] === void 0) {
            inputOptions["suffix"] = inputOptions["postfix"];
          }
          for (i2 = 0; i2 < FormatOptions.length; i2 += 1) {
            optionName = FormatOptions[i2];
            optionValue = inputOptions[optionName];
            if (optionValue === void 0) {
              if (optionName === "negative" && !filteredOptions.negativeBefore) {
                filteredOptions[optionName] = "-";
              } else if (optionName === "mark" && filteredOptions.thousand !== ".") {
                filteredOptions[optionName] = ".";
              } else {
                filteredOptions[optionName] = false;
              }
            } else if (optionName === "decimals") {
              if (optionValue >= 0 && optionValue < 8) {
                filteredOptions[optionName] = optionValue;
              } else {
                throw new Error(optionName);
              }
            } else if (optionName === "encoder" || optionName === "decoder" || optionName === "edit" || optionName === "undo") {
              if (typeof optionValue === "function") {
                filteredOptions[optionName] = optionValue;
              } else {
                throw new Error(optionName);
              }
            } else {
              if (typeof optionValue === "string") {
                filteredOptions[optionName] = optionValue;
              } else {
                throw new Error(optionName);
              }
            }
          }
          throwEqualError(filteredOptions, "mark", "thousand");
          throwEqualError(filteredOptions, "prefix", "negative");
          throwEqualError(filteredOptions, "prefix", "negativeBefore");
          return filteredOptions;
        }
        function passAll(options, method, input) {
          var i2, args = [];
          for (i2 = 0; i2 < FormatOptions.length; i2 += 1) {
            args.push(options[FormatOptions[i2]]);
          }
          args.push(input);
          return method.apply("", args);
        }
        function wNumb2(options) {
          if (!(this instanceof wNumb2)) {
            return new wNumb2(options);
          }
          if (typeof options !== "object") {
            return;
          }
          options = validate(options);
          this.to = function(input) {
            return passAll(options, formatTo, input);
          };
          this.from = function(input) {
            return passAll(options, formatFrom, input);
          };
        }
        return wNumb2;
      });
    })(wNumb);
    var wnumb = wNumb.exports;
    function useTooltip(props, context, dependencies2) {
      const { format: format2, step } = toRefs(props);
      const value = dependencies2.value;
      const classList = dependencies2.classList;
      const tooltipFormat = computed(() => {
        if (!format2 || !format2.value) {
          return wnumb({ decimals: step.value >= 0 ? 0 : 2 });
        }
        if (typeof format2.value == "function") {
          return { to: format2.value };
        }
        return wnumb({ ...format2.value });
      });
      const tooltipsFormat = computed(() => {
        return Array.isArray(value.value) ? value.value.map((v2) => tooltipFormat.value) : tooltipFormat.value;
      });
      const tooltipsMerge = (slider2, threshold, separator) => {
        var textIsRtl = getComputedStyle(slider2).direction === "rtl";
        var isRtl = slider2.noUiSlider.options.direction === "rtl";
        var isVertical = slider2.noUiSlider.options.orientation === "vertical";
        var tooltips = slider2.noUiSlider.getTooltips();
        var origins = slider2.noUiSlider.getOrigins();
        tooltips.forEach(function(tooltip, index2) {
          if (tooltip) {
            origins[index2].appendChild(tooltip);
          }
        });
        slider2.noUiSlider.on("update", function(values2, handle, unencoded, tap, positions) {
          var pools = [[]];
          var poolPositions = [[]];
          var poolValues = [[]];
          var atPool = 0;
          if (tooltips[0]) {
            pools[0][0] = 0;
            poolPositions[0][0] = positions[0];
            poolValues[0][0] = tooltipFormat.value.to(parseFloat(values2[0]));
          }
          for (var i2 = 1; i2 < values2.length; i2++) {
            if (!tooltips[i2] || values2[i2] - values2[i2 - 1] > threshold) {
              atPool++;
              pools[atPool] = [];
              poolValues[atPool] = [];
              poolPositions[atPool] = [];
            }
            if (tooltips[i2]) {
              pools[atPool].push(i2);
              poolValues[atPool].push(tooltipFormat.value.to(parseFloat(values2[i2])));
              poolPositions[atPool].push(positions[i2]);
            }
          }
          pools.forEach(function(pool, poolIndex) {
            var handlesInPool = pool.length;
            for (var j2 = 0; j2 < handlesInPool; j2++) {
              var handleNumber = pool[j2];
              if (j2 === handlesInPool - 1) {
                var offset2 = 0;
                poolPositions[poolIndex].forEach(function(value2) {
                  offset2 += 1e3 - value2;
                });
                var direction = isVertical ? "bottom" : "right";
                var last2 = isRtl ? 0 : handlesInPool - 1;
                var lastOffset = 1e3 - poolPositions[poolIndex][last2];
                offset2 = (textIsRtl && !isVertical ? 100 : 0) + offset2 / handlesInPool - lastOffset;
                tooltips[handleNumber].innerHTML = poolValues[poolIndex].join(separator);
                tooltips[handleNumber].style.display = "block";
                tooltips[handleNumber].style[direction] = offset2 + "%";
                classList.value.tooltipHidden.split(" ").forEach((c2) => {
                  if (tooltips[handleNumber].classList.contains(c2)) {
                    tooltips[handleNumber].classList.remove(c2);
                  }
                });
              } else {
                tooltips[handleNumber].style.display = "none";
                classList.value.tooltipHidden.split(" ").forEach((c2) => {
                  tooltips[handleNumber].classList.add(c2);
                });
              }
            }
          });
        });
      };
      return {
        tooltipFormat,
        tooltipsFormat,
        tooltipsMerge
      };
    }
    var PipsMode;
    (function(PipsMode2) {
      PipsMode2["Range"] = "range";
      PipsMode2["Steps"] = "steps";
      PipsMode2["Positions"] = "positions";
      PipsMode2["Count"] = "count";
      PipsMode2["Values"] = "values";
    })(PipsMode || (PipsMode = {}));
    var PipsType;
    (function(PipsType2) {
      PipsType2[PipsType2["None"] = -1] = "None";
      PipsType2[PipsType2["NoValue"] = 0] = "NoValue";
      PipsType2[PipsType2["LargeValue"] = 1] = "LargeValue";
      PipsType2[PipsType2["SmallValue"] = 2] = "SmallValue";
    })(PipsType || (PipsType = {}));
    function isValidFormatter(entry) {
      return isValidPartialFormatter(entry) && typeof entry.from === "function";
    }
    function isValidPartialFormatter(entry) {
      return typeof entry === "object" && typeof entry.to === "function";
    }
    function removeElement(el) {
      el.parentElement.removeChild(el);
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
    function preventDefault(e2) {
      e2.preventDefault();
    }
    function unique(array2) {
      return array2.filter(function(a2) {
        return !this[a2] ? this[a2] = true : false;
      }, {});
    }
    function closest(value, to2) {
      return Math.round(value / to2) * to2;
    }
    function offset(elem, orientation) {
      var rect = elem.getBoundingClientRect();
      var doc2 = elem.ownerDocument;
      var docElem = doc2.documentElement;
      var pageOffset = getPageOffset(doc2);
      if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
        pageOffset.x = 0;
      }
      return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;
    }
    function isNumeric(a2) {
      return typeof a2 === "number" && !isNaN(a2) && isFinite(a2);
    }
    function addClassFor(element, className, duration2) {
      if (duration2 > 0) {
        addClass(element, className);
        setTimeout(function() {
          removeClass(element, className);
        }, duration2);
      }
    }
    function limit(a2) {
      return Math.max(Math.min(a2, 100), 0);
    }
    function asArray(a2) {
      return Array.isArray(a2) ? a2 : [a2];
    }
    function countDecimals(numStr) {
      numStr = String(numStr);
      var pieces = numStr.split(".");
      return pieces.length > 1 ? pieces[1].length : 0;
    }
    function addClass(el, className) {
      if (el.classList && !/\s/.test(className)) {
        el.classList.add(className);
      } else {
        el.className += " " + className;
      }
    }
    function removeClass(el, className) {
      if (el.classList && !/\s/.test(className)) {
        el.classList.remove(className);
      } else {
        el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
      }
    }
    function hasClass(el, className) {
      return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className);
    }
    function getPageOffset(doc2) {
      var supportPageOffset = window.pageXOffset !== void 0;
      var isCSS1Compat = (doc2.compatMode || "") === "CSS1Compat";
      var x2 = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc2.documentElement.scrollLeft : doc2.body.scrollLeft;
      var y2 = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc2.documentElement.scrollTop : doc2.body.scrollTop;
      return {
        x: x2,
        y: y2
      };
    }
    function getActions() {
      return window.navigator.pointerEnabled ? {
        start: "pointerdown",
        move: "pointermove",
        end: "pointerup"
      } : window.navigator.msPointerEnabled ? {
        start: "MSPointerDown",
        move: "MSPointerMove",
        end: "MSPointerUp"
      } : {
        start: "mousedown touchstart",
        move: "mousemove touchmove",
        end: "mouseup touchend"
      };
    }
    function getSupportsPassive() {
      var supportsPassive = false;
      try {
        var opts = Object.defineProperty({}, "passive", {
          get: function() {
            supportsPassive = true;
          }
        });
        window.addEventListener("test", null, opts);
      } catch (e2) {
      }
      return supportsPassive;
    }
    function getSupportsTouchActionNone() {
      return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
    }
    function subRangeRatio(pa, pb) {
      return 100 / (pb - pa);
    }
    function fromPercentage(range, value, startRange) {
      return value * 100 / (range[startRange + 1] - range[startRange]);
    }
    function toPercentage(range, value) {
      return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);
    }
    function isPercentage(range, value) {
      return value * (range[1] - range[0]) / 100 + range[0];
    }
    function getJ(value, arr) {
      var j2 = 1;
      while (value >= arr[j2]) {
        j2 += 1;
      }
      return j2;
    }
    function toStepping(xVal, xPct, value) {
      if (value >= xVal.slice(-1)[0]) {
        return 100;
      }
      var j2 = getJ(value, xVal);
      var va = xVal[j2 - 1];
      var vb = xVal[j2];
      var pa = xPct[j2 - 1];
      var pb = xPct[j2];
      return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);
    }
    function fromStepping(xVal, xPct, value) {
      if (value >= 100) {
        return xVal.slice(-1)[0];
      }
      var j2 = getJ(value, xPct);
      var va = xVal[j2 - 1];
      var vb = xVal[j2];
      var pa = xPct[j2 - 1];
      var pb = xPct[j2];
      return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
    }
    function getStep(xPct, xSteps, snap, value) {
      if (value === 100) {
        return value;
      }
      var j2 = getJ(value, xPct);
      var a2 = xPct[j2 - 1];
      var b2 = xPct[j2];
      if (snap) {
        if (value - a2 > (b2 - a2) / 2) {
          return b2;
        }
        return a2;
      }
      if (!xSteps[j2 - 1]) {
        return value;
      }
      return xPct[j2 - 1] + closest(value - xPct[j2 - 1], xSteps[j2 - 1]);
    }
    var Spectrum = (
      /** @class */
      function() {
        function Spectrum2(entry, snap, singleStep) {
          this.xPct = [];
          this.xVal = [];
          this.xSteps = [];
          this.xNumSteps = [];
          this.xHighestCompleteStep = [];
          this.xSteps = [singleStep || false];
          this.xNumSteps = [false];
          this.snap = snap;
          var index2;
          var ordered = [];
          Object.keys(entry).forEach(function(index3) {
            ordered.push([asArray(entry[index3]), index3]);
          });
          ordered.sort(function(a2, b2) {
            return a2[0][0] - b2[0][0];
          });
          for (index2 = 0; index2 < ordered.length; index2++) {
            this.handleEntryPoint(ordered[index2][1], ordered[index2][0]);
          }
          this.xNumSteps = this.xSteps.slice(0);
          for (index2 = 0; index2 < this.xNumSteps.length; index2++) {
            this.handleStepPoint(index2, this.xNumSteps[index2]);
          }
        }
        Spectrum2.prototype.getDistance = function(value) {
          var distances = [];
          for (var index2 = 0; index2 < this.xNumSteps.length - 1; index2++) {
            distances[index2] = fromPercentage(this.xVal, value, index2);
          }
          return distances;
        };
        Spectrum2.prototype.getAbsoluteDistance = function(value, distances, direction) {
          var xPct_index = 0;
          if (value < this.xPct[this.xPct.length - 1]) {
            while (value > this.xPct[xPct_index + 1]) {
              xPct_index++;
            }
          } else if (value === this.xPct[this.xPct.length - 1]) {
            xPct_index = this.xPct.length - 2;
          }
          if (!direction && value === this.xPct[xPct_index + 1]) {
            xPct_index++;
          }
          if (distances === null) {
            distances = [];
          }
          var start_factor;
          var rest_factor = 1;
          var rest_rel_distance = distances[xPct_index];
          var range_pct = 0;
          var rel_range_distance = 0;
          var abs_distance_counter = 0;
          var range_counter = 0;
          if (direction) {
            start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
          } else {
            start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
          }
          while (rest_rel_distance > 0) {
            range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];
            if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
              rel_range_distance = range_pct * start_factor;
              rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];
              start_factor = 1;
            } else {
              rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor;
              rest_factor = 0;
            }
            if (direction) {
              abs_distance_counter = abs_distance_counter - rel_range_distance;
              if (this.xPct.length + range_counter >= 1) {
                range_counter--;
              }
            } else {
              abs_distance_counter = abs_distance_counter + rel_range_distance;
              if (this.xPct.length - range_counter >= 1) {
                range_counter++;
              }
            }
            rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
          }
          return value + abs_distance_counter;
        };
        Spectrum2.prototype.toStepping = function(value) {
          value = toStepping(this.xVal, this.xPct, value);
          return value;
        };
        Spectrum2.prototype.fromStepping = function(value) {
          return fromStepping(this.xVal, this.xPct, value);
        };
        Spectrum2.prototype.getStep = function(value) {
          value = getStep(this.xPct, this.xSteps, this.snap, value);
          return value;
        };
        Spectrum2.prototype.getDefaultStep = function(value, isDown, size2) {
          var j2 = getJ(value, this.xPct);
          if (value === 100 || isDown && value === this.xPct[j2 - 1]) {
            j2 = Math.max(j2 - 1, 1);
          }
          return (this.xVal[j2] - this.xVal[j2 - 1]) / size2;
        };
        Spectrum2.prototype.getNearbySteps = function(value) {
          var j2 = getJ(value, this.xPct);
          return {
            stepBefore: {
              startValue: this.xVal[j2 - 2],
              step: this.xNumSteps[j2 - 2],
              highestStep: this.xHighestCompleteStep[j2 - 2]
            },
            thisStep: {
              startValue: this.xVal[j2 - 1],
              step: this.xNumSteps[j2 - 1],
              highestStep: this.xHighestCompleteStep[j2 - 1]
            },
            stepAfter: {
              startValue: this.xVal[j2],
              step: this.xNumSteps[j2],
              highestStep: this.xHighestCompleteStep[j2]
            }
          };
        };
        Spectrum2.prototype.countStepDecimals = function() {
          var stepDecimals = this.xNumSteps.map(countDecimals);
          return Math.max.apply(null, stepDecimals);
        };
        Spectrum2.prototype.hasNoSize = function() {
          return this.xVal[0] === this.xVal[this.xVal.length - 1];
        };
        Spectrum2.prototype.convert = function(value) {
          return this.getStep(this.toStepping(value));
        };
        Spectrum2.prototype.handleEntryPoint = function(index2, value) {
          var percentage;
          if (index2 === "min") {
            percentage = 0;
          } else if (index2 === "max") {
            percentage = 100;
          } else {
            percentage = parseFloat(index2);
          }
          if (!isNumeric(percentage) || !isNumeric(value[0])) {
            throw new Error("noUiSlider: 'range' value isn't numeric.");
          }
          this.xPct.push(percentage);
          this.xVal.push(value[0]);
          var value1 = Number(value[1]);
          if (!percentage) {
            if (!isNaN(value1)) {
              this.xSteps[0] = value1;
            }
          } else {
            this.xSteps.push(isNaN(value1) ? false : value1);
          }
          this.xHighestCompleteStep.push(0);
        };
        Spectrum2.prototype.handleStepPoint = function(i2, n2) {
          if (!n2) {
            return;
          }
          if (this.xVal[i2] === this.xVal[i2 + 1]) {
            this.xSteps[i2] = this.xHighestCompleteStep[i2] = this.xVal[i2];
            return;
          }
          this.xSteps[i2] = fromPercentage([this.xVal[i2], this.xVal[i2 + 1]], n2, 0) / subRangeRatio(this.xPct[i2], this.xPct[i2 + 1]);
          var totalSteps = (this.xVal[i2 + 1] - this.xVal[i2]) / this.xNumSteps[i2];
          var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
          var step = this.xVal[i2] + this.xNumSteps[i2] * highestStep;
          this.xHighestCompleteStep[i2] = step;
        };
        return Spectrum2;
      }()
    );
    var defaultFormatter = {
      to: function(value) {
        return value === void 0 ? "" : value.toFixed(2);
      },
      from: Number
    };
    var cssClasses = {
      target: "target",
      base: "base",
      origin: "origin",
      handle: "handle",
      handleLower: "handle-lower",
      handleUpper: "handle-upper",
      touchArea: "touch-area",
      horizontal: "horizontal",
      vertical: "vertical",
      background: "background",
      connect: "connect",
      connects: "connects",
      ltr: "ltr",
      rtl: "rtl",
      textDirectionLtr: "txt-dir-ltr",
      textDirectionRtl: "txt-dir-rtl",
      draggable: "draggable",
      drag: "state-drag",
      tap: "state-tap",
      active: "active",
      tooltip: "tooltip",
      pips: "pips",
      pipsHorizontal: "pips-horizontal",
      pipsVertical: "pips-vertical",
      marker: "marker",
      markerHorizontal: "marker-horizontal",
      markerVertical: "marker-vertical",
      markerNormal: "marker-normal",
      markerLarge: "marker-large",
      markerSub: "marker-sub",
      value: "value",
      valueHorizontal: "value-horizontal",
      valueVertical: "value-vertical",
      valueNormal: "value-normal",
      valueLarge: "value-large",
      valueSub: "value-sub"
    };
    var INTERNAL_EVENT_NS = {
      tooltips: ".__tooltips",
      aria: ".__aria"
    };
    function testStep(parsed, entry) {
      if (!isNumeric(entry)) {
        throw new Error("noUiSlider: 'step' is not numeric.");
      }
      parsed.singleStep = entry;
    }
    function testKeyboardPageMultiplier(parsed, entry) {
      if (!isNumeric(entry)) {
        throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
      }
      parsed.keyboardPageMultiplier = entry;
    }
    function testKeyboardMultiplier(parsed, entry) {
      if (!isNumeric(entry)) {
        throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
      }
      parsed.keyboardMultiplier = entry;
    }
    function testKeyboardDefaultStep(parsed, entry) {
      if (!isNumeric(entry)) {
        throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
      }
      parsed.keyboardDefaultStep = entry;
    }
    function testRange(parsed, entry) {
      if (typeof entry !== "object" || Array.isArray(entry)) {
        throw new Error("noUiSlider: 'range' is not an object.");
      }
      if (entry.min === void 0 || entry.max === void 0) {
        throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
      }
      parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);
    }
    function testStart(parsed, entry) {
      entry = asArray(entry);
      if (!Array.isArray(entry) || !entry.length) {
        throw new Error("noUiSlider: 'start' option is incorrect.");
      }
      parsed.handles = entry.length;
      parsed.start = entry;
    }
    function testSnap(parsed, entry) {
      if (typeof entry !== "boolean") {
        throw new Error("noUiSlider: 'snap' option must be a boolean.");
      }
      parsed.snap = entry;
    }
    function testAnimate(parsed, entry) {
      if (typeof entry !== "boolean") {
        throw new Error("noUiSlider: 'animate' option must be a boolean.");
      }
      parsed.animate = entry;
    }
    function testAnimationDuration(parsed, entry) {
      if (typeof entry !== "number") {
        throw new Error("noUiSlider: 'animationDuration' option must be a number.");
      }
      parsed.animationDuration = entry;
    }
    function testConnect(parsed, entry) {
      var connect = [false];
      var i2;
      if (entry === "lower") {
        entry = [true, false];
      } else if (entry === "upper") {
        entry = [false, true];
      }
      if (entry === true || entry === false) {
        for (i2 = 1; i2 < parsed.handles; i2++) {
          connect.push(entry);
        }
        connect.push(false);
      } else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
        throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
      } else {
        connect = entry;
      }
      parsed.connect = connect;
    }
    function testOrientation(parsed, entry) {
      switch (entry) {
        case "horizontal":
          parsed.ort = 0;
          break;
        case "vertical":
          parsed.ort = 1;
          break;
        default:
          throw new Error("noUiSlider: 'orientation' option is invalid.");
      }
    }
    function testMargin(parsed, entry) {
      if (!isNumeric(entry)) {
        throw new Error("noUiSlider: 'margin' option must be numeric.");
      }
      if (entry === 0) {
        return;
      }
      parsed.margin = parsed.spectrum.getDistance(entry);
    }
    function testLimit(parsed, entry) {
      if (!isNumeric(entry)) {
        throw new Error("noUiSlider: 'limit' option must be numeric.");
      }
      parsed.limit = parsed.spectrum.getDistance(entry);
      if (!parsed.limit || parsed.handles < 2) {
        throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
      }
    }
    function testPadding(parsed, entry) {
      var index2;
      if (!isNumeric(entry) && !Array.isArray(entry)) {
        throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
      }
      if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
        throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
      }
      if (entry === 0) {
        return;
      }
      if (!Array.isArray(entry)) {
        entry = [entry, entry];
      }
      parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];
      for (index2 = 0; index2 < parsed.spectrum.xNumSteps.length - 1; index2++) {
        if (parsed.padding[0][index2] < 0 || parsed.padding[1][index2] < 0) {
          throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
        }
      }
      var totalPadding = entry[0] + entry[1];
      var firstValue = parsed.spectrum.xVal[0];
      var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];
      if (totalPadding / (lastValue - firstValue) > 1) {
        throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
      }
    }
    function testDirection(parsed, entry) {
      switch (entry) {
        case "ltr":
          parsed.dir = 0;
          break;
        case "rtl":
          parsed.dir = 1;
          break;
        default:
          throw new Error("noUiSlider: 'direction' option was not recognized.");
      }
    }
    function testBehaviour(parsed, entry) {
      if (typeof entry !== "string") {
        throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
      }
      var tap = entry.indexOf("tap") >= 0;
      var drag = entry.indexOf("drag") >= 0;
      var fixed = entry.indexOf("fixed") >= 0;
      var snap = entry.indexOf("snap") >= 0;
      var hover = entry.indexOf("hover") >= 0;
      var unconstrained = entry.indexOf("unconstrained") >= 0;
      var invertConnects = entry.indexOf("invert-connects") >= 0;
      var dragAll = entry.indexOf("drag-all") >= 0;
      var smoothSteps = entry.indexOf("smooth-steps") >= 0;
      if (fixed) {
        if (parsed.handles !== 2) {
          throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
        }
        testMargin(parsed, parsed.start[1] - parsed.start[0]);
      }
      if (invertConnects && parsed.handles !== 2) {
        throw new Error("noUiSlider: 'invert-connects' behaviour must be used with 2 handles");
      }
      if (unconstrained && (parsed.margin || parsed.limit)) {
        throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
      }
      parsed.events = {
        tap: tap || snap,
        drag,
        dragAll,
        smoothSteps,
        fixed,
        snap,
        hover,
        unconstrained,
        invertConnects
      };
    }
    function testTooltips(parsed, entry) {
      if (entry === false) {
        return;
      }
      if (entry === true || isValidPartialFormatter(entry)) {
        parsed.tooltips = [];
        for (var i2 = 0; i2 < parsed.handles; i2++) {
          parsed.tooltips.push(entry);
        }
      } else {
        entry = asArray(entry);
        if (entry.length !== parsed.handles) {
          throw new Error("noUiSlider: must pass a formatter for all handles.");
        }
        entry.forEach(function(formatter) {
          if (typeof formatter !== "boolean" && !isValidPartialFormatter(formatter)) {
            throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
          }
        });
        parsed.tooltips = entry;
      }
    }
    function testHandleAttributes(parsed, entry) {
      if (entry.length !== parsed.handles) {
        throw new Error("noUiSlider: must pass a attributes for all handles.");
      }
      parsed.handleAttributes = entry;
    }
    function testAriaFormat(parsed, entry) {
      if (!isValidPartialFormatter(entry)) {
        throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
      }
      parsed.ariaFormat = entry;
    }
    function testFormat(parsed, entry) {
      if (!isValidFormatter(entry)) {
        throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
      }
      parsed.format = entry;
    }
    function testKeyboardSupport(parsed, entry) {
      if (typeof entry !== "boolean") {
        throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
      }
      parsed.keyboardSupport = entry;
    }
    function testDocumentElement(parsed, entry) {
      parsed.documentElement = entry;
    }
    function testCssPrefix(parsed, entry) {
      if (typeof entry !== "string" && entry !== false) {
        throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
      }
      parsed.cssPrefix = entry;
    }
    function testCssClasses(parsed, entry) {
      if (typeof entry !== "object") {
        throw new Error("noUiSlider: 'cssClasses' must be an object.");
      }
      if (typeof parsed.cssPrefix === "string") {
        parsed.cssClasses = {};
        Object.keys(entry).forEach(function(key) {
          parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
        });
      } else {
        parsed.cssClasses = entry;
      }
    }
    function testOptions(options) {
      var parsed = {
        margin: null,
        limit: null,
        padding: null,
        animate: true,
        animationDuration: 300,
        ariaFormat: defaultFormatter,
        format: defaultFormatter
      };
      var tests = {
        step: { r: false, t: testStep },
        keyboardPageMultiplier: { r: false, t: testKeyboardPageMultiplier },
        keyboardMultiplier: { r: false, t: testKeyboardMultiplier },
        keyboardDefaultStep: { r: false, t: testKeyboardDefaultStep },
        start: { r: true, t: testStart },
        connect: { r: true, t: testConnect },
        direction: { r: true, t: testDirection },
        snap: { r: false, t: testSnap },
        animate: { r: false, t: testAnimate },
        animationDuration: { r: false, t: testAnimationDuration },
        range: { r: true, t: testRange },
        orientation: { r: false, t: testOrientation },
        margin: { r: false, t: testMargin },
        limit: { r: false, t: testLimit },
        padding: { r: false, t: testPadding },
        behaviour: { r: true, t: testBehaviour },
        ariaFormat: { r: false, t: testAriaFormat },
        format: { r: false, t: testFormat },
        tooltips: { r: false, t: testTooltips },
        keyboardSupport: { r: true, t: testKeyboardSupport },
        documentElement: { r: false, t: testDocumentElement },
        cssPrefix: { r: true, t: testCssPrefix },
        cssClasses: { r: true, t: testCssClasses },
        handleAttributes: { r: false, t: testHandleAttributes }
      };
      var defaults2 = {
        connect: false,
        direction: "ltr",
        behaviour: "tap",
        orientation: "horizontal",
        keyboardSupport: true,
        cssPrefix: "noUi-",
        cssClasses,
        keyboardPageMultiplier: 5,
        keyboardMultiplier: 1,
        keyboardDefaultStep: 10
      };
      if (options.format && !options.ariaFormat) {
        options.ariaFormat = options.format;
      }
      Object.keys(tests).forEach(function(name2) {
        if (!isSet(options[name2]) && defaults2[name2] === void 0) {
          if (tests[name2].r) {
            throw new Error("noUiSlider: '" + name2 + "' is required.");
          }
          return;
        }
        tests[name2].t(parsed, !isSet(options[name2]) ? defaults2[name2] : options[name2]);
      });
      parsed.pips = options.pips;
      var d2 = document.createElement("div");
      var msPrefix = d2.style.msTransform !== void 0;
      var noPrefix = d2.style.transform !== void 0;
      parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";
      var styles2 = [
        ["left", "top"],
        ["right", "bottom"]
      ];
      parsed.style = styles2[parsed.dir][parsed.ort];
      return parsed;
    }
    function scope(target, options, originalOptions) {
      var actions = getActions();
      var supportsTouchActionNone = getSupportsTouchActionNone();
      var supportsPassive = supportsTouchActionNone && getSupportsPassive();
      var scope_Target = target;
      var scope_Base;
      var scope_ConnectBase;
      var scope_Handles;
      var scope_Connects;
      var scope_Pips;
      var scope_Tooltips;
      var scope_Spectrum = options.spectrum;
      var scope_Values = [];
      var scope_Locations = [];
      var scope_HandleNumbers = [];
      var scope_ActiveHandlesCount = 0;
      var scope_Events = {};
      var scope_ConnectsInverted = false;
      var scope_Document = target.ownerDocument;
      var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
      var scope_Body = scope_Document.body;
      var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;
      function addNodeTo(addTarget, className) {
        var div = scope_Document.createElement("div");
        if (className) {
          addClass(div, className);
        }
        addTarget.appendChild(div);
        return div;
      }
      function addOrigin(base2, handleNumber) {
        var origin2 = addNodeTo(base2, options.cssClasses.origin);
        var handle = addNodeTo(origin2, options.cssClasses.handle);
        addNodeTo(handle, options.cssClasses.touchArea);
        handle.setAttribute("data-handle", String(handleNumber));
        if (options.keyboardSupport) {
          handle.setAttribute("tabindex", "0");
          handle.addEventListener("keydown", function(event) {
            return eventKeydown(event, handleNumber);
          });
        }
        if (options.handleAttributes !== void 0) {
          var attributes_1 = options.handleAttributes[handleNumber];
          Object.keys(attributes_1).forEach(function(attribute) {
            handle.setAttribute(attribute, attributes_1[attribute]);
          });
        }
        handle.setAttribute("role", "slider");
        handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");
        if (handleNumber === 0) {
          addClass(handle, options.cssClasses.handleLower);
        } else if (handleNumber === options.handles - 1) {
          addClass(handle, options.cssClasses.handleUpper);
        }
        origin2.handle = handle;
        return origin2;
      }
      function addConnect(base2, add2) {
        if (!add2) {
          return false;
        }
        return addNodeTo(base2, options.cssClasses.connect);
      }
      function addElements(connectOptions, base2) {
        scope_ConnectBase = addNodeTo(base2, options.cssClasses.connects);
        scope_Handles = [];
        scope_Connects = [];
        scope_Connects.push(addConnect(scope_ConnectBase, connectOptions[0]));
        for (var i2 = 0; i2 < options.handles; i2++) {
          scope_Handles.push(addOrigin(base2, i2));
          scope_HandleNumbers[i2] = i2;
          scope_Connects.push(addConnect(scope_ConnectBase, connectOptions[i2 + 1]));
        }
      }
      function addSlider(addTarget) {
        addClass(addTarget, options.cssClasses.target);
        if (options.dir === 0) {
          addClass(addTarget, options.cssClasses.ltr);
        } else {
          addClass(addTarget, options.cssClasses.rtl);
        }
        if (options.ort === 0) {
          addClass(addTarget, options.cssClasses.horizontal);
        } else {
          addClass(addTarget, options.cssClasses.vertical);
        }
        var textDirection = getComputedStyle(addTarget).direction;
        if (textDirection === "rtl") {
          addClass(addTarget, options.cssClasses.textDirectionRtl);
        } else {
          addClass(addTarget, options.cssClasses.textDirectionLtr);
        }
        return addNodeTo(addTarget, options.cssClasses.base);
      }
      function addTooltip(handle, handleNumber) {
        if (!options.tooltips || !options.tooltips[handleNumber]) {
          return false;
        }
        return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
      }
      function isSliderDisabled() {
        return scope_Target.hasAttribute("disabled");
      }
      function isHandleDisabled(handleNumber) {
        var handleOrigin = scope_Handles[handleNumber];
        return handleOrigin.hasAttribute("disabled");
      }
      function disable(handleNumber) {
        if (handleNumber !== null && handleNumber !== void 0) {
          scope_Handles[handleNumber].setAttribute("disabled", "");
          scope_Handles[handleNumber].handle.removeAttribute("tabindex");
        } else {
          scope_Target.setAttribute("disabled", "");
          scope_Handles.forEach(function(handle) {
            handle.handle.removeAttribute("tabindex");
          });
        }
      }
      function enable(handleNumber) {
        if (handleNumber !== null && handleNumber !== void 0) {
          scope_Handles[handleNumber].removeAttribute("disabled");
          scope_Handles[handleNumber].handle.setAttribute("tabindex", "0");
        } else {
          scope_Target.removeAttribute("disabled");
          scope_Handles.forEach(function(handle) {
            handle.removeAttribute("disabled");
            handle.handle.setAttribute("tabindex", "0");
          });
        }
      }
      function removeTooltips() {
        if (scope_Tooltips) {
          removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
          scope_Tooltips.forEach(function(tooltip) {
            if (tooltip) {
              removeElement(tooltip);
            }
          });
          scope_Tooltips = null;
        }
      }
      function tooltips() {
        removeTooltips();
        scope_Tooltips = scope_Handles.map(addTooltip);
        bindEvent("update" + INTERNAL_EVENT_NS.tooltips, function(values2, handleNumber, unencoded) {
          if (!scope_Tooltips || !options.tooltips) {
            return;
          }
          if (scope_Tooltips[handleNumber] === false) {
            return;
          }
          var formattedValue = values2[handleNumber];
          if (options.tooltips[handleNumber] !== true) {
            formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
          }
          scope_Tooltips[handleNumber].innerHTML = formattedValue;
        });
      }
      function aria() {
        removeEvent("update" + INTERNAL_EVENT_NS.aria);
        bindEvent("update" + INTERNAL_EVENT_NS.aria, function(values2, handleNumber, unencoded, tap, positions) {
          scope_HandleNumbers.forEach(function(index2) {
            var handle = scope_Handles[index2];
            var min2 = checkHandlePosition(scope_Locations, index2, 0, true, true, true);
            var max2 = checkHandlePosition(scope_Locations, index2, 100, true, true, true);
            var now2 = positions[index2];
            var text2 = String(options.ariaFormat.to(unencoded[index2]));
            min2 = scope_Spectrum.fromStepping(min2).toFixed(1);
            max2 = scope_Spectrum.fromStepping(max2).toFixed(1);
            now2 = scope_Spectrum.fromStepping(now2).toFixed(1);
            handle.children[0].setAttribute("aria-valuemin", min2);
            handle.children[0].setAttribute("aria-valuemax", max2);
            handle.children[0].setAttribute("aria-valuenow", now2);
            handle.children[0].setAttribute("aria-valuetext", text2);
          });
        });
      }
      function getGroup(pips2) {
        if (pips2.mode === PipsMode.Range || pips2.mode === PipsMode.Steps) {
          return scope_Spectrum.xVal;
        }
        if (pips2.mode === PipsMode.Count) {
          if (pips2.values < 2) {
            throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
          }
          var interval = pips2.values - 1;
          var spread2 = 100 / interval;
          var values2 = [];
          while (interval--) {
            values2[interval] = interval * spread2;
          }
          values2.push(100);
          return mapToRange(values2, pips2.stepped);
        }
        if (pips2.mode === PipsMode.Positions) {
          return mapToRange(pips2.values, pips2.stepped);
        }
        if (pips2.mode === PipsMode.Values) {
          if (pips2.stepped) {
            return pips2.values.map(function(value) {
              return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
            });
          }
          return pips2.values;
        }
        return [];
      }
      function mapToRange(values2, stepped) {
        return values2.map(function(value) {
          return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
        });
      }
      function generateSpread(pips2) {
        function safeIncrement(value, increment) {
          return Number((value + increment).toFixed(7));
        }
        var group2 = getGroup(pips2);
        var indexes = {};
        var firstInRange = scope_Spectrum.xVal[0];
        var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
        var ignoreFirst = false;
        var ignoreLast = false;
        var prevPct = 0;
        group2 = unique(group2.slice().sort(function(a2, b2) {
          return a2 - b2;
        }));
        if (group2[0] !== firstInRange) {
          group2.unshift(firstInRange);
          ignoreFirst = true;
        }
        if (group2[group2.length - 1] !== lastInRange) {
          group2.push(lastInRange);
          ignoreLast = true;
        }
        group2.forEach(function(current, index2) {
          var step;
          var i2;
          var q2;
          var low = current;
          var high = group2[index2 + 1];
          var newPct;
          var pctDifference;
          var pctPos;
          var type;
          var steps;
          var realSteps;
          var stepSize;
          var isSteps = pips2.mode === PipsMode.Steps;
          if (isSteps) {
            step = scope_Spectrum.xNumSteps[index2];
          }
          if (!step) {
            step = high - low;
          }
          if (high === void 0) {
            high = low;
          }
          step = Math.max(step, 1e-7);
          for (i2 = low; i2 <= high; i2 = safeIncrement(i2, step)) {
            newPct = scope_Spectrum.toStepping(i2);
            pctDifference = newPct - prevPct;
            steps = pctDifference / (pips2.density || 1);
            realSteps = Math.round(steps);
            stepSize = pctDifference / realSteps;
            for (q2 = 1; q2 <= realSteps; q2 += 1) {
              pctPos = prevPct + q2 * stepSize;
              indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
            }
            type = group2.indexOf(i2) > -1 ? PipsType.LargeValue : isSteps ? PipsType.SmallValue : PipsType.NoValue;
            if (!index2 && ignoreFirst && i2 !== high) {
              type = 0;
            }
            if (!(i2 === high && ignoreLast)) {
              indexes[newPct.toFixed(5)] = [i2, type];
            }
            prevPct = newPct;
          }
        });
        return indexes;
      }
      function addMarking(spread2, filterFunc, formatter) {
        var _a, _b;
        var element = scope_Document.createElement("div");
        var valueSizeClasses = (_a = {}, _a[PipsType.None] = "", _a[PipsType.NoValue] = options.cssClasses.valueNormal, _a[PipsType.LargeValue] = options.cssClasses.valueLarge, _a[PipsType.SmallValue] = options.cssClasses.valueSub, _a);
        var markerSizeClasses = (_b = {}, _b[PipsType.None] = "", _b[PipsType.NoValue] = options.cssClasses.markerNormal, _b[PipsType.LargeValue] = options.cssClasses.markerLarge, _b[PipsType.SmallValue] = options.cssClasses.markerSub, _b);
        var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];
        var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];
        addClass(element, options.cssClasses.pips);
        addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);
        function getClasses(type, source) {
          var a2 = source === options.cssClasses.value;
          var orientationClasses = a2 ? valueOrientationClasses : markerOrientationClasses;
          var sizeClasses = a2 ? valueSizeClasses : markerSizeClasses;
          return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];
        }
        function addSpread(offset2, value, type) {
          type = filterFunc ? filterFunc(value, type) : type;
          if (type === PipsType.None) {
            return;
          }
          var node = addNodeTo(element, false);
          node.className = getClasses(type, options.cssClasses.marker);
          node.style[options.style] = offset2 + "%";
          if (type > PipsType.NoValue) {
            node = addNodeTo(element, false);
            node.className = getClasses(type, options.cssClasses.value);
            node.setAttribute("data-value", String(value));
            node.style[options.style] = offset2 + "%";
            node.innerHTML = String(formatter.to(value));
          }
        }
        Object.keys(spread2).forEach(function(offset2) {
          addSpread(offset2, spread2[offset2][0], spread2[offset2][1]);
        });
        return element;
      }
      function removePips() {
        if (scope_Pips) {
          removeElement(scope_Pips);
          scope_Pips = null;
        }
      }
      function pips(pips2) {
        removePips();
        var spread2 = generateSpread(pips2);
        var filter2 = pips2.filter;
        var format2 = pips2.format || {
          to: function(value) {
            return String(Math.round(value));
          }
        };
        scope_Pips = scope_Target.appendChild(addMarking(spread2, filter2, format2));
        return scope_Pips;
      }
      function baseSize() {
        var rect = scope_Base.getBoundingClientRect();
        var alt = "offset" + ["Width", "Height"][options.ort];
        return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
      }
      function attachEvent(events, element, callback, data) {
        var method = function(event) {
          var e2 = fixEvent(event, data.pageOffset, data.target || element);
          if (!e2) {
            return false;
          }
          if (isSliderDisabled() && !data.doNotReject) {
            return false;
          }
          if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {
            return false;
          }
          if (events === actions.start && e2.buttons !== void 0 && e2.buttons > 1) {
            return false;
          }
          if (data.hover && e2.buttons) {
            return false;
          }
          if (!supportsPassive) {
            e2.preventDefault();
          }
          e2.calcPoint = e2.points[options.ort];
          callback(e2, data);
          return;
        };
        var methods = [];
        events.split(" ").forEach(function(eventName) {
          element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);
          methods.push([eventName, method]);
        });
        return methods;
      }
      function fixEvent(e2, pageOffset, eventTarget) {
        var touch = e2.type.indexOf("touch") === 0;
        var mouse = e2.type.indexOf("mouse") === 0;
        var pointer = e2.type.indexOf("pointer") === 0;
        var x2 = 0;
        var y2 = 0;
        if (e2.type.indexOf("MSPointer") === 0) {
          pointer = true;
        }
        if (e2.type === "mousedown" && !e2.buttons && !e2.touches) {
          return false;
        }
        if (touch) {
          var isTouchOnTarget = function(checkTouch) {
            var target2 = checkTouch.target;
            return target2 === eventTarget || eventTarget.contains(target2) || e2.composed && e2.composedPath().shift() === eventTarget;
          };
          if (e2.type === "touchstart") {
            var targetTouches = Array.prototype.filter.call(e2.touches, isTouchOnTarget);
            if (targetTouches.length > 1) {
              return false;
            }
            x2 = targetTouches[0].pageX;
            y2 = targetTouches[0].pageY;
          } else {
            var targetTouch = Array.prototype.find.call(e2.changedTouches, isTouchOnTarget);
            if (!targetTouch) {
              return false;
            }
            x2 = targetTouch.pageX;
            y2 = targetTouch.pageY;
          }
        }
        pageOffset = pageOffset || getPageOffset(scope_Document);
        if (mouse || pointer) {
          x2 = e2.clientX + pageOffset.x;
          y2 = e2.clientY + pageOffset.y;
        }
        e2.pageOffset = pageOffset;
        e2.points = [x2, y2];
        e2.cursor = mouse || pointer;
        return e2;
      }
      function calcPointToPercentage(calcPoint) {
        var location2 = calcPoint - offset(scope_Base, options.ort);
        var proposal = location2 * 100 / baseSize();
        proposal = limit(proposal);
        return options.dir ? 100 - proposal : proposal;
      }
      function getClosestHandle(clickedPosition) {
        var smallestDifference = 100;
        var handleNumber = false;
        scope_Handles.forEach(function(handle, index2) {
          if (isHandleDisabled(index2)) {
            return;
          }
          var handlePosition = scope_Locations[index2];
          var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);
          var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;
          var isCloser = differenceWithThisHandle < smallestDifference;
          var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;
          if (isCloser || isCloserAfter || clickAtEdge) {
            handleNumber = index2;
            smallestDifference = differenceWithThisHandle;
          }
        });
        return handleNumber;
      }
      function documentLeave(event, data) {
        if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {
          eventEnd(event, data);
        }
      }
      function eventMove(event, data) {
        if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {
          return eventEnd(event, data);
        }
        var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);
        var proposal = movement * 100 / data.baseSize;
        moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);
      }
      function eventEnd(event, data) {
        if (data.handle) {
          removeClass(data.handle, options.cssClasses.active);
          scope_ActiveHandlesCount -= 1;
        }
        data.listeners.forEach(function(c2) {
          scope_DocumentElement.removeEventListener(c2[0], c2[1]);
        });
        if (scope_ActiveHandlesCount === 0) {
          removeClass(scope_Target, options.cssClasses.drag);
          setZindex();
          if (event.cursor) {
            scope_Body.style.cursor = "";
            scope_Body.removeEventListener("selectstart", preventDefault);
          }
        }
        if (options.events.smoothSteps) {
          data.handleNumbers.forEach(function(handleNumber) {
            setHandle(handleNumber, scope_Locations[handleNumber], true, true, false, false);
          });
          data.handleNumbers.forEach(function(handleNumber) {
            fireEvent("update", handleNumber);
          });
        }
        data.handleNumbers.forEach(function(handleNumber) {
          fireEvent("change", handleNumber);
          fireEvent("set", handleNumber);
          fireEvent("end", handleNumber);
        });
      }
      function eventStart(event, data) {
        if (data.handleNumbers.some(isHandleDisabled)) {
          return;
        }
        var handle;
        if (data.handleNumbers.length === 1) {
          var handleOrigin = scope_Handles[data.handleNumbers[0]];
          handle = handleOrigin.children[0];
          scope_ActiveHandlesCount += 1;
          addClass(handle, options.cssClasses.active);
        }
        event.stopPropagation();
        var listeners = [];
        var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
          // The event target has changed so we need to propagate the original one so that we keep
          // relying on it to extract target touches.
          target: event.target,
          handle,
          connect: data.connect,
          listeners,
          startCalcPoint: event.calcPoint,
          baseSize: baseSize(),
          pageOffset: event.pageOffset,
          handleNumbers: data.handleNumbers,
          buttonsProperty: event.buttons,
          locations: scope_Locations.slice()
        });
        var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
          target: event.target,
          handle,
          listeners,
          doNotReject: true,
          handleNumbers: data.handleNumbers
        });
        var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
          target: event.target,
          handle,
          listeners,
          doNotReject: true,
          handleNumbers: data.handleNumbers
        });
        listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));
        if (event.cursor) {
          scope_Body.style.cursor = getComputedStyle(event.target).cursor;
          if (scope_Handles.length > 1) {
            addClass(scope_Target, options.cssClasses.drag);
          }
          scope_Body.addEventListener("selectstart", preventDefault, false);
        }
        data.handleNumbers.forEach(function(handleNumber) {
          fireEvent("start", handleNumber);
        });
      }
      function eventTap(event) {
        event.stopPropagation();
        var proposal = calcPointToPercentage(event.calcPoint);
        var handleNumber = getClosestHandle(proposal);
        if (handleNumber === false) {
          return;
        }
        if (!options.events.snap) {
          addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
        }
        setHandle(handleNumber, proposal, true, true);
        setZindex();
        fireEvent("slide", handleNumber, true);
        fireEvent("update", handleNumber, true);
        if (!options.events.snap) {
          fireEvent("change", handleNumber, true);
          fireEvent("set", handleNumber, true);
        } else {
          eventStart(event, { handleNumbers: [handleNumber] });
        }
      }
      function eventHover(event) {
        var proposal = calcPointToPercentage(event.calcPoint);
        var to2 = scope_Spectrum.getStep(proposal);
        var value = scope_Spectrum.fromStepping(to2);
        Object.keys(scope_Events).forEach(function(targetEvent) {
          if ("hover" === targetEvent.split(".")[0]) {
            scope_Events[targetEvent].forEach(function(callback) {
              callback.call(scope_Self, value);
            });
          }
        });
      }
      function eventKeydown(event, handleNumber) {
        if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
          return false;
        }
        var horizontalKeys = ["Left", "Right"];
        var verticalKeys = ["Down", "Up"];
        var largeStepKeys = ["PageDown", "PageUp"];
        var edgeKeys = ["Home", "End"];
        if (options.dir && !options.ort) {
          horizontalKeys.reverse();
        } else if (options.ort && !options.dir) {
          verticalKeys.reverse();
          largeStepKeys.reverse();
        }
        var key = event.key.replace("Arrow", "");
        var isLargeDown = key === largeStepKeys[0];
        var isLargeUp = key === largeStepKeys[1];
        var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
        var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
        var isMin = key === edgeKeys[0];
        var isMax = key === edgeKeys[1];
        if (!isDown && !isUp && !isMin && !isMax) {
          return true;
        }
        event.preventDefault();
        var to2;
        if (isUp || isDown) {
          var direction = isDown ? 0 : 1;
          var steps = getNextStepsForHandle(handleNumber);
          var step = steps[direction];
          if (step === null) {
            return false;
          }
          if (step === false) {
            step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);
          }
          if (isLargeUp || isLargeDown) {
            step *= options.keyboardPageMultiplier;
          } else {
            step *= options.keyboardMultiplier;
          }
          step = Math.max(step, 1e-7);
          step = (isDown ? -1 : 1) * step;
          to2 = scope_Values[handleNumber] + step;
        } else if (isMax) {
          to2 = options.spectrum.xVal[options.spectrum.xVal.length - 1];
        } else {
          to2 = options.spectrum.xVal[0];
        }
        setHandle(handleNumber, scope_Spectrum.toStepping(to2), true, true);
        fireEvent("slide", handleNumber);
        fireEvent("update", handleNumber);
        fireEvent("change", handleNumber);
        fireEvent("set", handleNumber);
        return false;
      }
      function bindSliderEvents(behaviour) {
        if (!behaviour.fixed) {
          scope_Handles.forEach(function(handle, index2) {
            attachEvent(actions.start, handle.children[0], eventStart, {
              handleNumbers: [index2]
            });
          });
        }
        if (behaviour.tap) {
          attachEvent(actions.start, scope_Base, eventTap, {});
        }
        if (behaviour.hover) {
          attachEvent(actions.move, scope_Base, eventHover, {
            hover: true
          });
        }
        if (behaviour.drag) {
          scope_Connects.forEach(function(connect, index2) {
            if (connect === false || index2 === 0 || index2 === scope_Connects.length - 1) {
              return;
            }
            var handleBefore = scope_Handles[index2 - 1];
            var handleAfter = scope_Handles[index2];
            var eventHolders = [connect];
            var handlesToDrag = [handleBefore, handleAfter];
            var handleNumbersToDrag = [index2 - 1, index2];
            addClass(connect, options.cssClasses.draggable);
            if (behaviour.fixed) {
              eventHolders.push(handleBefore.children[0]);
              eventHolders.push(handleAfter.children[0]);
            }
            if (behaviour.dragAll) {
              handlesToDrag = scope_Handles;
              handleNumbersToDrag = scope_HandleNumbers;
            }
            eventHolders.forEach(function(eventHolder) {
              attachEvent(actions.start, eventHolder, eventStart, {
                handles: handlesToDrag,
                handleNumbers: handleNumbersToDrag,
                connect
              });
            });
          });
        }
      }
      function bindEvent(namespacedEvent, callback) {
        scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
        scope_Events[namespacedEvent].push(callback);
        if (namespacedEvent.split(".")[0] === "update") {
          scope_Handles.forEach(function(a2, index2) {
            fireEvent("update", index2);
          });
        }
      }
      function isInternalNamespace(namespace) {
        return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
      }
      function removeEvent(namespacedEvent) {
        var event = namespacedEvent && namespacedEvent.split(".")[0];
        var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;
        Object.keys(scope_Events).forEach(function(bind2) {
          var tEvent = bind2.split(".")[0];
          var tNamespace = bind2.substring(tEvent.length);
          if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {
            if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {
              delete scope_Events[bind2];
            }
          }
        });
      }
      function fireEvent(eventName, handleNumber, tap) {
        Object.keys(scope_Events).forEach(function(targetEvent) {
          var eventType = targetEvent.split(".")[0];
          if (eventName === eventType) {
            scope_Events[targetEvent].forEach(function(callback) {
              callback.call(
                // Use the slider public API as the scope ('this')
                scope_Self,
                // Return values as array, so arg_1[arg_2] is always valid.
                scope_Values.map(options.format.to),
                // Handle index, 0 or 1
                handleNumber,
                // Un-formatted slider values
                scope_Values.slice(),
                // Event is fired by tap, true or false
                tap || false,
                // Left offset of the handle, in relation to the slider
                scope_Locations.slice(),
                // add the slider public API to an accessible parameter when this is unavailable
                scope_Self
              );
            });
          }
        });
      }
      function checkHandlePosition(reference2, handleNumber, to2, lookBackward, lookForward, getValue2, smoothSteps) {
        var distance;
        if (scope_Handles.length > 1 && !options.events.unconstrained) {
          if (lookBackward && handleNumber > 0) {
            distance = scope_Spectrum.getAbsoluteDistance(reference2[handleNumber - 1], options.margin, false);
            to2 = Math.max(to2, distance);
          }
          if (lookForward && handleNumber < scope_Handles.length - 1) {
            distance = scope_Spectrum.getAbsoluteDistance(reference2[handleNumber + 1], options.margin, true);
            to2 = Math.min(to2, distance);
          }
        }
        if (scope_Handles.length > 1 && options.limit) {
          if (lookBackward && handleNumber > 0) {
            distance = scope_Spectrum.getAbsoluteDistance(reference2[handleNumber - 1], options.limit, false);
            to2 = Math.min(to2, distance);
          }
          if (lookForward && handleNumber < scope_Handles.length - 1) {
            distance = scope_Spectrum.getAbsoluteDistance(reference2[handleNumber + 1], options.limit, true);
            to2 = Math.max(to2, distance);
          }
        }
        if (options.padding) {
          if (handleNumber === 0) {
            distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);
            to2 = Math.max(to2, distance);
          }
          if (handleNumber === scope_Handles.length - 1) {
            distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);
            to2 = Math.min(to2, distance);
          }
        }
        if (!smoothSteps) {
          to2 = scope_Spectrum.getStep(to2);
        }
        to2 = limit(to2);
        if (to2 === reference2[handleNumber] && !getValue2) {
          return false;
        }
        return to2;
      }
      function inRuleOrder(v2, a2) {
        var o2 = options.ort;
        return (o2 ? a2 : v2) + ", " + (o2 ? v2 : a2);
      }
      function moveHandles(upward, proposal, locations, handleNumbers, connect) {
        var proposals = locations.slice();
        var firstHandle = handleNumbers[0];
        var smoothSteps = options.events.smoothSteps;
        var b2 = [!upward, upward];
        var f2 = [upward, !upward];
        handleNumbers = handleNumbers.slice();
        if (upward) {
          handleNumbers.reverse();
        }
        if (handleNumbers.length > 1) {
          handleNumbers.forEach(function(handleNumber, o2) {
            var to2 = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b2[o2], f2[o2], false, smoothSteps);
            if (to2 === false) {
              proposal = 0;
            } else {
              proposal = to2 - proposals[handleNumber];
              proposals[handleNumber] = to2;
            }
          });
        } else {
          b2 = f2 = [true];
        }
        var state = false;
        handleNumbers.forEach(function(handleNumber, o2) {
          state = setHandle(handleNumber, locations[handleNumber] + proposal, b2[o2], f2[o2], false, smoothSteps) || state;
        });
        if (state) {
          handleNumbers.forEach(function(handleNumber) {
            fireEvent("update", handleNumber);
            fireEvent("slide", handleNumber);
          });
          if (connect != void 0) {
            fireEvent("drag", firstHandle);
          }
        }
      }
      function transformDirection(a2, b2) {
        return options.dir ? 100 - a2 - b2 : a2;
      }
      function updateHandlePosition(handleNumber, to2) {
        scope_Locations[handleNumber] = to2;
        scope_Values[handleNumber] = scope_Spectrum.fromStepping(to2);
        var translation = transformDirection(to2, 0) - scope_DirOffset;
        var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";
        scope_Handles[handleNumber].style[options.transformRule] = translateRule;
        if (options.events.invertConnects && scope_Locations.length > 1) {
          var handlesAreInOrder = scope_Locations.every(function(position, index2, locations) {
            return index2 === 0 || position >= locations[index2 - 1];
          });
          if (scope_ConnectsInverted !== !handlesAreInOrder) {
            invertConnects();
            return;
          }
        }
        updateConnect(handleNumber);
        updateConnect(handleNumber + 1);
        if (scope_ConnectsInverted) {
          updateConnect(handleNumber - 1);
          updateConnect(handleNumber + 2);
        }
      }
      function setZindex() {
        scope_HandleNumbers.forEach(function(handleNumber) {
          var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
          var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
          scope_Handles[handleNumber].style.zIndex = String(zIndex);
        });
      }
      function setHandle(handleNumber, to2, lookBackward, lookForward, exactInput, smoothSteps) {
        if (!exactInput) {
          to2 = checkHandlePosition(scope_Locations, handleNumber, to2, lookBackward, lookForward, false, smoothSteps);
        }
        if (to2 === false) {
          return false;
        }
        updateHandlePosition(handleNumber, to2);
        return true;
      }
      function updateConnect(index2) {
        if (!scope_Connects[index2]) {
          return;
        }
        var locations = scope_Locations.slice();
        if (scope_ConnectsInverted) {
          locations.sort(function(a2, b2) {
            return a2 - b2;
          });
        }
        var l2 = 0;
        var h2 = 100;
        if (index2 !== 0) {
          l2 = locations[index2 - 1];
        }
        if (index2 !== scope_Connects.length - 1) {
          h2 = locations[index2];
        }
        var connectWidth = h2 - l2;
        var translateRule = "translate(" + inRuleOrder(transformDirection(l2, connectWidth) + "%", "0") + ")";
        var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
        scope_Connects[index2].style[options.transformRule] = translateRule + " " + scaleRule;
      }
      function resolveToValue(to2, handleNumber) {
        if (to2 === null || to2 === false || to2 === void 0) {
          return scope_Locations[handleNumber];
        }
        if (typeof to2 === "number") {
          to2 = String(to2);
        }
        to2 = options.format.from(to2);
        if (to2 !== false) {
          to2 = scope_Spectrum.toStepping(to2);
        }
        if (to2 === false || isNaN(to2)) {
          return scope_Locations[handleNumber];
        }
        return to2;
      }
      function valueSet(input, fireSetEvent, exactInput) {
        var values2 = asArray(input);
        var isInit = scope_Locations[0] === void 0;
        fireSetEvent = fireSetEvent === void 0 ? true : fireSetEvent;
        if (options.animate && !isInit) {
          addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
        }
        scope_HandleNumbers.forEach(function(handleNumber) {
          setHandle(handleNumber, resolveToValue(values2[handleNumber], handleNumber), true, false, exactInput);
        });
        var i2 = scope_HandleNumbers.length === 1 ? 0 : 1;
        if (isInit && scope_Spectrum.hasNoSize()) {
          exactInput = true;
          scope_Locations[0] = 0;
          if (scope_HandleNumbers.length > 1) {
            var space_1 = 100 / (scope_HandleNumbers.length - 1);
            scope_HandleNumbers.forEach(function(handleNumber) {
              scope_Locations[handleNumber] = handleNumber * space_1;
            });
          }
        }
        for (; i2 < scope_HandleNumbers.length; ++i2) {
          scope_HandleNumbers.forEach(function(handleNumber) {
            setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
          });
        }
        setZindex();
        scope_HandleNumbers.forEach(function(handleNumber) {
          fireEvent("update", handleNumber);
          if (values2[handleNumber] !== null && fireSetEvent) {
            fireEvent("set", handleNumber);
          }
        });
      }
      function valueReset(fireSetEvent) {
        valueSet(options.start, fireSetEvent);
      }
      function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {
        handleNumber = Number(handleNumber);
        if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
          throw new Error("noUiSlider: invalid handle number, got: " + handleNumber);
        }
        setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);
        fireEvent("update", handleNumber);
        if (fireSetEvent) {
          fireEvent("set", handleNumber);
        }
      }
      function valueGet(unencoded) {
        if (unencoded === void 0) {
          unencoded = false;
        }
        if (unencoded) {
          return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);
        }
        var values2 = scope_Values.map(options.format.to);
        if (values2.length === 1) {
          return values2[0];
        }
        return values2;
      }
      function destroy() {
        removeEvent(INTERNAL_EVENT_NS.aria);
        removeEvent(INTERNAL_EVENT_NS.tooltips);
        Object.keys(options.cssClasses).forEach(function(key) {
          removeClass(scope_Target, options.cssClasses[key]);
        });
        while (scope_Target.firstChild) {
          scope_Target.removeChild(scope_Target.firstChild);
        }
        delete scope_Target.noUiSlider;
      }
      function getNextStepsForHandle(handleNumber) {
        var location2 = scope_Locations[handleNumber];
        var nearbySteps = scope_Spectrum.getNearbySteps(location2);
        var value = scope_Values[handleNumber];
        var increment = nearbySteps.thisStep.step;
        var decrement = null;
        if (options.snap) {
          return [
            value - nearbySteps.stepBefore.startValue || null,
            nearbySteps.stepAfter.startValue - value || null
          ];
        }
        if (increment !== false) {
          if (value + increment > nearbySteps.stepAfter.startValue) {
            increment = nearbySteps.stepAfter.startValue - value;
          }
        }
        if (value > nearbySteps.thisStep.startValue) {
          decrement = nearbySteps.thisStep.step;
        } else if (nearbySteps.stepBefore.step === false) {
          decrement = false;
        } else {
          decrement = value - nearbySteps.stepBefore.highestStep;
        }
        if (location2 === 100) {
          increment = null;
        } else if (location2 === 0) {
          decrement = null;
        }
        var stepDecimals = scope_Spectrum.countStepDecimals();
        if (increment !== null && increment !== false) {
          increment = Number(increment.toFixed(stepDecimals));
        }
        if (decrement !== null && decrement !== false) {
          decrement = Number(decrement.toFixed(stepDecimals));
        }
        return [decrement, increment];
      }
      function getNextSteps() {
        return scope_HandleNumbers.map(getNextStepsForHandle);
      }
      function updateOptions(optionsToUpdate, fireSetEvent) {
        var v2 = valueGet();
        var updateAble = [
          "margin",
          "limit",
          "padding",
          "range",
          "animate",
          "snap",
          "step",
          "format",
          "pips",
          "tooltips",
          "connect"
        ];
        updateAble.forEach(function(name2) {
          if (optionsToUpdate[name2] !== void 0) {
            originalOptions[name2] = optionsToUpdate[name2];
          }
        });
        var newOptions = testOptions(originalOptions);
        updateAble.forEach(function(name2) {
          if (optionsToUpdate[name2] !== void 0) {
            options[name2] = newOptions[name2];
          }
        });
        scope_Spectrum = newOptions.spectrum;
        options.margin = newOptions.margin;
        options.limit = newOptions.limit;
        options.padding = newOptions.padding;
        if (options.pips) {
          pips(options.pips);
        } else {
          removePips();
        }
        if (options.tooltips) {
          tooltips();
        } else {
          removeTooltips();
        }
        scope_Locations = [];
        valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v2, fireSetEvent);
        if (optionsToUpdate.connect) {
          updateConnectOption();
        }
      }
      function updateConnectOption() {
        while (scope_ConnectBase.firstChild) {
          scope_ConnectBase.removeChild(scope_ConnectBase.firstChild);
        }
        for (var i2 = 0; i2 <= options.handles; i2++) {
          scope_Connects[i2] = addConnect(scope_ConnectBase, options.connect[i2]);
          updateConnect(i2);
        }
        bindSliderEvents({ drag: options.events.drag, fixed: true });
      }
      function invertConnects() {
        scope_ConnectsInverted = !scope_ConnectsInverted;
        testConnect(
          options,
          // inverse the connect boolean array
          options.connect.map(function(b2) {
            return !b2;
          })
        );
        updateConnectOption();
      }
      function setupSlider() {
        scope_Base = addSlider(scope_Target);
        addElements(options.connect, scope_Base);
        bindSliderEvents(options.events);
        valueSet(options.start);
        if (options.pips) {
          pips(options.pips);
        }
        if (options.tooltips) {
          tooltips();
        }
        aria();
      }
      setupSlider();
      var scope_Self = {
        destroy,
        steps: getNextSteps,
        on: bindEvent,
        off: removeEvent,
        get: valueGet,
        set: valueSet,
        setHandle: valueSetHandle,
        reset: valueReset,
        disable,
        enable,
        // Exposed for unit testing, don't use this in your application.
        __moveHandles: function(upward, proposal, handleNumbers) {
          moveHandles(upward, proposal, scope_Locations, handleNumbers);
        },
        options: originalOptions,
        updateOptions,
        target: scope_Target,
        removePips,
        removeTooltips,
        getPositions: function() {
          return scope_Locations.slice();
        },
        getTooltips: function() {
          return scope_Tooltips;
        },
        getOrigins: function() {
          return scope_Handles;
        },
        pips
        // Issue #594
      };
      return scope_Self;
    }
    function initialize(target, originalOptions) {
      if (!target || !target.nodeName) {
        throw new Error("noUiSlider: create requires a single element, got: " + target);
      }
      if (target.noUiSlider) {
        throw new Error("noUiSlider: Slider was already initialized.");
      }
      var options = testOptions(originalOptions);
      var api = scope(target, options, originalOptions);
      target.noUiSlider = api;
      return api;
    }
    var nouislider = {
      // Exposed for unit testing, don't use this in your application.
      __spectrum: Spectrum,
      // A reference to the default classes, allows global changes.
      // Use the cssClasses option for changes to one slider.
      cssClasses,
      create: initialize
    };
    function arraysEqual(array1, array2) {
      if (!Array.isArray(array1) || !Array.isArray(array2)) {
        return false;
      }
      const array2Sorted = array2.slice().sort();
      return array1.length === array2.length && array1.slice().sort().every(function(value, index2) {
        return value === array2Sorted[index2];
      });
    }
    function useSlider(props, context, dependencies2) {
      const {
        orientation,
        direction,
        tooltips,
        step,
        min: min2,
        max: max2,
        merge: merge2,
        id,
        disabled,
        options,
        classes: classes2,
        format: format2,
        lazy,
        ariaLabelledby,
        aria
      } = toRefs(props);
      const value = dependencies2.value;
      const initialValue = dependencies2.initialValue;
      const tooltipsFormat = dependencies2.tooltipsFormat;
      const tooltipsMerge = dependencies2.tooltipsMerge;
      const tooltipFormat = dependencies2.tooltipFormat;
      const classList = dependencies2.classList;
      const slider2 = ref(null);
      const slider$ = ref(null);
      const inited = ref(false);
      const defaultOptions = computed(() => {
        let defaultOptions2 = {
          cssPrefix: "",
          cssClasses: classList.value,
          orientation: orientation.value,
          direction: direction.value,
          tooltips: tooltips.value ? tooltipsFormat.value : false,
          connect: "lower",
          start: isNullish(value.value) ? min2.value : value.value,
          range: {
            "min": min2.value,
            "max": max2.value
          }
        };
        if (step.value > 0) {
          defaultOptions2.step = step.value;
        }
        if (Array.isArray(value.value)) {
          defaultOptions2.connect = true;
        }
        if (ariaLabelledby && ariaLabelledby.value || aria && Object.keys(aria.value).length) {
          let handles = Array.isArray(value.value) ? value.value : [value.value];
          defaultOptions2.handleAttributes = handles.map((h2) => Object.assign({}, aria.value, ariaLabelledby && ariaLabelledby.value ? {
            "aria-labelledby": ariaLabelledby.value
          } : {}));
        }
        if (format2.value) {
          defaultOptions2.ariaFormat = tooltipFormat.value;
        }
        return defaultOptions2;
      });
      const sliderProps = computed(() => {
        let sliderProps2 = {
          id: id && id.value ? id.value : void 0
        };
        if (disabled.value) {
          sliderProps2.disabled = true;
        }
        return sliderProps2;
      });
      const isRange = computed(() => {
        return Array.isArray(value.value);
      });
      const reset = () => {
        updateValue(initialValue.value);
      };
      const getSliderValue = () => {
        let sliderValue = slider$.value.get();
        return Array.isArray(sliderValue) ? sliderValue.map((v2) => parseFloat(v2)) : parseFloat(sliderValue);
      };
      const update = (val, triggerChange = true) => {
        slider$.value.set(val, triggerChange);
      };
      const updateValue = (val) => {
        context.emit("input", val);
        context.emit("update:modelValue", val);
        context.emit("update", val);
      };
      const init = () => {
        slider$.value = nouislider.create(slider2.value, Object.assign({}, defaultOptions.value, options.value));
        if (tooltips.value && isRange.value && merge2.value >= 0) {
          tooltipsMerge(slider2.value, merge2.value, " - ");
        }
        slider$.value.on("set", () => {
          const sliderValue = getSliderValue();
          context.emit("change", sliderValue);
          context.emit("set", sliderValue);
          if (lazy.value) {
            updateValue(sliderValue);
          }
        });
        slider$.value.on("update", () => {
          if (!inited.value) {
            return;
          }
          const sliderValue = getSliderValue();
          if (isRange.value && arraysEqual(value.value, sliderValue) || !isRange.value && value.value == sliderValue) {
            context.emit("update", sliderValue);
            return;
          }
          if (!lazy.value) {
            updateValue(sliderValue);
          }
        });
        slider$.value.on("start", () => {
          context.emit("start", getSliderValue());
        });
        slider$.value.on("end", () => {
          context.emit("end", getSliderValue());
        });
        slider$.value.on("slide", () => {
          context.emit("slide", getSliderValue());
        });
        slider$.value.on("drag", () => {
          context.emit("drag", getSliderValue());
        });
        slider2.value.querySelectorAll("[data-handle]").forEach((handle) => {
          handle.onblur = () => {
            if (!slider2.value) {
              return;
            }
            classList.value.focused.split(" ").forEach((c2) => {
              slider2.value.classList.remove(c2);
            });
          };
          handle.onfocus = () => {
            classList.value.focused.split(" ").forEach((c2) => {
              slider2.value.classList.add(c2);
            });
          };
        });
        inited.value = true;
      };
      const destroy = () => {
        slider$.value.off();
        slider$.value.destroy();
        slider$.value = null;
      };
      const refresh = (n2, o2) => {
        inited.value = false;
        destroy();
        init();
      };
      onMounted(init);
      onUnmounted(destroy);
      watch(isRange, refresh, { immediate: false });
      watch(min2, refresh, { immediate: false });
      watch(max2, refresh, { immediate: false });
      watch(step, refresh, { immediate: false });
      watch(orientation, refresh, { immediate: false });
      watch(direction, refresh, { immediate: false });
      watch(tooltips, refresh, { immediate: false });
      watch(merge2, refresh, { immediate: false });
      watch(format2, refresh, { immediate: false, deep: true });
      watch(options, refresh, { immediate: false, deep: true });
      watch(classes2, refresh, { immediate: false, deep: true });
      watch(value, (value2, old) => {
        if (!old) {
          return;
        }
        if (
          // If both old and new has multiple handles
          // and the number of handles decreased
          typeof old === "object" && typeof value2 === "object" && value2 && Object.keys(old) > Object.keys(value2) || // If the old had multiple handles but
          // if it decreased to single
          typeof old === "object" && typeof value2 !== "object" || // Or has no value at all
          isNullish(value2)
        ) {
          refresh();
        }
      }, { immediate: false });
      watch(value, (newValue) => {
        if (isNullish(newValue)) {
          update(min2.value, false);
          return;
        }
        let sliderValue = getSliderValue();
        if (isRange.value && !Array.isArray(sliderValue)) {
          sliderValue = [sliderValue];
        }
        if (isRange.value && !arraysEqual(newValue, sliderValue) || !isRange.value && newValue != sliderValue) {
          update(newValue, false);
        }
      }, { deep: true });
      return {
        slider: slider2,
        slider$,
        isRange,
        sliderProps,
        init,
        destroy,
        refresh,
        update,
        reset
      };
    }
    const valueProps$1 = {
      value: {
        validator: function(p2) {
          return (p3) => typeof p3 === "number" || p3 instanceof Array || p3 === null || p3 === void 0 || p3 === false;
        },
        required: false
      },
      modelValue: {
        validator: function(p2) {
          return (p3) => typeof p3 === "number" || p3 instanceof Array || p3 === null || p3 === void 0 || p3 === false;
        },
        required: false
      }
    };
    var script$J = {
      name: "Slider",
      emits: [
        "input",
        "update:modelValue",
        "start",
        "slide",
        "drag",
        "update",
        "change",
        "set",
        "end"
      ],
      props: {
        ...valueProps$1,
        id: {
          type: [String, Number],
          required: false
        },
        disabled: {
          type: Boolean,
          required: false,
          default: false
        },
        min: {
          type: Number,
          required: false,
          default: 0
        },
        max: {
          type: Number,
          required: false,
          default: 100
        },
        step: {
          type: Number,
          required: false,
          default: 1
        },
        orientation: {
          type: String,
          required: false,
          default: "horizontal"
        },
        direction: {
          type: String,
          required: false,
          default: "ltr"
        },
        tooltips: {
          type: Boolean,
          required: false,
          default: true
        },
        options: {
          type: Object,
          required: false,
          default: () => ({})
        },
        merge: {
          type: Number,
          required: false,
          default: -1
        },
        format: {
          type: [Object, Function, Boolean],
          required: false,
          default: null
        },
        classes: {
          type: Object,
          required: false,
          default: () => ({})
        },
        showTooltip: {
          type: String,
          required: false,
          default: "always"
        },
        tooltipPosition: {
          type: String,
          required: false,
          default: null
        },
        lazy: {
          type: Boolean,
          required: false,
          default: true
        },
        ariaLabelledby: {
          type: String,
          required: false,
          default: void 0
        },
        aria: {
          required: false,
          type: Object,
          default: () => ({})
        }
      },
      setup(props, context) {
        const value = useValue$2(props);
        const classes2 = useClasses$1(props);
        const tooltip = useTooltip(props, context, {
          value: value.value,
          classList: classes2.classList
        });
        const slider2 = useSlider(props, context, {
          value: value.value,
          initialValue: value.initialValue,
          tooltipFormat: tooltip.tooltipFormat,
          tooltipsFormat: tooltip.tooltipsFormat,
          tooltipsMerge: tooltip.tooltipsMerge,
          classList: classes2.classList
        });
        return {
          ...classes2,
          ...tooltip,
          ...slider2
        };
      }
    };
    function render$k(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "div",
        mergeProps(_ctx.sliderProps, { ref: "slider" }),
        null,
        16
        /* FULL_PROPS */
      );
    }
    script$J.render = render$k;
    script$J.__file = "node_modules/@vueform/slider/src/Slider.vue";
    var script$I = {
      name: "SliderElement",
      components: {
        Slider: script$J
      },
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            slider: {
              target: "",
              focused: "",
              tooltipFocus: "",
              tooltipDrag: "",
              ltr: "",
              rtl: "",
              horizontal: "",
              vertical: "",
              textDirectionRtl: "",
              textDirectionLtr: "",
              base: "",
              connects: "",
              connect: "",
              origin: "",
              handle: "",
              touchArea: "",
              tooltip: "",
              tooltipTop: "",
              tooltipBottom: "",
              tooltipLeft: "",
              tooltipRight: "",
              tooltipHidden: "",
              active: "",
              draggable: "",
              tap: "",
              drag: ""
            }
          }
        };
      }
    };
    function render$j(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Slider = resolveComponent("Slider");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.wrapper)
              },
              [
                createCommentVNode(" @vueform/slider component "),
                createVNode(_component_Slider, mergeProps({
                  value: _ctx.value,
                  modelValue: _ctx.value
                }, _ctx.fieldOptions, {
                  aria: _ctx.aria,
                  classes: _ctx.classes.slider,
                  id: _ctx.fieldId,
                  ref: "input",
                  onUpdate: _ctx.handleUpdate,
                  onChange: _ctx.handleChange
                }), null, 16, ["value", "modelValue", "aria", "classes", "id", "onUpdate", "onChange"])
              ],
              2
              /* CLASS */
            )
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$I.render = render$j;
    script$I.__file = "themes/blank/templates/elements/SliderElement.vue";
    var script$H = {
      name: "SliderElement",
      render: script$I.render,
      components: {
        Slider: script$J
      },
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "vf-slider-wrapper",
            wrapper_sm: "vf-slider-wrapper-sm",
            wrapper_md: "",
            wrapper_lg: "vf-slider-wrapper-lg",
            slider: {
              target: "vf-slider-target",
              target_sm: "vf-slider-target-sm",
              target_md: "vf-slider-target-md",
              target_lg: "vf-slider-target-lg",
              focused: "vf-slider-focused",
              tooltipFocus: "vf-slider-tooltip-focus",
              tooltipDrag: "vf-slider-tooltip-drag",
              ltr: "vf-slider-ltr",
              rtl: "vf-slider-rtl",
              horizontal: "vf-slider-horizontal",
              horizontal_sm: "vf-slider-horizontal-sm",
              horizontal_md: "vf-slider-horizontal-md",
              horizontal_lg: "vf-slider-horizontal-lg",
              vertical: "vf-slider-vertical",
              vertical_sm: "vf-slider-vertical-sm",
              vertical_md: "vf-slider-vertical-md",
              vertical_lg: "vf-slider-vertical-lg",
              textDirectionRtl: "vf-slider-txt-dir-rtl",
              textDirectionLtr: "vf-slider-txt-dir-ltr",
              base: "vf-slider-base",
              base_sm: "vf-slider-base-sm",
              base_md: "vf-slider-base-md",
              base_lg: "vf-slider-base-lg",
              connects: "vf-slider-connects",
              connects_sm: "vf-slider-connects-sm",
              connects_md: "vf-slider-connects-md",
              connects_lg: "vf-slider-connects-lg",
              connect: "vf-slider-connect",
              connect_sm: "vf-slider-connect-sm",
              connect_md: "vf-slider-connect-md",
              connect_lg: "vf-slider-connect-lg",
              origin: "vf-slider-origin",
              handle: "vf-slider-handle",
              handle_sm: "vf-slider-handle-sm",
              handle_md: "vf-slider-handle-md",
              handle_lg: "vf-slider-handle-lg",
              handleUpper: "vf-handle-upper",
              handleLower: "vf-handle-lower",
              touchArea: "vf-slider-touch-area",
              tooltip: "vf-slider-tooltip",
              tooltip_sm: "vf-slider-tooltip-sm",
              tooltip_md: "vf-slider-tooltip-md",
              tooltip_lg: "vf-slider-tooltip-lg",
              tooltipTop: "vf-slider-tooltip-top",
              tooltipTop_sm: "vf-slider-tooltip-top-sm",
              tooltipTop_md: "vf-slider-tooltip-top-md",
              tooltipTop_lg: "vf-slider-tooltip-top-lg",
              tooltipBottom: "vf-slider-tooltip-bottom",
              tooltipBottom_sm: "vf-slider-tooltip-bottom-sm",
              tooltipBottom_md: "vf-slider-tooltip-bottom-md",
              tooltipBottom_lg: "vf-slider-tooltip-bottom-lg",
              tooltipLeft: "vf-slider-tooltip-left",
              tooltipLeft_sm: "vf-slider-tooltip-left-sm",
              tooltipLeft_md: "vf-slider-tooltip-left-md",
              tooltipLeft_lg: "vf-slider-tooltip-left-lg",
              tooltipRight: "vf-slider-tooltip-right",
              tooltipRight_sm: "vf-slider-tooltip-right-sm",
              tooltipRight_md: "vf-slider-tooltip-right-md",
              tooltipRight_lg: "vf-slider-tooltip-right-lg",
              tooltipHidden: "vf-slider-tooltip-hidden",
              active: "vf-slider-active",
              draggable: "vf-slider-draggable",
              tap: "vf-slider-state-tap",
              drag: "vf-slider-state-drag",
              $slider: (classes2, { Size }) => [
                classes2.slider.slider,
                classes2.slider[`slider_${Size}`]
              ],
              $horizontal: (classes2, { Size }) => [
                classes2.slider.horizontal,
                classes2.slider[`horizontal_${Size}`]
              ],
              $vertical: (classes2, { Size }) => [
                classes2.slider.vertical,
                classes2.slider[`vertical_${Size}`]
              ],
              $base: (classes2, { Size }) => [
                classes2.slider.base,
                classes2.slider[`base_${Size}`]
              ],
              $connects: (classes2, { Size }) => [
                classes2.slider.connects,
                classes2.slider[`connects_${Size}`]
              ],
              $connect: (classes2, { Size }) => [
                classes2.slider.connect,
                classes2.slider[`connect_${Size}`]
              ],
              $handle: (classes2, { Size }) => [
                classes2.slider.handle,
                classes2.slider[`handle_${Size}`]
              ],
              $tooltip: (classes2, { Size }) => [
                classes2.slider.tooltip,
                classes2.slider[`tooltip_${Size}`]
              ],
              $tooltipTop: (classes2, { Size }) => [
                classes2.slider.tooltipTop,
                classes2.slider[`tooltipTop_${Size}`]
              ],
              $tooltipBottom: (classes2, { Size }) => [
                classes2.slider.tooltipBottom,
                classes2.slider[`tooltipBottom_${Size}`]
              ],
              $tooltipLeft: (classes2, { Size }) => [
                classes2.slider.tooltipLeft,
                classes2.slider[`tooltipLeft_${Size}`]
              ],
              $tooltipRight: (classes2, { Size }) => [
                classes2.slider.tooltipRight,
                classes2.slider[`tooltipRight_${Size}`]
              ]
            },
            $wrapper: (classes2, { Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$l = '.vf-slider-wrapper {\n  margin-top: calc((var(--vf-min-height-input) - var(--vf-slider-height)) / 2);\n}\n\n.vf-slider-wrapper.vf-slider-wrapper-sm {\n  margin-top: calc((var(--vf-min-height-input-sm) - var(--vf-slider-height)) / 2);\n  margin-bottom: 0.25rem;\n}\n\n.vf-slider-wrapper.vf-slider-wrapper-lg {\n  margin-top: calc((var(--vf-min-height-input-lg) - var(--vf-slider-height)) / 2);\n}\n\n/* @vueform/slider styles */\n\n.vf-slider-target,\n.vf-slider-target * {\n  -webkit-touch-callout: none;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-user-select: none;\n  touch-action: none;\n  -moz-user-select: none;\n  user-select: none;\n  box-sizing: border-box;\n}\n\n.vf-slider-target {\n  position: relative;\n  margin: calc((var(--vf-line-height) - var(--vf-slider-height)) / 2) 0;\n}\n\n.vf-slider-target[disabled] {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.vf-slider-target.vf-slider-target-sm {\n  margin: calc((var(--vf-line-height-sm) - var(--vf-slider-height-sm)) / 2) 0;\n}\n\n.vf-slider-target.vf-slider-target-lg {\n  margin: calc((var(--vf-line-height-lg) - var(--vf-slider-height-lg)) / 2) 0;\n}\n\n.vf-slider-target.vf-slider-horizontal {\n  height: var(--vf-slider-height);\n}\n\n.vf-slider-target.vf-slider-horizontal.vf-slider-horizontal-sm {\n  height: var(--vf-slider-height-sm);\n}\n\n.vf-slider-target.vf-slider-horizontal.vf-slider-horizontal-lg {\n  height: var(--vf-slider-height-lg);\n}\n\n.vf-slider-target.vf-slider-vertical {\n  width: var(--vf-slider-height);\n  height: var(--vf-slider-height-vertical);\n}\n\n.vf-slider-target.vf-slider-vertical.vf-slider-vertical-sm {\n  width: var(--vf-slider-height-sm);\n  height: var(--vf-slider-height-vertical-sm);\n}\n\n.vf-slider-target.vf-slider-vertical.vf-slider-vertical-lg {\n  width: var(--vf-slider-height-lg);\n  height: var(--vf-slider-height-vertical-lg);\n}\n\n.vf-slider-target.vf-slider-state-drag * {\n  cursor: inherit !important;\n}\n\n.vf-slider-base,\n.vf-slider-connects {\n  width: 100%;\n  height: 100%;\n  position: relative;\n}\n\n.vf-slider-base {\n  box-shadow: var(--vf-shadow-input);\n  background-color: var(--vf-bg-passive);\n  border-radius: var(--vf-radius-slider);\n  z-index: 1;\n}\n\n.vf-slider-base.vf-slider-base-sm {\n  border-radius: var(--vf-radius-slider-sm);\n}\n\n.vf-slider-base.vf-slider-base-lg {\n  border-radius: var(--vf-radius-slider-lg);\n}\n\n.vf-slider-connects {\n  overflow: hidden;\n  z-index: 0;\n  border-radius: var(--vf-radius-slider);\n}\n\n.vf-slider-connects.vf-slider-connects-sm {\n  border-radius: var(--vf-radius-slider-sm);\n}\n\n.vf-slider-connects.vf-slider-connects-lg {\n  border-radius: var(--vf-radius-slider-lg);\n}\n\n.vf-slider-connect,\n.vf-slider-origin {\n  will-change: transform;\n  position: absolute;\n  z-index: 1;\n  top: 0;\n  right: 0;\n  height: 100%;\n  width: 100%;\n  -ms-transform-origin: 0 0;\n  -webkit-transform-origin: 0 0;\n  -webkit-transform-style: preserve-3d;\n  transform-origin: 0 0;\n  transform-style: flat;\n}\n\n.vf-slider-connect {\n  background: var(--vf-primary);\n  border-radius: var(--vf-radius-slider);\n  cursor: pointer;\n}\n\n.vf-slider-connect.vf-slider-connect-sm {\n  border-radius: var(--vf-radius-slider-sm);\n}\n\n.vf-slider-connect.vf-slider-connect-lg {\n  border-radius: var(--vf-radius-slider-lg);\n}\n\n[disabled] .vf-slider-connect {\n  background: var(--vf-slider-connect-bg-disabled);\n}\n\n.vf-slider-txt-dir-rtl.vf-slider-horizontal .vf-slider-origin {\n  left: 0;\n  right: auto;\n}\n\n.vf-slider-vertical .vf-slider-origin {\n  top: -100%;\n  width: 0;\n}\n\n.vf-slider-horizontal .vf-slider-origin {\n  height: 0;\n}\n\n.vf-slider-state-tap .vf-slider-connect,\n.vf-slider-state-tap .vf-slider-origin {\n  transition: transform 0.3s;\n}\n\n.vf-slider-handle {\n  backface-visibility: hidden;\n  position: absolute;\n  width: var(--vf-slider-handle-size);\n  height: var(--vf-slider-handle-size);\n  background-color: var(--vf-bg-slider-handle);\n  border-radius: 999px;\n  box-shadow: var(--vf-shadow-handles);\n  outline: 0px solid var(--vf-ring-color);\n  outline-offset: 0;\n  cursor: grab;\n  transition: box-shadow 0.2s ease-in-out, color 0.2s ease-in-out, background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;\n}\n\n.vf-slider-handle:focus {\n  box-shadow: var(--vf-shadow-handles-focus);\n  outline: var(--vf-ring-width) solid var(--vf-ring-color);\n}\n\n.vf-slider-handle:hover {\n  box-shadow: var(--vf-shadow-handles-hover);\n}\n\n.vf-slider-handle.vf-slider-handle-sm {\n  height: var(--vf-slider-handle-size-sm);\n  width: var(--vf-slider-handle-size-sm);\n}\n\n.vf-slider-handle.vf-slider-handle-lg {\n  height: var(--vf-slider-handle-size-lg);\n  width: var(--vf-slider-handle-size-lg);\n}\n\n.vf-slider-horizontal .vf-slider-handle {\n  top: calc((var(--vf-slider-handle-size) - var(--vf-slider-height)) / 2 * -1);\n  right: calc(var(--vf-slider-handle-size) / 2 * -1);\n}\n\n.vf-slider-horizontal .vf-slider-handle.vf-slider-handle-sm {\n  top: calc((var(--vf-slider-handle-size-sm) - var(--vf-slider-height-sm)) / 2 * -1);\n  right: calc(var(--vf-slider-handle-size-sm) / 2 * -1);\n}\n\n.vf-slider-horizontal .vf-slider-handle.vf-slider-handle-lg {\n  top: calc((var(--vf-slider-handle-size-lg) - var(--vf-slider-height-lg)) / 2 * -1);\n  right: calc(var(--vf-slider-handle-size-lg) / 2 * -1);\n}\n\n.vf-slider-horizontal.vf-slider-txt-dir-rtl .vf-slider-handle {\n  left: calc(var(--vf-slider-handle-width) / 2 * -1);\n  right: auto;\n}\n\n.vf-slider-horizontal.vf-slider-txt-dir-rtl .vf-slider-handle.vf-slider-handle-sm {\n  left: calc(var(--vf-slider-handle-width-sm) / 2 * -1);\n}\n\n.vf-slider-horizontal.vf-slider-txt-dir-rtl .vf-slider-handle.vf-slider-handle-lg {\n  left: calc(var(--vf-slider-handle-width-lg) / 2 * -1);\n}\n\n.vf-slider-vertical {\n  width: var(--vf-slider-height);\n  height: var(--vf-slider-vertical-height);\n}\n\n.vf-slider-vertical .vf-slider-handle {\n  bottom: calc(var(--vf-slider-handle-size) / 2 * -1);\n  right: calc((var(--vf-slider-handle-size) - var(--vf-slider-height)) / 2 * -1);\n}\n\n.vf-slider-vertical .vf-slider-handle.vf-slider-handle-sm {\n  bottom: calc(var(--vf-slider-handle-size-sm) / 2 * -1);\n  right: calc((var(--vf-slider-handle-size-sm) - var(--vf-slider-height-sm)) / 2 * -1);\n}\n\n.vf-slider-vertical .vf-slider-handle.vf-slider-handle-lg {\n  bottom: calc(var(--vf-slider-handle-size-lg) / 2 * -1);\n  right: calc((var(--vf-slider-handle-size-lg) - var(--vf-slider-height-lg)) / 2 * -1);\n}\n\n.vf-slider-touch-area {\n  height: 100%;\n  width: 100%;\n}\n\n.vf-slider-tooltip {\n  position: absolute;\n  display: block;\n  font-weight: 600;\n  white-space: nowrap;\n  min-width: 1.25rem;\n  text-align: center;\n  border: 1px solid var(--vf-border-color-slider-tooltip);\n  background: var(--vf-primary);\n  color: var(--vf-color-on-primary);\n  font-size: var(--vf-font-size-small);\n  line-height: var(--vf-line-height-small);\n  letter-spacing: var(--vf-letter-spacing-small);\n  padding: var(--vf-py-slider-tooltip) var(--vf-px-slider-tooltip);\n  border-radius: var(--vf-radius-small);\n}\n\n.vf-slider-tooltip.vf-slider-tooltip-sm {\n  font-size: var(--vf-font-size-small-sm);\n  line-height: var(--vf-line-height-small-sm);\n  letter-spacing: var(--vf-letter-spacing-small-sm);\n  padding: var(--vf-py-slider-tooltip-sm) var(--vf-px-slider-tooltip-sm);\n  border-radius: var(--vf-radius-small-sm);\n}\n\n.vf-slider-tooltip.vf-slider-tooltip-lg {\n  font-size: var(--vf-font-size-small-lg);\n  line-height: var(--vf-line-height-small-lg);\n  letter-spacing: var(--vf-letter-spacing-small-lg);\n  padding: var(--vf-py-slider-tooltip-lg) var(--vf-px-slider-tooltip-lg);\n  border-radius: var(--vf-radius-small-lg);\n}\n\n.vf-slider-tooltip-focus .vf-slider-tooltip,\n.vf-slider-tooltip-drag .vf-slider-tooltip {\n  display: none !important;\n}\n\n.vf-slider-tooltip-focus.vf-slider-focused .vf-slider-tooltip:not(.vf-slider-tooltip-hidden),\n.vf-slider-tooltip-drag.vf-slider-state-drag .vf-slider-tooltip:not(.vf-slider-tooltip-hidden),\n.vf-slider-tooltip-drag .vf-slider-active .vf-slider-tooltip {\n  display: block !important;\n}\n\n[disabled].vf-slider-target,\n[disabled].vf-slider-handle,\n[disabled] .vf-slider-handle {\n  cursor: not-allowed;\n}\n\n.vf-slider-horizontal .vf-slider-tooltip-top {\n  transform: translate(-50%, 0);\n  left: 50%;\n  bottom: calc(var(--vf-slider-handle-size) + var(--vf-slider-tooltip-distance));\n}\n\n.vf-slider-horizontal .vf-slider-tooltip-top:before {\n  content: "";\n  position: absolute;\n  left: 50%;\n  width: 0;\n  height: 0;\n  transform: translate(-50%);\n  bottom: calc(var(--vf-slider-tooltip-arrow-size) * -2);\n  border: var(--vf-slider-tooltip-arrow-size) solid transparent;\n  border-top-color: inherit;\n}\n\n.vf-slider-horizontal .vf-slider-tooltip-top.vf-slider-tooltip-top-sm {\n  bottom: calc(var(--vf-slider-handle-size-sm) + var(--vf-slider-tooltip-distance-sm));\n}\n\n.vf-slider-horizontal .vf-slider-tooltip-top.vf-slider-tooltip-top-sm:before {\n  bottom: calc(var(--vf-slider-tooltip-arrow-size-sm) * -2);\n  border: var(--vf-slider-tooltip-arrow-size-sm) solid transparent;\n  border-top-color: inherit;\n}\n\n.vf-slider-horizontal .vf-slider-tooltip-top.vf-slider-tooltip-top-lg {\n  bottom: calc(var(--vf-slider-handle-size-lg) + var(--vf-slider-tooltip-distance-lg));\n}\n\n.vf-slider-horizontal .vf-slider-tooltip-top.vf-slider-tooltip-top-lg:before {\n  bottom: calc(var(--vf-slider-tooltip-arrow-size-lg) * -2);\n  border: var(--vf-slider-tooltip-arrow-size-lg) solid transparent;\n  border-top-color: inherit;\n}\n\n.vf-slider-horizontal .vf-slider-origin > .vf-slider-tooltip-top {\n  bottom: calc((var(--vf-slider-handle-size) - var(--vf-slider-height)) / 2 + var(--vf-slider-tooltip-distance));\n}\n\n.vf-slider-horizontal .vf-slider-origin > .vf-slider-tooltip-top.vf-slider-tooltip-top-sm {\n  bottom: calc((var(--vf-slider-handle-size-sm) - var(--vf-slider-height-sm)) / 2 + var(--vf-slider-tooltip-distance-sm));\n}\n\n.vf-slider-horizontal .vf-slider-origin > .vf-slider-tooltip-top.vf-slider-tooltip-top-lg {\n  bottom: calc((var(--vf-slider-handle-size-lg) - var(--vf-slider-height-lg)) / 2 + var(--vf-slider-tooltip-distance-lg));\n}\n\n.vf-slider-horizontal .vf-slider-tooltip-bottom {\n  transform: translate(-50%, 0);\n  left: 50%;\n  top: calc(var(--vf-slider-handle-size) + var(--vf-slider-tooltip-distance));\n}\n\n.vf-slider-horizontal .vf-slider-tooltip-bottom:before {\n  content: "";\n  position: absolute;\n  left: 50%;\n  width: 0;\n  height: 0;\n  transform: translate(-50%);\n  top: calc(var(--vf-slider-tooltip-arrow-size) * -2);\n  border: var(--vf-slider-tooltip-arrow-size) solid transparent;\n  border-bottom-color: inherit;\n}\n\n.vf-slider-horizontal .vf-slider-tooltip-bottom.vf-slider-tooltip-bottom-sm {\n  top: calc(var(--vf-slider-handle-size-sm) + var(--vf-slider-tooltip-distance-sm));\n}\n\n.vf-slider-horizontal .vf-slider-tooltip-bottom.vf-slider-tooltip-bottom-sm:before {\n  top: calc(var(--vf-slider-tooltip-arrow-size-sm) * -2);\n  border: var(--vf-slider-tooltip-arrow-size-sm) solid transparent;\n  border-bottom-color: inherit;\n}\n\n.vf-slider-horizontal .vf-slider-tooltip-bottom.vf-slider-tooltip-bottom-lg {\n  top: calc(var(--vf-slider-handle-size-lg) + var(--vf-slider-tooltip-distance-lg));\n}\n\n.vf-slider-horizontal .vf-slider-tooltip-bottom.vf-slider-tooltip-bottom-lg:before {\n  top: calc(var(--vf-slider-tooltip-arrow-size-lg) * -2);\n  border: var(--vf-slider-tooltip-arrow-size-lg) solid transparent;\n  border-bottom-color: inherit;\n}\n\n.vf-slider-horizontal .vf-slider-origin > .vf-slider-tooltip-bottom {\n  top: calc((var(--vf-slider-handle-size) - var(--vf-slider-height)) / 2 + var(--vf-slider-height) + var(--vf-slider-tooltip-distance));\n}\n\n.vf-slider-horizontal .vf-slider-origin > .vf-slider-tooltip-bottom.vf-slider-tooltip-bottom-sm {\n  top: calc((var(--vf-slider-handle-size-sm) - var(--vf-slider-height-sm)) / 2 + var(--vf-slider-height-sm) + var(--vf-slider-tooltip-distance-sm));\n}\n\n.vf-slider-horizontal .vf-slider-origin > .vf-slider-tooltip-bottom.vf-slider-tooltip-bottom-lg {\n  top: calc((var(--vf-slider-handle-size-lg) - var(--vf-slider-height-lg)) / 2 + var(--vf-slider-height-lg) + var(--vf-slider-tooltip-distance-lg));\n}\n\n.vf-slider-vertical .vf-slider-tooltip-left {\n  transform: translate(0, -50%);\n  top: 50%;\n  right: calc(var(--vf-slider-handle-size) + var(--vf-slider-tooltip-distance));\n}\n\n.vf-slider-vertical .vf-slider-tooltip-left:before {\n  content: "";\n  position: absolute;\n  top: 50%;\n  width: 0;\n  height: 0;\n  transform: translateY(-50%);\n  right: calc(var(--vf-slider-tooltip-arrow-size) * -2);\n  border: var(--vf-slider-tooltip-arrow-size) solid transparent;\n  border-left-color: inherit;\n}\n\n.vf-slider-vertical .vf-slider-tooltip-left.vf-slider-tooltip-left-sm {\n  right: calc(var(--vf-slider-handle-size-sm) + var(--vf-slider-tooltip-distance-sm));\n}\n\n.vf-slider-vertical .vf-slider-tooltip-left.vf-slider-tooltip-left-sm:before {\n  right: calc(var(--vf-slider-tooltip-arrow-size-sm) * -2);\n  border: var(--vf-slider-tooltip-arrow-size-sm) solid transparent;\n  border-left-color: inherit;\n}\n\n.vf-slider-vertical .vf-slider-tooltip-left.vf-slider-tooltip-left-lg {\n  right: calc(var(--vf-slider-handle-siz-lg) + var(--vf-slider-tooltip-distanc-lg));\n}\n\n.vf-slider-vertical .vf-slider-tooltip-left.vf-slider-tooltip-left-lg:before {\n  right: calc(var(--vf-slider-tooltip-arrow-size-sm) * -2);\n  border: var(--vf-slider-tooltip-arrow-size-sm) solid transparent;\n  border-left-color: inherit;\n}\n\n.vf-slider-vertical .vf-slider-origin > .vf-slider-tooltip-left {\n  right: calc((var(--vf-slider-handle-size) - var(--vf-slider-height)) / 2 + var(--vf-slider-height) + var(--vf-slider-tooltip-distance));\n}\n\n.vf-slider-vertical .vf-slider-origin > .vf-slider-tooltip-left.vf-slider-tooltip-left-sm {\n  right: calc((var(--vf-slider-handle-size-sm) - var(--vf-slider-height-sm)) / 2 + var(--vf-slider-height-sm) + var(--vf-slider-tooltip-distance-sm));\n}\n\n.vf-slider-vertical .vf-slider-origin > .vf-slider-tooltip-left.vf-slider-tooltip-left-lg {\n  right: calc((var(--vf-slider-handle-size-lg) - var(--vf-slider-height-lg)) / 2 + var(--vf-slider-height-lg) + var(--vf-slider-tooltip-distance-lg));\n}\n\n.vf-slider-vertical .vf-slider-tooltip-right {\n  transform: translate(0, -50%);\n  top: 50%;\n  left: calc(var(--vf-slider-handle-size) + var(--vf-slider-tooltip-distance));\n}\n\n.vf-slider-vertical .vf-slider-tooltip-right:before {\n  content: "";\n  position: absolute;\n  top: 50%;\n  width: 0;\n  height: 0;\n  transform: translateY(-50%);\n  left: calc(var(--vf-slider-tooltip-arrow-size) * -2);\n  border: var(--vf-slider-tooltip-arrow-size) solid transparent;\n  border-right-color: inherit;\n}\n\n.vf-slider-vertical .vf-slider-tooltip-right.vf-slider-tooltip-right-sm {\n  left: calc(var(--vf-slider-handle-size-sm) + var(--vf-slider-tooltip-distance-sm));\n}\n\n.vf-slider-vertical .vf-slider-tooltip-right.vf-slider-tooltip-right-sm:before {\n  left: calc(var(--vf-slider-tooltip-arrow-size-sm) * -2);\n  border: var(--vf-slider-tooltip-arrow-size-sm) solid transparent;\n  border-right-color: inherit;\n}\n\n.vf-slider-vertical .vf-slider-tooltip-right.vf-slider-tooltip-right-lg {\n  left: calc(var(--vf-slider-handle-size-lg) + var(--vf-slider-tooltip-distance-lg));\n}\n\n.vf-slider-vertical .vf-slider-tooltip-right.vf-slider-tooltip-right-lg:before {\n  left: calc(var(--vf-slider-tooltip-arrow-size-lg) * -2);\n  border: var(--vf-slider-tooltip-arrow-size-lg) solid transparent;\n  border-right-color: inherit;\n}\n\n.vf-slider-vertical .vf-slider-origin > .vf-slider-tooltip-right {\n  left: calc((var(--vf-slider-handle-size) - var(--vf-slider-height)) / 2 + var(--vf-slider-tooltip-distance));\n}\n\n.vf-slider-vertical .vf-slider-origin > .vf-slider-tooltip-right.vf-slider-tooltip-right-sm {\n  left: calc((var(--vf-slider-handle-size-sm) - var(--vf-slider-height-sm)) / 2 + var(--vf-slider-tooltip-distance-sm));\n}\n\n.vf-slider-vertical .vf-slider-origin > .vf-slider-tooltip-right.vf-slider-tooltip-right-lg {\n  left: calc((var(--vf-slider-handle-size-lg) - var(--vf-slider-height-lg)) / 2 + var(--vf-slider-tooltip-distance-lg));\n}\n\n.vf-slider-horizontal .vf-slider-origin > .vf-slider-tooltip {\n  transform: translate(50%, 0);\n  left: auto;\n}\n\n.vf-slider-vertical .vf-slider-origin > .vf-slider-tooltip {\n  transform: translate(0, 50%);\n  top: auto;\n}\n\n.vf-slider-active {\n  cursor: grabbing;\n}\n\n.vf-slider-draggable {\n  cursor: ew-resize;\n}\n\n.vf-slider-vertical .vf-slider-draggable {\n  cursor: ns-resize;\n}';
    styleInject(css_248z$l);
    script$H.__file = "themes/vueform/templates/elements/SliderElement.vue";
    var script$G = {
      name: "StaticElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            content: "",
            tag: ""
          }
        };
      }
    };
    const _hoisted_1$f = ["innerHTML"];
    const _hoisted_2$a = ["href", "target", "innerHTML"];
    const _hoisted_3$8 = ["href", "target"];
    const _hoisted_4$5 = ["href", "target"];
    const _hoisted_5$2 = ["src", "alt", "title", "width", "height"];
    const _hoisted_6$1 = ["src", "alt", "title", "width", "height"];
    const _hoisted_7 = ["innerHTML"];
    function render$i(_ctx, _cache, $props, $setup, $data, $options) {
      return _ctx.wrap ? (openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        {
          key: 0,
          ref: "container"
        },
        createSlots({
          element: withCtx(() => [
            createCommentVNode(" If content is HTML "),
            _ctx.isHtml && (_ctx.resolvedContent || ["img", "hr"].indexOf(_ctx.tag) !== -1) ? (openBlock(), createElementBlock(
              Fragment,
              { key: 0 },
              [
                !_ctx.tag && _ctx.allowHtml ? (openBlock(), createElementBlock("div", mergeProps({
                  key: 0,
                  class: _ctx.classes.content,
                  innerHTML: _ctx.resolvedContent
                }, _ctx.attrs), null, 16, _hoisted_1$f)) : createCommentVNode("v-if", true),
                !_ctx.tag && !_ctx.allowHtml ? (openBlock(), createElementBlock(
                  "div",
                  mergeProps({
                    key: 1,
                    class: _ctx.classes.content
                  }, _ctx.attrs),
                  toDisplayString(_ctx.content),
                  17
                  /* TEXT, FULL_PROPS */
                )) : createCommentVNode("v-if", true),
                _ctx.tag === "a" ? (openBlock(), createElementBlock(
                  "div",
                  {
                    key: 2,
                    class: normalizeClass(_ctx.classes.tag)
                  },
                  [
                    _ctx.allowHtml ? (openBlock(), createElementBlock("a", mergeProps({
                      key: 0,
                      href: _ctx.href,
                      target: _ctx.target
                    }, _ctx.attrs, { innerHTML: _ctx.resolvedContent }), null, 16, _hoisted_2$a)) : (openBlock(), createElementBlock("a", mergeProps({
                      key: 1,
                      href: _ctx.href,
                      target: _ctx.target
                    }, _ctx.attrs), toDisplayString(_ctx.resolvedContent), 17, _hoisted_3$8))
                  ],
                  2
                  /* CLASS */
                )) : _ctx.tag === "hr" ? (openBlock(), createElementBlock(
                  "div",
                  {
                    key: 3,
                    class: normalizeClass(_ctx.classes.tag)
                  },
                  [
                    createBaseVNode(
                      "hr",
                      normalizeProps(guardReactiveProps(_ctx.attrs)),
                      null,
                      16
                      /* FULL_PROPS */
                    )
                  ],
                  2
                  /* CLASS */
                )) : _ctx.tag === "img" ? (openBlock(), createElementBlock(
                  "div",
                  {
                    key: 4,
                    class: normalizeClass(_ctx.classes.tag)
                  },
                  [
                    _ctx.href ? (openBlock(), createElementBlock("a", {
                      key: 0,
                      href: _ctx.href,
                      target: _ctx.target
                    }, [
                      createBaseVNode("img", mergeProps({
                        src: _ctx.src,
                        alt: _ctx.alt,
                        title: _ctx.title,
                        width: _ctx.width,
                        height: _ctx.height
                      }, _ctx.attrs), null, 16, _hoisted_5$2)
                    ], 8, _hoisted_4$5)) : (openBlock(), createElementBlock("img", mergeProps({
                      key: 1,
                      src: _ctx.src,
                      alt: _ctx.alt,
                      title: _ctx.title,
                      width: _ctx.width,
                      height: _ctx.height
                    }, _ctx.attrs), null, 16, _hoisted_6$1))
                  ],
                  2
                  /* CLASS */
                )) : (openBlock(), createElementBlock(
                  "div",
                  {
                    key: 5,
                    class: normalizeClass(_ctx.classes.tag)
                  },
                  [
                    _ctx.allowHtml ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
                      key: 0,
                      innerHTML: _ctx.resolvedContent
                    }, _ctx.attrs), null, 16, ["innerHTML"])) : (openBlock(), createBlock(
                      resolveDynamicComponent(_ctx.tag),
                      normalizeProps(mergeProps({ key: 1 }, _ctx.attrs)),
                      {
                        default: withCtx(() => [
                          createTextVNode(
                            toDisplayString(_ctx.resolvedContent),
                            1
                            /* TEXT */
                          )
                        ]),
                        _: 1
                        /* STABLE */
                      },
                      16
                      /* FULL_PROPS */
                    ))
                  ],
                  2
                  /* CLASS */
                ))
              ],
              64
              /* STABLE_FRAGMENT */
            )) : _ctx.resolvedContent ? (openBlock(), createElementBlock(
              Fragment,
              { key: 1 },
              [
                createCommentVNode(" If content is component "),
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.componentContent), { el$: _ctx.el$ }, null, 8, ["el$"]))
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : (openBlock(), createElementBlock(
              Fragment,
              { key: 2 },
              [
                createCommentVNode(" If content is a slot "),
                renderSlot(_ctx.$slots, "default", { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.slotContent), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            ))
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      )) : _ctx.content && _ctx.isHtml ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(_ctx.classes.content),
        innerHTML: _ctx.resolvedContent
      }, null, 10, _hoisted_7)) : _ctx.content ? (openBlock(), createBlock(
        resolveDynamicComponent(_ctx.componentContent),
        {
          key: 2,
          ref: "container"
        },
        null,
        512
        /* NEED_PATCH */
      )) : (openBlock(), createElementBlock(
        "div",
        {
          key: 3,
          class: normalizeClass(_ctx.classes.container),
          ref: "container"
        },
        [
          renderSlot(_ctx.$slots, "default", { el$: _ctx.el$ }, () => [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.slotContent), { el$: _ctx.el$ }, null, 8, ["el$"]))
          ])
        ],
        2
        /* CLASS */
      ));
    }
    script$G.render = render$i;
    script$G.__file = "themes/blank/templates/elements/StaticElement.vue";
    var script$F = {
      name: "StaticElement",
      render: script$G.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-contains-link",
            content: "vf-static",
            content_sm: "vf-static-sm",
            content_md: "",
            content_lg: "vf-static-lg",
            content_top_1: "vf-static-tag-top-1",
            content_top_2: "vf-static-tag-top-2",
            content_top_3: "vf-static-tag-top-3",
            content_bottom_1: "vf-static-tag-bottom-1",
            content_bottom_2: "vf-static-tag-bottom-2",
            content_bottom_3: "vf-static-tag-bottom-3",
            tag: "vf-static-tag",
            tag_sm: "vf-static-tag-sm",
            tag_md: "",
            tag_lg: "vf-static-tag-lg",
            tag_top_1: "vf-static-tag-top-1",
            tag_top_2: "vf-static-tag-top-2",
            tag_top_3: "vf-static-tag-top-3",
            tag_bottom_1: "vf-static-tag-bottom-1",
            tag_bottom_2: "vf-static-tag-bottom-2",
            tag_bottom_3: "vf-static-tag-bottom-3",
            tag_left: "vf-static-tag-left",
            tag_center: "vf-static-tag-center",
            tag_right: "vf-static-tag-right",
            tag_p: "vf-static-tag-p",
            tag_h1: "vf-static-tag-h1",
            tag_h2: "vf-static-tag-h2",
            tag_h3: "vf-static-tag-h3",
            tag_h4: "vf-static-tag-h4",
            tag_blockquote: "vf-static-tag-blockquote",
            tag_a: "vf-static-tag-a",
            tag_hr: "vf-static-tag-hr",
            tag_img: "vf-static-tag-img",
            $content: (classes2, { Size, top: top2, bottom: bottom2 }) => [
              classes2.content,
              classes2[`content_${Size}`],
              top2 >= 1 ? classes2[`content_top_${top2}`] : null,
              bottom2 >= 1 ? classes2[`content_bottom_${bottom2}`] : null
            ],
            $tag: (classes2, { Size, tag, align, top: top2, bottom: bottom2 }) => [
              classes2.tag,
              classes2[`tag_${Size}`],
              classes2[`tag_${tag}`],
              align === "left" ? classes2.tag_left : null,
              align === "center" ? classes2.tag_center : null,
              align === "right" ? classes2.tag_right : null,
              top2 >= 1 ? classes2[`tag_top_${top2}`] : null,
              bottom2 >= 1 ? classes2[`tag_bottom_${bottom2}`] : null
            ]
          }
        };
      }
    };
    var css_248z$k = "/* Styles contained in scss/_static.scss */";
    styleInject(css_248z$k);
    script$F.__file = "themes/vueform/templates/elements/StaticElement.vue";
    var script$E = {
      name: "TagsElement",
      components: {
        Multiselect: script$_
      },
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            select: {
              container: "",
              containerDisabled: "",
              containerOpen: "",
              containerOpenTop: "",
              containerActive: "",
              search: "",
              tags: "",
              tag: "",
              tagDisabled: "",
              tagRemove: "",
              tagRemoveIcon: "",
              tagsSearchWrapper: "",
              tagsSearch: "",
              tagsSearchCopy: "",
              placeholder: "",
              caret: "",
              caretOpen: "",
              clear: "",
              clearIcon: "",
              spinner: "",
              dropdown: "",
              dropdownTop: "",
              dropdownHidden: "",
              options: "",
              optionsTop: "",
              group: "",
              groupLabel: "",
              groupLabelPointable: "",
              groupLabelPointed: "",
              groupLabelSelected: "",
              groupLabelDisabled: "",
              groupLabelSelectedPointed: "",
              groupLabelSelectedDisabled: "",
              groupOptions: "",
              option: "",
              optionPointed: "",
              optionSelected: "",
              optionDisabled: "",
              optionSelectedPointed: "",
              optionSelectedDisabled: "",
              noOptions: "",
              noResults: "",
              fakeInput: "",
              spacer: ""
            }
          }
        };
      }
    };
    function render$h(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ElementLabelFloating = resolveComponent("ElementLabelFloating");
      const _component_Multiselect = resolveComponent("Multiselect");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            _ctx.hasFloating && !_ctx.empty ? (openBlock(), createBlock(_component_ElementLabelFloating, {
              key: 0,
              visible: !_ctx.empty
            }, null, 8, ["visible"])) : createCommentVNode("v-if", true),
            createCommentVNode(" @vueform/multiselect copmonent "),
            createVNode(_component_Multiselect, mergeProps(_ctx.fieldOptions, {
              modelValue: _ctx.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value = $event),
              classes: _ctx.classes.select,
              id: _ctx.fieldId,
              name: _ctx.name,
              options: _ctx.resolvedOptions,
              disabled: _ctx.isDisabled,
              placeholder: _ctx.Placeholder,
              attrs: _ctx.attrs,
              aria: _ctx.aria,
              locale: _ctx.form$.locale$,
              onSelect: _ctx.handleSelect,
              onDeselect: _ctx.handleDeselect,
              onSearchChange: _ctx.handleSearchChange,
              onTag: _ctx.handleTag,
              onOpen: _ctx.handleOpen,
              onClose: _ctx.handleClose,
              onClear: _ctx.handleClear,
              onPaste: _ctx.handlePaste,
              ref: "input"
            }), createSlots({
              _: 2
              /* DYNAMIC */
            }, [
              renderList({
                option: "option",
                noresults: "no-results",
                nooptions: "no-options",
                afterlist: "after-list",
                beforelist: "before-list",
                placeholder: "placeholder",
                grouplabel: "group-label",
                caret: "caret",
                clear: "clear",
                spinner: "spinner",
                default: "default"
              }, (slotName, slotKey) => {
                return {
                  name: slotKey,
                  fn: withCtx((props) => [
                    renderSlot(_ctx.$slots, slotName, mergeProps(props, { el$: _ctx.el$ }), () => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots[slotName]), mergeProps(props, { el$: _ctx.el$ }), null, 16, ["el$"]))
                    ])
                  ])
                };
              }),
              _ctx.fieldOptions.mode == "tags" ? {
                name: "tag",
                fn: withCtx(({ option, handleTagRemove, disabled }) => [
                  renderSlot(_ctx.$slots, "tag", {
                    option,
                    handleTagRemove,
                    disabled,
                    el$: _ctx.el$
                  }, () => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots.tag), {
                      option,
                      handleTagRemove,
                      disabled,
                      el$: _ctx.el$
                    }, null, 8, ["option", "handleTagRemove", "disabled", "el$"]))
                  ])
                ]),
                key: "0"
              } : void 0
            ]), 1040, ["modelValue", "classes", "id", "name", "options", "disabled", "placeholder", "attrs", "aria", "locale", "onSelect", "onDeselect", "onSearchChange", "onTag", "onOpen", "onClose", "onClear", "onPaste"])
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$E.render = render$h;
    script$E.__file = "themes/blank/templates/elements/TagsElement.vue";
    var script$D = {
      name: "TagsElement",
      render: script$E.render,
      components: {
        Multiselect: script$_
      },
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            select: {
              tags: "vf-multiselect-tags",
              tags_sm: "vf-multiselect-tags-sm",
              tags_md: "",
              tags_lg: "vf-multiselect-tags-lg",
              tag: "vf-multiselect-tag",
              tag_sm: "vf-multiselect-tag-sm",
              tag_md: "",
              tag_lg: "vf-multiselect-tag-lg",
              tagDisabled: "vf-multiselect-tag-disabled",
              tagDisabled_sm: "",
              tagDisabled_md: "",
              tagDisabled_lg: "",
              tagWrapper: "vf-multiselect-tag-wrapper",
              tagWrapperBreak: "vf-multiselect-tag-wrapper-break",
              tagRemove: "vf-multiselect-tag-remove",
              tagRemove_sm: "vf-multiselect-tag-remove-sm",
              tagRemove_md: "",
              tagRemove_lg: "vf-multiselect-tag-remove-lg",
              tagRemoveIcon: "vf-multiselect-tag-remove-icon",
              tagsSearchWrapper: "vf-multiselect-tags-search-wrapper",
              tagsSearchWrapper_sm: "",
              tagsSearchWrapper_md: "",
              tagsSearchWrapper_lg: "",
              tagsSearch: "vf-multiselect-tags-search",
              tagsSearch_sm: "vf-multiselect-tags-search-sm",
              tagsSearch_md: "",
              tagsSearch_lg: "vf-multiselect-tags-search-lg",
              tagsSearchCopy: "vf-multiselect-tags-search-copy",
              container: "vf-multiselect",
              container_enabled: "",
              container_disabled: "vf-multiselect-disabled",
              container_success: "vf-multiselect-success",
              container_danger: "vf-multiselect-danger",
              container_sm: "vf-multiselect-sm",
              container_md: "",
              container_lg: "vf-multiselect-lg",
              containerDisabled: "",
              containerOpen: "vf-multiselect-open",
              containerOpenTop: "vf-multiselect-open-top",
              containerActive: "vf-multiselect-active",
              containerActive_enabled: "",
              wrapper: "vf-multiselect-wrapper",
              wrapper_sm: "vf-multiselect-wrapper-sm",
              wrapper_md: "",
              wrapper_lg: "vf-multiselect-wrapper-lg",
              search: "vf-multiselect-search",
              search_sm: "vf-multiselect-search-sm",
              search_md: "",
              search_lg: "vf-multiselect-search-lg",
              placeholder: "vf-multiselect-placeholder",
              placeholder_sm: "vf-multiselect-placeholder-sm",
              placeholder_md: "",
              placeholder_lg: "vf-multiselect-placeholder-lg",
              caret: "vf-multiselect-caret",
              caret_sm: "vf-multiselect-caret-sm",
              caret_md: "",
              caret_lg: "vf-multiselect-caret-lg",
              caretOpen: "vf-multiselect-caret-open",
              clear: "vf-multiselect-clear",
              clear_sm: "vf-multiselect-clear-sm",
              clear_md: "",
              clear_lg: "vf-multiselect-clear-lg",
              clearIcon: "vf-multiselect-clear-icon",
              spinner: "vf-multiselect-spinner",
              spinner_sm: "vf-multiselect-spinner-sm",
              spinner_md: "",
              spinner_lg: "vf-multiselect-spinner-lg",
              infinite: "vf-multiselect-infinite",
              infinite_sm: "vf-multiselect-infinite-sm",
              infinite_md: "",
              infinite_lg: "vf-multiselect-infinite-lg",
              infiniteSpinner: "vf-multiselect-infinite-spinner",
              dropdown: "vf-multiselect-dropdown",
              dropdown_sm: "vf-multiselect-dropdown-sm",
              dropdown_md: "",
              dropdown_lg: "vf-multiselect-dropdown-lg",
              dropdownTop: "vf-multiselect-dropdown-top",
              dropdownTop_sm: "vf-multiselect-dropdown-top-sm",
              dropdownTop_md: "",
              dropdownTop_lg: "vf-multiselect-dropdown-top-lg",
              dropdownHidden: "vf-multiselect-dropdown-hidden",
              options: "vf-multiselect-options",
              optionsTop: "vf-multiselect-options-top",
              group: "vf-multiselect-group",
              groupLabel: "vf-multiselect-group-label",
              groupLabel_sm: "vf-multiselect-group-label-sm",
              groupLabel_md: "",
              groupLabel_lg: "vf-multiselect-group-label-lg",
              groupLabelPointable: "vf-multiselect-group-label-pointable",
              groupLabelPointed: "vf-multiselect-group-label-pointed",
              groupLabelSelected: "vf-multiselect-group-label-selected",
              groupLabelDisabled: "vf-multiselect-group-label-disabled",
              groupLabelSelectedPointed: "vf-multiselect-group-label-selected vf-multiselect-group-label-pointed",
              groupLabelSelectedDisabled: "vf-multiselect-group-label-selected vf-multiselect-group-label-disabled",
              groupOptions: "vf-multiselect-group-options",
              option: "vf-multiselect-option",
              option_sm: "vf-multiselect-option-sm",
              option_md: "",
              option_lg: "vf-multiselect-option-lg",
              optionPointed: "vf-multiselect-option-pointed",
              optionSelected: "vf-multiselect-option-selected",
              optionDisabled: "vf-multiselect-option-disabled",
              optionSelectedPointed: "vf-multiselect-option-selected vf-multiselect-option-pointed",
              optionSelectedDisabled: "vf-multiselect-option-selected vf-multiselect-option-disabled",
              noOptions: "vf-multiselect-no-options",
              noOptions_sm: "vf-multiselect-no-options-sm",
              noOptions_md: "",
              noOptions_lg: "vf-multiselect-no-options-lg",
              noResults: "vf-multiselect-no-results",
              noResults_sm: "vf-multiselect-no-results-sm",
              noResults_md: "",
              noResults_lg: "vf-multiselect-no-results-lg",
              fakeInput: "vf-multiselect-fake-input",
              assist: "vf-assistive-text",
              spacer: "vf-multiselect-spacer",
              spacer_sm: "vf-multiselect-spacer-sm",
              spacer_md: "",
              spacer_lg: "vf-multiselect-spacer-lg",
              $container: (classes2, { Size, isDanger, isSuccess, isDisabled }) => [
                classes2.select.container,
                classes2.select[`container_${Size}`],
                isDisabled ? classes2.select.container_disabled : null,
                !isDisabled && !isSuccess && !isDanger ? classes2.select.container_enabled : null,
                !isDisabled && isDanger ? classes2.select.container_danger : null,
                !isDisabled && isSuccess ? classes2.select.container_success : null
              ],
              $containerActive: (classes2, { Size, isDanger, isSuccess, isDisabled }) => [
                classes2.select.containerActive,
                classes2.select[`container_${Size}`],
                !isDisabled && !isSuccess && !isDanger ? classes2.select.containerActive_enabled : null
              ],
              $wrapper: (classes2, { Size }) => [
                classes2.select.wrapper,
                classes2.select[`wrapper_${Size}`]
              ],
              $search: (classes2, { Size }) => [
                classes2.select.search,
                classes2.select[`search_${Size}`]
              ],
              $placeholder: (classes2, { Size }) => [
                classes2.select.placeholder,
                classes2.select[`placeholder_${Size}`]
              ],
              $caret: (classes2, { Size }) => [
                classes2.select.caret,
                classes2.select[`caret_${Size}`]
              ],
              $clear: (classes2, { Size }) => [
                classes2.select.clear,
                classes2.select[`clear_${Size}`]
              ],
              $spinner: (classes2, { Size }) => [
                classes2.select.spinner,
                classes2.select[`spinner_${Size}`]
              ],
              $infinite: (classes2, { Size }) => [
                classes2.select.infinite,
                classes2.select[`infinite_${Size}`]
              ],
              $dropdown: (classes2, { Size }) => [
                classes2.select.dropdown,
                classes2.select[`dropdown_${Size}`]
              ],
              $dropdownTop: (classes2, { Size }) => [
                classes2.select.dropdownTop,
                classes2.select[`dropdownTop_${Size}`]
              ],
              $groupLabel: (classes2, { Size }) => [
                classes2.select.groupLabel,
                classes2.select[`groupLabel_${Size}`]
              ],
              $option: (classes2, { Size }) => [
                classes2.select.option,
                classes2.select[`option_${Size}`]
              ],
              $spacer: (classes2, { Size }) => [
                classes2.select.spacer,
                classes2.select[`spacer_${Size}`]
              ],
              $noOptions: (classes2, { Size }) => [
                classes2.select.noOptions,
                classes2.select[`noOptions_${Size}`]
              ],
              $noResults: (classes2, { Size }) => [
                classes2.select.noResults,
                classes2.select[`noResults_${Size}`]
              ],
              $tags: (classes2, { Size }) => [
                classes2.select.tags,
                classes2.select[`tags_${Size}`]
              ],
              $tag: (classes2, { Size }) => [
                classes2.select.tag,
                classes2.select[`tag_${Size}`]
              ],
              $tagDisabled: (classes2, { Size }) => [
                classes2.select.tagDisabled,
                classes2.select[`tagDisabled_${Size}`]
              ],
              $tagRemove: (classes2, { Size }) => [
                classes2.select.tagRemove,
                classes2.select[`tagRemove_${Size}`]
              ],
              $tagsSearchWrapper: (classes2, { Size }) => [
                classes2.select.tagsSearchWrapper,
                classes2.select[`tagsSearchWrapper_${Size}`]
              ],
              $tagsSearch: (classes2, { Size }) => [
                classes2.select.tagsSearch,
                classes2.select[`tagsSearch_${Size}`]
              ]
            },
            $input: (classes2, { isDisabled, Size, isDanger, isSuccess }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : null,
              !isDisabled && !isSuccess && !isDanger ? classes2.input_enabled : null,
              !isDisabled && isDanger ? classes2.input_danger : null,
              !isDisabled && isSuccess ? classes2.input_success : null
            ],
            $inputWrapper: (classes2, { Size }) => [
              classes2.inputWrapper,
              classes2[`inputWrapper_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$j = `/* Some styles are contained in SelectElement.vue */

.vf-multiselect-tags {
  flex-grow: 1;
  flex-shrink: 1;
  display: flex;
  flex-wrap: wrap;
  margin: var(--vf-space-tags) 0 0;
  padding-left: var(--vf-py-input);
  align-items: center;
  min-width: 0;
}

.vf-multiselect-tags.vf-multiselect-tags-sm {
  padding-left: var(--vf-py-input-sm);
}

.vf-multiselect-tags.vf-multiselect-tags-lg {
  padding-left: var(--vf-py-input-lg);
}

.vf-floating-wrapper ~ .vf-multiselect-tags,
.vf-floating-wrapper ~ div .vf-multiselect-tags {
  padding-left: var(--vf-px-input);
  margin: calc(var(--vf-space-tags) + var(--vf-floating-top) + 0.34375rem - 1px) 0 0;
}

.vf-floating-wrapper ~ .vf-multiselect-tags-sm,
.vf-floating-wrapper ~ div .vf-multiselect-tags-sm {
  padding-left: var(--vf-px-input-sm);
  margin: calc(var(--vf-space-tags-sm) + var(--vf-floating-top-sm) + 0.34375rem - 1px) 0 0;
}

.vf-floating-wrapper ~ .vf-multiselect-tags-lg,
.vf-floating-wrapper ~ div .vf-multiselect-tags-lg {
  padding-left: var(--vf-px-input-lg);
  margin: calc(var(--vf-space-tags-lg) + var(--vf-floating-top-lg) + 0.34375rem - 1px) 0 0;
}

.vf-multiselect-tag {
  background: var(--vf-bg-tag);
  color: var(--vf-color-tag);
  border-style: solid;
  border-width: var(--vf-border-width-tag);
  border-color: var(--vf-border-color-tag);
  font-size: var(--vf-font-size-small);
  line-height: var(--vf-line-height-small);
  letter-spacing: var(--vf-letter-spacing-small);
  font-weight: 600;
  padding: var(--vf-py-tag) 0 var(--vf-py-tag) var(--vf-px-tag);
  border-radius: var(--vf-radius-tag);
  margin-right: var(--vf-space-tags);
  margin-bottom: var(--vf-space-tags);
  display: flex;
  align-items: center;
  white-space: nowrap;
  min-width: 0;
}

.vf-multiselect-tag.vf-multiselect-tag-disabled {
  padding-right: var(--vf-px-tag);
  opacity: 0.5;
}

.vf-multiselect-tag.vf-multiselect-tag-sm {
  font-size: var(--vf-font-size-small-sm);
  line-height: var(--vf-line-height-small-sm);
  letter-spacing: var(--vf-letter-spacing-small-sm);
  border-radius: var(--vf-radius-tag-sm);
  padding: var(--vf-py-tag-sm) 0 var(--vf-py-tag-sm) var(--vf-px-tag-sm);
}

.vf-multiselect-tag.vf-multiselect-tag-sm.vf-multiselect-tag-disabled {
  padding-right: var(--vf-px-tag-sm);
}

.vf-multiselect-tag.vf-multiselect-tag-lg {
  font-size: var(--vf-font-size-small-lg);
  line-height: var(--vf-line-height-small-lg);
  letter-spacing: var(--vf-letter-spacing-small-lg);
  border-radius: var(--vf-radius-tag-lg);
  padding: var(--vf-py-tag-lg) 0 var(--vf-py-tag-lg) var(--vf-px-tag-lg);
}

.vf-multiselect-tag.vf-multiselect-tag-lg.vf-multiselect-tag-disabled {
  padding-right: var(--vf-px-tag-lg);
}

.vf-multiselect-tag-wrapper {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.vf-multiselect-tag-wrapper-break {
  white-space: normal;
  word-break: break-all;
}

.vf-multiselect-tag-remove {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0.25rem;
  margin: 0 0.125rem;
  border-radius: var(--vf-radius-tag);
}

.vf-multiselect-tag-remove:hover {
  background: rgba(0, 0, 0, 0.1);
}

.vf-multiselect-tag-remove.vf-multiselect-tag-remove-sm {
  border-radius: var(--vf-radius-tag-sm);
}

.vf-multiselect-tag-remove.vf-multiselect-tag-remove-lg {
  border-radius: var(--vf-radius-tag-lg);
}

.vf-multiselect-tag-remove-icon {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  mask-position: center;
  -webkit-mask-position: center;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-size: contain;
  -webkit-mask-size: contain;
  background-color: currentColor;
  display: inline-block;
  width: 0.75rem;
  height: 0.75rem;
}

.vf-multiselect-tags-search-wrapper {
  display: inline-block;
  position: relative;
  margin: 0 var(--vf-space-tags) var(--vf-space-tags);
  flex-grow: 1;
  flex-shrink: 1;
  height: 100%;
  max-width: 100%;
}

.vf-multiselect-tags-search-copy {
  visibility: hidden;
  white-space: pre-wrap;
  display: inline-block;
  height: 1px;
  width: 100%;
}

.vf-multiselect-tags-search {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  border: 0;
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  outline: none;
  padding: 0;
  font-size: inherit;
  font-family: inherit;
  box-sizing: border-box;
  width: 100%;
  appearance: none;
  font-size: var(--vf-font-size);
  line-height: var(--vf-line-height);
  letter-spacing: var(--vf-letter-spacing);
  background-color: transparent;
  padding-right: 0.5rem;
}

.vf-multiselect-tags-search::-webkit-search-decoration, .vf-multiselect-tags-search::-webkit-search-cancel-button, .vf-multiselect-tags-search::-webkit-search-results-button, .vf-multiselect-tags-search::-webkit-search-results-decoration {
  -webkit-appearance: none;
}

.vf-multiselect-tags-search.vf-multiselect-tags-search-sm {
  font-size: var(--vf-font-size-sm);
  line-height: var(--vf-line-height-sm);
  letter-spacing: var(--vf-letter-spacing-sm);
}

.vf-multiselect-tags-search.vf-multiselect-tags-search-lg {
  font-size: var(--vf-font-size-lg);
  line-height: var(--vf-line-height-lg);
  letter-spacing: var(--vf-letter-spacing-lg);
}

[dir=rtl] .vf-multiselect-tags {
  padding-left: 0;
  padding-right: var(--vf-py-input);
}

[dir=rtl] .vf-multiselect-tags.vf-multiselect-tags-sm {
  padding-right: var(--vf-py-input-sm);
}

[dir=rtl] .vf-multiselect-tags.vf-multiselect-tags-lg {
  padding-right: var(--vf-py-input-lg);
}

[dir=rtl] .vf-floating-wrapper ~ .vf-multiselect-tags,
[dir=rtl] .vf-floating-wrapper ~ div .vf-multiselect-tags {
  padding-left: 0;
  padding-right: var(--vf-px-input);
}

[dir=rtl] .vf-floating-wrapper ~ .vf-multiselect-tags-sm,
[dir=rtl] .vf-floating-wrapper ~ div .vf-multiselect-tags-sm {
  padding-left: 0;
  padding-right: var(--vf-px-input-sm);
}

[dir=rtl] .vf-floating-wrapper ~ .vf-multiselect-tags-lg,
[dir=rtl] .vf-floating-wrapper ~ div .vf-multiselect-tags-lg {
  padding-left: 0;
  padding-right: var(--vf-px-input-lg);
}

[dir=rtl] .vf-multiselect-tag {
  padding: var(--vf-py-tag) var(--vf-px-tag) var(--vf-py-tag) 0;
  margin-right: 0;
  margin-left: var(--vf-space-tags);
}

[dir=rtl] .vf-multiselect-tag.is-disabled {
  padding-left: ar(--vf-px-tag);
}`;
    styleInject(css_248z$j);
    script$D.__file = "themes/vueform/templates/elements/TagsElement.vue";
    var script$C = {
      name: "TextareaElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            inputContainer: "",
            input: ""
          }
        };
      }
    };
    const _hoisted_1$e = ["value", "name", "id", "placeholder", "disabled", "readonly", "rows", "data-autogrow"];
    function render$g(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ElementAddon = resolveComponent("ElementAddon");
      const _component_ElementLabelFloating = resolveComponent("ElementLabelFloating");
      const _component_ElementLoader = resolveComponent("ElementLoader");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.inputContainer)
              },
              [
                _ctx.hasAddonBefore ? (openBlock(), createBlock(_component_ElementAddon, {
                  key: 0,
                  type: "before"
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "addon-before", {}, () => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots["addon-before"]), { el$: _ctx.el$ }, null, 8, ["el$"]))
                    ])
                  ]),
                  _: 3
                  /* FORWARDED */
                })) : createCommentVNode("v-if", true),
                _ctx.hasAddonAfter ? (openBlock(), createBlock(_component_ElementAddon, {
                  key: 1,
                  type: "after"
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "addon-after", {}, () => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots["addon-after"]), { el$: _ctx.el$ }, null, 8, ["el$"]))
                    ])
                  ]),
                  _: 3
                  /* FORWARDED */
                })) : createCommentVNode("v-if", true),
                _ctx.hasFloating && !_ctx.empty ? (openBlock(), createBlock(_component_ElementLabelFloating, {
                  key: 2,
                  visible: !_ctx.empty
                }, null, 8, ["visible"])) : createCommentVNode("v-if", true),
                withDirectives(createVNode(
                  _component_ElementLoader,
                  null,
                  null,
                  512
                  /* NEED_PATCH */
                ), [
                  [vShow, _ctx.pending]
                ]),
                createBaseVNode("textarea", mergeProps({
                  value: _ctx.model,
                  name: _ctx.name,
                  id: _ctx.fieldId,
                  class: _ctx.classes.input,
                  placeholder: _ctx.Placeholder,
                  disabled: _ctx.isDisabled,
                  readonly: _ctx.readonly,
                  rows: _ctx.rows
                }, {
                  ..._ctx.attrs,
                  ..._ctx.aria
                }, {
                  "data-autogrow": _ctx.autogrow || void 0,
                  onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args)),
                  onKeyup: _cache[1] || (_cache[1] = (...args) => _ctx.handleKeyup && _ctx.handleKeyup(...args)),
                  onKeypress: _cache[2] || (_cache[2] = (...args) => _ctx.handleKeypress && _ctx.handleKeypress(...args)),
                  onInput: _cache[3] || (_cache[3] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
                  onBlur: _cache[4] || (_cache[4] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                  onFocus: _cache[5] || (_cache[5] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                  ref: "input"
                }), null, 16, _hoisted_1$e)
              ],
              2
              /* CLASS */
            )
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$C.render = render$g;
    script$C.__file = "themes/blank/templates/elements/TextareaElement.vue";
    var script$B = {
      name: "TextareaElement",
      render: script$C.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            inputContainer: "vf-input-group vf-input-group-textarea",
            inputContainer_sm: "vf-input-group-sm",
            inputContainer_md: "",
            inputContainer_lg: "vf-input-group-lg",
            inputContainer_default: "",
            inputContainer_disabled: "vf-input-group-disabled",
            inputContainer_focused: "vf-input-group-focused",
            inputContainer_success: "vf-input-group-success",
            inputContainer_danger: "vf-input-group-danger",
            input: "vf-input-field",
            input_sm: "",
            input_md: "",
            input_lg: "",
            input_enabled: "",
            input_disabled: "",
            input_focused: "",
            input_success: "",
            input_danger: "",
            $inputContainer: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.inputContainer,
              classes2[`inputContainer_${Size}`],
              isDisabled ? classes2.inputContainer_disabled : null,
              !isDisabled && !isSuccess && !isDanger ? classes2.inputContainer_default : null,
              !isDisabled && focused ? classes2.inputContainer_focused : null,
              !isDisabled && isSuccess ? classes2.inputContainer_success : null,
              !isDisabled && isDanger ? classes2.inputContainer_danger : null
            ],
            $input: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : null,
              !isDisabled && !isSuccess && !isDanger && !focused ? classes2.input_enabled : null,
              !isDisabled && focused && !isSuccess && !isDanger ? classes2.input_focused : null,
              !isDisabled && isDanger ? classes2.input_danger : null,
              !isDisabled && isSuccess ? classes2.input_success : null
            ]
          }
        };
      }
    };
    var css_248z$i = "/* Some styles are contained in Vueform.vue */";
    styleInject(css_248z$i);
    script$B.__file = "themes/vueform/templates/elements/TextareaElement.vue";
    var script$A = {
      name: "TextElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            inputContainer: "",
            input: ""
          }
        };
      }
    };
    const _hoisted_1$d = ["value", "type", "name", "id", "placeholder", "autocomplete", "disabled", "readonly"];
    function render$f(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ElementAddon = resolveComponent("ElementAddon");
      const _component_ElementLabelFloating = resolveComponent("ElementLabelFloating");
      const _component_ElementLoader = resolveComponent("ElementLoader");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.inputContainer)
              },
              [
                _ctx.hasAddonBefore ? (openBlock(), createBlock(_component_ElementAddon, {
                  key: 0,
                  type: "before"
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "addon-before", {}, () => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots["addon-before"]), { el$: _ctx.el$ }, null, 8, ["el$"]))
                    ])
                  ]),
                  _: 3
                  /* FORWARDED */
                })) : createCommentVNode("v-if", true),
                _ctx.hasAddonAfter ? (openBlock(), createBlock(_component_ElementAddon, {
                  key: 1,
                  type: "after"
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "addon-after", {}, () => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots["addon-after"]), { el$: _ctx.el$ }, null, 8, ["el$"]))
                    ])
                  ]),
                  _: 3
                  /* FORWARDED */
                })) : createCommentVNode("v-if", true),
                _ctx.hasFloating && !_ctx.empty ? (openBlock(), createBlock(_component_ElementLabelFloating, {
                  key: 2,
                  visible: !_ctx.empty
                }, null, 8, ["visible"])) : createCommentVNode("v-if", true),
                _ctx.isLoading ? (openBlock(), createBlock(_component_ElementLoader, { key: 3 })) : createCommentVNode("v-if", true),
                createBaseVNode("input", mergeProps({
                  value: _ctx.model,
                  type: _ctx.inputType,
                  name: _ctx.name,
                  id: _ctx.fieldId,
                  class: _ctx.classes.input,
                  placeholder: _ctx.Placeholder,
                  autocomplete: _ctx.autocomplete,
                  disabled: _ctx.isDisabled,
                  readonly: _ctx.readonly
                }, {
                  ..._ctx.attrs,
                  ..._ctx.aria
                }, {
                  onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args)),
                  onKeyup: _cache[1] || (_cache[1] = (...args) => _ctx.handleKeyup && _ctx.handleKeyup(...args)),
                  onKeypress: _cache[2] || (_cache[2] = (...args) => _ctx.handleKeypress && _ctx.handleKeypress(...args)),
                  onInput: _cache[3] || (_cache[3] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
                  onSelect: _cache[4] || (_cache[4] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
                  onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                  onFocus: _cache[6] || (_cache[6] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                  ref: "input"
                }), null, 16, _hoisted_1$d)
              ],
              2
              /* CLASS */
            )
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$A.render = render$f;
    script$A.__file = "themes/blank/templates/elements/TextElement.vue";
    var script$z = {
      name: "TextElement",
      render: script$A.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            inputContainer: "vf-input-group",
            inputContainer_sm: "vf-input-group-sm",
            inputContainer_md: "",
            inputContainer_lg: "vf-input-group-lg",
            inputContainer_default: "",
            inputContainer_disabled: "vf-input-group-disabled",
            inputContainer_focused: "vf-input-group-focused",
            inputContainer_success: "vf-input-group-success",
            inputContainer_danger: "vf-input-group-danger",
            input: "vf-input-field",
            input_sm: "",
            input_md: "",
            input_lg: "",
            input_enabled: "",
            input_disabled: "",
            input_focused: "",
            input_success: "",
            input_danger: "",
            $inputContainer: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.inputContainer,
              classes2[`inputContainer_${Size}`],
              isDisabled ? classes2.inputContainer_disabled : null,
              !isDisabled && !isSuccess && !isDanger ? classes2.inputContainer_default : null,
              !isDisabled && focused ? classes2.inputContainer_focused : null,
              !isDisabled && isSuccess ? classes2.inputContainer_success : null,
              !isDisabled && isDanger ? classes2.inputContainer_danger : null
            ],
            $input: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : null,
              !isDisabled && !isSuccess && !isDanger && !focused ? classes2.input_enabled : null,
              !isDisabled && focused && !isSuccess && !isDanger ? classes2.input_focused : null,
              !isDisabled && isDanger ? classes2.input_danger : null,
              !isDisabled && isSuccess ? classes2.input_success : null
            ]
          }
        };
      }
    };
    var css_248z$h = "/* Some styles are contained in Vueform.vue */";
    styleInject(css_248z$h);
    script$z.__file = "themes/vueform/templates/elements/TextElement.vue";
    function useValue$1(props, context, dependencies2) {
      const { value, modelValue, falseValue, trueValue, disabled } = toRefs(props);
      const externalValue = modelValue && modelValue.value !== void 0 ? modelValue : value;
      const checked = computed(() => {
        return externalValue.value === trueValue.value;
      });
      const update = (val) => {
        context.emit("input", val);
        context.emit("update:modelValue", val);
        context.emit("change", val);
      };
      const check2 = () => {
        update(trueValue.value);
      };
      const uncheck = () => {
        update(falseValue.value);
      };
      const handleInput = (val) => {
        update(val.target.checked ? trueValue.value : falseValue.value);
      };
      const handleClick = () => {
        if (disabled.value) {
          return;
        }
        checked.value ? uncheck() : check2();
      };
      if ([null, void 0, false, 0, "0", "off"].indexOf(externalValue.value) !== -1 && [falseValue.value, trueValue.value].indexOf(externalValue.value) === -1) {
        uncheck();
      }
      if ([true, 1, "1", "on"].indexOf(externalValue.value) !== -1 && [falseValue.value, trueValue.value].indexOf(externalValue.value) === -1) {
        check2();
      }
      return {
        externalValue,
        checked,
        update,
        check: check2,
        uncheck,
        handleInput,
        handleClick
      };
    }
    function useValue(props, context, dependencies2) {
      const { trueValue, falseValue, onLabel, offLabel } = toRefs(props);
      const checked = dependencies2.checked;
      const update = dependencies2.update;
      const label = computed(() => {
        let label2 = checked.value ? onLabel.value : offLabel.value;
        if (!label2) {
          label2 = "&nbsp;";
        }
        return label2;
      });
      const toggle2 = () => {
        update(checked.value ? falseValue.value : trueValue.value);
      };
      const on2 = () => {
        update(trueValue.value);
      };
      const off2 = () => {
        update(falseValue.value);
      };
      return {
        label,
        toggle: toggle2,
        on: on2,
        off: off2
      };
    }
    function useClasses(props, context, dependencies2) {
      const refs = toRefs(props);
      const disabled = refs.disabled;
      const checked = dependencies2.checked;
      const classes2 = computed(() => ({
        container: "toggle-container",
        toggle: "toggle",
        toggleOn: "toggle-on",
        toggleOff: "toggle-off",
        toggleOnDisabled: "toggle-on-disabled",
        toggleOffDisabled: "toggle-off-disabled",
        handle: "toggle-handle",
        handleOn: "toggle-handle-on",
        handleOff: "toggle-handle-off",
        handleOnDisabled: "toggle-handle-on-disabled",
        handleOffDisabled: "toggle-handle-off-disabled",
        label: "toggle-label",
        ...refs.classes.value
      }));
      const classList = computed(() => {
        return {
          container: classes2.value.container,
          toggle: [
            classes2.value.toggle,
            disabled.value ? checked.value ? classes2.value.toggleOnDisabled : classes2.value.toggleOffDisabled : checked.value ? classes2.value.toggleOn : classes2.value.toggleOff
          ],
          handle: [
            classes2.value.handle,
            disabled.value ? checked.value ? classes2.value.handleOnDisabled : classes2.value.handleOffDisabled : checked.value ? classes2.value.handleOn : classes2.value.handleOff
          ],
          label: classes2.value.label
        };
      });
      return {
        classList
      };
    }
    function useStyle(props, context, dependencies2) {
      const { disabled } = toRefs(props);
      const check2 = dependencies2.check;
      const uncheck = dependencies2.uncheck;
      const checked = dependencies2.checked;
      const handleSpace = () => {
        if (disabled.value) {
          return;
        }
        checked.value ? uncheck() : check2();
      };
      return {
        handleSpace
      };
    }
    const valueProps = {
      value: {
        validator: function(p2) {
          return (p3) => ["number", "string", "boolean"].indexOf(typeof p3) !== -1 || p3 === null || p3 === void 0;
        },
        required: false
      },
      modelValue: {
        validator: function(p2) {
          return (p3) => ["number", "string", "boolean"].indexOf(typeof p3) !== -1 || p3 === null || p3 === void 0;
        },
        required: false
      }
    };
    var script$y = {
      name: "Toggle",
      emits: [
        "input",
        "update:modelValue",
        "change"
      ],
      props: {
        ...valueProps,
        id: {
          type: [String, Number],
          required: false,
          default: "toggle"
        },
        name: {
          type: [String, Number],
          required: false,
          default: "toggle"
        },
        disabled: {
          type: Boolean,
          required: false,
          default: false
        },
        required: {
          type: Boolean,
          required: false,
          default: false
        },
        falseValue: {
          type: [String, Number, Boolean],
          required: false,
          default: false
        },
        trueValue: {
          type: [String, Number, Boolean],
          required: false,
          default: true
        },
        onLabel: {
          type: [String, Object],
          required: false,
          default: ""
        },
        offLabel: {
          type: [String, Object],
          required: false,
          default: ""
        },
        classes: {
          type: Object,
          required: false,
          default: () => ({})
        },
        labelledby: {
          type: String,
          required: false
        },
        describedby: {
          type: String,
          required: false
        },
        aria: {
          required: false,
          type: Object,
          default: () => ({})
        }
      },
      setup(props, context) {
        const value = useValue$1(props, context);
        const toggle2 = useValue(props, context, {
          checked: value.checked,
          update: value.update
        });
        const classes2 = useClasses(props, context, {
          checked: value.checked
        });
        const keyboard = useStyle(props, context, {
          check: value.check,
          uncheck: value.uncheck,
          checked: value.checked
        });
        return {
          ...value,
          ...classes2,
          ...toggle2,
          ...keyboard
        };
      }
    };
    const _hoisted_1$c = ["tabindex", "aria-checked", "aria-describedby", "aria-labelledby"];
    const _hoisted_2$9 = ["id", "name", "value", "checked", "disabled"];
    const _hoisted_3$7 = ["innerHTML"];
    const _hoisted_4$4 = ["checked"];
    function render$e(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", mergeProps({
        class: _ctx.classList.container,
        tabindex: $props.disabled ? void 0 : 0,
        "aria-checked": _ctx.checked,
        "aria-describedby": $props.describedby,
        "aria-labelledby": $props.labelledby,
        role: "switch"
      }, $props.aria, {
        onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.handleSpace && _ctx.handleSpace(...args), ["prevent"]), ["space"]))
      }), [
        withDirectives(createBaseVNode("input", {
          type: "checkbox",
          id: $props.id,
          name: $props.name,
          value: $props.trueValue,
          checked: _ctx.checked,
          disabled: $props.disabled
        }, null, 8, _hoisted_2$9), [
          [vShow, false]
        ]),
        createBaseVNode(
          "div",
          {
            class: normalizeClass(_ctx.classList.toggle),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
          },
          [
            createBaseVNode(
              "span",
              {
                class: normalizeClass(_ctx.classList.handle)
              },
              null,
              2
              /* CLASS */
            ),
            renderSlot(_ctx.$slots, "label", {
              checked: _ctx.checked,
              classList: _ctx.classList
            }, () => [
              createBaseVNode("span", {
                class: normalizeClass(_ctx.classList.label),
                innerHTML: _ctx.label
              }, null, 10, _hoisted_3$7)
            ]),
            $props.required ? (openBlock(), createElementBlock("input", {
              key: 0,
              type: "checkbox",
              style: {
                appearance: "none",
                height: "1px",
                margin: "0",
                padding: "0",
                fontSize: "0",
                background: "transparent",
                position: "absolute",
                width: "100%",
                bottom: "0",
                outline: "none"
              },
              checked: _ctx.checked,
              "aria-hidden": "true",
              tabindex: "-1",
              required: ""
            }, null, 8, _hoisted_4$4)) : createCommentVNode("v-if", true)
          ],
          2
          /* CLASS */
        )
      ], 16, _hoisted_1$c);
    }
    script$y.render = render$e;
    script$y.__file = "node_modules/@vueform/toggle/src/Toggle.vue";
    var script$x = {
      name: "ToggleElement",
      components: {
        Toggle: script$y
      },
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            toggle: {
              container: "",
              toggle: "",
              toggleOn: "",
              toggleOff: "",
              toggleOnDisabled: "",
              toggleOffDisabled: "",
              handle: "",
              handleOn: "",
              handleOff: "",
              handleOnDisabled: "",
              handleOffDisabled: "",
              label: ""
            },
            text: ""
          }
        };
      }
    };
    const _hoisted_1$b = ["innerHTML"];
    function render$d(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Toggle = resolveComponent("Toggle");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.wrapper)
              },
              [
                createCommentVNode(" @vueform/toggle component "),
                createVNode(_component_Toggle, mergeProps({
                  value: _ctx.value,
                  modelValue: _ctx.value
                }, _ctx.fieldOptions, {
                  classes: _ctx.classes.toggle,
                  name: _ctx.name,
                  id: _ctx.fieldId,
                  aria: _ctx.aria,
                  onInput: _ctx.handleChange,
                  ref: "input"
                }), null, 16, ["value", "modelValue", "classes", "name", "id", "aria", "onInput"]),
                _ctx.Text ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: normalizeClass(_ctx.classes.text),
                  innerHTML: _ctx.Text
                }, null, 10, _hoisted_1$b)) : (openBlock(), createElementBlock(
                  "span",
                  {
                    key: 1,
                    class: normalizeClass(_ctx.classes.text)
                  },
                  [
                    renderSlot(_ctx.$slots, "default", { el$: _ctx.el$ }, () => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.fieldSlots.default), { el$: _ctx.el$ }, null, 8, ["el$"]))
                    ])
                  ],
                  2
                  /* CLASS */
                ))
              ],
              2
              /* CLASS */
            )
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$x.render = render$d;
    script$x.__file = "themes/blank/templates/elements/ToggleElement.vue";
    var script$w = {
      name: "ToggleElement",
      render: script$x.render,
      components: {
        Toggle: script$y
      },
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-contains-link",
            wrapper: "vf-toggle-wrapper",
            wrapper_left: "vf-toggle-wrapper-left",
            wrapper_right: "vf-toggle-wrapper-right",
            text: "vf-toggle-text",
            text_sm: "vf-toggle-text-sm",
            text_md: "",
            text_lg: "vf-toggle-text-lg",
            text_left: "vf-toggle-text-left",
            text_right: "vf-toggle-text-right",
            toggle: {
              container: "vf-toggle-container",
              container_enabled: "",
              container_disabled: "vf-toggle-container-disabled",
              toggle: "vf-toggle",
              toggle_sm: "vf-toggle-sm",
              toggle_md: "",
              toggle_lg: "vf-toggle-lg",
              toggleOn: "vf-toggle-on",
              toggleOff: "vf-toggle-off",
              toggleOnDisabled: "vf-toggle-on-disabled",
              toggleOffDisabled: "vf-toggle-off-disabled",
              handle: "vf-toggle-handle",
              handle_sm: "vf-toggle-handle-sm",
              handle_md: "",
              handle_lg: "vf-toggle-handle-lg",
              handleOn: "vf-toggle-handle-on",
              handleOff: "vf-toggle-handle-off",
              handleOnDisabled: "vf-toggle-handle-on-disabled",
              handleOffDisabled: "vf-toggle-handle-off-disabled",
              label: "vf-toggle-label",
              label_sm: "vf-toggle-label-sm",
              label_md: "",
              label_lg: "vf-toggle-label-lg",
              $container: (classes2, { Size, isDisabled }) => [
                classes2.toggle.container,
                classes2.toggle[`container_${Size}`],
                !isDisabled ? classes2.toggle.container_enabled : classes2.toggle.container_disabled
              ],
              $toggle: (classes2, { Size }) => [
                classes2.toggle.toggle,
                classes2.toggle[`toggle_${Size}`]
              ],
              $handle: (classes2, { Size }) => [
                classes2.toggle.handle,
                classes2.toggle[`handle_${Size}`]
              ],
              $label: (classes2, { Size }) => [
                classes2.toggle.label,
                classes2.toggle[`label_${Size}`]
              ]
            },
            $text: (classes2, { Size, align }) => [
              classes2.text,
              classes2[`text_${Size}`],
              align === "left" ? classes2.text_left : null,
              align === "right" ? classes2.text_right : null
            ],
            $wrapper: (classes2, { align }) => [
              classes2.wrapper,
              align === "left" ? classes2.wrapper_left : null,
              align === "right" ? classes2.wrapper_right : null
            ]
          }
        };
      }
    };
    var css_248z$g = ".vf-toggle-wrapper {\n  display: flex;\n  align-items: flex-start;\n  width: 100%;\n}\n\n.vf-toggle-text {\n  margin-left: var(--vf-space-checkbox);\n}\n\n.vf-toggle-text.vf-toggle-text-sm {\n  margin-left: var(--vf-space-checkbox-sm);\n}\n\n.vf-toggle-text.vf-toggle-text-lg {\n  margin-left: var(--vf-space-checkbox-lg);\n}\n\n/* @vueform/toggle styles */\n\n.vf-toggle-container {\n  display: inline-block;\n  outline: 0px solid var(--vf-ring-color);\n  outline-offset: 0;\n  border-radius: 9999px;\n  transition: box-shadow 0.15s ease-in-out, color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out;\n  box-shadow: var(--vf-shadow-handles);\n}\n\n.vf-toggle-container:hover:not(.vf-toggle-container-disabled) {\n  box-shadow: var(--vf-shadow-handles-hover);\n}\n\n.vf-toggle-container:focus {\n  box-shadow: var(--vf-shadow-handles-focus);\n  outline: var(--vf-ring-width) solid var(--vf-ring-color);\n}\n\n.vf-toggle-container.vf-toggle-container-disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.vf-toggle {\n  display: flex;\n  border-radius: 999px;\n  position: relative;\n  cursor: pointer;\n  transition: 0.3s all;\n  align-items: center;\n  box-sizing: content-box;\n  border-width: var(--vf-border-width-toggle);\n  border-style: solid;\n  font-size: 0.75rem;\n  width: var(--vf-toggle-width);\n  height: var(--vf-toggle-height);\n  line-height: 1;\n}\n\n.vf-toggle.vf-toggle-sm {\n  width: var(--vf-toggle-width-sm);\n  height: var(--vf-toggle-height-sm);\n  font-size: 0.75rem;\n}\n\n.vf-toggle.vf-toggle-lg {\n  width: var(--vf-toggle-width-lg);\n  height: var(--vf-toggle-height-lg);\n  font-size: 0.8125rem;\n}\n\n.vf-toggle-on {\n  background: var(--vf-primary);\n  border-color: var(--vf-primary);\n  justify-content: flex-start;\n  color: var(--vf-color-on-primary);\n}\n\n.vf-toggle-off {\n  background: var(--vf-bg-passive);\n  border-color: var(--vf-bg-passive);\n  justify-content: flex-end;\n  color: var(--vf-color-passive);\n}\n\n.vf-toggle-on-disabled {\n  background: var(--vf-primary);\n  border-color: var(--vf-primary);\n  justify-content: flex-start;\n  color: var(--vf-color-on-primary);\n}\n\n.vf-toggle-off-disabled {\n  background: var(--vf-bg-passive);\n  border-color: var(--vf-bg-passive);\n  justify-content: flex-end;\n  color: var(--vf-color-passive);\n}\n\n.vf-toggle-handle {\n  display: inline-block;\n  background: var(--vf-bg-toggle-handle);\n  width: var(--vf-toggle-height);\n  height: var(--vf-toggle-height);\n  top: 0;\n  border-radius: 50%;\n  position: absolute;\n  transition-property: all;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms;\n}\n\n.vf-toggle-handle.vf-toggle-handle-sm {\n  width: var(--vf-toggle-height-sm);\n  height: var(--vf-toggle-height-sm);\n}\n\n.vf-toggle-handle.vf-toggle-handle-lg {\n  width: var(--vf-toggle-height-lg);\n  height: var(--vf-toggle-height-lg);\n}\n\n.vf-toggle-handle-on {\n  left: 100%;\n  transform: translateX(-100%);\n}\n\n.vf-toggle-handle-off {\n  left: 0%;\n}\n\n.vf-toggle-handle-on-disabled {\n  left: 100%;\n  transform: translateX(-100%);\n  background: var(--vf-bg-toggle-handle);\n}\n\n.vf-toggle-handle-off-disabled {\n  left: 0%;\n  background: var(--vf-bg-toggle-handle);\n}\n\n.vf-toggle-label {\n  text-align: center;\n  width: calc(var(--vf-toggle-width) - var(--vf-toggle-height));\n  box-sizing: border-box;\n  white-space: nowrap;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\n.vf-toggle-label.vf-toggle-label-sm {\n  width: calc(var(--vf-toggle-width-sm) - var(--vf-toggle-height-sm));\n}\n\n.vf-toggle-label.vf-toggle-label-lg {\n  width: calc(var(--vf-toggle-width-lg) - var(--vf-toggle-height-lg));\n}\n\nbody:not([dir=rtl]) .vf-toggle-wrapper-right {\n  justify-content: flex-end;\n}\n\nbody:not([dir=rtl]) .vf-toggle-text-right {\n  margin-left: 0;\n  margin-right: var(--vf-space-checkbox);\n  order: -1;\n}\n\nbody:not([dir=rtl]) .vf-toggle-text-right.vf-toggle-text-sm {\n  margin-left: 0;\n  margin-right: var(--vf-space-checkbox-sm);\n}\n\nbody:not([dir=rtl]) .vf-toggle-text-right.vf-toggle-text-lg {\n  margin-left: 0;\n  margin-right: var(--vf-space-checkbox-lg);\n}\n\nbody[dir=rtl] .vf-toggle-wrapper-left {\n  justify-content: flex-end;\n}\n\nbody[dir=rtl] .vf-toggle-text {\n  margin-left: 0;\n  margin-right: var(--vf-space-checkbox);\n}\n\nbody[dir=rtl] .vf-toggle-text.vf-toggle-text-sm {\n  margin-left: 0;\n  margin-right: var(--vf-space-checkbox-sm);\n}\n\nbody[dir=rtl] .vf-toggle-text.vf-toggle-text-lg {\n  margin-left: 0;\n  margin-right: var(--vf-space-checkbox-lg);\n}\n\nbody[dir=rtl] .vf-toggle-text.vf-toggle-text-left {\n  margin-right: 0;\n  margin-left: var(--vf-space-checkbox);\n  order: -1;\n}\n\nbody[dir=rtl] .vf-toggle-text.vf-toggle-text-left.vf-toggle-text-sm {\n  margin-right: 0;\n  margin-left: var(--vf-space-checkbox-sm);\n}\n\nbody[dir=rtl] .vf-toggle-text.vf-toggle-text-left.vf-toggle-text-lg {\n  margin-right: 0;\n  margin-left: var(--vf-space-checkbox-lg);\n}";
    styleInject(css_248z$g);
    script$w.__file = "themes/vueform/templates/elements/ToggleElement.vue";
    var script$v = {
      name: "EditorElement",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            input: ""
          }
        };
      }
    };
    function render$c(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_EditorWrapper = resolveComponent("EditorWrapper");
      return openBlock(), createBlock(
        resolveDynamicComponent(_ctx.elementLayout),
        { ref: "container" },
        createSlots({
          element: withCtx(() => [
            createVNode(_component_EditorWrapper, {
              value: _ctx.model,
              placeholder: _ctx.Placeholder,
              id: _ctx.fieldId,
              accept: _ctx.accept,
              "accept-mimes": _ctx.acceptMimes,
              endpoint: _ctx.editorEndpoint,
              method: _ctx.editorMethod,
              disabled: _ctx.isDisabled,
              "hide-tools": _ctx.hideTools,
              class: normalizeClass(_ctx.classes.input),
              attrs: _ctx.aria,
              onInput: _ctx.handleInput,
              onAlert: _ctx.handleAlert,
              onError: _ctx.handleError,
              onBlur: _ctx.handleBlur,
              ref: "input"
            }, null, 8, ["value", "placeholder", "id", "accept", "accept-mimes", "endpoint", "method", "disabled", "hide-tools", "class", "attrs", "onInput", "onAlert", "onError", "onBlur"])
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          renderList(_ctx.elementSlots, (component, slot) => {
            return {
              name: slot,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, slot, { el$: _ctx.el$ }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(component), { el$: _ctx.el$ }, null, 8, ["el$"]))
                ])
              ])
            };
          })
        ]),
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      );
    }
    script$v.render = render$c;
    script$v.__file = "themes/blank/templates/elements/EditorElement.vue";
    var script$u = {
      name: "EditorElement",
      render: script$v.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            input: "vf-editor",
            input_enabled: "",
            input_disabled: "vf-editor-disabled",
            input_success: "vf-editor-success",
            input_danger: "vf-editor-danger",
            input_focused: "vf-editor-focused",
            input_sm: "vf-editor-sm",
            input_md: "",
            input_lg: "vf-editor-lg",
            $input: (classes2, { isDisabled, focused, Size, isSuccess, isDanger }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : null,
              !isDisabled && !isSuccess && !isDanger ? classes2.input_default : null,
              !isDisabled && focused ? classes2.input_focused : null,
              !isDisabled && isSuccess ? classes2.input_success : null,
              !isDisabled && isDanger ? classes2.input_danger : null
            ]
          }
        };
      }
    };
    var css_248z$f = ".vf-editor {\n  outline: 0px solid var(--vf-ring-color);\n  outline-offset: 0;\n  border-style: solid;\n  transition: box-shadow 0.2s ease-in-out, color 0.2s ease-in-out, background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;\n  font-size: var(--vf-font-size);\n  line-height: var(--vf-line-height);\n  letter-spacing: var(--vf-letter-spacing);\n  background-color: var(--vf-bg-input);\n  color: var(--vf-color-input);\n  border-color: var(--vf-border-color-input);\n  box-shadow: var(--vf-shadow-input);\n  border-width: var(--vf-border-width-input-t) var(--vf-border-width-input-r) var(--vf-border-width-input-b) var(--vf-border-width-input-l);\n  border-radius: var(--vf-radius-input);\n}\n\n.vf-editor.vf-editor-disabled {\n  background-color: var(--vf-bg-disabled);\n  color: var(--vf-color-disabled);\n}\n\n.vf-editor.vf-editor-success {\n  background-color: var(--vf-bg-input-success);\n  color: var(--vf-color-input-success);\n  border-color: var(--vf-border-color-input-success);\n}\n\n.vf-editor.vf-editor-danger {\n  background-color: var(--vf-bg-input-danger);\n  color: var(--vf-color-input-danger);\n  border-color: var(--vf-border-color-input-danger);\n}\n\n.vf-editor:hover:not(.vf-editor-disabled) {\n  box-shadow: var(--vf-shadow-input-hover);\n}\n\n.vf-editor:hover:not(.vf-editor-disabled):not(.vf-editor-success):not(.vf-editor-danger) {\n  background-color: var(--vf-bg-input-hover);\n  color: var(--vf-color-input-hover);\n  border-color: var(--vf-border-color-input-hover);\n}\n\n.vf-editor.vf-editor-focused {\n  box-shadow: var(--vf-shadow-input-focus);\n  outline: var(--vf-ring-width) solid var(--vf-ring-color);\n  border-color: var(--vf-border-color-input-focus);\n}\n\n.vf-editor.vf-editor-focused:not(.vf-editor-success):not(.vf-editor-danger), .vf-editor.vf-editor-focused:not(.vf-editor-disabled):not(.vf-editor-success):not(.vf-editor-danger) {\n  background-color: var(--vf-bg-input-focus);\n  color: var(--vf-color-input-focus);\n}";
    styleInject(css_248z$f);
    script$u.__file = "themes/vueform/templates/elements/EditorElement.vue";
    var script$t = {
      name: "TTextareaElement",
      render: script$C.render,
      staticRenderFns: script$C.staticRenderFns,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            inputContainer: "",
            input: ""
          }
        };
      }
    };
    script$t.__file = "themes/blank/templates/elements/TTextareaElement.vue";
    var script$s = {
      name: "TTextareaElement",
      render: script$t.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            inputContainer: "vf-input-group vf-input-group-textarea",
            inputContainer_sm: "vf-input-group-sm",
            inputContainer_md: "",
            inputContainer_lg: "vf-input-group-lg",
            inputContainer_default: "",
            inputContainer_disabled: "vf-input-group-disabled",
            inputContainer_focused: "vf-input-group-focused",
            inputContainer_success: "vf-input-group-success",
            inputContainer_danger: "vf-input-group-danger",
            input: "vf-field",
            input_sm: "",
            input_md: "",
            input_lg: "",
            input_enabled: "",
            input_disabled: "",
            input_focused: "",
            input_success: "",
            input_danger: "",
            $inputContainer: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.inputContainer,
              classes2[`inputContainer_${Size}`],
              isDisabled ? classes2.inputContainer_disabled : null,
              !isDisabled && !isSuccess && !isDanger ? classes2.inputContainer_default : null,
              !isDisabled && focused ? classes2.inputContainer_focused : null,
              !isDisabled && isSuccess ? classes2.inputContainer_success : null,
              !isDisabled && isDanger ? classes2.inputContainer_danger : null
            ],
            $input: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : null,
              !isDisabled && !isSuccess && !isDanger && !focused ? classes2.input_enabled : null,
              !isDisabled && focused && !isSuccess && !isDanger ? classes2.input_focused : null,
              !isDisabled && isDanger ? classes2.input_danger : null,
              !isDisabled && isSuccess ? classes2.input_success : null
            ]
          }
        };
      }
    };
    var css_248z$e = "/* Some styles are contained in Vueform.vue */";
    styleInject(css_248z$e);
    script$s.__file = "themes/vueform/templates/elements/TTextareaElement.vue";
    var script$r = {
      name: "TTextElement",
      render: script$A.render,
      staticRenderFns: script$A.staticRenderFns,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            inputContainer: "",
            input: ""
          }
        };
      }
    };
    script$r.__file = "themes/blank/templates/elements/TTextElement.vue";
    var script$q = {
      name: "TTextElement",
      render: script$r.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            inputContainer: "vf-input-group",
            inputContainer_sm: "vf-input-group-sm",
            inputContainer_md: "",
            inputContainer_lg: "vf-input-group-lg",
            inputContainer_default: "",
            inputContainer_disabled: "vf-input-group-disabled",
            inputContainer_focused: "vf-input-group-focused",
            inputContainer_success: "vf-input-group-success",
            inputContainer_danger: "vf-input-group-danger",
            input: "vf-input-field",
            input_sm: "",
            input_md: "",
            input_lg: "",
            input_enabled: "",
            input_disabled: "",
            input_focused: "",
            input_success: "",
            input_danger: "",
            $inputContainer: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.inputContainer,
              classes2[`inputContainer_${Size}`],
              isDisabled ? classes2.inputContainer_disabled : null,
              !isDisabled && !isSuccess && !isDanger ? classes2.inputContainer_default : null,
              !isDisabled && focused ? classes2.inputContainer_focused : null,
              !isDisabled && isSuccess ? classes2.inputContainer_success : null,
              !isDisabled && isDanger ? classes2.inputContainer_danger : null
            ],
            $input: (classes2, { isDisabled, Size, isSuccess, isDanger, focused }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : null,
              !isDisabled && !isSuccess && !isDanger && !focused ? classes2.input_enabled : null,
              !isDisabled && focused && !isSuccess && !isDanger ? classes2.input_focused : null,
              !isDisabled && isDanger ? classes2.input_danger : null,
              !isDisabled && isSuccess ? classes2.input_success : null
            ]
          }
        };
      }
    };
    var css_248z$d = "/* Some styles are contained in Vueform.vue */";
    styleInject(css_248z$d);
    script$q.__file = "themes/vueform/templates/elements/TTextElement.vue";
    var script$p = {
      name: "TEditorElement",
      render: script$v.render,
      staticRenderFns: script$v.staticRenderFns,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            input: ""
          }
        };
      }
    };
    script$p.__file = "themes/blank/templates/elements/TEditorElement.vue";
    var script$o = {
      name: "TEditorElement",
      render: script$p.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-text-type",
            input: "vf-editor",
            input_enabled: "",
            input_disabled: "vf-editor-disabled",
            input_success: "vf-editor-success",
            input_danger: "vf-editor-danger",
            input_focused: "vf-editor-focused",
            input_focused_success: "vf-editor-focused-success",
            input_focused_danger: "vf-editor-focused-danger",
            input_sm: "vf-editor-sm",
            input_md: "",
            input_lg: "vf-editor-lg",
            $input: (classes2, { isDisabled, focused, Size, isSuccess, isDanger }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : null,
              !isDisabled && !isSuccess && !isDanger && !focused ? classes2.input_enabled : null,
              !isDisabled && isDanger ? classes2.input_danger : null,
              !isDisabled && isSuccess ? classes2.input_success : null,
              focused && !isDanger && !isSuccess ? classes2.input_focused : null,
              focused && isSuccess ? classes2.input_focused_success : null,
              focused && isDanger ? classes2.input_focused_danger : null
            ]
          }
        };
      }
    };
    var css_248z$c = "/* Some styles are contained in EditorElement.vue */";
    styleInject(css_248z$c);
    script$o.__file = "themes/vueform/templates/elements/TEditorElement.vue";
    var script$n = {
      name: "CheckboxgroupCheckbox",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            input: "",
            text: ""
          }
        };
      }
    };
    const _hoisted_1$a = ["value", "name", "id", "disabled", "aria-label"];
    const _hoisted_2$8 = ["innerHTML"];
    function render$b(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "label",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          renderSlot(_ctx.$slots, "default", mergeProps({ name: _ctx.name }, {
            classes: _ctx.classes,
            isDisabled: _ctx.isDisabled,
            id: _ctx.id,
            item: _ctx.item,
            value: _ctx.value,
            items: _ctx.items,
            index: _ctx.index
          }), () => [
            withDirectives(createBaseVNode("input", mergeProps({
              type: "checkbox",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.el$.model = $event)
            }, _ctx.attrs, {
              value: _ctx.value,
              class: _ctx.classes.input,
              name: _ctx.name,
              id: _ctx.id,
              disabled: _ctx.isDisabled,
              "aria-label": _ctx.item.label
            }), null, 16, _hoisted_1$a), [
              [vModelCheckbox, _ctx.el$.model]
            ]),
            createBaseVNode("span", {
              class: normalizeClass(_ctx.classes.text),
              innerHTML: _ctx.item.label
            }, null, 10, _hoisted_2$8)
          ])
        ],
        2
        /* CLASS */
      );
    }
    script$n.render = render$b;
    script$n.__file = "themes/blank/templates/elements/partials/CheckboxgroupCheckbox.vue";
    var script$m = {
      name: "CheckboxgroupCheckbox",
      render: script$n.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-checkbox-container",
            input: "vf-checkbox",
            input_enabled: "",
            input_disabled: "",
            input_sm: "vf-checkbox-sm",
            input_md: "",
            input_lg: "vf-checkbox-lg",
            text: "vf-checkbox-text",
            $input: (classes2, { isDisabled, Size }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : classes2.input_enabled
            ]
          }
        };
      }
    };
    var css_248z$b = "/* Some styles are contained in Vueform.vue & CheckboxgroupElement.vue */";
    styleInject(css_248z$b);
    script$m.__file = "themes/vueform/templates/elements/partials/CheckboxgroupCheckbox.vue";
    var script$l = {
      name: "CheckboxgroupCheckbox_tabs",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            input: "",
            text: ""
          }
        };
      }
    };
    const _hoisted_1$9 = ["aria-checked"];
    const _hoisted_2$7 = ["title"];
    const _hoisted_3$6 = ["value", "id", "name", "disabled"];
    const _hoisted_4$3 = ["innerHTML"];
    function render$a(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("label", mergeProps(_ctx.attrs, {
        class: _ctx.classes.container,
        tabindex: "0",
        role: "checkbox",
        "aria-checked": _ctx.checked,
        onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.el$.toggle(_ctx.value), ["prevent"]), ["space"])),
        onKeydown: _cache[2] || (_cache[2] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
      }), [
        renderSlot(_ctx.$slots, "default", mergeProps({ name: _ctx.name }, {
          classes: _ctx.classes,
          isDisabled: _ctx.isDisabled,
          id: _ctx.id,
          item: _ctx.item,
          value: _ctx.value,
          items: _ctx.items,
          index: _ctx.index
        }), () => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.classes.wrapper),
            title: _ctx.item.label
          }, [
            withDirectives(createBaseVNode("input", {
              type: "checkbox",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.el$.model = $event),
              value: _ctx.value,
              id: _ctx.id,
              class: normalizeClass(_ctx.classes.input),
              name: _ctx.name,
              disabled: _ctx.isDisabled
            }, null, 10, _hoisted_3$6), [
              [vModelCheckbox, _ctx.el$.model]
            ]),
            createBaseVNode("span", {
              class: normalizeClass(_ctx.classes.text),
              innerHTML: `${_ctx.item.label}`
            }, null, 10, _hoisted_4$3)
          ], 10, _hoisted_2$7)
        ])
      ], 16, _hoisted_1$9);
    }
    script$l.render = render$a;
    script$l.__file = "themes/blank/templates/elements/partials/CheckboxgroupCheckbox_tabs.vue";
    var script$k = {
      name: "CheckboxgroupCheckbox_tabs",
      render: script$l.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-checkbox-tabs-container",
            wrapper: "vf-checkbox-tabs",
            wrapper_not_last: "vf-checkbox-tabs-not-last",
            wrapper_first: "vf-checkbox-tabs-first",
            wrapper_first_sm: "vf-checkbox-tabs-first-sm",
            wrapper_first_md: "",
            wrapper_first_lg: "vf-checkbox-tabs-first-lg",
            wrapper_last: "vf-checkbox-tabs-last",
            wrapper_last_sm: "vf-checkbox-tabs-last-sm",
            wrapper_last_md: "",
            wrapper_last_lg: "vf-checkbox-tabs-last-lg",
            wrapper_selected: "vf-checkbox-tabs-selected",
            wrapper_unselected: "vf-checkbox-tabs-unselected",
            wrapper_disabled: "vf-checkbox-tabs-disabled",
            wrapper_sm: "vf-checkbox-tabs-sm",
            wrapper_md: "",
            wrapper_lg: "vf-checkbox-tabs-lg",
            input: "vf-checkbox-tabs-input",
            text: "",
            $wrapper: (classes2, { index: index2, items, el$, value, isDisabled, Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`],
              index2 < Object.keys(items).length - 1 ? classes2.wrapper_not_last : null,
              index2 === 0 ? classes2.wrapper_first : null,
              index2 === 0 ? classes2[`wrapper_first_${Size}`] : null,
              index2 === Object.keys(items).length - 1 ? classes2.wrapper_last : null,
              index2 === Object.keys(items).length - 1 ? classes2[`wrapper_last_${Size}`] : null,
              el$.value.indexOf(value) !== -1 ? classes2.wrapper_selected : classes2.wrapper_unselected,
              isDisabled ? classes2.wrapper_disabled : null
            ]
          }
        };
      }
    };
    var css_248z$a = "/* Some styles are contained in Vueform.vue & CheckboxgroupElement.vue */\n\n.vf-checkbox-tabs-container {\n  display: flex;\n  align-items: flex-start;\n  cursor: pointer;\n}\n\n.vf-checkbox-tabs {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-style: solid;\n  border-width: var(--vf-border-width-input-t) var(--vf-border-width-input-r) var(--vf-border-width-input-b) var(--vf-border-width-input-l);\n  border-color: var(--vf-border-color-input);\n  padding: var(--vf-py-group-tabs) var(--vf-px-group-tabs);\n  width: 100%;\n  background: var(--vf-bg-input);\n  color: var(--vf-color-input);\n  font-size: var(--vf-font-size);\n  line-height: var(--vf-line-height);\n  letter-spacing: var(--vf-letter-spacing);\n}\n\n.vf-checkbox-tabs.vf-checkbox-tabs-not-last {\n  border-right: 0;\n}\n\n.vf-checkbox-tabs.vf-checkbox-tabs-first {\n  border-radius: var(--vf-radius-input);\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.vf-checkbox-tabs.vf-checkbox-tabs-first.vf-checkbox-tabs-first-sm {\n  border-radius: var(--vf-radius-input-sm);\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.vf-checkbox-tabs.vf-checkbox-tabs-first.vf-checkbox-tabs-first-lg {\n  border-radius: var(--vf-radius-input-lg);\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.vf-checkbox-tabs.vf-checkbox-tabs-last {\n  border-radius: var(--vf-radius-input-lg);\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.vf-checkbox-tabs.vf-checkbox-tabs-last.vf-checkbox-tabs-last-sm {\n  border-radius: var(--vf-radius-input-sm);\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.vf-checkbox-tabs.vf-checkbox-tabs-last.vf-checkbox-tabs-last-lg {\n  border-radius: var(--vf-radius-input-lg);\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.vf-checkbox-tabs.vf-checkbox-tabs-selected {\n  background-color: var(--vf-primary);\n  border-color: rgba(0, 0, 0, 0.15);\n  color: var(--vf-color-on-primary);\n}\n\n.vf-checkbox-tabs.vf-checkbox-tabs-unselected {\n  border-color: var(--vf-border-color-input);\n}\n\n.vf-checkbox-tabs.vf-checkbox-tabs-unselected:hover:not(.vf-radio-tabs-disabled) {\n  background-color: var(--vf-bg-input-hover);\n  color: var(--vf-color-input-hover);\n}\n\n.vf-checkbox-tabs.vf-checkbox-tabs-disabled {\n  opacity: 0.5;\n}\n\n.vf-checkbox-tabs.vf-checkbox-tabs-sm {\n  padding: var(--vf-py-group-tabs-sm) var(--vf-px-group-tabs-sm);\n  font-size: var(--vf-font-size-sm);\n  line-height: var(--vf-line-height-sm);\n  letter-spacing: var(--vf-letter-spacing-sm);\n}\n\n.vf-checkbox-tabs.vf-checkbox-tabs-lg {\n  padding: var(--vf-py-group-tabs-lg) var(--vf-px-group-tabs-lg);\n  font-size: var(--vf-font-size-lg);\n  line-height: var(--vf-line-height-lg);\n  letter-spacing: var(--vf-letter-spacing-lg);\n}\n\n.vf-checkbox-tabs-input {\n  display: none;\n}";
    styleInject(css_248z$a);
    script$k.__file = "themes/vueform/templates/elements/partials/CheckboxgroupCheckbox_tabs.vue";
    var script$j = {
      name: "CheckboxgroupCheckbox_tabs",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            input: "",
            text_wrapper: "",
            text: "",
            description: ""
          }
        };
      }
    };
    const _hoisted_1$8 = ["value", "name", "id", "disabled"];
    const _hoisted_2$6 = ["innerHTML"];
    const _hoisted_3$5 = ["innerHTML"];
    function render$9(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "label",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          renderSlot(_ctx.$slots, "default", mergeProps({ name: _ctx.name }, {
            classes: _ctx.classes,
            isDisabled: _ctx.isDisabled,
            id: _ctx.id,
            item: _ctx.item,
            value: _ctx.value,
            items: _ctx.items,
            index: _ctx.index
          }), () => [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.wrapper)
              },
              [
                withDirectives(createBaseVNode("input", mergeProps({
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.el$.model = $event)
                }, _ctx.attrs, {
                  value: _ctx.value,
                  class: _ctx.classes.input,
                  name: _ctx.name,
                  id: _ctx.id,
                  disabled: _ctx.isDisabled
                }), null, 16, _hoisted_1$8), [
                  [vModelCheckbox, _ctx.el$.model]
                ]),
                createBaseVNode(
                  "div",
                  {
                    class: normalizeClass(_ctx.classes.text_wrapper)
                  },
                  [
                    createBaseVNode("div", {
                      class: normalizeClass(_ctx.classes.text),
                      innerHTML: _ctx.item.label
                    }, null, 10, _hoisted_2$6),
                    createBaseVNode("div", {
                      class: normalizeClass(_ctx.classes.description),
                      innerHTML: _ctx.item.description
                    }, null, 10, _hoisted_3$5)
                  ],
                  2
                  /* CLASS */
                )
              ],
              2
              /* CLASS */
            )
          ])
        ],
        2
        /* CLASS */
      );
    }
    script$j.render = render$9;
    script$j.__file = "themes/blank/templates/elements/partials/CheckboxgroupCheckbox_blocks.vue";
    var script$i = {
      name: "CheckboxgroupCheckbox_blocks",
      render: script$j.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-checkbox-blocks-container",
            container_sm: "vf-checkbox-blocks-container-sm",
            container_md: "",
            container_lg: "vf-checkbox-blocks-container-lg",
            wrapper: "vf-checkbox-blocks",
            wrapper_not_last: "vf-checkbox-blocks-not-last",
            wrapper_first: "vf-checkbox-blocks-first",
            wrapper_first_sm: "vf-checkbox-blocks-first-sm",
            wrapper_first_md: "",
            wrapper_first_lg: "vf-checkbox-blocks-first-lg",
            wrapper_last: "vf-checkbox-blocks-last",
            wrapper_last_sm: "vf-checkbox-blocks-last-sm",
            wrapper_last_md: "",
            wrapper_last_lg: "vf-checkbox-blocks-last-lg",
            wrapper_selected: "vf-checkbox-blocks-selected",
            wrapper_unselected: "vf-checkbox-blocks-unselected",
            wrapper_disabled: "vf-checkbox-blocks-disabled",
            wrapper_sm: "vf-checkbox-blocks-sm",
            wrapper_md: "",
            wrapper_lg: "vf-checkbox-blocks-lg",
            input: "vf-checkbox",
            input_enabled: "",
            input_disabled: "",
            input_sm: "vf-checkbox-sm",
            input_md: "",
            input_lg: "vf-checkbox-lg",
            text_wrapper: "vf-checkbox-blocks-text-wrapper",
            text: "vf-checkbox-blocks-text",
            description: "vf-checkbox-blocks-description",
            description_sm: "vf-checkbox-blocks-description-sm",
            description_md: "",
            description_lg: "vf-checkbox-blocks-description-lg",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ],
            $wrapper: (classes2, { index: index2, items, el$, value, isDisabled, Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`],
              index2 < Object.keys(items).length - 1 ? classes2.wrapper_not_last : null,
              index2 === 0 ? classes2.wrapper_first : null,
              index2 === 0 ? classes2[`wrapper_first_${Size}`] : null,
              index2 === Object.keys(items).length - 1 ? classes2.wrapper_last : null,
              index2 === Object.keys(items).length - 1 ? classes2[`wrapper_last_${Size}`] : null,
              el$.value.indexOf(value) !== -1 ? classes2.wrapper_selected : classes2.wrapper_unselected,
              isDisabled ? classes2.wrapper_disabled : null
            ],
            $input: (classes2, { isDisabled, Size }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : classes2.input_enabled
            ],
            $description: (classes2, { Size }) => [
              classes2.description,
              classes2[`description_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$9 = "/* Some styles are contained in Vueform.vue & CheckboxgroupElement.vue */\n\n.vf-checkbox-blocks-container {\n  display: flex;\n  align-items: flex-start;\n  cursor: pointer;\n  border-radius: var(--vf-radius-large);\n}\n\n.vf-checkbox-blocks-container .vf-checkbox {\n  margin-top: 0;\n}\n\n.vf-checkbox-blocks-container.vf-checkbox-blocks-container-sm {\n  border-radius: var(--vf-radius-large-sm);\n}\n\n.vf-checkbox-blocks-container.vf-checkbox-blocks-container-lg {\n  border-radius: var(--vf-radius-large-lg);\n}\n\n.vf-checkbox-blocks {\n  display: flex;\n  align-items: center;\n  border-style: solid;\n  border-width: var(--vf-border-width-input-t) var(--vf-border-width-input-r) var(--vf-border-width-input-b) var(--vf-border-width-input-l);\n  border-color: var(--vf-border-color-input);\n  width: 100%;\n  padding: var(--vf-py-group-blocks) var(--vf-px-group-blocks);\n  color: var(--vf-color-input);\n  font-size: var(--vf-font-size);\n  line-height: var(--vf-line-height);\n  letter-spacing: var(--vf-letter-spacing);\n  background: var(--vf-bg-input);\n}\n\n.vf-checkbox-blocks.vf-checkbox-blocks-not-last {\n  border-bottom: 0;\n}\n\n.vf-checkbox-blocks.vf-checkbox-blocks-first {\n  border-radius: var(--vf-radius-large);\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.vf-checkbox-blocks.vf-checkbox-blocks-first.vf-checkbox-blocks-first-sm {\n  border-radius: var(--vf-radius-large-sm);\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.vf-checkbox-blocks.vf-checkbox-blocks-first.vf-checkbox-blocks-first-lg {\n  border-radius: var(--vf-radius-large-lg);\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.vf-checkbox-blocks.vf-checkbox-blocks-last {\n  border-radius: var(--vf-radius-large);\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n\n.vf-checkbox-blocks.vf-checkbox-blocks-last.vf-checkbox-blocks-last-sm {\n  border-radius: var(--vf-radius-large-sm);\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n\n.vf-checkbox-blocks.vf-checkbox-blocks-last.vf-checkbox-blocks-last-lg {\n  border-radius: var(--vf-radius-large-lg);\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n\n.vf-checkbox-blocks.vf-checkbox-blocks-selected {\n  background-color: var(--vf-bg-selected);\n}\n\n.vf-checkbox-blocks.vf-checkbox-blocks-disabled {\n  opacity: 0.5;\n}\n\n.vf-checkbox-blocks.vf-checkbox-blocks-sm {\n  padding: var(--vf-py-group-blocks-sm) var(--vf-px-group-blocks-sm);\n  font-size: var(--vf-font-size-sm);\n  line-height: var(--vf-line-height-sm);\n  letter-spacing: var(--vf-letter-spacing-sm);\n}\n\n.vf-checkbox-blocks.vf-checkbox-blocks-lg {\n  padding: var(--vf-py-group-blocks-lg) var(--vf-px-group-blocks-lg);\n  font-size: var(--vf-font-size-lg);\n  line-height: var(--vf-line-height-lg);\n  letter-spacing: var(--vf-letter-spacing-lg);\n}\n\n.vf-checkbox-blocks-text-wrapper {\n  margin-left: 0.5rem;\n}\n\n.vf-checkbox-blocks-description {\n  color: var(--vf-color-muted);\n  font-size: var(--vf-font-size-small);\n  line-height: var(--vf-line-height-small);\n  letter-spacing: var(--vf-letter-spacing-small);\n  margin-top: -0.125rem;\n}\n\n.vf-checkbox-blocks-description.vf-checkbox-blocks-description-sm {\n  font-size: var(--vf-font-size-small-sm);\n  line-height: var(--vf-line-height-small-sm);\n  letter-spacing: var(--vf-letter-spacing-small-sm);\n  margin-top: -0.125rem;\n}\n\n.vf-checkbox-blocks-description.vf-checkbox-blocks-description-lg {\n  font-size: var(--vf-font-size-small-lg);\n  line-height: var(--vf-line-height-small-lg);\n  letter-spacing: var(--vf-letter-spacing-small-lg);\n  margin-top: -0.125rem;\n}";
    styleInject(css_248z$9);
    script$i.__file = "themes/vueform/templates/elements/partials/CheckboxgroupCheckbox_blocks.vue";
    var script$h = {
      name: "DragAndDrop",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            icon: "",
            title: "",
            description: ""
          }
        };
      }
    };
    function render$8(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(_ctx.classes.container),
          onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["prevent"])),
          ref: "area"
        },
        [
          createBaseVNode(
            "span",
            {
              class: normalizeClass(_ctx.classes.icon)
            },
            null,
            2
            /* CLASS */
          ),
          _ctx.title ? (openBlock(), createElementBlock(
            "span",
            {
              key: 0,
              class: normalizeClass(_ctx.classes.title)
            },
            toDisplayString(_ctx.title),
            3
            /* TEXT, CLASS */
          )) : createCommentVNode("v-if", true),
          _ctx.description ? (openBlock(), createElementBlock(
            "span",
            {
              key: 1,
              class: normalizeClass(_ctx.classes.description)
            },
            toDisplayString(_ctx.description),
            3
            /* TEXT, CLASS */
          )) : createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      );
    }
    script$h.render = render$8;
    script$h.__file = "themes/blank/templates/elements/partials/DragAndDrop.vue";
    var script$g = {
      name: "DragAndDrop",
      render: script$h.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-dnd",
            container_sm: "vf-dnd-sm",
            container_md: "",
            container_lg: "vf-dnd-lg",
            container_inactive: "",
            container_active: "is-active",
            container_enabled: "",
            container_disabled: "is-disabled",
            icon: "vf-dnd-icon-upload",
            title: "vf-dnd-title",
            description: "vf-dnd-description",
            $container: (classes2, { dragging, disabled, Size }) => [
              classes2.container,
              classes2[`container_${Size}`],
              dragging ? classes2.container_active : classes2.container_inactive,
              disabled ? classes2.container_disabled : classes2.container_enabled
            ]
          }
        };
      }
    };
    var css_248z$8 = `.vf-dnd {
  background-color: #FFFFFF;
  transition: 0.3s;
  border-width: var(--vf-border-width-input-t) var(--vf-border-width-input-r) var(--vf-border-width-input-b) var(--vf-border-width-input-l);
  border-style: dashed;
  border-color: var(--vf-border-color-input);
  padding: 1.5rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-weight: inherit;
  line-height: inherit;
  color: inherit;
  font-size: inherit;
  box-sizing: border-box;
  cursor: pointer;
  text-align: center;
  position: relative;
  transition: 0.3s;
  background-color: var(--vf-bg-input);
  color: var(--vf-color-input);
  border-radius: var(--vf-radius-large);
  box-shadow: var(--vf-shadow-input);
  text-align: center;
}

.vf-dnd.vf-dnd-sm {
  border-radius: var(--vf-radius-large);
}

.vf-dnd.is-disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.vf-dnd.is-active {
  border-color: var(--vf-primary);
}

.vf-dnd-icon-upload {
  display: flex;
  width: 2.25rem;
  height: 2rem;
  align-items: center;
  justify-content: center;
  background: var(--vf-primary);
  mask-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='36px' height='32px' viewBox='0 0 36 32' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E%3Cpath d='M35.0499042,20.6125054 C35.656165,21.1750041 35.9999142,21.9687644 35.9999142,22.8000002 L35.9999142,28.9999976 C35.9999142,30.6562437 34.6561674,31.9999905 32.9999213,31.9999905 L2.99999285,31.9999905 C1.3437468,31.9999905 0,30.6562437 0,28.9999976 L0,22.8000002 C0,21.9687644 0.34374918,21.1750041 0.950009942,20.6125054 L6.86247143,15.0687564 C7.01249549,14.9313056 7.24998271,14.9375311 7.39372016,15.0875552 L8.24998033,16.0000286 C8.38749221,16.1500527 8.3812056,16.3875399 8.23124258,16.5312773 L4.52501363,20.0062446 L11.7374598,20.0062446 L13.737455,24.0062351 L22.2624591,24.0062351 L24.2624544,20.0062446 L31.4811871,20.0062446 L27.7749582,16.5312773 C27.6249341,16.3875399 27.612422,16.1500527 27.7561594,16.0000286 L28.606194,15.0875552 C28.7499315,14.9375311 28.9874187,14.925019 29.1374427,15.0687564 L35.0499042,20.6125054 Z M33.9999189,28.9999976 L33.9999189,23.0000119 C33.9999189,22.4500254 33.5499078,22.0000143 32.9999213,22.0000143 L25.4999392,22.0000143 L23.499944,26.0000048 L12.4999702,26.0000048 L10.499975,22.0000143 L2.99999285,22.0000143 C2.45000637,22.0000143 1.99999523,22.4500254 1.99999523,23.0000119 L1.99999523,28.9999976 C1.99999523,29.5499841 2.45000637,29.9999952 2.99999285,29.9999952 L32.9999213,29.9999952 C33.5499078,29.9999952 33.9999189,29.5499841 33.9999189,28.9999976 Z M25.999938,8.00004768 C27.7811838,8.00004768 28.6686939,10.1562925 27.4186968,11.4125151 L19.4187159,19.4124961 C18.6374678,20.1937442 17.368733,20.1937442 16.5874849,19.4124961 L8.58750394,11.4125151 C7.32499474,10.1562925 8.22495598,8.00004768 9.99997616,8.00004768 L13.9999666,8.00004768 L13.9999666,1.50006318 C13.9999666,0.675052941 14.6749528,6.67572021e-05 15.499963,6.67572021e-05 L20.4999511,6.67572021e-05 C21.3249614,6.67572021e-05 21.9999475,0.675052941 21.9999475,1.50006318 L21.9999475,8.00004768 L25.999938,8.00004768 Z M17.9999571,18.0000238 L25.999938,10.0000429 L19.9999523,10.0000429 L19.9999523,2.00006199 L15.9999619,2.00006199 L15.9999619,10.0000429 L9.99997616,10.0000429 L17.9999571,18.0000238 Z' id='inbox-in' fill='currentColor'%3E%3C/path%3E%3C/g%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='36px' height='32px' viewBox='0 0 36 32' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E%3Cpath d='M35.0499042,20.6125054 C35.656165,21.1750041 35.9999142,21.9687644 35.9999142,22.8000002 L35.9999142,28.9999976 C35.9999142,30.6562437 34.6561674,31.9999905 32.9999213,31.9999905 L2.99999285,31.9999905 C1.3437468,31.9999905 0,30.6562437 0,28.9999976 L0,22.8000002 C0,21.9687644 0.34374918,21.1750041 0.950009942,20.6125054 L6.86247143,15.0687564 C7.01249549,14.9313056 7.24998271,14.9375311 7.39372016,15.0875552 L8.24998033,16.0000286 C8.38749221,16.1500527 8.3812056,16.3875399 8.23124258,16.5312773 L4.52501363,20.0062446 L11.7374598,20.0062446 L13.737455,24.0062351 L22.2624591,24.0062351 L24.2624544,20.0062446 L31.4811871,20.0062446 L27.7749582,16.5312773 C27.6249341,16.3875399 27.612422,16.1500527 27.7561594,16.0000286 L28.606194,15.0875552 C28.7499315,14.9375311 28.9874187,14.925019 29.1374427,15.0687564 L35.0499042,20.6125054 Z M33.9999189,28.9999976 L33.9999189,23.0000119 C33.9999189,22.4500254 33.5499078,22.0000143 32.9999213,22.0000143 L25.4999392,22.0000143 L23.499944,26.0000048 L12.4999702,26.0000048 L10.499975,22.0000143 L2.99999285,22.0000143 C2.45000637,22.0000143 1.99999523,22.4500254 1.99999523,23.0000119 L1.99999523,28.9999976 C1.99999523,29.5499841 2.45000637,29.9999952 2.99999285,29.9999952 L32.9999213,29.9999952 C33.5499078,29.9999952 33.9999189,29.5499841 33.9999189,28.9999976 Z M25.999938,8.00004768 C27.7811838,8.00004768 28.6686939,10.1562925 27.4186968,11.4125151 L19.4187159,19.4124961 C18.6374678,20.1937442 17.368733,20.1937442 16.5874849,19.4124961 L8.58750394,11.4125151 C7.32499474,10.1562925 8.22495598,8.00004768 9.99997616,8.00004768 L13.9999666,8.00004768 L13.9999666,1.50006318 C13.9999666,0.675052941 14.6749528,6.67572021e-05 15.499963,6.67572021e-05 L20.4999511,6.67572021e-05 C21.3249614,6.67572021e-05 21.9999475,0.675052941 21.9999475,1.50006318 L21.9999475,8.00004768 L25.999938,8.00004768 Z M17.9999571,18.0000238 L25.999938,10.0000429 L19.9999523,10.0000429 L19.9999523,2.00006199 L15.9999619,2.00006199 L15.9999619,10.0000429 L9.99997616,10.0000429 L17.9999571,18.0000238 Z' id='inbox-in' fill='currentColor'%3E%3C/path%3E%3C/g%3E%3C/svg%3E");
  mask-size: cover;
  -webkit-mask-size: cover;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-position: center center;
  -webkit-mask-position: center center;
}

.vf-dnd-title {
  font-weight: 600;
  margin-top: 0.75rem;
}`;
    styleInject(css_248z$8);
    script$g.__file = "themes/vueform/templates/elements/partials/DragAndDrop.vue";
    var script$f = {
      name: "FilePreview",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            file: "",
            filenameLink: "",
            filenameStatic: "",
            actions: "",
            percent: "",
            upload: "",
            progressBar: "",
            progress: "",
            warning: "",
            warningIcon: "",
            uploaded: "",
            uploadedIcon: "",
            remove: "",
            removeIcon: "",
            assistiveText: ""
          }
        };
      }
    };
    const _hoisted_1$7 = ["aria-labelledby", "aria-placeholder", "aria-describedby"];
    const _hoisted_2$5 = ["id"];
    const _hoisted_3$4 = ["href"];
    function render$7(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("div", mergeProps({
        class: _ctx.classes.container
      }, _ctx.attrs, {
        tabindex: "0",
        role: "button",
        "aria-labelledby": _ctx.ariaLabelledby,
        "aria-placeholder": _ctx.ariaPlaceholder,
        "aria-describedby": `${_ctx.el$.fieldId}-file-description`,
        onKeyup: _cache[3] || (_cache[3] = (...args) => _ctx.handleKeyup && _ctx.handleKeyup(...args))
      }), [
        createBaseVNode("span", {
          id: `${_ctx.el$.fieldId}-file-description`,
          class: normalizeClass(_ctx.classes.assistiveText),
          "aria-hidden": ""
        }, toDisplayString(_ctx.form$.translations.vueform.a11y.file.description), 11, _hoisted_2$5),
        createBaseVNode(
          "div",
          {
            class: normalizeClass(_ctx.classes.wrapper)
          },
          [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.file)
              },
              [
                createCommentVNode(" Filename "),
                _ctx.hasLink && _ctx.clickable ? (openBlock(), createElementBlock("a", {
                  key: 0,
                  href: _ctx.link,
                  class: normalizeClass(_ctx.classes.filenameLink),
                  target: "_blank",
                  rel: "nofollow noopener"
                }, toDisplayString(_ctx.filename), 11, _hoisted_3$4)) : (openBlock(), createElementBlock(
                  "span",
                  {
                    key: 1,
                    class: normalizeClass(_ctx.classes.filenameStatic)
                  },
                  toDisplayString(_ctx.filename),
                  3
                  /* TEXT, CLASS */
                ))
              ],
              2
              /* CLASS */
            ),
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.actions)
              },
              [
                createCommentVNode(" Remove "),
                _ctx.canRemove ? (openBlock(), createElementBlock(
                  "div",
                  {
                    key: 0,
                    class: normalizeClass(_ctx.classes.remove),
                    onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.remove && _ctx.remove(...args), ["prevent"])),
                    onKeypress: _cache[1] || (_cache[1] = withKeys((...args) => _ctx.remove && _ctx.remove(...args), ["enter", "space"])),
                    "aria-roledescription": "❎",
                    role: "button",
                    tabindex: "0"
                  },
                  [
                    createBaseVNode(
                      "span",
                      {
                        class: normalizeClass(_ctx.classes.removeIcon)
                      },
                      null,
                      2
                      /* CLASS */
                    )
                  ],
                  34
                  /* CLASS, NEED_HYDRATION */
                )) : createCommentVNode("v-if", true),
                createCommentVNode(" Progress "),
                _ctx.uploading ? (openBlock(), createElementBlock(
                  "div",
                  {
                    key: 1,
                    class: normalizeClass(_ctx.classes.percent)
                  },
                  toDisplayString(_ctx.progress) + "%",
                  3
                  /* TEXT, CLASS */
                )) : createCommentVNode("v-if", true),
                createCommentVNode(" Error "),
                _ctx.hasError ? (openBlock(), createElementBlock(
                  "span",
                  {
                    key: 2,
                    class: normalizeClass(_ctx.classes.warning)
                  },
                  [
                    createBaseVNode(
                      "span",
                      {
                        class: normalizeClass(_ctx.classes.warningIcon)
                      },
                      null,
                      2
                      /* CLASS */
                    )
                  ],
                  2
                  /* CLASS */
                )) : createCommentVNode("v-if", true),
                createCommentVNode(" Upload button "),
                _ctx.canUploadTemp ? (openBlock(), createElementBlock(
                  "div",
                  {
                    key: 3,
                    class: normalizeClass(_ctx.classes.upload),
                    onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.upload && _ctx.upload(...args), ["prevent"])),
                    tabindex: "-1"
                  },
                  toDisplayString(_ctx.uploadText),
                  3
                  /* TEXT, CLASS */
                )) : _ctx.el$.stage > 1 ? (openBlock(), createElementBlock(
                  Fragment,
                  { key: 4 },
                  [
                    createCommentVNode(" Success "),
                    createBaseVNode(
                      "span",
                      {
                        class: normalizeClass(_ctx.classes.uploaded)
                      },
                      [
                        createBaseVNode(
                          "span",
                          {
                            class: normalizeClass(_ctx.classes.uploadedIcon)
                          },
                          null,
                          2
                          /* CLASS */
                        )
                      ],
                      2
                      /* CLASS */
                    )
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                )) : createCommentVNode("v-if", true)
              ],
              2
              /* CLASS */
            )
          ],
          2
          /* CLASS */
        ),
        _ctx.uploading ? (openBlock(), createElementBlock(
          "div",
          {
            key: 0,
            class: normalizeClass(_ctx.classes.progressBar)
          },
          [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.progress),
                style: normalizeStyle({ width: _ctx.progress + "%" })
              },
              null,
              6
              /* CLASS, STYLE */
            )
          ],
          2
          /* CLASS */
        )) : createCommentVNode("v-if", true)
      ], 16, _hoisted_1$7)), [
        [vShow, _ctx.visible]
      ]);
    }
    script$f.render = render$7;
    script$f.__file = "themes/blank/templates/elements/partials/FilePreview.vue";
    var script$e = {
      name: "FilePreview",
      render: script$f.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-file-preview",
            container_sm: "vf-file-preview-sm",
            container_md: "",
            container_lg: "vf-file-preview-lg",
            wrapper: "vf-file-preview-wrapper",
            file: "vf-file-preview-file",
            filenameLink: "vf-file-preview-filename-link",
            filenameStatic: "vf-file-preview-filename",
            actions: "vf-file-preview-actions",
            percent: "vf-file-preview-percent",
            upload: "vf-file-preview-upload",
            progressBar: "vf-file-preview-progress-bar",
            progress: "vf-file-preview-progress",
            warning: "vf-file-preview-warning",
            warningIcon: "vf-file-preview-warning-icon",
            uploaded: "vf-file-preview-uploaded",
            uploadedIcon: "vf-file-preview-uploaded-icon",
            remove: "vf-file-preview-remove",
            removeIcon: "vf-file-preview-remove-icon",
            assistiveText: "vf-assistive-text",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$7 = `.vf-file-preview {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  color: inherit;
  min-height: var(--vf-min-height-input);
  display: flex;
  justify-content: center;
  flex-direction: column;
  position: relative;
}

.vf-file-preview:hover .vf-file-preview-uploaded,
.vf-file-preview:hover .vf-file-preview-warning,
.vf-file-preview:hover .vf-file-preview-percent {
  display: none;
}

.vf-file-preview:hover .vf-file-preview-remove {
  display: inline-block;
}

.vf-file-preview.vf-file-preview-sm {
  padding-top: calc(var(--vf-py-input-sm) + var(--vf-border-width-input-t));
  min-height: var(--vf-min-height-input-sm);
}

.vf-file-preview.vf-file-preview-lg {
  padding-top: calc(var(--vf-py-input-lg) + var(--vf-border-width-input-t));
  min-height: var(--vf-min-height-input-lg);
}

.vf-file-preview-wrapper {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.vf-file-preview-file {
  display: flex;
  align-items: center;
}

.vf-file-preview-filename-link {
  text-decoration: none;
  color: inherit;
}

.vf-file-preview-filename-link:hover, .vf-file-preview-filename-link:focus, .vf-file-preview-filename-link:active {
  color: inherit;
}

.vf-file-preview-filename-link:hover {
  text-decoration: underline;
}

.vf-file-preview-actions {
  display: flex;
  align-items: center;
}

.vf-file-preview-upload {
  font-size: 0.75rem;
  margin-left: 0.5rem;
  white-space: nowrap;
  padding: 0.0625rem 0.4375rem;
  background: var(--vf-primary);
  color: var(--vf-color-on-primary);
  border-radius: var(--vf-radius-small);
  text-decoration: none;
  transition: 0.15s;
  outline: 0px solid var(--vf-ring-color);
  outline-offset: 0;
}

.vf-file-preview-upload:hover {
  transform: scale(1.05);
}

.vf-file-preview-upload:focus {
  outline: var(--vf-ring-width) solid var(--vf-ring-color);
}

.vf-file-preview-percent {
  font-size: 0.875rem;
  color: var(--vf-color-muted);
  margin-left: 0.375rem;
}

.vf-file-preview-progress-bar {
  margin-top: 0.625rem;
  border-radius: 0;
  height: 0.1875rem;
  background: var(--vf-bg-passive);
  position: absolute;
  bottom: 0;
  width: 100%;
}

.vf-file-preview-progress {
  border-radius: 0;
  height: 100%;
  background: var(--vf-primary);
  transition: 0.6s ease;
}

.vf-file-preview-warning,
.vf-file-preview-uploaded,
.vf-file-preview-remove {
  display: flex;
  width: 1rem;
  height: 1rem;
  align-items: center;
  justify-content: center;
  border-radius: 999px;
}

.vf-file-preview-warning-icon,
.vf-file-preview-uploaded-icon,
.vf-file-preview-remove-icon {
  width: 100%;
  height: 100%;
  display: block;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-position: center center;
  -webkit-mask-position: center center;
}

.vf-file-preview-remove {
  display: none;
  margin-left: 0.375rem;
  background-color: var(--vf-bg-passive);
  transition: 0.15s;
}

.vf-file-preview-remove:hover {
  filter: brightness(0.9);
}

.vf-file-preview-remove-icon {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  mask-size: 0.75rem 0.75rem;
  -webkit-mask-size: 0.75rem 0.75rem;
  background-color: var(--vf-color-passive);
}

.vf-file-preview-uploaded {
  background-color: var(--vf-bg-success);
}

.vf-file-preview-uploaded-icon {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z'%3E%3C/path%3E%3C/svg%3E");
  mask-size: 0.625rem 0.625rem;
  -webkit-mask-size: 0.625rem 0.625rem;
  background-color: var(--vf-color-success);
}

.vf-file-preview-warning {
  background-color: var(--vf-bg-danger);
}

.vf-file-preview-warning-icon {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 192 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 192 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z'%3E%3C/path%3E%3C/svg%3E");
  mask-size: 0.625rem 0.625rem;
  -webkit-mask-size: 0.625rem 0.625rem;
  background-color: var(--vf-color-danger);
}

.vf-file-removing .vf-file-preview {
  opacity: 0.6;
}`;
    styleInject(css_248z$7);
    script$e.__file = "themes/vueform/templates/elements/partials/FilePreview.vue";
    var script$d = {
      name: "FilePreview_image",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            image: "",
            img: "",
            file: "",
            filenameLink: "",
            filenameStatic: "",
            actions: "",
            percent: "",
            upload: "",
            progressBar: "",
            progress: "",
            warning: "",
            warningIcon: "",
            uploaded: "",
            uploadedIcon: "",
            remove: "",
            removeIcon: ""
          }
        };
      }
    };
    const _hoisted_1$6 = ["aria-labelledby", "aria-placeholder", "aria-describedby"];
    const _hoisted_2$4 = ["id"];
    const _hoisted_3$3 = ["href"];
    const _hoisted_4$2 = ["src", "alt", "title"];
    const _hoisted_5$1 = ["src", "alt", "title"];
    const _hoisted_6 = ["href"];
    function render$6(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("div", mergeProps({
        class: _ctx.classes.container,
        tabindex: "0",
        role: "button"
      }, _ctx.attrs, {
        "aria-labelledby": _ctx.ariaLabelledby,
        "aria-placeholder": _ctx.ariaPlaceholder,
        "aria-describedby": `${_ctx.el$.fieldId}-file-description`,
        onKeyup: _cache[4] || (_cache[4] = (...args) => _ctx.handleKeyup && _ctx.handleKeyup(...args))
      }), [
        createBaseVNode("span", {
          id: `${_ctx.el$.fieldId}-file-description`,
          class: normalizeClass(_ctx.classes.assistiveText),
          "aria-hidden": ""
        }, toDisplayString(_ctx.form$.translations.vueform.a11y.file.description), 11, _hoisted_2$4),
        createBaseVNode(
          "div",
          {
            class: normalizeClass(_ctx.classes.wrapper)
          },
          [
            createCommentVNode(" Image "),
            _ctx.uploaded && _ctx.hasLink && _ctx.clickable ? (openBlock(), createElementBlock("a", {
              key: 0,
              href: _ctx.link,
              class: normalizeClass(_ctx.classes.image),
              target: "_blank",
              rel: "nofollow noopener"
            }, [
              createBaseVNode("img", {
                class: normalizeClass(_ctx.classes.img),
                src: _ctx.preview,
                alt: _ctx.filename,
                title: _ctx.filename,
                "aria-hidden": "true"
              }, null, 10, _hoisted_4$2)
            ], 10, _hoisted_3$3)) : (openBlock(), createElementBlock(
              "span",
              {
                key: 1,
                class: normalizeClass(_ctx.classes.image)
              },
              [
                createBaseVNode("img", {
                  class: normalizeClass(_ctx.classes.img),
                  src: _ctx.preview,
                  alt: _ctx.filename,
                  title: _ctx.filename,
                  "aria-hidden": "true"
                }, null, 10, _hoisted_5$1)
              ],
              2
              /* CLASS */
            )),
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.file)
              },
              [
                createCommentVNode(" Filename "),
                _ctx.hasLink && _ctx.clickable ? (openBlock(), createElementBlock("a", {
                  key: 0,
                  href: _ctx.link,
                  class: normalizeClass(_ctx.classes.filenameLink),
                  target: "_blank",
                  rel: "nofollow noopener"
                }, toDisplayString(_ctx.filename), 11, _hoisted_6)) : (openBlock(), createElementBlock(
                  "span",
                  {
                    key: 1,
                    class: normalizeClass(_ctx.classes.filenameStatic)
                  },
                  toDisplayString(_ctx.filename),
                  3
                  /* TEXT, CLASS */
                ))
              ],
              2
              /* CLASS */
            ),
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.actions)
              },
              [
                createCommentVNode(" Remove "),
                _ctx.canRemove ? (openBlock(), createElementBlock(
                  "div",
                  {
                    key: 0,
                    class: normalizeClass(_ctx.classes.remove),
                    onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.remove && _ctx.remove(...args), ["prevent"])),
                    onKeypress: _cache[1] || (_cache[1] = withKeys((...args) => _ctx.remove && _ctx.remove(...args), ["enter", "space"])),
                    "aria-roledescription": "❎",
                    role: "button",
                    tabindex: "0"
                  },
                  [
                    createBaseVNode(
                      "span",
                      {
                        class: normalizeClass(_ctx.classes.removeIcon)
                      },
                      null,
                      2
                      /* CLASS */
                    )
                  ],
                  34
                  /* CLASS, NEED_HYDRATION */
                )) : createCommentVNode("v-if", true),
                createCommentVNode(" Progress "),
                _ctx.uploading ? (openBlock(), createElementBlock(
                  "div",
                  {
                    key: 1,
                    class: normalizeClass(_ctx.classes.percent)
                  },
                  toDisplayString(_ctx.progress) + "%",
                  3
                  /* TEXT, CLASS */
                )) : createCommentVNode("v-if", true),
                createCommentVNode(" Error "),
                _ctx.hasError ? (openBlock(), createElementBlock(
                  "span",
                  {
                    key: 2,
                    class: normalizeClass(_ctx.classes.warning)
                  },
                  [
                    createBaseVNode(
                      "span",
                      {
                        class: normalizeClass(_ctx.classes.warningIcon)
                      },
                      null,
                      2
                      /* CLASS */
                    )
                  ],
                  2
                  /* CLASS */
                )) : createCommentVNode("v-if", true),
                createCommentVNode(" Upload button "),
                _ctx.canUploadTemp ? (openBlock(), createElementBlock(
                  "div",
                  {
                    key: 3,
                    class: normalizeClass(_ctx.classes.upload),
                    onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.upload && _ctx.upload(...args), ["prevent"])),
                    onKeypress: _cache[3] || (_cache[3] = withKeys((...args) => _ctx.upload && _ctx.upload(...args), ["enter", "space"])),
                    tabindex: "-1",
                    role: "button"
                  },
                  toDisplayString(_ctx.uploadText),
                  35
                  /* TEXT, CLASS, NEED_HYDRATION */
                )) : _ctx.el$.stage > 1 ? (openBlock(), createElementBlock(
                  Fragment,
                  { key: 4 },
                  [
                    createCommentVNode(" Success "),
                    createBaseVNode(
                      "span",
                      {
                        class: normalizeClass(_ctx.classes.uploaded)
                      },
                      [
                        createBaseVNode(
                          "span",
                          {
                            class: normalizeClass(_ctx.classes.uploadedIcon)
                          },
                          null,
                          2
                          /* CLASS */
                        )
                      ],
                      2
                      /* CLASS */
                    )
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                )) : createCommentVNode("v-if", true)
              ],
              2
              /* CLASS */
            )
          ],
          2
          /* CLASS */
        ),
        _ctx.uploading ? (openBlock(), createElementBlock(
          "div",
          {
            key: 0,
            class: normalizeClass(_ctx.classes.progressBar)
          },
          [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.progress),
                style: normalizeStyle({ width: _ctx.progress + "%" })
              },
              null,
              6
              /* CLASS, STYLE */
            )
          ],
          2
          /* CLASS */
        )) : createCommentVNode("v-if", true)
      ], 16, _hoisted_1$6)), [
        [vShow, _ctx.visible]
      ]);
    }
    script$d.render = render$6;
    script$d.__file = "themes/blank/templates/elements/partials/FilePreview_image.vue";
    var script$c = {
      name: "ImagePreview",
      render: script$d.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-file-preview-image",
            wrapper: "vf-file-preview-image-wrapper",
            image: "vf-file-preview-image-image",
            image_link: "",
            image_static: "",
            image_sm: "vf-file-preview-image-image-sm",
            image_md: "",
            image_lg: "vf-file-preview-image-image-lg",
            img: "vf-file-preview-image-img",
            img_sm: "vf-file-preview-image-img-sm",
            img_md: "",
            img_lg: "vf-file-preview-image-img-lg",
            file: "vf-file-preview-image-file",
            filenameLink: "vf-file-preview-image-filename-link",
            filenameStatic: "vf-file-preview-image-filename",
            actions: "vf-file-preview-image-actions",
            percent: "vf-file-preview-image-percent",
            upload: "vf-file-preview-image-upload",
            progressBar: "vf-file-preview-image-progress-bar",
            progressBar_sm: "vf-file-preview-image-progress-bar-sm",
            progressBar_md: "",
            progressBar_lg: "vf-file-preview-image-progress-bar-lg",
            progress: "vf-file-preview-image-progress",
            warning: "vf-file-preview-image-warning",
            warningIcon: "vf-file-preview-image-warning-icon",
            uploaded: "vf-file-preview-image-uploaded",
            uploadedIcon: "vf-file-preview-image-uploaded-icon",
            remove: "vf-file-preview-image-remove",
            removeIcon: "vf-file-preview-image-remove-icon",
            assistiveText: "vf-assistive-text",
            $image: (classes2, { hasLink, Size }) => [
              classes2.image,
              classes2[`image_${Size}`],
              hasLink ? classes2.image_link : classes2.image_static
            ],
            $img: (classes2, { Size }) => [
              classes2.img,
              classes2[`img_${Size}`]
            ],
            $progressBar: (classes2, { Size }) => [
              classes2.progressBar,
              classes2[`progressBar_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$6 = `.vf-file-preview-image {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  color: inherit;
  display: flex;
  justify-content: flex-start;
  flex-direction: row;
  position: relative;
}

.vf-file-preview-image:hover .vf-file-preview-image-uploaded,
.vf-file-preview-image:hover .vf-file-preview-image-warning,
.vf-file-preview-image:hover .vf-file-preview-image-percent {
  display: none;
}

.vf-file-preview-image:hover .vf-file-preview-image-remove {
  display: inline-block;
}

.vf-file-preview-image-image {
  display: flex;
  align-items: center;
  flex: 0 0 auto;
  background: var(--vf-bg-passive);
  border-radius: var(--vf-radius-image);
  outline: 0px solid var(--vf-ring-color);
  outline-offset: 0;
  box-shadow: var(--vf-shadow-input);
}

.vf-file-preview-image-image:focus {
  outline: var(--vf-ring-width) solid var(--vf-ring-color);
}

.vf-file-preview-image-image.vf-file-preview-image-image-sm {
  border-radius: var(--vf-radius-image-sm);
}

.vf-file-preview-image-image.vf-file-preview-image-image-lg {
  border-radius: var(--vf-radius-image-lg);
}

.vf-file-preview-image-img {
  -o-object-fit: cover;
     object-fit: cover;
  width: var(--vf-min-height-input);
  height: var(--vf-min-height-input);
  border-radius: var(--vf-radius-image);
  border: 0;
}

.vf-file-preview-image-img[src=""], .vf-file-preview-image-img[src="data:"], .vf-file-preview-image-img:not([src]) {
  opacity: 0;
}

.vf-file-preview-image-img.vf-file-preview-image-img-sm {
  width: var(--vf-min-height-input-sm);
  height: var(--vf-min-height-input-sm);
  border-radius: var(--vf-radius-image-sm);
}

.vf-file-preview-image-img.vf-file-preview-image-img-lg {
  width: var(--vf-min-height-input-lg);
  height: var(--vf-min-height-input-lg);
  border-radius: var(--vf-radius-image-lg);
}

.vf-file-preview-image-wrapper {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
}

.vf-file-preview-image-file {
  display: flex;
  align-items: center;
  margin-left: 0.625rem;
  flex: 1 1 auto;
}

.vf-file-preview-image-filename-link {
  text-decoration: none;
  color: inherit;
}

.vf-file-preview-image-filename-link:hover, .vf-file-preview-image-filename-link:focus, .vf-file-preview-image-filename-link:active {
  color: inherit;
}

.vf-file-preview-image-filename-link:hover {
  text-decoration: underline;
}

.vf-file-preview-image-actions {
  display: flex;
  align-items: center;
}

.vf-file-preview-image-upload {
  font-size: 0.75rem;
  margin-left: 0.5rem;
  white-space: nowrap;
  padding: 0.0625rem 0.4375rem;
  background: var(--vf-primary);
  color: var(--vf-color-on-primary);
  border-radius: var(--vf-radius-small);
  text-decoration: none;
  transition: 0.15s;
  outline: 0px solid var(--vf-ring-color);
  outline-offset: 0;
}

.vf-file-preview-image-upload:hover {
  transform: scale(1.05);
}

.vf-file-preview-image-upload:focus {
  outline: var(--vf-ring-width) solid var(--vf-ring-color);
}

.vf-file-preview-image-percent {
  font-size: 0.875rem;
  color: var(--vf-color-muted);
  margin-left: 0.375rem;
}

.vf-file-preview-image-progress-bar {
  margin-top: 0.625rem;
  border-radius: 0;
  height: 0.1875rem;
  background: var(--vf-bg-passive);
  position: absolute;
  bottom: 0;
  left: calc(var(--vf-min-height-input) + 0.625rem);
  right: 0;
}

.vf-file-preview-image-progress-bar.vf-file-preview-image-progress-bar-sm {
  left: calc(var(--vf-min-height-input-sm) + 0.625rem);
}

.vf-file-preview-image-progress-bar.vf-file-preview-image-progress-bar-lg {
  left: calc(var(--vf-min-height-input-lg) + 0.625rem);
}

.vf-file-preview-image-progress {
  border-radius: 0;
  display: block;
  height: 100%;
  background: var(--vf-primary);
  transition: 0.6s ease;
}

.vf-file-preview-image-warning,
.vf-file-preview-image-uploaded,
.vf-file-preview-image-remove {
  display: flex;
  width: 1rem;
  height: 1rem;
  align-items: center;
  justify-content: center;
  border-radius: 999px;
}

.vf-file-preview-image-warning-icon,
.vf-file-preview-image-uploaded-icon,
.vf-file-preview-image-remove-icon {
  width: 100%;
  height: 100%;
  display: block;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-position: center center;
  -webkit-mask-position: center center;
}

.vf-file-preview-image-remove {
  display: none;
  margin-left: 0.375rem;
  background-color: var(--vf-bg-passive);
  transition: 0.15s;
}

.vf-file-preview-image-remove:hover {
  filter: brightness(0.9);
}

.vf-file-preview-image-remove-icon {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  mask-size: 0.75rem 0.75rem;
  -webkit-mask-size: 0.75rem 0.75rem;
  background-color: var(--vf-color-passive);
}

.vf-file-preview-image-uploaded {
  background-color: var(--vf-bg-success);
}

.vf-file-preview-image-uploaded-icon {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z'%3E%3C/path%3E%3C/svg%3E");
  mask-size: 0.625rem 0.625rem;
  -webkit-mask-size: 0.625rem 0.625rem;
  background-color: var(--vf-color-success);
}

.vf-file-preview-image-warning {
  background-color: var(--vf-bg-danger);
}

.vf-file-preview-image-warning-icon {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 192 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 192 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z'%3E%3C/path%3E%3C/svg%3E");
  mask-size: 0.625rem 0.625rem;
  -webkit-mask-size: 0.625rem 0.625rem;
  background-color: var(--vf-color-danger);
}

.vf-file-removing .vf-file-preview-image {
  opacity: 0.6;
}`;
    styleInject(css_248z$6);
    script$c.__file = "themes/vueform/templates/elements/partials/FilePreview_image.vue";
    var script$b = {
      name: "FilePreview_gallery",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            image: "",
            img: "",
            overlay: "",
            upload: "",
            progressBar: "",
            progress: "",
            warning: "",
            warningIcon: "",
            uploaded: "",
            uploadedIcon: "",
            remove: "",
            removeIcon: ""
          }
        };
      }
    };
    const _hoisted_1$5 = ["aria-labelledby", "aria-placeholder", "aria-role", "aria-describedby"];
    const _hoisted_2$3 = ["id"];
    const _hoisted_3$2 = ["href"];
    const _hoisted_4$1 = ["src", "alt", "title"];
    const _hoisted_5 = ["src", "alt", "title"];
    function render$5(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("div", mergeProps({
        class: _ctx.classes.container,
        tabindex: "0",
        role: "button"
      }, _ctx.attrs, {
        "aria-labelledby": _ctx.ariaLabelledby,
        "aria-placeholder": _ctx.ariaPlaceholder,
        "aria-role": _ctx.ariaRoledescription,
        "aria-describedby": `${_ctx.el$.fieldId}-file-description`,
        onKeyup: _cache[4] || (_cache[4] = (...args) => _ctx.handleKeyup && _ctx.handleKeyup(...args))
      }), [
        createBaseVNode("span", {
          id: `${_ctx.el$.fieldId}-file-description`,
          class: normalizeClass(_ctx.classes.assistiveText),
          "aria-hidden": ""
        }, toDisplayString(_ctx.form$.translations.vueform.a11y.file.description), 11, _hoisted_2$3),
        createCommentVNode(" Image  "),
        _ctx.uploaded && _ctx.hasLink && _ctx.clickable ? (openBlock(), createElementBlock("a", {
          key: 0,
          class: normalizeClass(_ctx.classes.image),
          href: _ctx.link,
          target: "_blank",
          rel: "nofollow noopener"
        }, [
          createBaseVNode("img", {
            src: _ctx.preview,
            class: normalizeClass(_ctx.classes.img),
            alt: _ctx.filename,
            title: _ctx.filename,
            "aria-hidden": "true"
          }, null, 10, _hoisted_4$1)
        ], 10, _hoisted_3$2)) : (openBlock(), createElementBlock(
          "div",
          {
            key: 1,
            class: normalizeClass(_ctx.classes.image)
          },
          [
            createBaseVNode("img", {
              class: normalizeClass(_ctx.classes.img),
              src: _ctx.preview,
              alt: _ctx.filename,
              title: _ctx.filename,
              "aria-hidden": "true"
            }, null, 10, _hoisted_5)
          ],
          2
          /* CLASS */
        )),
        createCommentVNode(" Overlay "),
        !_ctx.uploaded && !_ctx.uploading ? (openBlock(), createElementBlock(
          "div",
          {
            key: 2,
            class: normalizeClass(_ctx.classes.overlay)
          },
          [
            _ctx.canUploadTemp ? (openBlock(), createElementBlock(
              "div",
              {
                key: 0,
                class: normalizeClass(_ctx.classes.upload),
                onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.upload && _ctx.upload(...args), ["prevent"])),
                onKeypress: _cache[1] || (_cache[1] = withKeys((...args) => _ctx.upload && _ctx.upload(...args), ["enter", "space"])),
                tabindex: "-1",
                role: "button"
              },
              toDisplayString(_ctx.uploadText),
              35
              /* TEXT, CLASS, NEED_HYDRATION */
            )) : createCommentVNode("v-if", true)
          ],
          2
          /* CLASS */
        )) : createCommentVNode("v-if", true),
        createCommentVNode(" Error "),
        _ctx.hasError ? (openBlock(), createElementBlock(
          "span",
          {
            key: 3,
            class: normalizeClass(_ctx.classes.warning)
          },
          [
            createBaseVNode(
              "span",
              {
                class: normalizeClass(_ctx.classes.warningIcon)
              },
              null,
              2
              /* CLASS */
            )
          ],
          2
          /* CLASS */
        )) : _ctx.el$.stage > 1 ? (openBlock(), createElementBlock(
          Fragment,
          { key: 4 },
          [
            createCommentVNode(" Success "),
            createBaseVNode(
              "span",
              {
                class: normalizeClass(_ctx.classes.uploaded)
              },
              [
                createBaseVNode(
                  "span",
                  {
                    class: normalizeClass(_ctx.classes.uploadedIcon)
                  },
                  null,
                  2
                  /* CLASS */
                )
              ],
              2
              /* CLASS */
            )
          ],
          2112
          /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
        )) : createCommentVNode("v-if", true),
        createCommentVNode(" Remove "),
        _ctx.canRemove ? (openBlock(), createElementBlock(
          "div",
          {
            key: 5,
            class: normalizeClass(_ctx.classes.remove),
            onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.remove && _ctx.remove(...args), ["prevent"])),
            onKeypress: _cache[3] || (_cache[3] = withKeys((...args) => _ctx.remove && _ctx.remove(...args), ["enter", "space"])),
            "aria-roledescription": "❎",
            role: "button",
            tabindex: "0"
          },
          [
            createBaseVNode(
              "span",
              {
                class: normalizeClass(_ctx.classes.removeIcon)
              },
              null,
              2
              /* CLASS */
            )
          ],
          34
          /* CLASS, NEED_HYDRATION */
        )) : createCommentVNode("v-if", true),
        createCommentVNode(" Progress "),
        _ctx.uploading ? (openBlock(), createElementBlock(
          "div",
          {
            key: 6,
            class: normalizeClass(_ctx.classes.progressBar)
          },
          [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.progress),
                style: normalizeStyle({ width: _ctx.progress + "%" })
              },
              null,
              6
              /* CLASS, STYLE */
            )
          ],
          2
          /* CLASS */
        )) : createCommentVNode("v-if", true)
      ], 16, _hoisted_1$5)), [
        [vShow, _ctx.visible]
      ]);
    }
    script$b.render = render$5;
    script$b.__file = "themes/blank/templates/elements/partials/FilePreview_gallery.vue";
    var script$a = {
      name: "GalleryPreview",
      render: script$b.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-file-preview-gallery",
            container_sm: "vf-file-preview-gallery-sm",
            container_md: "",
            container_lg: "vf-file-preview-gallery-lg",
            image: "vf-file-preview-gallery-image",
            image_sm: "vf-file-preview-gallery-image-sm",
            image_md: "",
            image_lg: "vf-file-preview-gallery-image-lg",
            image_link: "",
            image_static: "",
            img: "vf-file-preview-gallery-img",
            img_sm: "vf-file-preview-gallery-img-sm",
            img_md: "",
            img_lg: "vf-file-preview-gallery-img-lg",
            overlay: "vf-file-preview-gallery-overlay",
            overlay_sm: "vf-file-preview-gallery-overlay-sm",
            overlay_md: "",
            overlay_lg: "vf-file-preview-gallery-overlay-lg",
            upload: "vf-file-preview-gallery-upload",
            progressBar: "vf-file-preview-gallery-progress-bar",
            progress: "vf-file-preview-gallery-progress",
            warning: "vf-file-preview-gallery-warning",
            warningIcon: "vf-file-preview-gallery-warning-icon",
            uploaded: "vf-file-preview-gallery-uploaded",
            uploadedIcon: "vf-file-preview-gallery-uploaded-icon",
            remove: "vf-file-preview-gallery-remove",
            removeIcon: "vf-file-preview-gallery-remove-icon",
            assistiveText: "vf-assistive-text",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ],
            $image: (classes2, { Size }) => [
              classes2.image,
              classes2[`image_${Size}`]
            ],
            $img: (classes2, { Size }) => [
              classes2.img,
              classes2[`img_${Size}`]
            ],
            $overlay: (classes2, { Size }) => [
              classes2.overlay,
              classes2[`overlay_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$5 = `.vf-file-preview-gallery {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  color: inherit;
  display: flex;
  justify-content: flex-start;
  flex-direction: column;
  transition: 0.2s background;
  width: var(--vf-gallery-size);
  height: var(--vf-gallery-size);
  position: relative;
}

.vf-file-preview-gallery:hover .vf-file-preview-gallery-overlay {
  opacity: 1;
  visibility: visible;
}

.vf-file-preview-gallery:hover .vf-file-preview-gallery-remove {
  opacity: 1;
  visibility: visible;
}

.vf-file-preview-gallery.vf-file-preview-gallery-sm {
  width: var(--vf-gallery-size-sm);
  height: var(--vf-gallery-size-sm);
}

.vf-file-preview-gallery.vf-file-preview-gallery-lg {
  width: var(--vf-gallery-size-lg);
  height: var(--vf-gallery-size-lg);
}

.vf-file-preview-gallery-overlay {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.5);
  transition: 0.3s;
  opacity: 0;
  visibility: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: row;
  padding: 0.75rem;
  border-radius: var(--vf-radius-gallery);
}

.vf-file-preview-gallery-overlay.vf-file-preview-gallery-overlay-sm {
  border-radius: var(--vf-radius-gallery-sm);
}

.vf-file-preview-gallery-overlay.vf-file-preview-gallery-overlay-lg {
  border-radius: var(--vf-radius-gallery-lg);
}

.vf-file-preview-gallery-upload {
  font-size: 0.75rem;
  white-space: nowrap;
  background: #FFFFFF;
  padding: 0.0625rem 0.4375rem;
  background: var(--vf-primary);
  color: var(--vf-color-on-primary);
  border-radius: var(--vf-radius-small);
  text-decoration: none;
  transition: 0.15s;
  outline: 0px solid var(--vf-ring-color);
  outline-offset: 0;
}

.vf-file-preview-gallery-upload:hover {
  transform: scale(1.05);
}

.vf-file-preview-gallery-upload:focus {
  outline: var(--vf-ring-width) solid var(--vf-ring-color);
}

.vf-file-preview-gallery-image {
  width: 100%;
  height: 100%;
  font-size: 0;
  background: var(--vf-bg-passive);
  border-radius: var(--vf-radius-gallery);
  outline: none;
}

.vf-file-preview-gallery-image.vf-file-preview-gallery-image-sm {
  border-radius: var(--vf-radius-gallery-sm);
}

.vf-file-preview-gallery-image.vf-file-preview-gallery-image-lg {
  border-radius: var(--vf-radius-gallery-lg);
}

.vf-file-preview-gallery-img {
  width: 100%;
  height: 100%;
  -o-object-fit: cover;
     object-fit: cover;
  border-radius: var(--vf-radius-gallery);
}

.vf-file-preview-gallery-img[src=""], .vf-file-preview-gallery-img[src="data:"], .vf-file-preview-gallery-img:not([src]) {
  opacity: 0;
}

.vf-file-preview-gallery-img.vf-file-preview-gallery-img-sm {
  border-radius: var(--vf-radius-gallery-sm);
}

.vf-file-preview-gallery-img.vf-file-preview-gallery-img-lg {
  border-radius: var(--vf-radius-gallery-lg);
}

.vf-file-preview-gallery-progress-bar {
  border-radius: 0;
  height: 0.1875rem;
  position: absolute;
  left: 0.1875rem;
  bottom: 0.1875rem;
  z-index: 1;
  background: #FFFFFF;
  right: 0.1875rem;
}

.vf-file-preview-gallery-progress {
  border-radius: 0;
  height: 100%;
  background: var(--vf-primary);
  transition: 0.6s ease;
}

.vf-file-preview-gallery-remove,
.vf-file-preview-gallery-uploaded,
.vf-file-preview-gallery-warning {
  display: flex;
  width: 1rem;
  height: 1rem;
  align-items: center;
  justify-content: center;
}

.vf-file-preview-gallery-remove-icon,
.vf-file-preview-gallery-uploaded-icon,
.vf-file-preview-gallery-warning-icon {
  width: 100%;
  height: 100%;
  display: block;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-position: center center;
  -webkit-mask-position: center center;
}

.vf-file-preview-gallery-remove {
  position: absolute;
  right: 0.1875rem;
  top: 0.1875rem;
  opacity: 0;
  visibility: hidden;
  background-color: var(--vf-bg-passive);
  border-radius: 999px;
  transition: 0.15s;
}

.vf-file-preview-gallery-remove:hover {
  filter: brightness(0.9);
}

.vf-file-preview-gallery-remove-icon {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  mask-size: 0.75rem 0.75rem;
  -webkit-mask-size: 0.75rem 0.75rem;
  background-color: var(--vf-color-passive);
}

.vf-file-preview-gallery-uploaded {
  position: absolute;
  right: 0.1875rem;
  bottom: 0.1875rem;
  border-radius: 999px;
  background-color: var(--vf-bg-success);
}

.vf-file-preview-gallery-uploaded-icon {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z'%3E%3C/path%3E%3C/svg%3E");
  mask-size: 0.625rem 0.625rem;
  -webkit-mask-size: 0.625rem 0.625rem;
  background-color: var(--vf-color-success);
}

.vf-file-preview-gallery-warning {
  position: absolute;
  right: 0.1875rem;
  bottom: 0.1875rem;
  border-radius: 999px;
  background-color: var(--vf-bg-danger);
}

.vf-file-preview-gallery-warning-icon {
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 192 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z'%3E%3C/path%3E%3C/svg%3E");
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 192 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z'%3E%3C/path%3E%3C/svg%3E");
  mask-size: 0.625rem 0.625rem;
  -webkit-mask-size: 0.625rem 0.625rem;
  background-color: var(--vf-color-danger);
}

.vf-file-removing .vf-file-preview-gallery {
  opacity: 0.6;
}

.is-sorting .vf-file-preview-gallery:hover .vf-file-preview-gallery-overlay, .vf-gallery.is-disabled .vf-file-preview-gallery:hover .vf-file-preview-gallery-overlay {
  opacity: 0;
  visibility: hidden;
}

.is-sorting .vf-file-preview-gallery:hover .vf-file-preview-gallery-remove, .vf-gallery.is-disabled .vf-file-preview-gallery:hover .vf-file-preview-gallery-remove {
  opacity: 0;
  visibility: hidden;
}`;
    styleInject(css_248z$5);
    script$a.__file = "themes/vueform/templates/elements/partials/FilePreview_gallery.vue";
    var script$9 = {
      name: "RadiogroupRadio",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            input: "",
            text: ""
          }
        };
      }
    };
    const _hoisted_1$4 = ["value", "name", "id", "disabled", "aria-label"];
    const _hoisted_2$2 = ["innerHTML"];
    function render$4(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "label",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          renderSlot(_ctx.$slots, "default", mergeProps({ name: _ctx.name }, {
            classes: _ctx.classes,
            isDisabled: _ctx.isDisabled,
            id: _ctx.id,
            item: _ctx.item,
            value: _ctx.value,
            items: _ctx.items,
            index: _ctx.index
          }), () => [
            withDirectives(createBaseVNode("input", mergeProps({
              type: "radio",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.el$.value = $event)
            }, _ctx.attrs, {
              value: _ctx.value,
              class: _ctx.classes.input,
              name: _ctx.name,
              id: _ctx.id,
              disabled: _ctx.isDisabled,
              "aria-label": _ctx.item.label
            }), null, 16, _hoisted_1$4), [
              [vModelRadio, _ctx.el$.value]
            ]),
            createBaseVNode("span", {
              class: normalizeClass(_ctx.classes.text),
              innerHTML: _ctx.item.label
            }, null, 10, _hoisted_2$2)
          ])
        ],
        2
        /* CLASS */
      );
    }
    script$9.render = render$4;
    script$9.__file = "themes/blank/templates/elements/partials/RadiogroupRadio.vue";
    var script$8 = {
      name: "RadiogroupRadio",
      render: script$9.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-radio-container",
            input: "vf-radio",
            input_enabled: "",
            input_disabled: "",
            input_sm: "vf-radio-sm",
            input_md: "",
            input_lg: "vf-radio-lg",
            text: "vf-radio-text",
            $input: (classes2, { isDisabled, Size }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : classes2.input_enabled
            ]
          }
        };
      }
    };
    var css_248z$4 = "/* Some styles are contained in Vueform.vue & RadiogroupElement.vue */";
    styleInject(css_248z$4);
    script$8.__file = "themes/vueform/templates/elements/partials/RadiogroupRadio.vue";
    var script$7 = {
      name: "RadiogroupRadio_tabs",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            input: "",
            text: ""
          }
        };
      }
    };
    const _hoisted_1$3 = ["aria-checked"];
    const _hoisted_2$1 = ["title"];
    const _hoisted_3$1 = ["value", "name", "id", "disabled"];
    const _hoisted_4 = ["innerHTML"];
    function render$3(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("label", mergeProps(_ctx.attrs, {
        class: _ctx.classes.container,
        tabindex: "0",
        role: "radio",
        "aria-checked": _ctx.checked,
        onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.el$.update(_ctx.value), ["prevent"]), ["space"])),
        onKeydown: _cache[2] || (_cache[2] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
      }), [
        renderSlot(_ctx.$slots, "default", mergeProps({ name: _ctx.name }, {
          classes: _ctx.classes,
          isDisabled: _ctx.isDisabled,
          id: _ctx.id,
          item: _ctx.item,
          value: _ctx.value,
          items: _ctx.items,
          index: _ctx.index
        }), () => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.classes.wrapper),
            title: _ctx.item.label
          }, [
            withDirectives(createBaseVNode("input", {
              type: "radio",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.el$.model = $event),
              value: _ctx.value,
              class: normalizeClass(_ctx.classes.input),
              name: _ctx.name,
              id: _ctx.id,
              disabled: _ctx.isDisabled
            }, null, 10, _hoisted_3$1), [
              [vModelRadio, _ctx.el$.model]
            ]),
            createBaseVNode("span", {
              class: normalizeClass(_ctx.classes.text),
              innerHTML: `${_ctx.item.label}`
            }, null, 10, _hoisted_4)
          ], 10, _hoisted_2$1)
        ])
      ], 16, _hoisted_1$3);
    }
    script$7.render = render$3;
    script$7.__file = "themes/blank/templates/elements/partials/RadiogroupRadio_tabs.vue";
    var script$6 = {
      name: "RadiogroupRadio_tabs",
      render: script$7.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-radio-tabs-container",
            wrapper: "vf-radio-tabs",
            wrapper_not_last: "vf-radio-tabs-not-last",
            wrapper_first: "vf-radio-tabs-first",
            wrapper_first_sm: "vf-radio-tabs-first-sm",
            wrapper_first_md: "",
            wrapper_first_lg: "vf-radio-tabs-first-lg",
            wrapper_last: "vf-radio-tabs-last",
            wrapper_last_sm: "vf-radio-tabs-last-sm",
            wrapper_last_md: "",
            wrapper_last_lg: "vf-radio-tabs-last-lg",
            wrapper_selected: "vf-radio-tabs-selected",
            wrapper_unselected: "vf-radio-tabs-unselected",
            wrapper_disabled: "vf-radio-tabs-disabled",
            wrapper_sm: "vf-radio-tabs-sm",
            wrapper_md: "",
            wrapper_lg: "vf-radio-tabs-lg",
            input: "vf-radio-tabs-input",
            text: "",
            $wrapper: (classes2, { index: index2, items, el$, value, isDisabled, Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`],
              index2 < Object.keys(items).length - 1 ? classes2.wrapper_not_last : null,
              index2 === 0 ? classes2.wrapper_first : null,
              index2 === Object.keys(items).length - 1 ? classes2.wrapper_last : null,
              el$.value == value ? classes2.wrapper_selected : classes2.wrapper_unselected,
              isDisabled ? classes2.wrapper_disabled : null
            ]
          }
        };
      }
    };
    var css_248z$3 = "/* Some styles are contained in Vueform.vue & RadiogroupElement.vue */\n\n.vf-radio-tabs-container {\n  display: flex;\n  align-items: flex-start;\n  cursor: pointer;\n}\n\n.vf-radio-tabs {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-style: solid;\n  border-width: var(--vf-border-width-input-t) var(--vf-border-width-input-r) var(--vf-border-width-input-b) var(--vf-border-width-input-l);\n  border-color: var(--vf-border-color-input);\n  padding: var(--vf-py-group-tabs) var(--vf-px-group-tabs);\n  width: 100%;\n  background: var(--vf-bg-input);\n  color: var(--vf-color-input);\n  font-size: var(--vf-font-size);\n  line-height: var(--vf-line-height);\n  letter-spacing: var(--vf-letter-spacing);\n}\n\n.vf-radio-tabs.vf-radio-tabs-not-last {\n  border-right: 0;\n}\n\n.vf-radio-tabs.vf-radio-tabs-first {\n  border-radius: var(--vf-radius-input);\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.vf-radio-tabs.vf-radio-tabs-first.vf-radio-tabs-first-sm {\n  border-radius: var(--vf-radius-input-sm);\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.vf-radio-tabs.vf-radio-tabs-first.vf-radio-tabs-first-lg {\n  border-radius: var(--vf-radius-input-lg);\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.vf-radio-tabs.vf-radio-tabs-last {\n  border-radius: var(--vf-radius-input-lg);\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.vf-radio-tabs.vf-radio-tabs-last.vf-radio-tabs-last-sm {\n  border-radius: var(--vf-radius-input-sm);\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.vf-radio-tabs.vf-radio-tabs-last.vf-radio-tabs-last-lg {\n  border-radius: var(--vf-radius-input-lg);\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.vf-radio-tabs.vf-radio-tabs-selected {\n  background-color: var(--vf-primary);\n  border-color: rgba(0, 0, 0, 0.15);\n  color: var(--vf-color-on-primary);\n}\n\n.vf-radio-tabs.vf-radio-tabs-unselected {\n  border-color: var(--vf-border-color-input);\n}\n\n.vf-radio-tabs.vf-radio-tabs-unselected:hover:not(.vf-radio-tabs-disabled) {\n  background-color: var(--vf-bg-input-hover);\n  color: var(--vf-color-input-hover);\n}\n\n.vf-radio-tabs.vf-radio-tabs-disabled {\n  opacity: 0.5;\n}\n\n.vf-radio-tabs.vf-radio-tabs-sm {\n  padding: var(--vf-py-group-tabs-sm) var(--vf-px-group-tabs-sm);\n  font-size: var(--vf-font-size-sm);\n  line-height: var(--vf-line-height-sm);\n  letter-spacing: var(--vf-letter-spacing-sm);\n}\n\n.vf-radio-tabs.vf-radio-tabs-lg {\n  padding: var(--vf-py-group-tabs-lg) var(--vf-px-group-tabs-lg);\n  font-size: var(--vf-font-size-lg);\n  line-height: var(--vf-line-height-lg);\n  letter-spacing: var(--vf-letter-spacing-lg);\n}\n\n.vf-radio-tabs-input {\n  display: none;\n}";
    styleInject(css_248z$3);
    script$6.__file = "themes/vueform/templates/elements/partials/RadiogroupRadio_tabs.vue";
    var script$5 = {
      name: "RadiogroupRadio_tabs",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            wrapper: "",
            input: "",
            text_wrapper: "",
            text: "",
            description: ""
          }
        };
      }
    };
    const _hoisted_1$2 = ["value", "name", "id", "disabled"];
    const _hoisted_2 = ["innerHTML"];
    const _hoisted_3 = ["innerHTML"];
    function render$2(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "label",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          renderSlot(_ctx.$slots, "default", mergeProps({ name: _ctx.name }, {
            classes: _ctx.classes,
            isDisabled: _ctx.isDisabled,
            id: _ctx.id,
            item: _ctx.item,
            value: _ctx.value,
            items: _ctx.items,
            index: _ctx.index
          }), () => [
            createBaseVNode(
              "div",
              {
                class: normalizeClass(_ctx.classes.wrapper)
              },
              [
                withDirectives(createBaseVNode("input", mergeProps({
                  type: "radio",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.el$.model = $event)
                }, _ctx.attrs, {
                  value: _ctx.value,
                  class: _ctx.classes.input,
                  name: _ctx.name,
                  id: _ctx.id,
                  disabled: _ctx.isDisabled
                }), null, 16, _hoisted_1$2), [
                  [vModelRadio, _ctx.el$.model]
                ]),
                createBaseVNode(
                  "div",
                  {
                    class: normalizeClass(_ctx.classes.text_wrapper)
                  },
                  [
                    createBaseVNode("div", {
                      class: normalizeClass(_ctx.classes.text),
                      innerHTML: _ctx.item.label
                    }, null, 10, _hoisted_2),
                    createBaseVNode("div", {
                      class: normalizeClass(_ctx.classes.description),
                      innerHTML: _ctx.item.description
                    }, null, 10, _hoisted_3)
                  ],
                  2
                  /* CLASS */
                )
              ],
              2
              /* CLASS */
            )
          ])
        ],
        2
        /* CLASS */
      );
    }
    script$5.render = render$2;
    script$5.__file = "themes/blank/templates/elements/partials/RadiogroupRadio_blocks.vue";
    var script$4 = {
      name: "RadiogroupRadio_blocks",
      render: script$5.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "vf-radio-blocks-container",
            container_sm: "vf-radio-blocks-container-sm",
            container_md: "",
            container_lg: "vf-radio-blocks-container-lg",
            wrapper: "vf-radio-blocks",
            wrapper_not_last: "vf-radio-blocks-not-last",
            wrapper_first: "vf-radio-blocks-first",
            wrapper_first_sm: "vf-radio-blocks-first-sm",
            wrapper_first_md: "",
            wrapper_first_lg: "vf-radio-blocks-first-lg",
            wrapper_last: "vf-radio-blocks-last",
            wrapper_last_sm: "vf-radio-blocks-last-sm",
            wrapper_last_md: "",
            wrapper_last_lg: "vf-radio-blocks-last-lg",
            wrapper_selected: "vf-radio-blocks-selected",
            wrapper_unselected: "vf-radio-blocks-unselected",
            wrapper_disabled: "vf-radio-blocks-disabled",
            wrapper_sm: "vf-radio-blocks-sm",
            wrapper_md: "",
            wrapper_lg: "vf-radio-blocks-lg",
            input: "vf-radio",
            input_enabled: "",
            input_disabled: "",
            input_sm: "vf-radio-sm",
            input_md: "",
            input_lg: "vf-radio-lg",
            text_wrapper: "vf-radio-blocks-text-wrapper",
            text: "vf-radio-blocks-text",
            description: "vf-radio-blocks-description",
            description_sm: "vf-radio-blocks-description-sm",
            description_md: "",
            description_lg: "vf-radio-blocks-description-lg",
            $container: (classes2, { Size }) => [
              classes2.container,
              classes2[`container_${Size}`]
            ],
            $wrapper: (classes2, { index: index2, items, el$, value, isDisabled, Size }) => [
              classes2.wrapper,
              classes2[`wrapper_${Size}`],
              index2 < Object.keys(items).length - 1 ? classes2.wrapper_not_last : null,
              index2 === 0 ? classes2.wrapper_first : null,
              index2 === 0 ? classes2[`wrapper_first_${Size}`] : null,
              index2 === Object.keys(items).length - 1 ? classes2.wrapper_last : null,
              index2 === Object.keys(items).length - 1 ? classes2[`wrapper_last_${Size}`] : null,
              el$.value == value ? classes2.wrapper_selected : classes2.wrapper_unselected,
              isDisabled ? classes2.wrapper_disabled : null
            ],
            $input: (classes2, { isDisabled, Size }) => [
              classes2.input,
              classes2[`input_${Size}`],
              isDisabled ? classes2.input_disabled : classes2.input_enabled
            ],
            $description: (classes2, { Size }) => [
              classes2.description,
              classes2[`description_${Size}`]
            ]
          }
        };
      }
    };
    var css_248z$2 = "/* Some styles are contained in Vueform.vue & RadiogroupElement.vue */\n\n.vf-radio-blocks-container {\n  display: flex;\n  align-items: flex-start;\n  cursor: pointer;\n  background: var(--vf-bg-input);\n  border-radius: var(--vf-radius-large);\n}\n\n.vf-radio-blocks-container .vf-radio {\n  margin-top: 0;\n}\n\n.vf-radio-blocks-container.vf-radio-blocks-container-sm {\n  border-radius: var(--vf-radius-large-sm);\n}\n\n.vf-radio-blocks-container.vf-radio-blocks-container-lg {\n  border-radius: var(--vf-radius-large-lg);\n}\n\n.vf-radio-blocks {\n  display: flex;\n  align-items: center;\n  border-style: solid;\n  border-width: var(--vf-border-width-input-t) var(--vf-border-width-input-r) var(--vf-border-width-input-b) var(--vf-border-width-input-l);\n  border-color: var(--vf-border-color-input);\n  width: 100%;\n  padding: var(--vf-py-group-blocks) var(--vf-px-group-blocks);\n  background: var(--vf-bg-input);\n  color: var(--vf-color-input);\n  font-size: var(--vf-font-size);\n  line-height: var(--vf-line-height);\n  letter-spacing: var(--vf-letter-spacing);\n}\n\n.vf-radio-blocks.vf-radio-blocks-not-last {\n  border-bottom: 0;\n}\n\n.vf-radio-blocks.vf-radio-blocks-first {\n  border-radius: var(--vf-radius-large);\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.vf-radio-blocks.vf-radio-blocks-first.vf-radio-blocks-first-sm {\n  border-radius: var(--vf-radius-large-sm);\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.vf-radio-blocks.vf-radio-blocks-first.vf-radio-blocks-first-lg {\n  border-radius: var(--vf-radius-large-lg);\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.vf-radio-blocks.vf-radio-blocks-last {\n  border-radius: var(--vf-radius-large);\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n\n.vf-radio-blocks.vf-radio-blocks-last.vf-radio-blocks-last-sm {\n  border-radius: var(--vf-radius-large-sm);\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n\n.vf-radio-blocks.vf-radio-blocks-last.vf-radio-blocks-last-lg {\n  border-radius: var(--vf-radius-large-lg);\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n\n.vf-radio-blocks.vf-radio-blocks-selected {\n  background-color: var(--vf-bg-selected);\n}\n\n.vf-radio-blocks.vf-radio-blocks-disabled {\n  opacity: 0.5;\n}\n\n.vf-radio-blocks.vf-radio-blocks-sm {\n  padding: var(--vf-py-group-blocks-sm) var(--vf-px-group-blocks-sm);\n  font-size: var(--vf-font-size-sm);\n  line-height: var(--vf-line-height-sm);\n  letter-spacing: var(--vf-letter-spacing-sm);\n}\n\n.vf-radio-blocks.vf-radio-blocks-lg {\n  padding: var(--vf-py-group-blocks-lg) var(--vf-px-group-blocks-lg);\n  font-size: var(--vf-font-size-lg);\n  line-height: var(--vf-line-height-lg);\n  letter-spacing: var(--vf-letter-spacing-lg);\n}\n\n.vf-radio-blocks-text-wrapper {\n  margin-left: 0.5rem;\n}\n\n.vf-radio-blocks-description {\n  color: var(--vf-color-muted);\n  font-size: var(--vf-font-size-small);\n  line-height: var(--vf-line-height-small);\n  letter-spacing: var(--vf-letter-spacing-small);\n  margin-top: -0.125rem;\n}\n\n.vf-radio-blocks-description.vf-radio-blocks-description-sm {\n  font-size: var(--vf-font-size-small-sm);\n  line-height: var(--vf-line-height-small-sm);\n  letter-spacing: var(--vf-letter-spacing-small-sm);\n  margin-top: -0.125rem;\n}\n\n.vf-radio-blocks-description.vf-radio-blocks-description-lg {\n  font-size: var(--vf-font-size-small-lg);\n  line-height: var(--vf-line-height-small-lg);\n  letter-spacing: var(--vf-letter-spacing-small-lg);\n  margin-top: -0.125rem;\n}";
    styleInject(css_248z$2);
    script$4.__file = "themes/vueform/templates/elements/partials/RadiogroupRadio_blocks.vue";
    var script$3 = {
      name: "DatepickerWrapper",
      data() {
        return {
          merge: true,
          defaultClasses: {
            datepicker: "",
            calendarContainer: ""
          }
        };
      }
    };
    const _hoisted_1$1 = ["id", "placeholder"];
    function render$1(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("input", mergeProps({
        type: "text",
        class: _ctx.classes.datepicker,
        id: _ctx.id,
        placeholder: _ctx.placeholder
      }, _ctx.attrs, { ref: "input" }), null, 16, _hoisted_1$1);
    }
    script$3.render = render$1;
    script$3.__file = "themes/blank/templates/wrappers/DatepickerWrapper.vue";
    var script$2 = {
      name: "DatepickerWrapper",
      render: script$3.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            datepicker: "",
            calendarContainer: "flatpickr-calendar-container"
          }
        };
      }
    };
    var css_248z$1 = '.flatpickr-wrapper {\n  width: 100%;\n  height: 100%;\n}\n\n.flatpickr-calendar {\n  background: transparent;\n  opacity: 0;\n  display: none;\n  text-align: center;\n  visibility: hidden;\n  padding: 0;\n  animation: none;\n  direction: ltr;\n  border: 0;\n  font-size: 14px;\n  line-height: 24px;\n  border-radius: 5px;\n  position: absolute;\n  width: 307.875px;\n  box-sizing: border-box;\n  touch-action: manipulation;\n  box-shadow: 0 3px 13px rgba(0, 0, 0, 0.08);\n  color: var(--vf-color-input);\n}\n\n.flatpickr-calendar.open,\n.flatpickr-calendar.inline {\n  opacity: 1;\n  max-height: 640px;\n  visibility: visible;\n}\n\n.flatpickr-calendar.open {\n  display: inline-block;\n  z-index: 999;\n}\n\n.flatpickr-calendar.animate.open {\n  animation: fpFadeInDown 300ms cubic-bezier(0.23, 1, 0.32, 1);\n}\n\n.flatpickr-calendar.inline {\n  display: block;\n  position: relative;\n  top: 2px;\n}\n\n.flatpickr-calendar.rightMost {\n  left: auto;\n  right: 0;\n}\n\n.flatpickr-calendar.static {\n  position: absolute;\n  top: calc(100% + 2px);\n}\n\n.flatpickr-calendar.static.open {\n  z-index: 999;\n  display: block;\n}\n\n.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+1) .flatpickr-day.inRange:nth-child(7n+7) {\n  box-shadow: none !important;\n}\n\n.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+2) .flatpickr-day.inRange:nth-child(7n+1) {\n  box-shadow: -2px 0 0 var(--vf-bg-selected), 5px 0 0 var(--vf-bg-selected);\n}\n\n.flatpickr-calendar .hasWeeks .dayContainer,\n.flatpickr-calendar .hasTime .dayContainer {\n  border-bottom: 0;\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.flatpickr-calendar .hasWeeks .dayContainer {\n  border-left: 0;\n}\n\n.flatpickr-calendar.hasTime .flatpickr-time {\n  height: 40px;\n  border-top: 1px solid var(--vf-border-color-input);\n}\n\n.flatpickr-calendar.hasTime .flatpickr-innerContainer {\n  border-bottom: 0;\n}\n\n.flatpickr-calendar.noCalendar.hasTime .flatpickr-time {\n  height: auto;\n}\n\n.flatpickr-calendar:before,\n.flatpickr-calendar:after {\n  position: absolute;\n  display: block;\n  pointer-events: none;\n  border: solid transparent;\n  content: "";\n  height: 0;\n  width: 0;\n  left: 22px;\n}\n\n.flatpickr-calendar.rightMost:before,\n.flatpickr-calendar.arrowRight:before,\n.flatpickr-calendar.rightMost:after,\n.flatpickr-calendar.arrowRight:after {\n  left: auto;\n  right: 22px;\n}\n\n.flatpickr-calendar.arrowCenter:before,\n.flatpickr-calendar.arrowCenter:after {\n  left: 50%;\n  right: 50%;\n}\n\n.flatpickr-calendar:before {\n  border-width: 5px;\n  margin: 0 -5px;\n  box-sizing: border-box;\n}\n\n.flatpickr-calendar:after {\n  border-width: 4px;\n  margin: 0 -4px;\n  box-sizing: border-box;\n}\n\n.flatpickr-calendar.arrowTop:before,\n.flatpickr-calendar.arrowTop:after {\n  bottom: 100%;\n}\n\n.flatpickr-calendar.arrowTop:before {\n  border-bottom-color: var(--vf-bg-date-head);\n  box-sizing: border-box;\n}\n\n.flatpickr-calendar.arrowTop:after {\n  border-bottom-color: var(--vf-bg-date-head);\n  box-sizing: border-box;\n}\n\n.flatpickr-calendar.arrowBottom:before,\n.flatpickr-calendar.arrowBottom:after {\n  top: 100%;\n}\n\n.flatpickr-calendar.arrowBottom:before {\n  border-top-color: var(--vf-bg-date-head);\n}\n\n.flatpickr-calendar.arrowBottom:after {\n  border-top-color: var(--vf-bg-date-head);\n}\n\n.flatpickr-calendar:focus {\n  outline: 0;\n}\n\n.flatpickr-wrapper {\n  position: relative;\n  display: flex;\n}\n\n.flatpickr-months {\n  display: flex;\n}\n\n.flatpickr-months .flatpickr-month {\n  border-radius: 5px 5px 0 0;\n  background: var(--vf-bg-date-head);\n  color: var(--vf-color-date-head);\n  fill: var(--vf-color-date-head);\n  height: 34px;\n  line-height: 1;\n  text-align: center;\n  position: relative;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n  overflow: hidden;\n  flex: 1;\n}\n\n.flatpickr-months .flatpickr-prev-month,\n.flatpickr-months .flatpickr-next-month {\n  text-decoration: none;\n  cursor: pointer;\n  position: absolute;\n  top: 0;\n  height: 34px;\n  padding: 10px;\n  z-index: 1;\n  color: var(--vf-color-date-head);\n  fill: var(--vf-color-date-head);\n}\n\n.flatpickr-months .flatpickr-prev-month.flatpickr-disabled,\n.flatpickr-months .flatpickr-next-month.flatpickr-disabled {\n  display: none;\n}\n\n.flatpickr-months .flatpickr-prev-month i,\n.flatpickr-months .flatpickr-next-month i {\n  position: relative;\n}\n\n.flatpickr-months .flatpickr-prev-month.flatpickr-prev-month,\n.flatpickr-months .flatpickr-next-month.flatpickr-prev-month {\n  left: 0;\n}\n\n.flatpickr-months .flatpickr-prev-month.flatpickr-next-month,\n.flatpickr-months .flatpickr-next-month.flatpickr-next-month {\n  right: 0;\n}\n\n.flatpickr-months .flatpickr-prev-month:hover,\n.flatpickr-months .flatpickr-next-month:hover {\n  color: var(--vf-color-date-head);\n}\n\n.flatpickr-months .flatpickr-prev-month:hover svg,\n.flatpickr-months .flatpickr-next-month:hover svg {\n  opacity: 1;\n}\n\n.flatpickr-months .flatpickr-prev-month svg,\n.flatpickr-months .flatpickr-next-month svg {\n  width: 14px;\n  height: 14px;\n  opacity: 0.7;\n  display: block;\n}\n\n.flatpickr-months .flatpickr-prev-month svg path,\n.flatpickr-months .flatpickr-next-month svg path {\n  transition: fill 0.1s;\n  fill: inherit;\n}\n\n.numInputWrapper {\n  position: relative;\n  height: auto;\n}\n\n.numInputWrapper input,\n.numInputWrapper span {\n  display: inline-block;\n}\n\n.numInputWrapper input {\n  width: 100%;\n}\n\n.numInputWrapper input::-ms-clear {\n  display: none;\n}\n\n.numInputWrapper input::-webkit-outer-spin-button,\n.numInputWrapper input::-webkit-inner-spin-button {\n  margin: 0;\n  -webkit-appearance: none;\n}\n\n.numInputWrapper span {\n  position: absolute;\n  right: 0;\n  width: 14px;\n  padding: 0 4px 0 2px;\n  height: 50%;\n  line-height: 50%;\n  opacity: 0;\n  cursor: pointer;\n  border: 1px solid var(--vf-border-color-input);\n  box-sizing: border-box;\n}\n\n.numInputWrapper span:hover {\n  background: var(--vf-bg-selected);\n}\n\n.numInputWrapper span:active {\n  background: var(--vf-bg-selected);\n}\n\n.numInputWrapper span:after {\n  display: block;\n  content: "";\n  position: absolute;\n}\n\n.numInputWrapper span.arrowUp {\n  top: 0;\n  border-bottom: 0;\n}\n\n.numInputWrapper span.arrowUp:after {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-bottom: 4px solid var(--vf-color-input);\n  top: 26%;\n  box-sizing: border-box;\n}\n\n.numInputWrapper span.arrowDown {\n  top: 50%;\n}\n\n.numInputWrapper span.arrowDown:after {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-top: 4px solid var(--vf-color-input);\n  top: 40%;\n  box-sizing: border-box;\n}\n\n.numInputWrapper span svg {\n  width: inherit;\n  height: auto;\n}\n\n.numInputWrapper span svg path {\n  fill: var(--vf-color-input);\n}\n\n.numInputWrapper:hover {\n  background: rgba(0, 0, 0, 0.05);\n}\n\n.numInputWrapper:hover span {\n  opacity: 1;\n}\n\n.flatpickr-current-month {\n  font-size: 135%;\n  line-height: inherit;\n  font-weight: 300;\n  color: inherit;\n  position: absolute;\n  width: 75%;\n  left: 12.5%;\n  padding: 7.48px 0 0 0;\n  line-height: 1;\n  height: 34px;\n  display: inline-block;\n  text-align: center;\n  transform: translate3d(0px, 0px, 0px);\n}\n\n.flatpickr-current-month span.cur-month {\n  font-family: inherit;\n  font-weight: 700;\n  color: inherit;\n  display: inline-block;\n  margin-left: 0.5ch;\n  padding: 0;\n}\n\n.flatpickr-current-month span.cur-month:hover {\n  background: rgba(0, 0, 0, 0.05);\n}\n\n.flatpickr-current-month .numInputWrapper {\n  width: 6ch;\n  width: 7ch\\0 ;\n  display: inline-block;\n}\n\n.flatpickr-current-month .numInputWrapper span.arrowUp:after {\n  border-bottom-color: var(--vf-color-date-head);\n}\n\n.flatpickr-current-month .numInputWrapper span.arrowDown:after {\n  border-top-color: var(--vf-color-date-head);\n}\n\n.flatpickr-current-month input.cur-year {\n  background: transparent;\n  box-sizing: border-box;\n  color: inherit;\n  cursor: text;\n  padding: 0 0 0 0.5ch;\n  margin: 0;\n  display: inline-block;\n  font-size: inherit;\n  font-family: inherit;\n  font-weight: 300;\n  line-height: inherit;\n  height: auto;\n  border: 0;\n  border-radius: 0;\n  vertical-align: initial;\n  -webkit-appearance: textfield;\n  -moz-appearance: textfield;\n  appearance: textfield;\n}\n\n.flatpickr-current-month input.cur-year:focus {\n  outline: 0;\n}\n\n.flatpickr-current-month input.cur-year[disabled],\n.flatpickr-current-month input.cur-year[disabled]:hover {\n  font-size: 100%;\n  color: var(--vf-gray-300);\n  background: transparent;\n  pointer-events: none;\n}\n\n.flatpickr-current-month .flatpickr-monthDropdown-months {\n  appearance: menulist;\n  background: var(--vf-bg-date-head);\n  border: none;\n  border-radius: 0;\n  box-sizing: border-box;\n  color: inherit;\n  cursor: pointer;\n  font-size: inherit;\n  font-family: inherit;\n  font-weight: 300;\n  height: auto;\n  line-height: inherit;\n  margin: -1px 0 0 0;\n  outline: none;\n  padding: 0 0 0 0.5ch;\n  position: relative;\n  vertical-align: initial;\n  -webkit-box-sizing: border-box;\n  -webkit-appearance: menulist;\n  -moz-appearance: menulist;\n  width: auto;\n}\n\n.flatpickr-current-month .flatpickr-monthDropdown-months:focus,\n.flatpickr-current-month .flatpickr-monthDropdown-months:active {\n  outline: none;\n}\n\n.flatpickr-current-month .flatpickr-monthDropdown-months:hover {\n  background: rgba(0, 0, 0, 0.1);\n}\n\n.flatpickr-current-month .flatpickr-monthDropdown-months .flatpickr-monthDropdown-month {\n  background-color: var(--vf-bg-date-head);\n  outline: none;\n  padding: 0;\n}\n\n.flatpickr-weekdays {\n  background: var(--vf-bg-date-head);\n  text-align: center;\n  overflow: hidden;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  height: 28px;\n}\n\n.flatpickr-weekdays .flatpickr-weekdaycontainer {\n  display: flex;\n  flex: 1;\n}\n\nspan.flatpickr-weekday {\n  cursor: default;\n  font-size: 90%;\n  background: var(--vf-bg-date-head);\n  color: var(--vf-color-date-head);\n  line-height: 1;\n  margin: 0;\n  text-align: center;\n  display: block;\n  flex: 1;\n  font-weight: bolder;\n}\n\n.dayContainer,\n.flatpickr-weeks {\n  padding: 1px 0 0 0;\n}\n\n.flatpickr-days {\n  position: relative;\n  overflow: hidden;\n  display: flex;\n  align-items: flex-start;\n  width: 307.875px;\n  background-color: var(--vf-bg-input);\n}\n\n.flatpickr-days:focus {\n  outline: 0;\n}\n\n.dayContainer {\n  padding: 0;\n  outline: 0;\n  text-align: left;\n  width: 307.875px;\n  min-width: 307.875px;\n  max-width: 307.875px;\n  box-sizing: border-box;\n  display: inline-block;\n  display: flex;\n  flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  justify-content: space-around;\n  transform: translate3d(0px, 0px, 0px);\n  opacity: 1;\n}\n\n.dayContainer + .dayContainer {\n  box-shadow: -1px 0 0 var(--vf-gray-200);\n}\n\n.flatpickr-day {\n  background: none;\n  border: 1px solid transparent;\n  border-radius: 150px;\n  box-sizing: border-box;\n  cursor: pointer;\n  font-weight: 400;\n  width: 14.2857143%;\n  flex-basis: 14.2857143%;\n  max-width: 39px;\n  height: 39px;\n  line-height: 38px;\n  margin: 0;\n  display: inline-block;\n  position: relative;\n  justify-content: center;\n  text-align: center;\n}\n\n.flatpickr-day.inRange,\n.flatpickr-day.prevMonthDay.inRange,\n.flatpickr-day.nextMonthDay.inRange,\n.flatpickr-day.today.inRange,\n.flatpickr-day.prevMonthDay.today.inRange,\n.flatpickr-day.nextMonthDay.today.inRange,\n.flatpickr-day:hover,\n.flatpickr-day.prevMonthDay:hover,\n.flatpickr-day.nextMonthDay:hover,\n.flatpickr-day:focus,\n.flatpickr-day.prevMonthDay:focus,\n.flatpickr-day.nextMonthDay:focus {\n  cursor: pointer;\n  outline: 0;\n  background: var(--vf-bg-selected);\n  border-color: var(--vf-bg-selected);\n}\n\n.flatpickr-day.today {\n  border-color: var(--vf-bg-selected);\n}\n\n.flatpickr-day.today:hover,\n.flatpickr-day.today:focus {\n  border-color: var(--vf-bg-selected);\n  background: var(--vf-bg-selected);\n}\n\n.flatpickr-day.selected,\n.flatpickr-day.startRange,\n.flatpickr-day.endRange,\n.flatpickr-day.selected.inRange,\n.flatpickr-day.startRange.inRange,\n.flatpickr-day.endRange.inRange,\n.flatpickr-day.selected:focus,\n.flatpickr-day.startRange:focus,\n.flatpickr-day.endRange:focus,\n.flatpickr-day.selected:hover,\n.flatpickr-day.startRange:hover,\n.flatpickr-day.endRange:hover,\n.flatpickr-day.selected.prevMonthDay,\n.flatpickr-day.startRange.prevMonthDay,\n.flatpickr-day.endRange.prevMonthDay,\n.flatpickr-day.selected.nextMonthDay,\n.flatpickr-day.startRange.nextMonthDay,\n.flatpickr-day.endRange.nextMonthDay {\n  background: var(--vf-primary);\n  box-shadow: none;\n  color: #fff;\n  border-color: var(--vf-primary);\n}\n\n.flatpickr-day.selected.startRange,\n.flatpickr-day.startRange.startRange,\n.flatpickr-day.endRange.startRange {\n  border-radius: 50px 0 0 50px;\n}\n\n.flatpickr-day.selected.endRange,\n.flatpickr-day.startRange.endRange,\n.flatpickr-day.endRange.endRange {\n  border-radius: 0 50px 50px 0;\n}\n\n.flatpickr-day.selected.startRange + .endRange:not(:nth-child(7n+1)),\n.flatpickr-day.startRange.startRange + .endRange:not(:nth-child(7n+1)),\n.flatpickr-day.endRange.startRange + .endRange:not(:nth-child(7n+1)) {\n  box-shadow: -10px 0 0 var(--vf-primary);\n}\n\n.flatpickr-day.selected.startRange.endRange,\n.flatpickr-day.startRange.startRange.endRange,\n.flatpickr-day.endRange.startRange.endRange {\n  border-radius: 50px;\n}\n\n.flatpickr-day.inRange {\n  border-radius: 0;\n  box-shadow: -5px 0 0 var(--vf-bg-selected), 5px 0 0 var(--vf-bg-selected);\n}\n\n.flatpickr-day.flatpickr-disabled,\n.flatpickr-day.flatpickr-disabled:hover,\n.flatpickr-day.prevMonthDay,\n.flatpickr-day.nextMonthDay,\n.flatpickr-day.notAllowed,\n.flatpickr-day.notAllowed.prevMonthDay,\n.flatpickr-day.notAllowed.nextMonthDay {\n  color: var(--vf-color-disabled);\n  background: transparent;\n  border-color: transparent;\n  cursor: default;\n}\n\n.flatpickr-day.flatpickr-disabled,\n.flatpickr-day.flatpickr-disabled:hover {\n  cursor: not-allowed;\n  color: var(--vf-color-disabled);\n}\n\n.flatpickr-day.week.selected {\n  border-radius: 0;\n  box-shadow: -5px 0 0 var(--vf-primary), 5px 0 0 var(--vf-primary);\n}\n\n.flatpickr-day.hidden {\n  visibility: hidden;\n}\n\n.rangeMode .flatpickr-day {\n  margin-top: 1px;\n}\n\n.flatpickr-weekwrapper {\n  float: left;\n}\n\n.flatpickr-weekwrapper .flatpickr-weeks {\n  padding: 0 12px;\n}\n\n.flatpickr-weekwrapper .flatpickr-weekday {\n  float: none;\n  width: 100%;\n  line-height: 28px;\n}\n\n.flatpickr-weekwrapper span.flatpickr-day,\n.flatpickr-weekwrapper span.flatpickr-day:hover {\n  display: block;\n  width: 100%;\n  max-width: none;\n  color: var(--vf-gray-300);\n  background: transparent;\n  cursor: default;\n  border: none;\n}\n\n.flatpickr-innerContainer {\n  display: block;\n  display: flex;\n  box-sizing: border-box;\n  overflow: hidden;\n  background: var(--vf-bg-input);\n}\n\n.flatpickr-rContainer {\n  display: inline-block;\n  padding: 0;\n  box-sizing: border-box;\n}\n\n.flatpickr-time {\n  text-align: center;\n  outline: 0;\n  display: block;\n  height: 0;\n  line-height: 40px;\n  max-height: 40px;\n  box-sizing: border-box;\n  overflow: hidden;\n  display: flex;\n  background: var(--vf-bg-input);\n  border-radius: 0 0 5px 5px;\n  color: var(--vf-color-input);\n}\n\n.flatpickr-time:after {\n  content: "";\n  display: table;\n  clear: both;\n}\n\n.flatpickr-time .numInputWrapper {\n  flex: 1;\n  width: 40%;\n  height: 40px;\n  float: left;\n}\n\n.flatpickr-time .numInputWrapper span.arrowUp:after {\n  border-bottom-color: var(--vf-color-input);\n  box-sizing: border-box;\n}\n\n.flatpickr-time .numInputWrapper span.arrowDown:after {\n  border-top-color: var(--vf-color-input);\n  box-sizing: border-box;\n}\n\n.flatpickr-time.hasSeconds .numInputWrapper {\n  width: 26%;\n}\n\n.flatpickr-time.time24hr .numInputWrapper {\n  width: 49%;\n}\n\n.flatpickr-time input {\n  background: transparent;\n  box-shadow: none;\n  border: 0;\n  border-radius: 0;\n  text-align: center;\n  margin: 0;\n  padding: 0;\n  height: inherit;\n  line-height: inherit;\n  font-size: 14px;\n  position: relative;\n  box-sizing: border-box;\n  -webkit-appearance: textfield;\n  -moz-appearance: textfield;\n  appearance: textfield;\n  color: var(--vf-color-input);\n  background: var(--vf-bg-input);\n}\n\n.flatpickr-time input.flatpickr-hour {\n  font-weight: bold;\n}\n\n.flatpickr-time input.flatpickr-minute,\n.flatpickr-time input.flatpickr-second {\n  font-weight: 400;\n}\n\n.flatpickr-time input:focus {\n  outline: 0;\n  border: 0;\n}\n\n.flatpickr-time .flatpickr-time-separator,\n.flatpickr-time .flatpickr-am-pm {\n  height: inherit;\n  float: left;\n  line-height: inherit;\n  font-weight: bold;\n  width: 2%;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n  align-self: center;\n  background: var(--vf-bg-input);\n}\n\n.flatpickr-time .flatpickr-am-pm {\n  outline: 0;\n  width: 18%;\n  cursor: pointer;\n  text-align: center;\n  font-weight: 400;\n}\n\n.flatpickr-time input:hover,\n.flatpickr-time .flatpickr-am-pm:hover,\n.flatpickr-time input:focus,\n.flatpickr-time .flatpickr-am-pm:focus {\n  background: var(--vf-bg-selected);\n}\n\n.flatpickr-input[readonly] {\n  cursor: pointer;\n}\n\n@keyframes fpFadeInDown {\n  from {\n    opacity: 0;\n    transform: translate3d(0, -20px, 0);\n  }\n\n  to {\n    opacity: 1;\n    transform: translate3d(0, 0, 0);\n  }\n}\n\nspan.flatpickr-day.selected {\n  font-weight: bold;\n}';
    styleInject(css_248z$1);
    script$2.__file = "themes/vueform/templates/wrappers/DatepickerWrapper.vue";
    var t = "2.1.3";
    const e = "[data-trix-attachment]", i = { preview: { presentation: "gallery", caption: { name: true, size: true } }, file: { caption: { size: true } } }, n = { default: { tagName: "div", parse: false }, quote: { tagName: "blockquote", nestable: true }, heading1: { tagName: "h1", terminal: true, breakOnReturn: true, group: false }, code: { tagName: "pre", terminal: true, htmlAttributes: ["language"], text: { plaintext: true } }, bulletList: { tagName: "ul", parse: false }, bullet: { tagName: "li", listAttribute: "bulletList", group: false, nestable: true, test(t2) {
      return r(t2.parentNode) === n[this.listAttribute].tagName;
    } }, numberList: { tagName: "ol", parse: false }, number: { tagName: "li", listAttribute: "numberList", group: false, nestable: true, test(t2) {
      return r(t2.parentNode) === n[this.listAttribute].tagName;
    } }, attachmentGallery: { tagName: "div", exclusive: true, terminal: true, parse: false, group: false } }, r = (t2) => {
      var e2;
      return null == t2 || null === (e2 = t2.tagName) || void 0 === e2 ? void 0 : e2.toLowerCase();
    }, o = navigator.userAgent.match(/android\s([0-9]+.*Chrome)/i), s = o && parseInt(o[1]);
    var a = { composesExistingText: /Android.*Chrome/.test(navigator.userAgent), recentAndroid: s && s > 12, samsungAndroid: s && navigator.userAgent.match(/Android.*SM-/), forcesObjectResizing: /Trident.*rv:11/.test(navigator.userAgent), supportsInputEvents: "undefined" != typeof InputEvent && ["data", "getTargetRanges", "inputType"].every((t2) => t2 in InputEvent.prototype) }, l = { attachFiles: "Attach Files", bold: "Bold", bullets: "Bullets", byte: "Byte", bytes: "Bytes", captionPlaceholder: "Add a caption…", code: "Code", heading1: "Heading", indent: "Increase Level", italic: "Italic", link: "Link", numbers: "Numbers", outdent: "Decrease Level", quote: "Quote", redo: "Redo", remove: "Remove", strike: "Strikethrough", undo: "Undo", unlink: "Unlink", url: "URL", urlPlaceholder: "Enter a URL…", GB: "GB", KB: "KB", MB: "MB", PB: "PB", TB: "TB" };
    const c = [l.bytes, l.KB, l.MB, l.GB, l.TB, l.PB];
    var u = { prefix: "IEC", precision: 2, formatter(t2) {
      switch (t2) {
        case 0:
          return "0 ".concat(l.bytes);
        case 1:
          return "1 ".concat(l.byte);
        default:
          let e2;
          "SI" === this.prefix ? e2 = 1e3 : "IEC" === this.prefix && (e2 = 1024);
          const i2 = Math.floor(Math.log(t2) / Math.log(e2)), n2 = (t2 / Math.pow(e2, i2)).toFixed(this.precision).replace(/0*$/, "").replace(/\.$/, "");
          return "".concat(n2, " ").concat(c[i2]);
      }
    } };
    const h = "\uFEFF", d = " ", g = function(t2) {
      for (const e2 in t2) {
        const i2 = t2[e2];
        this[e2] = i2;
      }
      return this;
    }, m = document.documentElement, p = m.matches, f = function(t2) {
      let { onElement: e2, matchingSelector: i2, withCallback: n2, inPhase: r2, preventDefault: o2, times: s2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const a2 = e2 || m, l2 = i2, c2 = "capturing" === r2, u2 = function(t3) {
        null != s2 && 0 == --s2 && u2.destroy();
        const e3 = A(t3.target, { matchingSelector: l2 });
        null != e3 && (null == n2 || n2.call(e3, t3, e3), o2 && t3.preventDefault());
      };
      return u2.destroy = () => a2.removeEventListener(t2, u2, c2), a2.addEventListener(t2, u2, c2), u2;
    }, b = function(t2) {
      let { onElement: e2, bubbles: i2, cancelable: n2, attributes: r2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const o2 = null != e2 ? e2 : m;
      i2 = false !== i2, n2 = false !== n2;
      const s2 = document.createEvent("Events");
      return s2.initEvent(t2, i2, n2), null != r2 && g.call(s2, r2), o2.dispatchEvent(s2);
    }, v = function(t2, e2) {
      if (1 === (null == t2 ? void 0 : t2.nodeType))
        return p.call(t2, e2);
    }, A = function(t2) {
      let { matchingSelector: e2, untilNode: i2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      for (; t2 && t2.nodeType !== Node.ELEMENT_NODE; )
        t2 = t2.parentNode;
      if (null != t2) {
        if (null == e2)
          return t2;
        if (t2.closest && null == i2)
          return t2.closest(e2);
        for (; t2 && t2 !== i2; ) {
          if (v(t2, e2))
            return t2;
          t2 = t2.parentNode;
        }
      }
    }, x = (t2) => document.activeElement !== t2 && y(t2, document.activeElement), y = function(t2, e2) {
      if (t2 && e2)
        for (; e2; ) {
          if (e2 === t2)
            return true;
          e2 = e2.parentNode;
        }
    }, C = function(t2) {
      var e2;
      if (null === (e2 = t2) || void 0 === e2 || !e2.parentNode)
        return;
      let i2 = 0;
      for (t2 = t2.previousSibling; t2; )
        i2++, t2 = t2.previousSibling;
      return i2;
    }, k = (t2) => {
      var e2;
      return null == t2 || null === (e2 = t2.parentNode) || void 0 === e2 ? void 0 : e2.removeChild(t2);
    }, R = function(t2) {
      let { onlyNodesOfType: e2, usingFilter: i2, expandEntityReferences: n2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const r2 = (() => {
        switch (e2) {
          case "element":
            return NodeFilter.SHOW_ELEMENT;
          case "text":
            return NodeFilter.SHOW_TEXT;
          case "comment":
            return NodeFilter.SHOW_COMMENT;
          default:
            return NodeFilter.SHOW_ALL;
        }
      })();
      return document.createTreeWalker(t2, r2, null != i2 ? i2 : null, true === n2);
    }, E = (t2) => {
      var e2;
      return null == t2 || null === (e2 = t2.tagName) || void 0 === e2 ? void 0 : e2.toLowerCase();
    }, S = function(t2) {
      let e2, i2, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      "object" == typeof t2 ? (n2 = t2, t2 = n2.tagName) : n2 = { attributes: n2 };
      const r2 = document.createElement(t2);
      if (null != n2.editable && (null == n2.attributes && (n2.attributes = {}), n2.attributes.contenteditable = n2.editable), n2.attributes)
        for (e2 in n2.attributes)
          i2 = n2.attributes[e2], r2.setAttribute(e2, i2);
      if (n2.style)
        for (e2 in n2.style)
          i2 = n2.style[e2], r2.style[e2] = i2;
      if (n2.data)
        for (e2 in n2.data)
          i2 = n2.data[e2], r2.dataset[e2] = i2;
      return n2.className && n2.className.split(" ").forEach((t3) => {
        r2.classList.add(t3);
      }), n2.textContent && (r2.textContent = n2.textContent), n2.childNodes && [].concat(n2.childNodes).forEach((t3) => {
        r2.appendChild(t3);
      }), r2;
    };
    let L;
    const D = function() {
      if (null != L)
        return L;
      L = [];
      for (const t2 in n) {
        const e2 = n[t2];
        e2.tagName && L.push(e2.tagName);
      }
      return L;
    }, w = (t2) => B(null == t2 ? void 0 : t2.firstChild), T = function(t2) {
      let { strict: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { strict: true };
      return e2 ? B(t2) : B(t2) || !B(t2.firstChild) && function(t3) {
        return D().includes(E(t3)) && !D().includes(E(t3.firstChild));
      }(t2);
    }, B = (t2) => F(t2) && "block" === (null == t2 ? void 0 : t2.data), F = (t2) => (null == t2 ? void 0 : t2.nodeType) === Node.COMMENT_NODE, P = function(t2) {
      let { name: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      if (t2)
        return O(t2) ? t2.data === h ? !e2 || t2.parentNode.dataset.trixCursorTarget === e2 : void 0 : P(t2.firstChild);
    }, I = (t2) => v(t2, e), N = (t2) => O(t2) && "" === (null == t2 ? void 0 : t2.data), O = (t2) => (null == t2 ? void 0 : t2.nodeType) === Node.TEXT_NODE, M = { level2Enabled: true, getLevel() {
      return this.level2Enabled && a.supportsInputEvents ? 2 : 0;
    }, pickFiles(t2) {
      const e2 = S("input", { type: "file", multiple: true, hidden: true, id: this.fileInputId });
      e2.addEventListener("change", () => {
        t2(e2.files), k(e2);
      }), k(document.getElementById(this.fileInputId)), document.body.appendChild(e2), e2.click();
    } };
    var j = { removeBlankTableCells: false, tableCellSeparator: " | ", tableRowSeparator: "\n" }, W = { bold: { tagName: "strong", inheritable: true, parser(t2) {
      const e2 = window.getComputedStyle(t2);
      return "bold" === e2.fontWeight || e2.fontWeight >= 600;
    } }, italic: { tagName: "em", inheritable: true, parser: (t2) => "italic" === window.getComputedStyle(t2).fontStyle }, href: { groupTagName: "a", parser(t2) {
      const i2 = "a:not(".concat(e, ")"), n2 = t2.closest(i2);
      if (n2)
        return n2.getAttribute("href");
    } }, strike: { tagName: "del", inheritable: true }, frozen: { style: { backgroundColor: "highlight" } } }, U = { getDefaultHTML: () => '<div class="trix-button-row">\n      <span class="trix-button-group trix-button-group--text-tools" data-trix-button-group="text-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-bold" data-trix-attribute="bold" data-trix-key="b" title="'.concat(l.bold, '" tabindex="-1">').concat(l.bold, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-italic" data-trix-attribute="italic" data-trix-key="i" title="').concat(l.italic, '" tabindex="-1">').concat(l.italic, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-strike" data-trix-attribute="strike" title="').concat(l.strike, '" tabindex="-1">').concat(l.strike, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-link" data-trix-attribute="href" data-trix-action="link" data-trix-key="k" title="').concat(l.link, '" tabindex="-1">').concat(l.link, '</button>\n      </span>\n\n      <span class="trix-button-group trix-button-group--block-tools" data-trix-button-group="block-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-heading-1" data-trix-attribute="heading1" title="').concat(l.heading1, '" tabindex="-1">').concat(l.heading1, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-quote" data-trix-attribute="quote" title="').concat(l.quote, '" tabindex="-1">').concat(l.quote, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-code" data-trix-attribute="code" title="').concat(l.code, '" tabindex="-1">').concat(l.code, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-bullet-list" data-trix-attribute="bullet" title="').concat(l.bullets, '" tabindex="-1">').concat(l.bullets, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-number-list" data-trix-attribute="number" title="').concat(l.numbers, '" tabindex="-1">').concat(l.numbers, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-decrease-nesting-level" data-trix-action="decreaseNestingLevel" title="').concat(l.outdent, '" tabindex="-1">').concat(l.outdent, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-increase-nesting-level" data-trix-action="increaseNestingLevel" title="').concat(l.indent, '" tabindex="-1">').concat(l.indent, '</button>\n      </span>\n\n      <span class="trix-button-group trix-button-group--file-tools" data-trix-button-group="file-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-attach" data-trix-action="attachFiles" title="').concat(l.attachFiles, '" tabindex="-1">').concat(l.attachFiles, '</button>\n      </span>\n\n      <span class="trix-button-group-spacer"></span>\n\n      <span class="trix-button-group trix-button-group--history-tools" data-trix-button-group="history-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-undo" data-trix-action="undo" data-trix-key="z" title="').concat(l.undo, '" tabindex="-1">').concat(l.undo, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-redo" data-trix-action="redo" data-trix-key="shift+z" title="').concat(l.redo, '" tabindex="-1">').concat(l.redo, '</button>\n      </span>\n    </div>\n\n    <div class="trix-dialogs" data-trix-dialogs>\n      <div class="trix-dialog trix-dialog--link" data-trix-dialog="href" data-trix-dialog-attribute="href">\n        <div class="trix-dialog__link-fields">\n          <input type="url" name="href" class="trix-input trix-input--dialog" placeholder="').concat(l.urlPlaceholder, '" aria-label="').concat(l.url, '" required data-trix-input>\n          <div class="trix-button-group">\n            <input type="button" class="trix-button trix-button--dialog" value="').concat(l.link, '" data-trix-method="setAttribute">\n            <input type="button" class="trix-button trix-button--dialog" value="').concat(l.unlink, '" data-trix-method="removeAttribute">\n          </div>\n        </div>\n      </div>\n    </div>') };
    const q = { interval: 5e3 };
    var V = Object.freeze({ __proto__: null, attachments: i, blockAttributes: n, browser: a, css: { attachment: "attachment", attachmentCaption: "attachment__caption", attachmentCaptionEditor: "attachment__caption-editor", attachmentMetadata: "attachment__metadata", attachmentMetadataContainer: "attachment__metadata-container", attachmentName: "attachment__name", attachmentProgress: "attachment__progress", attachmentSize: "attachment__size", attachmentToolbar: "attachment__toolbar", attachmentGallery: "attachment-gallery" }, fileSize: u, input: M, keyNames: { 8: "backspace", 9: "tab", 13: "return", 27: "escape", 37: "left", 39: "right", 46: "delete", 68: "d", 72: "h", 79: "o" }, lang: l, parser: j, textAttributes: W, toolbar: U, undo: q });
    class H {
      static proxyMethod(t2) {
        const { name: e2, toMethod: i2, toProperty: n2, optional: r2 } = z(t2);
        this.prototype[e2] = function() {
          let t3, o2;
          var s2, a2;
          i2 ? o2 = r2 ? null === (s2 = this[i2]) || void 0 === s2 ? void 0 : s2.call(this) : this[i2]() : n2 && (o2 = this[n2]);
          return r2 ? (t3 = null === (a2 = o2) || void 0 === a2 ? void 0 : a2[e2], t3 ? _.call(t3, o2, arguments) : void 0) : (t3 = o2[e2], _.call(t3, o2, arguments));
        };
      }
    }
    const z = function(t2) {
      const e2 = t2.match(J);
      if (!e2)
        throw new Error("can't parse @proxyMethod expression: ".concat(t2));
      const i2 = { name: e2[4] };
      return null != e2[2] ? i2.toMethod = e2[1] : i2.toProperty = e2[1], null != e2[3] && (i2.optional = true), i2;
    }, { apply: _ } = Function.prototype, J = new RegExp("^(.+?)(\\(\\))?(\\?)?\\.(.+?)$");
    var K, G, $;
    class X extends H {
      static box() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
        return t2 instanceof this ? t2 : this.fromUCS2String(null == t2 ? void 0 : t2.toString());
      }
      static fromUCS2String(t2) {
        return new this(t2, tt(t2));
      }
      static fromCodepoints(t2) {
        return new this(et(t2), t2);
      }
      constructor(t2, e2) {
        super(...arguments), this.ucs2String = t2, this.codepoints = e2, this.length = this.codepoints.length, this.ucs2Length = this.ucs2String.length;
      }
      offsetToUCS2Offset(t2) {
        return et(this.codepoints.slice(0, Math.max(0, t2))).length;
      }
      offsetFromUCS2Offset(t2) {
        return tt(this.ucs2String.slice(0, Math.max(0, t2))).length;
      }
      slice() {
        return this.constructor.fromCodepoints(this.codepoints.slice(...arguments));
      }
      charAt(t2) {
        return this.slice(t2, t2 + 1);
      }
      isEqualTo(t2) {
        return this.constructor.box(t2).ucs2String === this.ucs2String;
      }
      toJSON() {
        return this.ucs2String;
      }
      getCacheKey() {
        return this.ucs2String;
      }
      toString() {
        return this.ucs2String;
      }
    }
    const Y = 1 === (null === (K = Array.from) || void 0 === K ? void 0 : K.call(Array, "👼").length), Q = null != (null === (G = " ".codePointAt) || void 0 === G ? void 0 : G.call(" ", 0)), Z = " 👼" === (null === ($ = String.fromCodePoint) || void 0 === $ ? void 0 : $.call(String, 32, 128124));
    let tt, et;
    tt = Y && Q ? (t2) => Array.from(t2).map((t3) => t3.codePointAt(0)) : function(t2) {
      const e2 = [];
      let i2 = 0;
      const { length: n2 } = t2;
      for (; i2 < n2; ) {
        let r2 = t2.charCodeAt(i2++);
        if (55296 <= r2 && r2 <= 56319 && i2 < n2) {
          const e3 = t2.charCodeAt(i2++);
          56320 == (64512 & e3) ? r2 = ((1023 & r2) << 10) + (1023 & e3) + 65536 : i2--;
        }
        e2.push(r2);
      }
      return e2;
    }, et = Z ? (t2) => String.fromCodePoint(...Array.from(t2 || [])) : function(t2) {
      return (() => {
        const e2 = [];
        return Array.from(t2).forEach((t3) => {
          let i2 = "";
          t3 > 65535 && (t3 -= 65536, i2 += String.fromCharCode(t3 >>> 10 & 1023 | 55296), t3 = 56320 | 1023 & t3), e2.push(i2 + String.fromCharCode(t3));
        }), e2;
      })().join("");
    };
    let it = 0;
    class nt extends H {
      static fromJSONString(t2) {
        return this.fromJSON(JSON.parse(t2));
      }
      constructor() {
        super(...arguments), this.id = ++it;
      }
      hasSameConstructorAs(t2) {
        return this.constructor === (null == t2 ? void 0 : t2.constructor);
      }
      isEqualTo(t2) {
        return this === t2;
      }
      inspect() {
        const t2 = [], e2 = this.contentsForInspection() || {};
        for (const i2 in e2) {
          const n2 = e2[i2];
          t2.push("".concat(i2, "=").concat(n2));
        }
        return "#<".concat(this.constructor.name, ":").concat(this.id).concat(t2.length ? " ".concat(t2.join(", ")) : "", ">");
      }
      contentsForInspection() {
      }
      toJSONString() {
        return JSON.stringify(this);
      }
      toUTF16String() {
        return X.box(this);
      }
      getCacheKey() {
        return this.id.toString();
      }
    }
    const rt = function() {
      let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
      if (t2.length !== e2.length)
        return false;
      for (let i2 = 0; i2 < t2.length; i2++) {
        if (t2[i2] !== e2[i2])
          return false;
      }
      return true;
    }, ot = function(t2) {
      const e2 = t2.slice(0);
      for (var i2 = arguments.length, n2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++)
        n2[r2 - 1] = arguments[r2];
      return e2.splice(...n2), e2;
    }, st = /[\u05BE\u05C0\u05C3\u05D0-\u05EA\u05F0-\u05F4\u061B\u061F\u0621-\u063A\u0640-\u064A\u066D\u0671-\u06B7\u06BA-\u06BE\u06C0-\u06CE\u06D0-\u06D5\u06E5\u06E6\u200F\u202B\u202E\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE72\uFE74\uFE76-\uFEFC]/, at = function() {
      const t2 = S("input", { dir: "auto", name: "x", dirName: "x.dir" }), e2 = S("textarea", { dir: "auto", name: "y", dirName: "y.dir" }), i2 = S("form");
      i2.appendChild(t2), i2.appendChild(e2);
      const n2 = function() {
        try {
          return new FormData(i2).has(e2.dirName);
        } catch (t3) {
          return false;
        }
      }(), r2 = function() {
        try {
          return t2.matches(":dir(ltr),:dir(rtl)");
        } catch (t3) {
          return false;
        }
      }();
      return n2 ? function(t3) {
        return e2.value = t3, new FormData(i2).get(e2.dirName);
      } : r2 ? function(e3) {
        return t2.value = e3, t2.matches(":dir(rtl)") ? "rtl" : "ltr";
      } : function(t3) {
        const e3 = t3.trim().charAt(0);
        return st.test(e3) ? "rtl" : "ltr";
      };
    }();
    let lt = null, ct = null, ut = null, ht = null;
    const dt = () => (lt || (lt = ft().concat(mt())), lt), gt = (t2) => n[t2], mt = () => (ct || (ct = Object.keys(n)), ct), pt = (t2) => W[t2], ft = () => (ut || (ut = Object.keys(W)), ut), bt = function(t2, e2) {
      vt(t2).textContent = e2.replace(/%t/g, t2);
    }, vt = function(t2) {
      const e2 = document.createElement("style");
      e2.setAttribute("type", "text/css"), e2.setAttribute("data-tag-name", t2.toLowerCase());
      const i2 = At();
      return i2 && e2.setAttribute("nonce", i2), document.head.insertBefore(e2, document.head.firstChild), e2;
    }, At = function() {
      const t2 = xt("trix-csp-nonce") || xt("csp-nonce");
      if (t2)
        return t2.getAttribute("content");
    }, xt = (t2) => document.head.querySelector("meta[name=".concat(t2, "]")), yt = { "application/x-trix-feature-detection": "test" }, Ct = function(t2) {
      const e2 = t2.getData("text/plain"), i2 = t2.getData("text/html");
      if (!e2 || !i2)
        return null == e2 ? void 0 : e2.length;
      {
        const { body: t3 } = new DOMParser().parseFromString(i2, "text/html");
        if (t3.textContent === e2)
          return !t3.querySelector("*");
      }
    }, kt = /Mac|^iP/.test(navigator.platform) ? (t2) => t2.metaKey : (t2) => t2.ctrlKey, Rt = (t2) => setTimeout(t2, 1), Et = function() {
      let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      const e2 = {};
      for (const i2 in t2) {
        const n2 = t2[i2];
        e2[i2] = n2;
      }
      return e2;
    }, St = function() {
      let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      if (Object.keys(t2).length !== Object.keys(e2).length)
        return false;
      for (const i2 in t2) {
        if (t2[i2] !== e2[i2])
          return false;
      }
      return true;
    }, Lt = function(t2) {
      if (null != t2)
        return Array.isArray(t2) || (t2 = [t2, t2]), [Tt(t2[0]), Tt(null != t2[1] ? t2[1] : t2[0])];
    }, Dt = function(t2) {
      if (null == t2)
        return;
      const [e2, i2] = Lt(t2);
      return Bt(e2, i2);
    }, wt = function(t2, e2) {
      if (null == t2 || null == e2)
        return;
      const [i2, n2] = Lt(t2), [r2, o2] = Lt(e2);
      return Bt(i2, r2) && Bt(n2, o2);
    }, Tt = function(t2) {
      return "number" == typeof t2 ? t2 : Et(t2);
    }, Bt = function(t2, e2) {
      return "number" == typeof t2 ? t2 === e2 : St(t2, e2);
    };
    class Ft extends H {
      constructor() {
        super(...arguments), this.update = this.update.bind(this), this.selectionManagers = [];
      }
      start() {
        this.started || (this.started = true, document.addEventListener("selectionchange", this.update, true));
      }
      stop() {
        if (this.started)
          return this.started = false, document.removeEventListener("selectionchange", this.update, true);
      }
      registerSelectionManager(t2) {
        if (!this.selectionManagers.includes(t2))
          return this.selectionManagers.push(t2), this.start();
      }
      unregisterSelectionManager(t2) {
        if (this.selectionManagers = this.selectionManagers.filter((e2) => e2 !== t2), 0 === this.selectionManagers.length)
          return this.stop();
      }
      notifySelectionManagersOfSelectionChange() {
        return this.selectionManagers.map((t2) => t2.selectionDidChange());
      }
      update() {
        this.notifySelectionManagersOfSelectionChange();
      }
      reset() {
        this.update();
      }
    }
    const Pt = new Ft(), It = function() {
      const t2 = window.getSelection();
      if (t2.rangeCount > 0)
        return t2;
    }, Nt = function() {
      var t2;
      const e2 = null === (t2 = It()) || void 0 === t2 ? void 0 : t2.getRangeAt(0);
      if (e2 && !Mt(e2))
        return e2;
    }, Ot = function(t2) {
      const e2 = window.getSelection();
      return e2.removeAllRanges(), e2.addRange(t2), Pt.update();
    }, Mt = (t2) => jt(t2.startContainer) || jt(t2.endContainer), jt = (t2) => !Object.getPrototypeOf(t2), Wt = (t2) => t2.replace(new RegExp("".concat(h), "g"), "").replace(new RegExp("".concat(d), "g"), " "), Ut = new RegExp("[^\\S".concat(d, "]")), qt = (t2) => t2.replace(new RegExp("".concat(Ut.source), "g"), " ").replace(/\ {2,}/g, " "), Vt = function(t2, e2) {
      if (t2.isEqualTo(e2))
        return ["", ""];
      const i2 = Ht(t2, e2), { length: n2 } = i2.utf16String;
      let r2;
      if (n2) {
        const { offset: o2 } = i2, s2 = t2.codepoints.slice(0, o2).concat(t2.codepoints.slice(o2 + n2));
        r2 = Ht(e2, X.fromCodepoints(s2));
      } else
        r2 = Ht(e2, t2);
      return [i2.utf16String.toString(), r2.utf16String.toString()];
    }, Ht = function(t2, e2) {
      let i2 = 0, n2 = t2.length, r2 = e2.length;
      for (; i2 < n2 && t2.charAt(i2).isEqualTo(e2.charAt(i2)); )
        i2++;
      for (; n2 > i2 + 1 && t2.charAt(n2 - 1).isEqualTo(e2.charAt(r2 - 1)); )
        n2--, r2--;
      return { utf16String: t2.slice(i2, n2), offset: i2 };
    };
    class zt extends nt {
      static fromCommonAttributesOfObjects() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        if (!t2.length)
          return new this();
        let e2 = Gt(t2[0]), i2 = e2.getKeys();
        return t2.slice(1).forEach((t3) => {
          i2 = e2.getKeysCommonToHash(Gt(t3)), e2 = e2.slice(i2);
        }), e2;
      }
      static box(t2) {
        return Gt(t2);
      }
      constructor() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        super(...arguments), this.values = Kt(t2);
      }
      add(t2, e2) {
        return this.merge(_t(t2, e2));
      }
      remove(t2) {
        return new zt(Kt(this.values, t2));
      }
      get(t2) {
        return this.values[t2];
      }
      has(t2) {
        return t2 in this.values;
      }
      merge(t2) {
        return new zt(Jt(this.values, $t(t2)));
      }
      slice(t2) {
        const e2 = {};
        return Array.from(t2).forEach((t3) => {
          this.has(t3) && (e2[t3] = this.values[t3]);
        }), new zt(e2);
      }
      getKeys() {
        return Object.keys(this.values);
      }
      getKeysCommonToHash(t2) {
        return t2 = Gt(t2), this.getKeys().filter((e2) => this.values[e2] === t2.values[e2]);
      }
      isEqualTo(t2) {
        return rt(this.toArray(), Gt(t2).toArray());
      }
      isEmpty() {
        return 0 === this.getKeys().length;
      }
      toArray() {
        if (!this.array) {
          const t2 = [];
          for (const e2 in this.values) {
            const i2 = this.values[e2];
            t2.push(t2.push(e2, i2));
          }
          this.array = t2.slice(0);
        }
        return this.array;
      }
      toObject() {
        return Kt(this.values);
      }
      toJSON() {
        return this.toObject();
      }
      contentsForInspection() {
        return { values: JSON.stringify(this.values) };
      }
    }
    const _t = function(t2, e2) {
      const i2 = {};
      return i2[t2] = e2, i2;
    }, Jt = function(t2, e2) {
      const i2 = Kt(t2);
      for (const t3 in e2) {
        const n2 = e2[t3];
        i2[t3] = n2;
      }
      return i2;
    }, Kt = function(t2, e2) {
      const i2 = {};
      return Object.keys(t2).sort().forEach((n2) => {
        n2 !== e2 && (i2[n2] = t2[n2]);
      }), i2;
    }, Gt = function(t2) {
      return t2 instanceof zt ? t2 : new zt(t2);
    }, $t = function(t2) {
      return t2 instanceof zt ? t2.values : t2;
    };
    class Xt {
      static groupObjects() {
        let t2, e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], { depth: i2, asTree: n2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        n2 && null == i2 && (i2 = 0);
        const r2 = [];
        return Array.from(e2).forEach((e3) => {
          var o2;
          if (t2) {
            var s2, a2, l2;
            if (null !== (s2 = e3.canBeGrouped) && void 0 !== s2 && s2.call(e3, i2) && null !== (a2 = (l2 = t2[t2.length - 1]).canBeGroupedWith) && void 0 !== a2 && a2.call(l2, e3, i2))
              return void t2.push(e3);
            r2.push(new this(t2, { depth: i2, asTree: n2 })), t2 = null;
          }
          null !== (o2 = e3.canBeGrouped) && void 0 !== o2 && o2.call(e3, i2) ? t2 = [e3] : r2.push(e3);
        }), t2 && r2.push(new this(t2, { depth: i2, asTree: n2 })), r2;
      }
      constructor() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], { depth: e2, asTree: i2 } = arguments.length > 1 ? arguments[1] : void 0;
        this.objects = t2, i2 && (this.depth = e2, this.objects = this.constructor.groupObjects(this.objects, { asTree: i2, depth: this.depth + 1 }));
      }
      getObjects() {
        return this.objects;
      }
      getDepth() {
        return this.depth;
      }
      getCacheKey() {
        const t2 = ["objectGroup"];
        return Array.from(this.getObjects()).forEach((e2) => {
          t2.push(e2.getCacheKey());
        }), t2.join("/");
      }
    }
    class Yt extends H {
      constructor() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        super(...arguments), this.objects = {}, Array.from(t2).forEach((t3) => {
          const e2 = JSON.stringify(t3);
          null == this.objects[e2] && (this.objects[e2] = t3);
        });
      }
      find(t2) {
        const e2 = JSON.stringify(t2);
        return this.objects[e2];
      }
    }
    class Qt {
      constructor(t2) {
        this.reset(t2);
      }
      add(t2) {
        const e2 = Zt(t2);
        this.elements[e2] = t2;
      }
      remove(t2) {
        const e2 = Zt(t2), i2 = this.elements[e2];
        if (i2)
          return delete this.elements[e2], i2;
      }
      reset() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        return this.elements = {}, Array.from(t2).forEach((t3) => {
          this.add(t3);
        }), t2;
      }
    }
    const Zt = (t2) => t2.dataset.trixStoreKey;
    class te extends H {
      isPerforming() {
        return true === this.performing;
      }
      hasPerformed() {
        return true === this.performed;
      }
      hasSucceeded() {
        return this.performed && this.succeeded;
      }
      hasFailed() {
        return this.performed && !this.succeeded;
      }
      getPromise() {
        return this.promise || (this.promise = new Promise((t2, e2) => (this.performing = true, this.perform((i2, n2) => {
          this.succeeded = i2, this.performing = false, this.performed = true, this.succeeded ? t2(n2) : e2(n2);
        })))), this.promise;
      }
      perform(t2) {
        return t2(false);
      }
      release() {
        var t2, e2;
        null === (t2 = this.promise) || void 0 === t2 || null === (e2 = t2.cancel) || void 0 === e2 || e2.call(t2), this.promise = null, this.performing = null, this.performed = null, this.succeeded = null;
      }
    }
    te.proxyMethod("getPromise().then"), te.proxyMethod("getPromise().catch");
    class ee extends H {
      constructor(t2) {
        let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        super(...arguments), this.object = t2, this.options = e2, this.childViews = [], this.rootView = this;
      }
      getNodes() {
        return this.nodes || (this.nodes = this.createNodes()), this.nodes.map((t2) => t2.cloneNode(true));
      }
      invalidate() {
        var t2;
        return this.nodes = null, this.childViews = [], null === (t2 = this.parentView) || void 0 === t2 ? void 0 : t2.invalidate();
      }
      invalidateViewForObject(t2) {
        var e2;
        return null === (e2 = this.findViewForObject(t2)) || void 0 === e2 ? void 0 : e2.invalidate();
      }
      findOrCreateCachedChildView(t2, e2, i2) {
        let n2 = this.getCachedViewForObject(e2);
        return n2 ? this.recordChildView(n2) : (n2 = this.createChildView(...arguments), this.cacheViewForObject(n2, e2)), n2;
      }
      createChildView(t2, e2) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        e2 instanceof Xt && (i2.viewClass = t2, t2 = ie);
        const n2 = new t2(e2, i2);
        return this.recordChildView(n2);
      }
      recordChildView(t2) {
        return t2.parentView = this, t2.rootView = this.rootView, this.childViews.push(t2), t2;
      }
      getAllChildViews() {
        let t2 = [];
        return this.childViews.forEach((e2) => {
          t2.push(e2), t2 = t2.concat(e2.getAllChildViews());
        }), t2;
      }
      findElement() {
        return this.findElementForObject(this.object);
      }
      findElementForObject(t2) {
        const e2 = null == t2 ? void 0 : t2.id;
        if (e2)
          return this.rootView.element.querySelector("[data-trix-id='".concat(e2, "']"));
      }
      findViewForObject(t2) {
        for (const e2 of this.getAllChildViews())
          if (e2.object === t2)
            return e2;
      }
      getViewCache() {
        return this.rootView !== this ? this.rootView.getViewCache() : this.isViewCachingEnabled() ? (this.viewCache || (this.viewCache = {}), this.viewCache) : void 0;
      }
      isViewCachingEnabled() {
        return false !== this.shouldCacheViews;
      }
      enableViewCaching() {
        this.shouldCacheViews = true;
      }
      disableViewCaching() {
        this.shouldCacheViews = false;
      }
      getCachedViewForObject(t2) {
        var e2;
        return null === (e2 = this.getViewCache()) || void 0 === e2 ? void 0 : e2[t2.getCacheKey()];
      }
      cacheViewForObject(t2, e2) {
        const i2 = this.getViewCache();
        i2 && (i2[e2.getCacheKey()] = t2);
      }
      garbageCollectCachedViews() {
        const t2 = this.getViewCache();
        if (t2) {
          const e2 = this.getAllChildViews().concat(this).map((t3) => t3.object.getCacheKey());
          for (const i2 in t2)
            e2.includes(i2) || delete t2[i2];
        }
      }
    }
    class ie extends ee {
      constructor() {
        super(...arguments), this.objectGroup = this.object, this.viewClass = this.options.viewClass, delete this.options.viewClass;
      }
      getChildViews() {
        return this.childViews.length || Array.from(this.objectGroup.getObjects()).forEach((t2) => {
          this.findOrCreateCachedChildView(this.viewClass, t2, this.options);
        }), this.childViews;
      }
      createNodes() {
        const t2 = this.createContainerElement();
        return this.getChildViews().forEach((e2) => {
          Array.from(e2.getNodes()).forEach((e3) => {
            t2.appendChild(e3);
          });
        }), [t2];
      }
      createContainerElement() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.objectGroup.getDepth();
        return this.getChildViews()[0].createContainerElement(t2);
      }
    }
    const { css: ne } = V;
    class re extends ee {
      constructor() {
        super(...arguments), this.attachment = this.object, this.attachment.uploadProgressDelegate = this, this.attachmentPiece = this.options.piece;
      }
      createContentNodes() {
        return [];
      }
      createNodes() {
        let t2;
        const e2 = t2 = S({ tagName: "figure", className: this.getClassName(), data: this.getData(), editable: false }), i2 = this.getHref();
        return i2 && (t2 = S({ tagName: "a", editable: false, attributes: { href: i2, tabindex: -1 } }), e2.appendChild(t2)), this.attachment.hasContent() ? t2.innerHTML = this.attachment.getContent() : this.createContentNodes().forEach((e3) => {
          t2.appendChild(e3);
        }), t2.appendChild(this.createCaptionElement()), this.attachment.isPending() && (this.progressElement = S({ tagName: "progress", attributes: { class: ne.attachmentProgress, value: this.attachment.getUploadProgress(), max: 100 }, data: { trixMutable: true, trixStoreKey: ["progressElement", this.attachment.id].join("/") } }), e2.appendChild(this.progressElement)), [oe("left"), e2, oe("right")];
      }
      createCaptionElement() {
        const t2 = S({ tagName: "figcaption", className: ne.attachmentCaption }), e2 = this.attachmentPiece.getCaption();
        if (e2)
          t2.classList.add("".concat(ne.attachmentCaption, "--edited")), t2.textContent = e2;
        else {
          let e3, i2;
          const n2 = this.getCaptionConfig();
          if (n2.name && (e3 = this.attachment.getFilename()), n2.size && (i2 = this.attachment.getFormattedFilesize()), e3) {
            const i3 = S({ tagName: "span", className: ne.attachmentName, textContent: e3 });
            t2.appendChild(i3);
          }
          if (i2) {
            e3 && t2.appendChild(document.createTextNode(" "));
            const n3 = S({ tagName: "span", className: ne.attachmentSize, textContent: i2 });
            t2.appendChild(n3);
          }
        }
        return t2;
      }
      getClassName() {
        const t2 = [ne.attachment, "".concat(ne.attachment, "--").concat(this.attachment.getType())], e2 = this.attachment.getExtension();
        return e2 && t2.push("".concat(ne.attachment, "--").concat(e2)), t2.join(" ");
      }
      getData() {
        const t2 = { trixAttachment: JSON.stringify(this.attachment), trixContentType: this.attachment.getContentType(), trixId: this.attachment.id }, { attributes: e2 } = this.attachmentPiece;
        return e2.isEmpty() || (t2.trixAttributes = JSON.stringify(e2)), this.attachment.isPending() && (t2.trixSerialize = false), t2;
      }
      getHref() {
        if (!se(this.attachment.getContent(), "a"))
          return this.attachment.getHref();
      }
      getCaptionConfig() {
        var t2;
        const e2 = this.attachment.getType(), n2 = Et(null === (t2 = i[e2]) || void 0 === t2 ? void 0 : t2.caption);
        return "file" === e2 && (n2.name = true), n2;
      }
      findProgressElement() {
        var t2;
        return null === (t2 = this.findElement()) || void 0 === t2 ? void 0 : t2.querySelector("progress");
      }
      attachmentDidChangeUploadProgress() {
        const t2 = this.attachment.getUploadProgress(), e2 = this.findProgressElement();
        e2 && (e2.value = t2);
      }
    }
    const oe = (t2) => S({ tagName: "span", textContent: h, data: { trixCursorTarget: t2, trixSerialize: false } }), se = function(t2, e2) {
      const i2 = S("div");
      return i2.innerHTML = t2 || "", i2.querySelector(e2);
    };
    class ae extends re {
      constructor() {
        super(...arguments), this.attachment.previewDelegate = this;
      }
      createContentNodes() {
        return this.image = S({ tagName: "img", attributes: { src: "" }, data: { trixMutable: true } }), this.refresh(this.image), [this.image];
      }
      createCaptionElement() {
        const t2 = super.createCaptionElement(...arguments);
        return t2.textContent || t2.setAttribute("data-trix-placeholder", l.captionPlaceholder), t2;
      }
      refresh(t2) {
        var e2;
        t2 || (t2 = null === (e2 = this.findElement()) || void 0 === e2 ? void 0 : e2.querySelector("img"));
        if (t2)
          return this.updateAttributesForImage(t2);
      }
      updateAttributesForImage(t2) {
        const e2 = this.attachment.getURL(), i2 = this.attachment.getPreviewURL();
        if (t2.src = i2 || e2, i2 === e2)
          t2.removeAttribute("data-trix-serialized-attributes");
        else {
          const i3 = JSON.stringify({ src: e2 });
          t2.setAttribute("data-trix-serialized-attributes", i3);
        }
        const n2 = this.attachment.getWidth(), r2 = this.attachment.getHeight();
        null != n2 && (t2.width = n2), null != r2 && (t2.height = r2);
        const o2 = ["imageElement", this.attachment.id, t2.src, t2.width, t2.height].join("/");
        t2.dataset.trixStoreKey = o2;
      }
      attachmentDidChangeAttributes() {
        return this.refresh(this.image), this.refresh();
      }
    }
    class le extends ee {
      constructor() {
        super(...arguments), this.piece = this.object, this.attributes = this.piece.getAttributes(), this.textConfig = this.options.textConfig, this.context = this.options.context, this.piece.attachment ? this.attachment = this.piece.attachment : this.string = this.piece.toString();
      }
      createNodes() {
        let t2 = this.attachment ? this.createAttachmentNodes() : this.createStringNodes();
        const e2 = this.createElement();
        if (e2) {
          const i2 = function(t3) {
            for (; null !== (e3 = t3) && void 0 !== e3 && e3.firstElementChild; ) {
              var e3;
              t3 = t3.firstElementChild;
            }
            return t3;
          }(e2);
          Array.from(t2).forEach((t3) => {
            i2.appendChild(t3);
          }), t2 = [e2];
        }
        return t2;
      }
      createAttachmentNodes() {
        const t2 = this.attachment.isPreviewable() ? ae : re;
        return this.createChildView(t2, this.piece.attachment, { piece: this.piece }).getNodes();
      }
      createStringNodes() {
        var t2;
        if (null !== (t2 = this.textConfig) && void 0 !== t2 && t2.plaintext)
          return [document.createTextNode(this.string)];
        {
          const t3 = [], e2 = this.string.split("\n");
          for (let i2 = 0; i2 < e2.length; i2++) {
            const n2 = e2[i2];
            if (i2 > 0) {
              const e3 = S("br");
              t3.push(e3);
            }
            if (n2.length) {
              const e3 = document.createTextNode(this.preserveSpaces(n2));
              t3.push(e3);
            }
          }
          return t3;
        }
      }
      createElement() {
        let t2, e2, i2;
        const n2 = {};
        for (e2 in this.attributes) {
          i2 = this.attributes[e2];
          const o2 = pt(e2);
          if (o2) {
            if (o2.tagName) {
              var r2;
              const e3 = S(o2.tagName);
              r2 ? (r2.appendChild(e3), r2 = e3) : t2 = r2 = e3;
            }
            if (o2.styleProperty && (n2[o2.styleProperty] = i2), o2.style)
              for (e2 in o2.style)
                i2 = o2.style[e2], n2[e2] = i2;
          }
        }
        if (Object.keys(n2).length)
          for (e2 in t2 || (t2 = S("span")), n2)
            i2 = n2[e2], t2.style[e2] = i2;
        return t2;
      }
      createContainerElement() {
        for (const t2 in this.attributes) {
          const e2 = this.attributes[t2], i2 = pt(t2);
          if (i2 && i2.groupTagName) {
            const n2 = {};
            return n2[t2] = e2, S(i2.groupTagName, n2);
          }
        }
      }
      preserveSpaces(t2) {
        return this.context.isLast && (t2 = t2.replace(/\ $/, d)), t2 = t2.replace(/(\S)\ {3}(\S)/g, "$1 ".concat(d, " $2")).replace(/\ {2}/g, "".concat(d, " ")).replace(/\ {2}/g, " ".concat(d)), (this.context.isFirst || this.context.followsWhitespace) && (t2 = t2.replace(/^\ /, d)), t2;
      }
    }
    class ce extends ee {
      constructor() {
        super(...arguments), this.text = this.object, this.textConfig = this.options.textConfig;
      }
      createNodes() {
        const t2 = [], e2 = Xt.groupObjects(this.getPieces()), i2 = e2.length - 1;
        for (let r2 = 0; r2 < e2.length; r2++) {
          const o2 = e2[r2], s2 = {};
          0 === r2 && (s2.isFirst = true), r2 === i2 && (s2.isLast = true), ue(n2) && (s2.followsWhitespace = true);
          const a2 = this.findOrCreateCachedChildView(le, o2, { textConfig: this.textConfig, context: s2 });
          t2.push(...Array.from(a2.getNodes() || []));
          var n2 = o2;
        }
        return t2;
      }
      getPieces() {
        return Array.from(this.text.getPieces()).filter((t2) => !t2.hasAttribute("blockBreak"));
      }
    }
    const ue = (t2) => /\s$/.test(null == t2 ? void 0 : t2.toString()), { css: he } = V;
    class de extends ee {
      constructor() {
        super(...arguments), this.block = this.object, this.attributes = this.block.getAttributes();
      }
      createNodes() {
        const t2 = [document.createComment("block")];
        if (this.block.isEmpty())
          t2.push(S("br"));
        else {
          var e2;
          const i2 = null === (e2 = gt(this.block.getLastAttribute())) || void 0 === e2 ? void 0 : e2.text, n2 = this.findOrCreateCachedChildView(ce, this.block.text, { textConfig: i2 });
          t2.push(...Array.from(n2.getNodes() || [])), this.shouldAddExtraNewlineElement() && t2.push(S("br"));
        }
        if (this.attributes.length)
          return t2;
        {
          let e3;
          const { tagName: i2 } = n.default;
          this.block.isRTL() && (e3 = { dir: "rtl" });
          const r2 = S({ tagName: i2, attributes: e3 });
          return t2.forEach((t3) => r2.appendChild(t3)), [r2];
        }
      }
      createContainerElement(t2) {
        const e2 = {};
        let i2;
        const n2 = this.attributes[t2], { tagName: r2, htmlAttributes: o2 = [] } = gt(n2);
        if (0 === t2 && this.block.isRTL() && Object.assign(e2, { dir: "rtl" }), "attachmentGallery" === n2) {
          const t3 = this.block.getBlockBreakPosition();
          i2 = "".concat(he.attachmentGallery, " ").concat(he.attachmentGallery, "--").concat(t3);
        }
        return Object.entries(this.block.htmlAttributes).forEach((t3) => {
          let [i3, n3] = t3;
          o2.includes(i3) && (e2[i3] = n3);
        }), S({ tagName: r2, className: i2, attributes: e2 });
      }
      shouldAddExtraNewlineElement() {
        return /\n\n$/.test(this.block.toString());
      }
    }
    class ge extends ee {
      static render(t2) {
        const e2 = S("div"), i2 = new this(t2, { element: e2 });
        return i2.render(), i2.sync(), e2;
      }
      constructor() {
        super(...arguments), this.element = this.options.element, this.elementStore = new Qt(), this.setDocument(this.object);
      }
      setDocument(t2) {
        t2.isEqualTo(this.document) || (this.document = this.object = t2);
      }
      render() {
        if (this.childViews = [], this.shadowElement = S("div"), !this.document.isEmpty()) {
          const t2 = Xt.groupObjects(this.document.getBlocks(), { asTree: true });
          Array.from(t2).forEach((t3) => {
            const e2 = this.findOrCreateCachedChildView(de, t3);
            Array.from(e2.getNodes()).map((t4) => this.shadowElement.appendChild(t4));
          });
        }
      }
      isSynced() {
        return pe(this.shadowElement, this.element);
      }
      sync() {
        const t2 = this.createDocumentFragmentForSync();
        for (; this.element.lastChild; )
          this.element.removeChild(this.element.lastChild);
        return this.element.appendChild(t2), this.didSync();
      }
      didSync() {
        return this.elementStore.reset(me(this.element)), Rt(() => this.garbageCollectCachedViews());
      }
      createDocumentFragmentForSync() {
        const t2 = document.createDocumentFragment();
        return Array.from(this.shadowElement.childNodes).forEach((e2) => {
          t2.appendChild(e2.cloneNode(true));
        }), Array.from(me(t2)).forEach((t3) => {
          const e2 = this.elementStore.remove(t3);
          e2 && t3.parentNode.replaceChild(e2, t3);
        }), t2;
      }
    }
    const me = (t2) => t2.querySelectorAll("[data-trix-store-key]"), pe = (t2, e2) => fe(t2.innerHTML) === fe(e2.innerHTML), fe = (t2) => t2.replace(/&nbsp;/g, " ");
    function Ae(t2, e2, i2) {
      return (e2 = xe(e2)) in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
    }
    function xe(t2) {
      var e2 = function(t3, e3) {
        if ("object" != typeof t3 || null === t3)
          return t3;
        var i2 = t3[Symbol.toPrimitive];
        if (void 0 !== i2) {
          var n2 = i2.call(t3, e3 || "default");
          if ("object" != typeof n2)
            return n2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === e3 ? String : Number)(t3);
      }(t2, "string");
      return "symbol" == typeof e2 ? e2 : String(e2);
    }
    class ye extends nt {
      static registerType(t2, e2) {
        e2.type = t2, this.types[t2] = e2;
      }
      static fromJSON(t2) {
        const e2 = this.types[t2.type];
        if (e2)
          return e2.fromJSON(t2);
      }
      constructor(t2) {
        let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        super(...arguments), this.attributes = zt.box(e2);
      }
      copyWithAttributes(t2) {
        return new this.constructor(this.getValue(), t2);
      }
      copyWithAdditionalAttributes(t2) {
        return this.copyWithAttributes(this.attributes.merge(t2));
      }
      copyWithoutAttribute(t2) {
        return this.copyWithAttributes(this.attributes.remove(t2));
      }
      copy() {
        return this.copyWithAttributes(this.attributes);
      }
      getAttribute(t2) {
        return this.attributes.get(t2);
      }
      getAttributesHash() {
        return this.attributes;
      }
      getAttributes() {
        return this.attributes.toObject();
      }
      hasAttribute(t2) {
        return this.attributes.has(t2);
      }
      hasSameStringValueAsPiece(t2) {
        return t2 && this.toString() === t2.toString();
      }
      hasSameAttributesAsPiece(t2) {
        return t2 && (this.attributes === t2.attributes || this.attributes.isEqualTo(t2.attributes));
      }
      isBlockBreak() {
        return false;
      }
      isEqualTo(t2) {
        return super.isEqualTo(...arguments) || this.hasSameConstructorAs(t2) && this.hasSameStringValueAsPiece(t2) && this.hasSameAttributesAsPiece(t2);
      }
      isEmpty() {
        return 0 === this.length;
      }
      isSerializable() {
        return true;
      }
      toJSON() {
        return { type: this.constructor.type, attributes: this.getAttributes() };
      }
      contentsForInspection() {
        return { type: this.constructor.type, attributes: this.attributes.inspect() };
      }
      canBeGrouped() {
        return this.hasAttribute("href");
      }
      canBeGroupedWith(t2) {
        return this.getAttribute("href") === t2.getAttribute("href");
      }
      getLength() {
        return this.length;
      }
      canBeConsolidatedWith(t2) {
        return false;
      }
    }
    Ae(ye, "types", {});
    class Ce extends te {
      constructor(t2) {
        super(...arguments), this.url = t2;
      }
      perform(t2) {
        const e2 = new Image();
        e2.onload = () => (e2.width = this.width = e2.naturalWidth, e2.height = this.height = e2.naturalHeight, t2(true, e2)), e2.onerror = () => t2(false), e2.src = this.url;
      }
    }
    class ke extends nt {
      static attachmentForFile(t2) {
        const e2 = new this(this.attributesForFile(t2));
        return e2.setFile(t2), e2;
      }
      static attributesForFile(t2) {
        return new zt({ filename: t2.name, filesize: t2.size, contentType: t2.type });
      }
      static fromJSON(t2) {
        return new this(t2);
      }
      constructor() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        super(t2), this.releaseFile = this.releaseFile.bind(this), this.attributes = zt.box(t2), this.didChangeAttributes();
      }
      getAttribute(t2) {
        return this.attributes.get(t2);
      }
      hasAttribute(t2) {
        return this.attributes.has(t2);
      }
      getAttributes() {
        return this.attributes.toObject();
      }
      setAttributes() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const e2 = this.attributes.merge(t2);
        var i2, n2, r2, o2;
        if (!this.attributes.isEqualTo(e2))
          return this.attributes = e2, this.didChangeAttributes(), null === (i2 = this.previewDelegate) || void 0 === i2 || null === (n2 = i2.attachmentDidChangeAttributes) || void 0 === n2 || n2.call(i2, this), null === (r2 = this.delegate) || void 0 === r2 || null === (o2 = r2.attachmentDidChangeAttributes) || void 0 === o2 ? void 0 : o2.call(r2, this);
      }
      didChangeAttributes() {
        if (this.isPreviewable())
          return this.preloadURL();
      }
      isPending() {
        return null != this.file && !(this.getURL() || this.getHref());
      }
      isPreviewable() {
        return this.attributes.has("previewable") ? this.attributes.get("previewable") : ke.previewablePattern.test(this.getContentType());
      }
      getType() {
        return this.hasContent() ? "content" : this.isPreviewable() ? "preview" : "file";
      }
      getURL() {
        return this.attributes.get("url");
      }
      getHref() {
        return this.attributes.get("href");
      }
      getFilename() {
        return this.attributes.get("filename") || "";
      }
      getFilesize() {
        return this.attributes.get("filesize");
      }
      getFormattedFilesize() {
        const t2 = this.attributes.get("filesize");
        return "number" == typeof t2 ? u.formatter(t2) : "";
      }
      getExtension() {
        var t2;
        return null === (t2 = this.getFilename().match(/\.(\w+)$/)) || void 0 === t2 ? void 0 : t2[1].toLowerCase();
      }
      getContentType() {
        return this.attributes.get("contentType");
      }
      hasContent() {
        return this.attributes.has("content");
      }
      getContent() {
        return this.attributes.get("content");
      }
      getWidth() {
        return this.attributes.get("width");
      }
      getHeight() {
        return this.attributes.get("height");
      }
      getFile() {
        return this.file;
      }
      setFile(t2) {
        if (this.file = t2, this.isPreviewable())
          return this.preloadFile();
      }
      releaseFile() {
        this.releasePreloadedFile(), this.file = null;
      }
      getUploadProgress() {
        return null != this.uploadProgress ? this.uploadProgress : 0;
      }
      setUploadProgress(t2) {
        var e2, i2;
        if (this.uploadProgress !== t2)
          return this.uploadProgress = t2, null === (e2 = this.uploadProgressDelegate) || void 0 === e2 || null === (i2 = e2.attachmentDidChangeUploadProgress) || void 0 === i2 ? void 0 : i2.call(e2, this);
      }
      toJSON() {
        return this.getAttributes();
      }
      getCacheKey() {
        return [super.getCacheKey(...arguments), this.attributes.getCacheKey(), this.getPreviewURL()].join("/");
      }
      getPreviewURL() {
        return this.previewURL || this.preloadingURL;
      }
      setPreviewURL(t2) {
        var e2, i2, n2, r2;
        if (t2 !== this.getPreviewURL())
          return this.previewURL = t2, null === (e2 = this.previewDelegate) || void 0 === e2 || null === (i2 = e2.attachmentDidChangeAttributes) || void 0 === i2 || i2.call(e2, this), null === (n2 = this.delegate) || void 0 === n2 || null === (r2 = n2.attachmentDidChangePreviewURL) || void 0 === r2 ? void 0 : r2.call(n2, this);
      }
      preloadURL() {
        return this.preload(this.getURL(), this.releaseFile);
      }
      preloadFile() {
        if (this.file)
          return this.fileObjectURL = URL.createObjectURL(this.file), this.preload(this.fileObjectURL);
      }
      releasePreloadedFile() {
        this.fileObjectURL && (URL.revokeObjectURL(this.fileObjectURL), this.fileObjectURL = null);
      }
      preload(t2, e2) {
        if (t2 && t2 !== this.getPreviewURL()) {
          this.preloadingURL = t2;
          return new Ce(t2).then((i2) => {
            let { width: n2, height: r2 } = i2;
            return this.getWidth() && this.getHeight() || this.setAttributes({ width: n2, height: r2 }), this.preloadingURL = null, this.setPreviewURL(t2), null == e2 ? void 0 : e2();
          }).catch(() => (this.preloadingURL = null, null == e2 ? void 0 : e2()));
        }
      }
    }
    Ae(ke, "previewablePattern", /^image(\/(gif|png|webp|jpe?g)|$)/);
    class Re extends ye {
      static fromJSON(t2) {
        return new this(ke.fromJSON(t2.attachment), t2.attributes);
      }
      constructor(t2) {
        super(...arguments), this.attachment = t2, this.length = 1, this.ensureAttachmentExclusivelyHasAttribute("href"), this.attachment.hasContent() || this.removeProhibitedAttributes();
      }
      ensureAttachmentExclusivelyHasAttribute(t2) {
        this.hasAttribute(t2) && (this.attachment.hasAttribute(t2) || this.attachment.setAttributes(this.attributes.slice([t2])), this.attributes = this.attributes.remove(t2));
      }
      removeProhibitedAttributes() {
        const t2 = this.attributes.slice(Re.permittedAttributes);
        t2.isEqualTo(this.attributes) || (this.attributes = t2);
      }
      getValue() {
        return this.attachment;
      }
      isSerializable() {
        return !this.attachment.isPending();
      }
      getCaption() {
        return this.attributes.get("caption") || "";
      }
      isEqualTo(t2) {
        var e2;
        return super.isEqualTo(t2) && this.attachment.id === (null == t2 || null === (e2 = t2.attachment) || void 0 === e2 ? void 0 : e2.id);
      }
      toString() {
        return "￼";
      }
      toJSON() {
        const t2 = super.toJSON(...arguments);
        return t2.attachment = this.attachment, t2;
      }
      getCacheKey() {
        return [super.getCacheKey(...arguments), this.attachment.getCacheKey()].join("/");
      }
      toConsole() {
        return JSON.stringify(this.toString());
      }
    }
    Ae(Re, "permittedAttributes", ["caption", "presentation"]), ye.registerType("attachment", Re);
    class Ee extends ye {
      static fromJSON(t2) {
        return new this(t2.string, t2.attributes);
      }
      constructor(t2) {
        super(...arguments), this.string = ((t3) => t3.replace(/\r\n?/g, "\n"))(t2), this.length = this.string.length;
      }
      getValue() {
        return this.string;
      }
      toString() {
        return this.string.toString();
      }
      isBlockBreak() {
        return "\n" === this.toString() && true === this.getAttribute("blockBreak");
      }
      toJSON() {
        const t2 = super.toJSON(...arguments);
        return t2.string = this.string, t2;
      }
      canBeConsolidatedWith(t2) {
        return t2 && this.hasSameConstructorAs(t2) && this.hasSameAttributesAsPiece(t2);
      }
      consolidateWith(t2) {
        return new this.constructor(this.toString() + t2.toString(), this.attributes);
      }
      splitAtOffset(t2) {
        let e2, i2;
        return 0 === t2 ? (e2 = null, i2 = this) : t2 === this.length ? (e2 = this, i2 = null) : (e2 = new this.constructor(this.string.slice(0, t2), this.attributes), i2 = new this.constructor(this.string.slice(t2), this.attributes)), [e2, i2];
      }
      toConsole() {
        let { string: t2 } = this;
        return t2.length > 15 && (t2 = t2.slice(0, 14) + "…"), JSON.stringify(t2.toString());
      }
    }
    ye.registerType("string", Ee);
    class Se extends nt {
      static box(t2) {
        return t2 instanceof this ? t2 : new this(t2);
      }
      constructor() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        super(...arguments), this.objects = t2.slice(0), this.length = this.objects.length;
      }
      indexOf(t2) {
        return this.objects.indexOf(t2);
      }
      splice() {
        for (var t2 = arguments.length, e2 = new Array(t2), i2 = 0; i2 < t2; i2++)
          e2[i2] = arguments[i2];
        return new this.constructor(ot(this.objects, ...e2));
      }
      eachObject(t2) {
        return this.objects.map((e2, i2) => t2(e2, i2));
      }
      insertObjectAtIndex(t2, e2) {
        return this.splice(e2, 0, t2);
      }
      insertSplittableListAtIndex(t2, e2) {
        return this.splice(e2, 0, ...t2.objects);
      }
      insertSplittableListAtPosition(t2, e2) {
        const [i2, n2] = this.splitObjectAtPosition(e2);
        return new this.constructor(i2).insertSplittableListAtIndex(t2, n2);
      }
      editObjectAtIndex(t2, e2) {
        return this.replaceObjectAtIndex(e2(this.objects[t2]), t2);
      }
      replaceObjectAtIndex(t2, e2) {
        return this.splice(e2, 1, t2);
      }
      removeObjectAtIndex(t2) {
        return this.splice(t2, 1);
      }
      getObjectAtIndex(t2) {
        return this.objects[t2];
      }
      getSplittableListInRange(t2) {
        const [e2, i2, n2] = this.splitObjectsAtRange(t2);
        return new this.constructor(e2.slice(i2, n2 + 1));
      }
      selectSplittableList(t2) {
        const e2 = this.objects.filter((e3) => t2(e3));
        return new this.constructor(e2);
      }
      removeObjectsInRange(t2) {
        const [e2, i2, n2] = this.splitObjectsAtRange(t2);
        return new this.constructor(e2).splice(i2, n2 - i2 + 1);
      }
      transformObjectsInRange(t2, e2) {
        const [i2, n2, r2] = this.splitObjectsAtRange(t2), o2 = i2.map((t3, i3) => n2 <= i3 && i3 <= r2 ? e2(t3) : t3);
        return new this.constructor(o2);
      }
      splitObjectsAtRange(t2) {
        let e2, [i2, n2, r2] = this.splitObjectAtPosition(De(t2));
        return [i2, e2] = new this.constructor(i2).splitObjectAtPosition(we(t2) + r2), [i2, n2, e2 - 1];
      }
      getObjectAtPosition(t2) {
        const { index: e2 } = this.findIndexAndOffsetAtPosition(t2);
        return this.objects[e2];
      }
      splitObjectAtPosition(t2) {
        let e2, i2;
        const { index: n2, offset: r2 } = this.findIndexAndOffsetAtPosition(t2), o2 = this.objects.slice(0);
        if (null != n2)
          if (0 === r2)
            e2 = n2, i2 = 0;
          else {
            const t3 = this.getObjectAtIndex(n2), [s2, a2] = t3.splitAtOffset(r2);
            o2.splice(n2, 1, s2, a2), e2 = n2 + 1, i2 = s2.getLength() - r2;
          }
        else
          e2 = o2.length, i2 = 0;
        return [o2, e2, i2];
      }
      consolidate() {
        const t2 = [];
        let e2 = this.objects[0];
        return this.objects.slice(1).forEach((i2) => {
          var n2, r2;
          null !== (n2 = (r2 = e2).canBeConsolidatedWith) && void 0 !== n2 && n2.call(r2, i2) ? e2 = e2.consolidateWith(i2) : (t2.push(e2), e2 = i2);
        }), e2 && t2.push(e2), new this.constructor(t2);
      }
      consolidateFromIndexToIndex(t2, e2) {
        const i2 = this.objects.slice(0).slice(t2, e2 + 1), n2 = new this.constructor(i2).consolidate().toArray();
        return this.splice(t2, i2.length, ...n2);
      }
      findIndexAndOffsetAtPosition(t2) {
        let e2, i2 = 0;
        for (e2 = 0; e2 < this.objects.length; e2++) {
          const n2 = i2 + this.objects[e2].getLength();
          if (i2 <= t2 && t2 < n2)
            return { index: e2, offset: t2 - i2 };
          i2 = n2;
        }
        return { index: null, offset: null };
      }
      findPositionAtIndexAndOffset(t2, e2) {
        let i2 = 0;
        for (let n2 = 0; n2 < this.objects.length; n2++) {
          const r2 = this.objects[n2];
          if (n2 < t2)
            i2 += r2.getLength();
          else if (n2 === t2) {
            i2 += e2;
            break;
          }
        }
        return i2;
      }
      getEndPosition() {
        return null == this.endPosition && (this.endPosition = 0, this.objects.forEach((t2) => this.endPosition += t2.getLength())), this.endPosition;
      }
      toString() {
        return this.objects.join("");
      }
      toArray() {
        return this.objects.slice(0);
      }
      toJSON() {
        return this.toArray();
      }
      isEqualTo(t2) {
        return super.isEqualTo(...arguments) || Le(this.objects, null == t2 ? void 0 : t2.objects);
      }
      contentsForInspection() {
        return { objects: "[".concat(this.objects.map((t2) => t2.inspect()).join(", "), "]") };
      }
    }
    const Le = function(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
      if (t2.length !== e2.length)
        return false;
      let i2 = true;
      for (let n2 = 0; n2 < t2.length; n2++) {
        const r2 = t2[n2];
        i2 && !r2.isEqualTo(e2[n2]) && (i2 = false);
      }
      return i2;
    }, De = (t2) => t2[0], we = (t2) => t2[1];
    class Te extends nt {
      static textForAttachmentWithAttributes(t2, e2) {
        return new this([new Re(t2, e2)]);
      }
      static textForStringWithAttributes(t2, e2) {
        return new this([new Ee(t2, e2)]);
      }
      static fromJSON(t2) {
        return new this(Array.from(t2).map((t3) => ye.fromJSON(t3)));
      }
      constructor() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        super(...arguments);
        const e2 = t2.filter((t3) => !t3.isEmpty());
        this.pieceList = new Se(e2);
      }
      copy() {
        return this.copyWithPieceList(this.pieceList);
      }
      copyWithPieceList(t2) {
        return new this.constructor(t2.consolidate().toArray());
      }
      copyUsingObjectMap(t2) {
        const e2 = this.getPieces().map((e3) => t2.find(e3) || e3);
        return new this.constructor(e2);
      }
      appendText(t2) {
        return this.insertTextAtPosition(t2, this.getLength());
      }
      insertTextAtPosition(t2, e2) {
        return this.copyWithPieceList(this.pieceList.insertSplittableListAtPosition(t2.pieceList, e2));
      }
      removeTextAtRange(t2) {
        return this.copyWithPieceList(this.pieceList.removeObjectsInRange(t2));
      }
      replaceTextAtRange(t2, e2) {
        return this.removeTextAtRange(e2).insertTextAtPosition(t2, e2[0]);
      }
      moveTextFromRangeToPosition(t2, e2) {
        if (t2[0] <= e2 && e2 <= t2[1])
          return;
        const i2 = this.getTextAtRange(t2), n2 = i2.getLength();
        return t2[0] < e2 && (e2 -= n2), this.removeTextAtRange(t2).insertTextAtPosition(i2, e2);
      }
      addAttributeAtRange(t2, e2, i2) {
        const n2 = {};
        return n2[t2] = e2, this.addAttributesAtRange(n2, i2);
      }
      addAttributesAtRange(t2, e2) {
        return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e2, (e3) => e3.copyWithAdditionalAttributes(t2)));
      }
      removeAttributeAtRange(t2, e2) {
        return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e2, (e3) => e3.copyWithoutAttribute(t2)));
      }
      setAttributesAtRange(t2, e2) {
        return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e2, (e3) => e3.copyWithAttributes(t2)));
      }
      getAttributesAtPosition(t2) {
        var e2;
        return (null === (e2 = this.pieceList.getObjectAtPosition(t2)) || void 0 === e2 ? void 0 : e2.getAttributes()) || {};
      }
      getCommonAttributes() {
        const t2 = Array.from(this.pieceList.toArray()).map((t3) => t3.getAttributes());
        return zt.fromCommonAttributesOfObjects(t2).toObject();
      }
      getCommonAttributesAtRange(t2) {
        return this.getTextAtRange(t2).getCommonAttributes() || {};
      }
      getExpandedRangeForAttributeAtOffset(t2, e2) {
        let i2, n2 = i2 = e2;
        const r2 = this.getLength();
        for (; n2 > 0 && this.getCommonAttributesAtRange([n2 - 1, i2])[t2]; )
          n2--;
        for (; i2 < r2 && this.getCommonAttributesAtRange([e2, i2 + 1])[t2]; )
          i2++;
        return [n2, i2];
      }
      getTextAtRange(t2) {
        return this.copyWithPieceList(this.pieceList.getSplittableListInRange(t2));
      }
      getStringAtRange(t2) {
        return this.pieceList.getSplittableListInRange(t2).toString();
      }
      getStringAtPosition(t2) {
        return this.getStringAtRange([t2, t2 + 1]);
      }
      startsWithString(t2) {
        return this.getStringAtRange([0, t2.length]) === t2;
      }
      endsWithString(t2) {
        const e2 = this.getLength();
        return this.getStringAtRange([e2 - t2.length, e2]) === t2;
      }
      getAttachmentPieces() {
        return this.pieceList.toArray().filter((t2) => !!t2.attachment);
      }
      getAttachments() {
        return this.getAttachmentPieces().map((t2) => t2.attachment);
      }
      getAttachmentAndPositionById(t2) {
        let e2 = 0;
        for (const n2 of this.pieceList.toArray()) {
          var i2;
          if ((null === (i2 = n2.attachment) || void 0 === i2 ? void 0 : i2.id) === t2)
            return { attachment: n2.attachment, position: e2 };
          e2 += n2.length;
        }
        return { attachment: null, position: null };
      }
      getAttachmentById(t2) {
        const { attachment: e2 } = this.getAttachmentAndPositionById(t2);
        return e2;
      }
      getRangeOfAttachment(t2) {
        const e2 = this.getAttachmentAndPositionById(t2.id), i2 = e2.position;
        if (t2 = e2.attachment)
          return [i2, i2 + 1];
      }
      updateAttributesForAttachment(t2, e2) {
        const i2 = this.getRangeOfAttachment(e2);
        return i2 ? this.addAttributesAtRange(t2, i2) : this;
      }
      getLength() {
        return this.pieceList.getEndPosition();
      }
      isEmpty() {
        return 0 === this.getLength();
      }
      isEqualTo(t2) {
        var e2;
        return super.isEqualTo(t2) || (null == t2 || null === (e2 = t2.pieceList) || void 0 === e2 ? void 0 : e2.isEqualTo(this.pieceList));
      }
      isBlockBreak() {
        return 1 === this.getLength() && this.pieceList.getObjectAtIndex(0).isBlockBreak();
      }
      eachPiece(t2) {
        return this.pieceList.eachObject(t2);
      }
      getPieces() {
        return this.pieceList.toArray();
      }
      getPieceAtPosition(t2) {
        return this.pieceList.getObjectAtPosition(t2);
      }
      contentsForInspection() {
        return { pieceList: this.pieceList.inspect() };
      }
      toSerializableText() {
        const t2 = this.pieceList.selectSplittableList((t3) => t3.isSerializable());
        return this.copyWithPieceList(t2);
      }
      toString() {
        return this.pieceList.toString();
      }
      toJSON() {
        return this.pieceList.toJSON();
      }
      toConsole() {
        return JSON.stringify(this.pieceList.toArray().map((t2) => JSON.parse(t2.toConsole())));
      }
      getDirection() {
        return at(this.toString());
      }
      isRTL() {
        return "rtl" === this.getDirection();
      }
    }
    class Be extends nt {
      static fromJSON(t2) {
        return new this(Te.fromJSON(t2.text), t2.attributes, t2.htmlAttributes);
      }
      constructor(t2, e2, i2) {
        super(...arguments), this.text = Fe(t2 || new Te()), this.attributes = e2 || [], this.htmlAttributes = i2 || {};
      }
      isEmpty() {
        return this.text.isBlockBreak();
      }
      isEqualTo(t2) {
        return !!super.isEqualTo(t2) || this.text.isEqualTo(null == t2 ? void 0 : t2.text) && rt(this.attributes, null == t2 ? void 0 : t2.attributes) && St(this.htmlAttributes, null == t2 ? void 0 : t2.htmlAttributes);
      }
      copyWithText(t2) {
        return new Be(t2, this.attributes, this.htmlAttributes);
      }
      copyWithoutText() {
        return this.copyWithText(null);
      }
      copyWithAttributes(t2) {
        return new Be(this.text, t2, this.htmlAttributes);
      }
      copyWithoutAttributes() {
        return this.copyWithAttributes(null);
      }
      copyUsingObjectMap(t2) {
        const e2 = t2.find(this.text);
        return e2 ? this.copyWithText(e2) : this.copyWithText(this.text.copyUsingObjectMap(t2));
      }
      addAttribute(t2) {
        const e2 = this.attributes.concat(je(t2));
        return this.copyWithAttributes(e2);
      }
      addHTMLAttribute(t2, e2) {
        const i2 = Object.assign({}, this.htmlAttributes, { [t2]: e2 });
        return new Be(this.text, this.attributes, i2);
      }
      removeAttribute(t2) {
        const { listAttribute: e2 } = gt(t2), i2 = Ue(Ue(this.attributes, t2), e2);
        return this.copyWithAttributes(i2);
      }
      removeLastAttribute() {
        return this.removeAttribute(this.getLastAttribute());
      }
      getLastAttribute() {
        return We(this.attributes);
      }
      getAttributes() {
        return this.attributes.slice(0);
      }
      getAttributeLevel() {
        return this.attributes.length;
      }
      getAttributeAtLevel(t2) {
        return this.attributes[t2 - 1];
      }
      hasAttribute(t2) {
        return this.attributes.includes(t2);
      }
      hasAttributes() {
        return this.getAttributeLevel() > 0;
      }
      getLastNestableAttribute() {
        return We(this.getNestableAttributes());
      }
      getNestableAttributes() {
        return this.attributes.filter((t2) => gt(t2).nestable);
      }
      getNestingLevel() {
        return this.getNestableAttributes().length;
      }
      decreaseNestingLevel() {
        const t2 = this.getLastNestableAttribute();
        return t2 ? this.removeAttribute(t2) : this;
      }
      increaseNestingLevel() {
        const t2 = this.getLastNestableAttribute();
        if (t2) {
          const e2 = this.attributes.lastIndexOf(t2), i2 = ot(this.attributes, e2 + 1, 0, ...je(t2));
          return this.copyWithAttributes(i2);
        }
        return this;
      }
      getListItemAttributes() {
        return this.attributes.filter((t2) => gt(t2).listAttribute);
      }
      isListItem() {
        var t2;
        return null === (t2 = gt(this.getLastAttribute())) || void 0 === t2 ? void 0 : t2.listAttribute;
      }
      isTerminalBlock() {
        var t2;
        return null === (t2 = gt(this.getLastAttribute())) || void 0 === t2 ? void 0 : t2.terminal;
      }
      breaksOnReturn() {
        var t2;
        return null === (t2 = gt(this.getLastAttribute())) || void 0 === t2 ? void 0 : t2.breakOnReturn;
      }
      findLineBreakInDirectionFromPosition(t2, e2) {
        const i2 = this.toString();
        let n2;
        switch (t2) {
          case "forward":
            n2 = i2.indexOf("\n", e2);
            break;
          case "backward":
            n2 = i2.slice(0, e2).lastIndexOf("\n");
        }
        if (-1 !== n2)
          return n2;
      }
      contentsForInspection() {
        return { text: this.text.inspect(), attributes: this.attributes };
      }
      toString() {
        return this.text.toString();
      }
      toJSON() {
        return { text: this.text, attributes: this.attributes, htmlAttributes: this.htmlAttributes };
      }
      getDirection() {
        return this.text.getDirection();
      }
      isRTL() {
        return this.text.isRTL();
      }
      getLength() {
        return this.text.getLength();
      }
      canBeConsolidatedWith(t2) {
        return !this.hasAttributes() && !t2.hasAttributes() && this.getDirection() === t2.getDirection();
      }
      consolidateWith(t2) {
        const e2 = Te.textForStringWithAttributes("\n"), i2 = this.getTextWithoutBlockBreak().appendText(e2);
        return this.copyWithText(i2.appendText(t2.text));
      }
      splitAtOffset(t2) {
        let e2, i2;
        return 0 === t2 ? (e2 = null, i2 = this) : t2 === this.getLength() ? (e2 = this, i2 = null) : (e2 = this.copyWithText(this.text.getTextAtRange([0, t2])), i2 = this.copyWithText(this.text.getTextAtRange([t2, this.getLength()]))), [e2, i2];
      }
      getBlockBreakPosition() {
        return this.text.getLength() - 1;
      }
      getTextWithoutBlockBreak() {
        return Oe(this.text) ? this.text.getTextAtRange([0, this.getBlockBreakPosition()]) : this.text.copy();
      }
      canBeGrouped(t2) {
        return this.attributes[t2];
      }
      canBeGroupedWith(t2, e2) {
        const i2 = t2.getAttributes(), r2 = i2[e2], o2 = this.attributes[e2];
        return o2 === r2 && !(false === gt(o2).group && !(() => {
          if (!ht) {
            ht = [];
            for (const t3 in n) {
              const { listAttribute: e3 } = n[t3];
              null != e3 && ht.push(e3);
            }
          }
          return ht;
        })().includes(i2[e2 + 1])) && (this.getDirection() === t2.getDirection() || t2.isEmpty());
      }
    }
    const Fe = function(t2) {
      return t2 = Pe(t2), t2 = Ne(t2);
    }, Pe = function(t2) {
      let e2 = false;
      const i2 = t2.getPieces();
      let n2 = i2.slice(0, i2.length - 1);
      const r2 = i2[i2.length - 1];
      return r2 ? (n2 = n2.map((t3) => t3.isBlockBreak() ? (e2 = true, Me(t3)) : t3), e2 ? new Te([...n2, r2]) : t2) : t2;
    }, Ie = Te.textForStringWithAttributes("\n", { blockBreak: true }), Ne = function(t2) {
      return Oe(t2) ? t2 : t2.appendText(Ie);
    }, Oe = function(t2) {
      const e2 = t2.getLength();
      if (0 === e2)
        return false;
      return t2.getTextAtRange([e2 - 1, e2]).isBlockBreak();
    }, Me = (t2) => t2.copyWithoutAttribute("blockBreak"), je = function(t2) {
      const { listAttribute: e2 } = gt(t2);
      return e2 ? [e2, t2] : [t2];
    }, We = (t2) => t2.slice(-1)[0], Ue = function(t2, e2) {
      const i2 = t2.lastIndexOf(e2);
      return -1 === i2 ? t2 : ot(t2, i2, 1);
    };
    class qe extends nt {
      static fromJSON(t2) {
        return new this(Array.from(t2).map((t3) => Be.fromJSON(t3)));
      }
      static fromString(t2, e2) {
        const i2 = Te.textForStringWithAttributes(t2, e2);
        return new this([new Be(i2)]);
      }
      constructor() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        super(...arguments), 0 === t2.length && (t2 = [new Be()]), this.blockList = Se.box(t2);
      }
      isEmpty() {
        const t2 = this.getBlockAtIndex(0);
        return 1 === this.blockList.length && t2.isEmpty() && !t2.hasAttributes();
      }
      copy() {
        const t2 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).consolidateBlocks ? this.blockList.consolidate().toArray() : this.blockList.toArray();
        return new this.constructor(t2);
      }
      copyUsingObjectsFromDocument(t2) {
        const e2 = new Yt(t2.getObjects());
        return this.copyUsingObjectMap(e2);
      }
      copyUsingObjectMap(t2) {
        const e2 = this.getBlocks().map((e3) => t2.find(e3) || e3.copyUsingObjectMap(t2));
        return new this.constructor(e2);
      }
      copyWithBaseBlockAttributes() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        const e2 = this.getBlocks().map((e3) => {
          const i2 = t2.concat(e3.getAttributes());
          return e3.copyWithAttributes(i2);
        });
        return new this.constructor(e2);
      }
      replaceBlock(t2, e2) {
        const i2 = this.blockList.indexOf(t2);
        return -1 === i2 ? this : new this.constructor(this.blockList.replaceObjectAtIndex(e2, i2));
      }
      insertDocumentAtRange(t2, e2) {
        const { blockList: i2 } = t2;
        e2 = Lt(e2);
        let [n2] = e2;
        const { index: r2, offset: o2 } = this.locationFromPosition(n2);
        let s2 = this;
        const a2 = this.getBlockAtPosition(n2);
        return Dt(e2) && a2.isEmpty() && !a2.hasAttributes() ? s2 = new this.constructor(s2.blockList.removeObjectAtIndex(r2)) : a2.getBlockBreakPosition() === o2 && n2++, s2 = s2.removeTextAtRange(e2), new this.constructor(s2.blockList.insertSplittableListAtPosition(i2, n2));
      }
      mergeDocumentAtRange(t2, e2) {
        let i2, n2;
        e2 = Lt(e2);
        const [r2] = e2, o2 = this.locationFromPosition(r2), s2 = this.getBlockAtIndex(o2.index).getAttributes(), a2 = t2.getBaseBlockAttributes(), l2 = s2.slice(-a2.length);
        if (rt(a2, l2)) {
          const e3 = s2.slice(0, -a2.length);
          i2 = t2.copyWithBaseBlockAttributes(e3);
        } else
          i2 = t2.copy({ consolidateBlocks: true }).copyWithBaseBlockAttributes(s2);
        const c2 = i2.getBlockCount(), u2 = i2.getBlockAtIndex(0);
        if (rt(s2, u2.getAttributes())) {
          const t3 = u2.getTextWithoutBlockBreak();
          if (n2 = this.insertTextAtRange(t3, e2), c2 > 1) {
            i2 = new this.constructor(i2.getBlocks().slice(1));
            const e3 = r2 + t3.getLength();
            n2 = n2.insertDocumentAtRange(i2, e3);
          }
        } else
          n2 = this.insertDocumentAtRange(i2, e2);
        return n2;
      }
      insertTextAtRange(t2, e2) {
        e2 = Lt(e2);
        const [i2] = e2, { index: n2, offset: r2 } = this.locationFromPosition(i2), o2 = this.removeTextAtRange(e2);
        return new this.constructor(o2.blockList.editObjectAtIndex(n2, (e3) => e3.copyWithText(e3.text.insertTextAtPosition(t2, r2))));
      }
      removeTextAtRange(t2) {
        let e2;
        t2 = Lt(t2);
        const [i2, n2] = t2;
        if (Dt(t2))
          return this;
        const [r2, o2] = Array.from(this.locationRangeFromRange(t2)), s2 = r2.index, a2 = r2.offset, l2 = this.getBlockAtIndex(s2), c2 = o2.index, u2 = o2.offset, h2 = this.getBlockAtIndex(c2);
        if (n2 - i2 == 1 && l2.getBlockBreakPosition() === a2 && h2.getBlockBreakPosition() !== u2 && "\n" === h2.text.getStringAtPosition(u2))
          e2 = this.blockList.editObjectAtIndex(c2, (t3) => t3.copyWithText(t3.text.removeTextAtRange([u2, u2 + 1])));
        else {
          let t3;
          const i3 = l2.text.getTextAtRange([0, a2]), n3 = h2.text.getTextAtRange([u2, h2.getLength()]), r3 = i3.appendText(n3);
          t3 = s2 !== c2 && 0 === a2 && l2.getAttributeLevel() >= h2.getAttributeLevel() ? h2.copyWithText(r3) : l2.copyWithText(r3);
          const o3 = c2 + 1 - s2;
          e2 = this.blockList.splice(s2, o3, t3);
        }
        return new this.constructor(e2);
      }
      moveTextFromRangeToPosition(t2, e2) {
        let i2;
        t2 = Lt(t2);
        const [n2, r2] = t2;
        if (n2 <= e2 && e2 <= r2)
          return this;
        let o2 = this.getDocumentAtRange(t2), s2 = this.removeTextAtRange(t2);
        const a2 = n2 < e2;
        a2 && (e2 -= o2.getLength());
        const [l2, ...c2] = o2.getBlocks();
        return 0 === c2.length ? (i2 = l2.getTextWithoutBlockBreak(), a2 && (e2 += 1)) : i2 = l2.text, s2 = s2.insertTextAtRange(i2, e2), 0 === c2.length ? s2 : (o2 = new this.constructor(c2), e2 += i2.getLength(), s2.insertDocumentAtRange(o2, e2));
      }
      addAttributeAtRange(t2, e2, i2) {
        let { blockList: n2 } = this;
        return this.eachBlockAtRange(i2, (i3, r2, o2) => n2 = n2.editObjectAtIndex(o2, function() {
          return gt(t2) ? i3.addAttribute(t2, e2) : r2[0] === r2[1] ? i3 : i3.copyWithText(i3.text.addAttributeAtRange(t2, e2, r2));
        })), new this.constructor(n2);
      }
      addAttribute(t2, e2) {
        let { blockList: i2 } = this;
        return this.eachBlock((n2, r2) => i2 = i2.editObjectAtIndex(r2, () => n2.addAttribute(t2, e2))), new this.constructor(i2);
      }
      removeAttributeAtRange(t2, e2) {
        let { blockList: i2 } = this;
        return this.eachBlockAtRange(e2, function(e3, n2, r2) {
          gt(t2) ? i2 = i2.editObjectAtIndex(r2, () => e3.removeAttribute(t2)) : n2[0] !== n2[1] && (i2 = i2.editObjectAtIndex(r2, () => e3.copyWithText(e3.text.removeAttributeAtRange(t2, n2))));
        }), new this.constructor(i2);
      }
      updateAttributesForAttachment(t2, e2) {
        const i2 = this.getRangeOfAttachment(e2), [n2] = Array.from(i2), { index: r2 } = this.locationFromPosition(n2), o2 = this.getTextAtIndex(r2);
        return new this.constructor(this.blockList.editObjectAtIndex(r2, (i3) => i3.copyWithText(o2.updateAttributesForAttachment(t2, e2))));
      }
      removeAttributeForAttachment(t2, e2) {
        const i2 = this.getRangeOfAttachment(e2);
        return this.removeAttributeAtRange(t2, i2);
      }
      setHTMLAttributeAtPosition(t2, e2, i2) {
        const n2 = this.getBlockAtPosition(t2), r2 = n2.addHTMLAttribute(e2, i2);
        return this.replaceBlock(n2, r2);
      }
      insertBlockBreakAtRange(t2) {
        let e2;
        t2 = Lt(t2);
        const [i2] = t2, { offset: n2 } = this.locationFromPosition(i2), r2 = this.removeTextAtRange(t2);
        return 0 === n2 && (e2 = [new Be()]), new this.constructor(r2.blockList.insertSplittableListAtPosition(new Se(e2), i2));
      }
      applyBlockAttributeAtRange(t2, e2, i2) {
        const n2 = this.expandRangeToLineBreaksAndSplitBlocks(i2);
        let r2 = n2.document;
        i2 = n2.range;
        const o2 = gt(t2);
        if (o2.listAttribute) {
          r2 = r2.removeLastListAttributeAtRange(i2, { exceptAttributeName: t2 });
          const e3 = r2.convertLineBreaksToBlockBreaksInRange(i2);
          r2 = e3.document, i2 = e3.range;
        } else
          r2 = o2.exclusive ? r2.removeBlockAttributesAtRange(i2) : o2.terminal ? r2.removeLastTerminalAttributeAtRange(i2) : r2.consolidateBlocksAtRange(i2);
        return r2.addAttributeAtRange(t2, e2, i2);
      }
      removeLastListAttributeAtRange(t2) {
        let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, { blockList: i2 } = this;
        return this.eachBlockAtRange(t2, function(t3, n2, r2) {
          const o2 = t3.getLastAttribute();
          o2 && gt(o2).listAttribute && o2 !== e2.exceptAttributeName && (i2 = i2.editObjectAtIndex(r2, () => t3.removeAttribute(o2)));
        }), new this.constructor(i2);
      }
      removeLastTerminalAttributeAtRange(t2) {
        let { blockList: e2 } = this;
        return this.eachBlockAtRange(t2, function(t3, i2, n2) {
          const r2 = t3.getLastAttribute();
          r2 && gt(r2).terminal && (e2 = e2.editObjectAtIndex(n2, () => t3.removeAttribute(r2)));
        }), new this.constructor(e2);
      }
      removeBlockAttributesAtRange(t2) {
        let { blockList: e2 } = this;
        return this.eachBlockAtRange(t2, function(t3, i2, n2) {
          t3.hasAttributes() && (e2 = e2.editObjectAtIndex(n2, () => t3.copyWithoutAttributes()));
        }), new this.constructor(e2);
      }
      expandRangeToLineBreaksAndSplitBlocks(t2) {
        let e2;
        t2 = Lt(t2);
        let [i2, n2] = t2;
        const r2 = this.locationFromPosition(i2), o2 = this.locationFromPosition(n2);
        let s2 = this;
        const a2 = s2.getBlockAtIndex(r2.index);
        if (r2.offset = a2.findLineBreakInDirectionFromPosition("backward", r2.offset), null != r2.offset && (e2 = s2.positionFromLocation(r2), s2 = s2.insertBlockBreakAtRange([e2, e2 + 1]), o2.index += 1, o2.offset -= s2.getBlockAtIndex(r2.index).getLength(), r2.index += 1), r2.offset = 0, 0 === o2.offset && o2.index > r2.index)
          o2.index -= 1, o2.offset = s2.getBlockAtIndex(o2.index).getBlockBreakPosition();
        else {
          const t3 = s2.getBlockAtIndex(o2.index);
          "\n" === t3.text.getStringAtRange([o2.offset - 1, o2.offset]) ? o2.offset -= 1 : o2.offset = t3.findLineBreakInDirectionFromPosition("forward", o2.offset), o2.offset !== t3.getBlockBreakPosition() && (e2 = s2.positionFromLocation(o2), s2 = s2.insertBlockBreakAtRange([e2, e2 + 1]));
        }
        return i2 = s2.positionFromLocation(r2), n2 = s2.positionFromLocation(o2), { document: s2, range: t2 = Lt([i2, n2]) };
      }
      convertLineBreaksToBlockBreaksInRange(t2) {
        t2 = Lt(t2);
        let [e2] = t2;
        const i2 = this.getStringAtRange(t2).slice(0, -1);
        let n2 = this;
        return i2.replace(/.*?\n/g, function(t3) {
          e2 += t3.length, n2 = n2.insertBlockBreakAtRange([e2 - 1, e2]);
        }), { document: n2, range: t2 };
      }
      consolidateBlocksAtRange(t2) {
        t2 = Lt(t2);
        const [e2, i2] = t2, n2 = this.locationFromPosition(e2).index, r2 = this.locationFromPosition(i2).index;
        return new this.constructor(this.blockList.consolidateFromIndexToIndex(n2, r2));
      }
      getDocumentAtRange(t2) {
        t2 = Lt(t2);
        const e2 = this.blockList.getSplittableListInRange(t2).toArray();
        return new this.constructor(e2);
      }
      getStringAtRange(t2) {
        let e2;
        const i2 = t2 = Lt(t2);
        return i2[i2.length - 1] !== this.getLength() && (e2 = -1), this.getDocumentAtRange(t2).toString().slice(0, e2);
      }
      getBlockAtIndex(t2) {
        return this.blockList.getObjectAtIndex(t2);
      }
      getBlockAtPosition(t2) {
        const { index: e2 } = this.locationFromPosition(t2);
        return this.getBlockAtIndex(e2);
      }
      getTextAtIndex(t2) {
        var e2;
        return null === (e2 = this.getBlockAtIndex(t2)) || void 0 === e2 ? void 0 : e2.text;
      }
      getTextAtPosition(t2) {
        const { index: e2 } = this.locationFromPosition(t2);
        return this.getTextAtIndex(e2);
      }
      getPieceAtPosition(t2) {
        const { index: e2, offset: i2 } = this.locationFromPosition(t2);
        return this.getTextAtIndex(e2).getPieceAtPosition(i2);
      }
      getCharacterAtPosition(t2) {
        const { index: e2, offset: i2 } = this.locationFromPosition(t2);
        return this.getTextAtIndex(e2).getStringAtRange([i2, i2 + 1]);
      }
      getLength() {
        return this.blockList.getEndPosition();
      }
      getBlocks() {
        return this.blockList.toArray();
      }
      getBlockCount() {
        return this.blockList.length;
      }
      getEditCount() {
        return this.editCount;
      }
      eachBlock(t2) {
        return this.blockList.eachObject(t2);
      }
      eachBlockAtRange(t2, e2) {
        let i2, n2;
        t2 = Lt(t2);
        const [r2, o2] = t2, s2 = this.locationFromPosition(r2), a2 = this.locationFromPosition(o2);
        if (s2.index === a2.index)
          return i2 = this.getBlockAtIndex(s2.index), n2 = [s2.offset, a2.offset], e2(i2, n2, s2.index);
        for (let t3 = s2.index; t3 <= a2.index; t3++)
          if (i2 = this.getBlockAtIndex(t3), i2) {
            switch (t3) {
              case s2.index:
                n2 = [s2.offset, i2.text.getLength()];
                break;
              case a2.index:
                n2 = [0, a2.offset];
                break;
              default:
                n2 = [0, i2.text.getLength()];
            }
            e2(i2, n2, t3);
          }
      }
      getCommonAttributesAtRange(t2) {
        t2 = Lt(t2);
        const [e2] = t2;
        if (Dt(t2))
          return this.getCommonAttributesAtPosition(e2);
        {
          const e3 = [], i2 = [];
          return this.eachBlockAtRange(t2, function(t3, n2) {
            if (n2[0] !== n2[1])
              return e3.push(t3.text.getCommonAttributesAtRange(n2)), i2.push(Ve(t3));
          }), zt.fromCommonAttributesOfObjects(e3).merge(zt.fromCommonAttributesOfObjects(i2)).toObject();
        }
      }
      getCommonAttributesAtPosition(t2) {
        let e2, i2;
        const { index: n2, offset: r2 } = this.locationFromPosition(t2), o2 = this.getBlockAtIndex(n2);
        if (!o2)
          return {};
        const s2 = Ve(o2), a2 = o2.text.getAttributesAtPosition(r2), l2 = o2.text.getAttributesAtPosition(r2 - 1), c2 = Object.keys(W).filter((t3) => W[t3].inheritable);
        for (e2 in l2)
          i2 = l2[e2], (i2 === a2[e2] || c2.includes(e2)) && (s2[e2] = i2);
        return s2;
      }
      getRangeOfCommonAttributeAtPosition(t2, e2) {
        const { index: i2, offset: n2 } = this.locationFromPosition(e2), r2 = this.getTextAtIndex(i2), [o2, s2] = Array.from(r2.getExpandedRangeForAttributeAtOffset(t2, n2)), a2 = this.positionFromLocation({ index: i2, offset: o2 }), l2 = this.positionFromLocation({ index: i2, offset: s2 });
        return Lt([a2, l2]);
      }
      getBaseBlockAttributes() {
        let t2 = this.getBlockAtIndex(0).getAttributes();
        for (let e2 = 1; e2 < this.getBlockCount(); e2++) {
          const i2 = this.getBlockAtIndex(e2).getAttributes(), n2 = Math.min(t2.length, i2.length);
          t2 = (() => {
            const e3 = [];
            for (let r2 = 0; r2 < n2 && i2[r2] === t2[r2]; r2++)
              e3.push(i2[r2]);
            return e3;
          })();
        }
        return t2;
      }
      getAttachmentById(t2) {
        for (const e2 of this.getAttachments())
          if (e2.id === t2)
            return e2;
      }
      getAttachmentPieces() {
        let t2 = [];
        return this.blockList.eachObject((e2) => {
          let { text: i2 } = e2;
          return t2 = t2.concat(i2.getAttachmentPieces());
        }), t2;
      }
      getAttachments() {
        return this.getAttachmentPieces().map((t2) => t2.attachment);
      }
      getRangeOfAttachment(t2) {
        let e2 = 0;
        const i2 = this.blockList.toArray();
        for (let n2 = 0; n2 < i2.length; n2++) {
          const { text: r2 } = i2[n2], o2 = r2.getRangeOfAttachment(t2);
          if (o2)
            return Lt([e2 + o2[0], e2 + o2[1]]);
          e2 += r2.getLength();
        }
      }
      getLocationRangeOfAttachment(t2) {
        const e2 = this.getRangeOfAttachment(t2);
        return this.locationRangeFromRange(e2);
      }
      getAttachmentPieceForAttachment(t2) {
        for (const e2 of this.getAttachmentPieces())
          if (e2.attachment === t2)
            return e2;
      }
      findRangesForBlockAttribute(t2) {
        let e2 = 0;
        const i2 = [];
        return this.getBlocks().forEach((n2) => {
          const r2 = n2.getLength();
          n2.hasAttribute(t2) && i2.push([e2, e2 + r2]), e2 += r2;
        }), i2;
      }
      findRangesForTextAttribute(t2) {
        let { withValue: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = 0, n2 = [];
        const r2 = [];
        return this.getPieces().forEach((o2) => {
          const s2 = o2.getLength();
          (function(i3) {
            return e2 ? i3.getAttribute(t2) === e2 : i3.hasAttribute(t2);
          })(o2) && (n2[1] === i2 ? n2[1] = i2 + s2 : r2.push(n2 = [i2, i2 + s2])), i2 += s2;
        }), r2;
      }
      locationFromPosition(t2) {
        const e2 = this.blockList.findIndexAndOffsetAtPosition(Math.max(0, t2));
        if (null != e2.index)
          return e2;
        {
          const t3 = this.getBlocks();
          return { index: t3.length - 1, offset: t3[t3.length - 1].getLength() };
        }
      }
      positionFromLocation(t2) {
        return this.blockList.findPositionAtIndexAndOffset(t2.index, t2.offset);
      }
      locationRangeFromPosition(t2) {
        return Lt(this.locationFromPosition(t2));
      }
      locationRangeFromRange(t2) {
        if (!(t2 = Lt(t2)))
          return;
        const [e2, i2] = Array.from(t2), n2 = this.locationFromPosition(e2), r2 = this.locationFromPosition(i2);
        return Lt([n2, r2]);
      }
      rangeFromLocationRange(t2) {
        let e2;
        t2 = Lt(t2);
        const i2 = this.positionFromLocation(t2[0]);
        return Dt(t2) || (e2 = this.positionFromLocation(t2[1])), Lt([i2, e2]);
      }
      isEqualTo(t2) {
        return this.blockList.isEqualTo(null == t2 ? void 0 : t2.blockList);
      }
      getTexts() {
        return this.getBlocks().map((t2) => t2.text);
      }
      getPieces() {
        const t2 = [];
        return Array.from(this.getTexts()).forEach((e2) => {
          t2.push(...Array.from(e2.getPieces() || []));
        }), t2;
      }
      getObjects() {
        return this.getBlocks().concat(this.getTexts()).concat(this.getPieces());
      }
      toSerializableDocument() {
        const t2 = [];
        return this.blockList.eachObject((e2) => t2.push(e2.copyWithText(e2.text.toSerializableText()))), new this.constructor(t2);
      }
      toString() {
        return this.blockList.toString();
      }
      toJSON() {
        return this.blockList.toJSON();
      }
      toConsole() {
        return JSON.stringify(this.blockList.toArray().map((t2) => JSON.parse(t2.text.toConsole())));
      }
    }
    const Ve = function(t2) {
      const e2 = {}, i2 = t2.getLastAttribute();
      return i2 && (e2[i2] = true), e2;
    }, He = "style href src width height language class".split(" "), ze = "javascript:".split(" "), _e = "script iframe form noscript".split(" ");
    class Je extends H {
      static sanitize(t2, e2) {
        const i2 = new this(t2, e2);
        return i2.sanitize(), i2;
      }
      constructor(t2) {
        let { allowedAttributes: e2, forbiddenProtocols: i2, forbiddenElements: n2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        super(...arguments), this.allowedAttributes = e2 || He, this.forbiddenProtocols = i2 || ze, this.forbiddenElements = n2 || _e, this.body = Ke(t2);
      }
      sanitize() {
        return this.sanitizeElements(), this.normalizeListElementNesting();
      }
      getHTML() {
        return this.body.innerHTML;
      }
      getBody() {
        return this.body;
      }
      sanitizeElements() {
        const t2 = R(this.body), e2 = [];
        for (; t2.nextNode(); ) {
          const i2 = t2.currentNode;
          switch (i2.nodeType) {
            case Node.ELEMENT_NODE:
              this.elementIsRemovable(i2) ? e2.push(i2) : this.sanitizeElement(i2);
              break;
            case Node.COMMENT_NODE:
              e2.push(i2);
          }
        }
        return e2.forEach((t3) => k(t3)), this.body;
      }
      sanitizeElement(t2) {
        return t2.hasAttribute("href") && this.forbiddenProtocols.includes(t2.protocol) && t2.removeAttribute("href"), Array.from(t2.attributes).forEach((e2) => {
          let { name: i2 } = e2;
          this.allowedAttributes.includes(i2) || 0 === i2.indexOf("data-trix") || t2.removeAttribute(i2);
        }), t2;
      }
      normalizeListElementNesting() {
        return Array.from(this.body.querySelectorAll("ul,ol")).forEach((t2) => {
          const e2 = t2.previousElementSibling;
          e2 && "li" === E(e2) && e2.appendChild(t2);
        }), this.body;
      }
      elementIsRemovable(t2) {
        if ((null == t2 ? void 0 : t2.nodeType) === Node.ELEMENT_NODE)
          return this.elementIsForbidden(t2) || this.elementIsntSerializable(t2);
      }
      elementIsForbidden(t2) {
        return this.forbiddenElements.includes(E(t2));
      }
      elementIsntSerializable(t2) {
        return "false" === t2.getAttribute("data-trix-serialize") && !I(t2);
      }
    }
    const Ke = function() {
      let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
      t2 = t2.replace(/<\/html[^>]*>[^]*$/i, "</html>");
      const e2 = document.implementation.createHTMLDocument("");
      return e2.documentElement.innerHTML = t2, Array.from(e2.head.querySelectorAll("style")).forEach((t3) => {
        e2.body.appendChild(t3);
      }), e2.body;
    }, Ge = function(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return { string: t2 = Wt(t2), attributes: e2, type: "string" };
    }, $e = (t2, e2) => {
      try {
        const i2 = JSON.parse(t2.getAttribute("data-trix-".concat(e2)));
        return "text/html" === i2.contentType && i2.content && (i2.content = Je.sanitize(i2.content).getHTML()), i2;
      } catch (t3) {
        return {};
      }
    };
    class Xe extends H {
      static parse(t2, e2) {
        const i2 = new this(t2, e2);
        return i2.parse(), i2;
      }
      constructor(t2) {
        let { referenceElement: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        super(...arguments), this.html = t2, this.referenceElement = e2, this.blocks = [], this.blockElements = [], this.processedElements = [];
      }
      getDocument() {
        return qe.fromJSON(this.blocks);
      }
      parse() {
        try {
          this.createHiddenContainer();
          const t2 = Je.sanitize(this.html).getHTML();
          this.containerElement.innerHTML = t2;
          const e2 = R(this.containerElement, { usingFilter: ti });
          for (; e2.nextNode(); )
            this.processNode(e2.currentNode);
          return this.translateBlockElementMarginsToNewlines();
        } finally {
          this.removeHiddenContainer();
        }
      }
      createHiddenContainer() {
        return this.referenceElement ? (this.containerElement = this.referenceElement.cloneNode(false), this.containerElement.removeAttribute("id"), this.containerElement.setAttribute("data-trix-internal", ""), this.containerElement.style.display = "none", this.referenceElement.parentNode.insertBefore(this.containerElement, this.referenceElement.nextSibling)) : (this.containerElement = S({ tagName: "div", style: { display: "none" } }), document.body.appendChild(this.containerElement));
      }
      removeHiddenContainer() {
        return k(this.containerElement);
      }
      processNode(t2) {
        switch (t2.nodeType) {
          case Node.TEXT_NODE:
            if (!this.isInsignificantTextNode(t2))
              return this.appendBlockForTextNode(t2), this.processTextNode(t2);
            break;
          case Node.ELEMENT_NODE:
            return this.appendBlockForElement(t2), this.processElement(t2);
        }
      }
      appendBlockForTextNode(t2) {
        const e2 = t2.parentNode;
        if (e2 === this.currentBlockElement && this.isBlockElement(t2.previousSibling))
          return this.appendStringWithAttributes("\n");
        if (e2 === this.containerElement || this.isBlockElement(e2)) {
          var i2;
          const t3 = this.getBlockAttributes(e2), n2 = this.getBlockHTMLAttributes(e2);
          rt(t3, null === (i2 = this.currentBlock) || void 0 === i2 ? void 0 : i2.attributes) || (this.currentBlock = this.appendBlockForAttributesWithElement(t3, e2, n2), this.currentBlockElement = e2);
        }
      }
      appendBlockForElement(t2) {
        const e2 = this.isBlockElement(t2), i2 = y(this.currentBlockElement, t2);
        if (e2 && !this.isBlockElement(t2.firstChild)) {
          if (!this.isInsignificantTextNode(t2.firstChild) || !this.isBlockElement(t2.firstElementChild)) {
            const e3 = this.getBlockAttributes(t2), n2 = this.getBlockHTMLAttributes(t2);
            if (t2.firstChild) {
              if (i2 && rt(e3, this.currentBlock.attributes))
                return this.appendStringWithAttributes("\n");
              this.currentBlock = this.appendBlockForAttributesWithElement(e3, t2, n2), this.currentBlockElement = t2;
            }
          }
        } else if (this.currentBlockElement && !i2 && !e2) {
          const e3 = this.findParentBlockElement(t2);
          if (e3)
            return this.appendBlockForElement(e3);
          this.currentBlock = this.appendEmptyBlock(), this.currentBlockElement = null;
        }
      }
      findParentBlockElement(t2) {
        let { parentElement: e2 } = t2;
        for (; e2 && e2 !== this.containerElement; ) {
          if (this.isBlockElement(e2) && this.blockElements.includes(e2))
            return e2;
          e2 = e2.parentElement;
        }
        return null;
      }
      processTextNode(t2) {
        let e2 = t2.data;
        var i2;
        Ye(t2.parentNode) || (e2 = qt(e2), ni(null === (i2 = t2.previousSibling) || void 0 === i2 ? void 0 : i2.textContent) && (e2 = ei(e2)));
        return this.appendStringWithAttributes(e2, this.getTextAttributes(t2.parentNode));
      }
      processElement(t2) {
        let e2;
        if (I(t2)) {
          if (e2 = $e(t2, "attachment"), Object.keys(e2).length) {
            const i2 = this.getTextAttributes(t2);
            this.appendAttachmentWithAttributes(e2, i2), t2.innerHTML = "";
          }
          return this.processedElements.push(t2);
        }
        switch (E(t2)) {
          case "br":
            return this.isExtraBR(t2) || this.isBlockElement(t2.nextSibling) || this.appendStringWithAttributes("\n", this.getTextAttributes(t2)), this.processedElements.push(t2);
          case "img":
            e2 = { url: t2.getAttribute("src"), contentType: "image" };
            const i2 = ((t3) => {
              const e3 = t3.getAttribute("width"), i3 = t3.getAttribute("height"), n2 = {};
              return e3 && (n2.width = parseInt(e3, 10)), i3 && (n2.height = parseInt(i3, 10)), n2;
            })(t2);
            for (const t3 in i2) {
              const n2 = i2[t3];
              e2[t3] = n2;
            }
            return this.appendAttachmentWithAttributes(e2, this.getTextAttributes(t2)), this.processedElements.push(t2);
          case "tr":
            if (this.needsTableSeparator(t2))
              return this.appendStringWithAttributes(j.tableRowSeparator);
            break;
          case "td":
            if (this.needsTableSeparator(t2))
              return this.appendStringWithAttributes(j.tableCellSeparator);
        }
      }
      appendBlockForAttributesWithElement(t2, e2) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        this.blockElements.push(e2);
        const n2 = function() {
          return { text: [], attributes: arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, htmlAttributes: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {} };
        }(t2, i2);
        return this.blocks.push(n2), n2;
      }
      appendEmptyBlock() {
        return this.appendBlockForAttributesWithElement([], null);
      }
      appendStringWithAttributes(t2, e2) {
        return this.appendPiece(Ge(t2, e2));
      }
      appendAttachmentWithAttributes(t2, e2) {
        return this.appendPiece(function(t3) {
          return { attachment: t3, attributes: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, type: "attachment" };
        }(t2, e2));
      }
      appendPiece(t2) {
        return 0 === this.blocks.length && this.appendEmptyBlock(), this.blocks[this.blocks.length - 1].text.push(t2);
      }
      appendStringToTextAtIndex(t2, e2) {
        const { text: i2 } = this.blocks[e2], n2 = i2[i2.length - 1];
        if ("string" !== (null == n2 ? void 0 : n2.type))
          return i2.push(Ge(t2));
        n2.string += t2;
      }
      prependStringToTextAtIndex(t2, e2) {
        const { text: i2 } = this.blocks[e2], n2 = i2[0];
        if ("string" !== (null == n2 ? void 0 : n2.type))
          return i2.unshift(Ge(t2));
        n2.string = t2 + n2.string;
      }
      getTextAttributes(t2) {
        let e2;
        const i2 = {};
        for (const n2 in W) {
          const r2 = W[n2];
          if (r2.tagName && A(t2, { matchingSelector: r2.tagName, untilNode: this.containerElement }))
            i2[n2] = true;
          else if (r2.parser) {
            if (e2 = r2.parser(t2), e2) {
              let o2 = false;
              for (const i3 of this.findBlockElementAncestors(t2))
                if (r2.parser(i3) === e2) {
                  o2 = true;
                  break;
                }
              o2 || (i2[n2] = e2);
            }
          } else
            r2.styleProperty && (e2 = t2.style[r2.styleProperty], e2 && (i2[n2] = e2));
        }
        if (I(t2)) {
          const n2 = $e(t2, "attributes");
          for (const t3 in n2)
            e2 = n2[t3], i2[t3] = e2;
        }
        return i2;
      }
      getBlockAttributes(t2) {
        const e2 = [];
        for (; t2 && t2 !== this.containerElement; ) {
          for (const r2 in n) {
            const o2 = n[r2];
            var i2;
            if (false !== o2.parse) {
              if (E(t2) === o2.tagName)
                (null !== (i2 = o2.test) && void 0 !== i2 && i2.call(o2, t2) || !o2.test) && (e2.push(r2), o2.listAttribute && e2.push(o2.listAttribute));
            }
          }
          t2 = t2.parentNode;
        }
        return e2.reverse();
      }
      getBlockHTMLAttributes(t2) {
        const e2 = {}, i2 = Object.values(n).find((e3) => e3.tagName === E(t2));
        return ((null == i2 ? void 0 : i2.htmlAttributes) || []).forEach((i3) => {
          t2.hasAttribute(i3) && (e2[i3] = t2.getAttribute(i3));
        }), e2;
      }
      findBlockElementAncestors(t2) {
        const e2 = [];
        for (; t2 && t2 !== this.containerElement; ) {
          const i2 = E(t2);
          D().includes(i2) && e2.push(t2), t2 = t2.parentNode;
        }
        return e2;
      }
      isBlockElement(t2) {
        if ((null == t2 ? void 0 : t2.nodeType) === Node.ELEMENT_NODE && !I(t2) && !A(t2, { matchingSelector: "td", untilNode: this.containerElement }))
          return D().includes(E(t2)) || "block" === window.getComputedStyle(t2).display;
      }
      isInsignificantTextNode(t2) {
        if ((null == t2 ? void 0 : t2.nodeType) !== Node.TEXT_NODE)
          return;
        if (!ii(t2.data))
          return;
        const { parentNode: e2, previousSibling: i2, nextSibling: n2 } = t2;
        return Qe(e2.previousSibling) && !this.isBlockElement(e2.previousSibling) || Ye(e2) ? void 0 : !i2 || this.isBlockElement(i2) || !n2 || this.isBlockElement(n2);
      }
      isExtraBR(t2) {
        return "br" === E(t2) && this.isBlockElement(t2.parentNode) && t2.parentNode.lastChild === t2;
      }
      needsTableSeparator(t2) {
        if (j.removeBlankTableCells) {
          var e2;
          const i2 = null === (e2 = t2.previousSibling) || void 0 === e2 ? void 0 : e2.textContent;
          return i2 && /\S/.test(i2);
        }
        return t2.previousSibling;
      }
      translateBlockElementMarginsToNewlines() {
        const t2 = this.getMarginOfDefaultBlockElement();
        for (let e2 = 0; e2 < this.blocks.length; e2++) {
          const i2 = this.getMarginOfBlockElementAtIndex(e2);
          i2 && (i2.top > 2 * t2.top && this.prependStringToTextAtIndex("\n", e2), i2.bottom > 2 * t2.bottom && this.appendStringToTextAtIndex("\n", e2));
        }
      }
      getMarginOfBlockElementAtIndex(t2) {
        const e2 = this.blockElements[t2];
        if (e2 && e2.textContent && !D().includes(E(e2)) && !this.processedElements.includes(e2))
          return Ze(e2);
      }
      getMarginOfDefaultBlockElement() {
        const t2 = S(n.default.tagName);
        return this.containerElement.appendChild(t2), Ze(t2);
      }
    }
    const Ye = function(t2) {
      const { whiteSpace: e2 } = window.getComputedStyle(t2);
      return ["pre", "pre-wrap", "pre-line"].includes(e2);
    }, Qe = (t2) => t2 && !ni(t2.textContent), Ze = function(t2) {
      const e2 = window.getComputedStyle(t2);
      if ("block" === e2.display)
        return { top: parseInt(e2.marginTop), bottom: parseInt(e2.marginBottom) };
    }, ti = function(t2) {
      return "style" === E(t2) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
    }, ei = (t2) => t2.replace(new RegExp("^".concat(Ut.source, "+")), ""), ii = (t2) => new RegExp("^".concat(Ut.source, "*$")).test(t2), ni = (t2) => /\s$/.test(t2), ri = ["contenteditable", "data-trix-id", "data-trix-store-key", "data-trix-mutable", "data-trix-placeholder", "tabindex"], oi = "data-trix-serialized-attributes", si = "[".concat(oi, "]"), ai = new RegExp("<!--block-->", "g"), li = { "application/json": function(t2) {
      let e2;
      if (t2 instanceof qe)
        e2 = t2;
      else {
        if (!(t2 instanceof HTMLElement))
          throw new Error("unserializable object");
        e2 = Xe.parse(t2.innerHTML).getDocument();
      }
      return e2.toSerializableDocument().toJSONString();
    }, "text/html": function(t2) {
      let e2;
      if (t2 instanceof qe)
        e2 = ge.render(t2);
      else {
        if (!(t2 instanceof HTMLElement))
          throw new Error("unserializable object");
        e2 = t2.cloneNode(true);
      }
      return Array.from(e2.querySelectorAll("[data-trix-serialize=false]")).forEach((t3) => {
        k(t3);
      }), ri.forEach((t3) => {
        Array.from(e2.querySelectorAll("[".concat(t3, "]"))).forEach((e3) => {
          e3.removeAttribute(t3);
        });
      }), Array.from(e2.querySelectorAll(si)).forEach((t3) => {
        try {
          const e3 = JSON.parse(t3.getAttribute(oi));
          t3.removeAttribute(oi);
          for (const i2 in e3) {
            const n2 = e3[i2];
            t3.setAttribute(i2, n2);
          }
        } catch (t4) {
        }
      }), e2.innerHTML.replace(ai, "");
    } };
    var ci = Object.freeze({ __proto__: null });
    class ui extends H {
      constructor(t2, e2) {
        super(...arguments), this.attachmentManager = t2, this.attachment = e2, this.id = this.attachment.id, this.file = this.attachment.file;
      }
      remove() {
        return this.attachmentManager.requestRemovalOfAttachment(this.attachment);
      }
    }
    ui.proxyMethod("attachment.getAttribute"), ui.proxyMethod("attachment.hasAttribute"), ui.proxyMethod("attachment.setAttribute"), ui.proxyMethod("attachment.getAttributes"), ui.proxyMethod("attachment.setAttributes"), ui.proxyMethod("attachment.isPending"), ui.proxyMethod("attachment.isPreviewable"), ui.proxyMethod("attachment.getURL"), ui.proxyMethod("attachment.getHref"), ui.proxyMethod("attachment.getFilename"), ui.proxyMethod("attachment.getFilesize"), ui.proxyMethod("attachment.getFormattedFilesize"), ui.proxyMethod("attachment.getExtension"), ui.proxyMethod("attachment.getContentType"), ui.proxyMethod("attachment.getFile"), ui.proxyMethod("attachment.setFile"), ui.proxyMethod("attachment.releaseFile"), ui.proxyMethod("attachment.getUploadProgress"), ui.proxyMethod("attachment.setUploadProgress");
    class hi extends H {
      constructor() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        super(...arguments), this.managedAttachments = {}, Array.from(t2).forEach((t3) => {
          this.manageAttachment(t3);
        });
      }
      getAttachments() {
        const t2 = [];
        for (const e2 in this.managedAttachments) {
          const i2 = this.managedAttachments[e2];
          t2.push(i2);
        }
        return t2;
      }
      manageAttachment(t2) {
        return this.managedAttachments[t2.id] || (this.managedAttachments[t2.id] = new ui(this, t2)), this.managedAttachments[t2.id];
      }
      attachmentIsManaged(t2) {
        return t2.id in this.managedAttachments;
      }
      requestRemovalOfAttachment(t2) {
        var e2, i2;
        if (this.attachmentIsManaged(t2))
          return null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.attachmentManagerDidRequestRemovalOfAttachment) || void 0 === i2 ? void 0 : i2.call(e2, t2);
      }
      unmanageAttachment(t2) {
        const e2 = this.managedAttachments[t2.id];
        return delete this.managedAttachments[t2.id], e2;
      }
    }
    class di {
      constructor(t2) {
        this.composition = t2, this.document = this.composition.document;
        const e2 = this.composition.getSelectedRange();
        this.startPosition = e2[0], this.endPosition = e2[1], this.startLocation = this.document.locationFromPosition(this.startPosition), this.endLocation = this.document.locationFromPosition(this.endPosition), this.block = this.document.getBlockAtIndex(this.endLocation.index), this.breaksOnReturn = this.block.breaksOnReturn(), this.previousCharacter = this.block.text.getStringAtPosition(this.endLocation.offset - 1), this.nextCharacter = this.block.text.getStringAtPosition(this.endLocation.offset);
      }
      shouldInsertBlockBreak() {
        return this.block.hasAttributes() && this.block.isListItem() && !this.block.isEmpty() ? 0 !== this.startLocation.offset : this.breaksOnReturn && "\n" !== this.nextCharacter;
      }
      shouldBreakFormattedBlock() {
        return this.block.hasAttributes() && !this.block.isListItem() && (this.breaksOnReturn && "\n" === this.nextCharacter || "\n" === this.previousCharacter);
      }
      shouldDecreaseListLevel() {
        return this.block.hasAttributes() && this.block.isListItem() && this.block.isEmpty();
      }
      shouldPrependListItem() {
        return this.block.isListItem() && 0 === this.startLocation.offset && !this.block.isEmpty();
      }
      shouldRemoveLastBlockAttribute() {
        return this.block.hasAttributes() && !this.block.isListItem() && this.block.isEmpty();
      }
    }
    class gi extends H {
      constructor() {
        super(...arguments), this.document = new qe(), this.attachments = [], this.currentAttributes = {}, this.revision = 0;
      }
      setDocument(t2) {
        var e2, i2;
        if (!t2.isEqualTo(this.document))
          return this.document = t2, this.refreshAttachments(), this.revision++, null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionDidChangeDocument) || void 0 === i2 ? void 0 : i2.call(e2, t2);
      }
      getSnapshot() {
        return { document: this.document, selectedRange: this.getSelectedRange() };
      }
      loadSnapshot(t2) {
        var e2, i2, n2, r2;
        let { document: o2, selectedRange: s2 } = t2;
        return null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionWillLoadSnapshot) || void 0 === i2 || i2.call(e2), this.setDocument(null != o2 ? o2 : new qe()), this.setSelection(null != s2 ? s2 : [0, 0]), null === (n2 = this.delegate) || void 0 === n2 || null === (r2 = n2.compositionDidLoadSnapshot) || void 0 === r2 ? void 0 : r2.call(n2);
      }
      insertText(t2) {
        let { updatePosition: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { updatePosition: true };
        const i2 = this.getSelectedRange();
        this.setDocument(this.document.insertTextAtRange(t2, i2));
        const n2 = i2[0], r2 = n2 + t2.getLength();
        return e2 && this.setSelection(r2), this.notifyDelegateOfInsertionAtRange([n2, r2]);
      }
      insertBlock() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Be();
        const e2 = new qe([t2]);
        return this.insertDocument(e2);
      }
      insertDocument() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new qe();
        const e2 = this.getSelectedRange();
        this.setDocument(this.document.insertDocumentAtRange(t2, e2));
        const i2 = e2[0], n2 = i2 + t2.getLength();
        return this.setSelection(n2), this.notifyDelegateOfInsertionAtRange([i2, n2]);
      }
      insertString(t2, e2) {
        const i2 = this.getCurrentTextAttributes(), n2 = Te.textForStringWithAttributes(t2, i2);
        return this.insertText(n2, e2);
      }
      insertBlockBreak() {
        const t2 = this.getSelectedRange();
        this.setDocument(this.document.insertBlockBreakAtRange(t2));
        const e2 = t2[0], i2 = e2 + 1;
        return this.setSelection(i2), this.notifyDelegateOfInsertionAtRange([e2, i2]);
      }
      insertLineBreak() {
        const t2 = new di(this);
        if (t2.shouldDecreaseListLevel())
          return this.decreaseListLevel(), this.setSelection(t2.startPosition);
        if (t2.shouldPrependListItem()) {
          const e2 = new qe([t2.block.copyWithoutText()]);
          return this.insertDocument(e2);
        }
        return t2.shouldInsertBlockBreak() ? this.insertBlockBreak() : t2.shouldRemoveLastBlockAttribute() ? this.removeLastBlockAttribute() : t2.shouldBreakFormattedBlock() ? this.breakFormattedBlock(t2) : this.insertString("\n");
      }
      insertHTML(t2) {
        const e2 = Xe.parse(t2).getDocument(), i2 = this.getSelectedRange();
        this.setDocument(this.document.mergeDocumentAtRange(e2, i2));
        const n2 = i2[0], r2 = n2 + e2.getLength() - 1;
        return this.setSelection(r2), this.notifyDelegateOfInsertionAtRange([n2, r2]);
      }
      replaceHTML(t2) {
        const e2 = Xe.parse(t2).getDocument().copyUsingObjectsFromDocument(this.document), i2 = this.getLocationRange({ strict: false }), n2 = this.document.rangeFromLocationRange(i2);
        return this.setDocument(e2), this.setSelection(n2);
      }
      insertFile(t2) {
        return this.insertFiles([t2]);
      }
      insertFiles(t2) {
        const e2 = [];
        return Array.from(t2).forEach((t3) => {
          var i2;
          if (null !== (i2 = this.delegate) && void 0 !== i2 && i2.compositionShouldAcceptFile(t3)) {
            const i3 = ke.attachmentForFile(t3);
            e2.push(i3);
          }
        }), this.insertAttachments(e2);
      }
      insertAttachment(t2) {
        return this.insertAttachments([t2]);
      }
      insertAttachments(t2) {
        let e2 = new Te();
        return Array.from(t2).forEach((t3) => {
          var n2;
          const r2 = t3.getType(), o2 = null === (n2 = i[r2]) || void 0 === n2 ? void 0 : n2.presentation, s2 = this.getCurrentTextAttributes();
          o2 && (s2.presentation = o2);
          const a2 = Te.textForAttachmentWithAttributes(t3, s2);
          e2 = e2.appendText(a2);
        }), this.insertText(e2);
      }
      shouldManageDeletingInDirection(t2) {
        const e2 = this.getLocationRange();
        if (Dt(e2)) {
          if ("backward" === t2 && 0 === e2[0].offset)
            return true;
          if (this.shouldManageMovingCursorInDirection(t2))
            return true;
        } else if (e2[0].index !== e2[1].index)
          return true;
        return false;
      }
      deleteInDirection(t2) {
        let e2, i2, n2, { length: r2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const o2 = this.getLocationRange();
        let s2 = this.getSelectedRange();
        const a2 = Dt(s2);
        if (a2 ? i2 = "backward" === t2 && 0 === o2[0].offset : n2 = o2[0].index !== o2[1].index, i2 && this.canDecreaseBlockAttributeLevel()) {
          const t3 = this.getBlock();
          if (t3.isListItem() ? this.decreaseListLevel() : this.decreaseBlockAttributeLevel(), this.setSelection(s2[0]), t3.isEmpty())
            return false;
        }
        return a2 && (s2 = this.getExpandedRangeInDirection(t2, { length: r2 }), "backward" === t2 && (e2 = this.getAttachmentAtRange(s2))), e2 ? (this.editAttachment(e2), false) : (this.setDocument(this.document.removeTextAtRange(s2)), this.setSelection(s2[0]), !i2 && !n2 && void 0);
      }
      moveTextFromRange(t2) {
        const [e2] = Array.from(this.getSelectedRange());
        return this.setDocument(this.document.moveTextFromRangeToPosition(t2, e2)), this.setSelection(e2);
      }
      removeAttachment(t2) {
        const e2 = this.document.getRangeOfAttachment(t2);
        if (e2)
          return this.stopEditingAttachment(), this.setDocument(this.document.removeTextAtRange(e2)), this.setSelection(e2[0]);
      }
      removeLastBlockAttribute() {
        const [t2, e2] = Array.from(this.getSelectedRange()), i2 = this.document.getBlockAtPosition(e2);
        return this.removeCurrentAttribute(i2.getLastAttribute()), this.setSelection(t2);
      }
      insertPlaceholder() {
        return this.placeholderPosition = this.getPosition(), this.insertString(" ");
      }
      selectPlaceholder() {
        if (null != this.placeholderPosition)
          return this.setSelectedRange([this.placeholderPosition, this.placeholderPosition + 1]), this.getSelectedRange();
      }
      forgetPlaceholder() {
        this.placeholderPosition = null;
      }
      hasCurrentAttribute(t2) {
        const e2 = this.currentAttributes[t2];
        return null != e2 && false !== e2;
      }
      toggleCurrentAttribute(t2) {
        const e2 = !this.currentAttributes[t2];
        return e2 ? this.setCurrentAttribute(t2, e2) : this.removeCurrentAttribute(t2);
      }
      canSetCurrentAttribute(t2) {
        return gt(t2) ? this.canSetCurrentBlockAttribute(t2) : this.canSetCurrentTextAttribute(t2);
      }
      canSetCurrentTextAttribute(t2) {
        const e2 = this.getSelectedDocument();
        if (e2) {
          for (const t3 of Array.from(e2.getAttachments()))
            if (!t3.hasContent())
              return false;
          return true;
        }
      }
      canSetCurrentBlockAttribute(t2) {
        const e2 = this.getBlock();
        if (e2)
          return !e2.isTerminalBlock();
      }
      setCurrentAttribute(t2, e2) {
        return gt(t2) ? this.setBlockAttribute(t2, e2) : (this.setTextAttribute(t2, e2), this.currentAttributes[t2] = e2, this.notifyDelegateOfCurrentAttributesChange());
      }
      setHTMLAtributeAtPosition(t2, e2, i2) {
        var n2;
        const r2 = this.document.getBlockAtPosition(t2), o2 = null === (n2 = gt(r2.getLastAttribute())) || void 0 === n2 ? void 0 : n2.htmlAttributes;
        if (r2 && null != o2 && o2.includes(e2)) {
          const n3 = this.document.setHTMLAttributeAtPosition(t2, e2, i2);
          this.setDocument(n3);
        }
      }
      setTextAttribute(t2, e2) {
        const i2 = this.getSelectedRange();
        if (!i2)
          return;
        const [n2, r2] = Array.from(i2);
        if (n2 !== r2)
          return this.setDocument(this.document.addAttributeAtRange(t2, e2, i2));
        if ("href" === t2) {
          const t3 = Te.textForStringWithAttributes(e2, { href: e2 });
          return this.insertText(t3);
        }
      }
      setBlockAttribute(t2, e2) {
        const i2 = this.getSelectedRange();
        if (this.canSetCurrentAttribute(t2))
          return this.setDocument(this.document.applyBlockAttributeAtRange(t2, e2, i2)), this.setSelection(i2);
      }
      removeCurrentAttribute(t2) {
        return gt(t2) ? (this.removeBlockAttribute(t2), this.updateCurrentAttributes()) : (this.removeTextAttribute(t2), delete this.currentAttributes[t2], this.notifyDelegateOfCurrentAttributesChange());
      }
      removeTextAttribute(t2) {
        const e2 = this.getSelectedRange();
        if (e2)
          return this.setDocument(this.document.removeAttributeAtRange(t2, e2));
      }
      removeBlockAttribute(t2) {
        const e2 = this.getSelectedRange();
        if (e2)
          return this.setDocument(this.document.removeAttributeAtRange(t2, e2));
      }
      canDecreaseNestingLevel() {
        var t2;
        return (null === (t2 = this.getBlock()) || void 0 === t2 ? void 0 : t2.getNestingLevel()) > 0;
      }
      canIncreaseNestingLevel() {
        var t2;
        const e2 = this.getBlock();
        if (e2) {
          if (null === (t2 = gt(e2.getLastNestableAttribute())) || void 0 === t2 || !t2.listAttribute)
            return e2.getNestingLevel() > 0;
          {
            const t3 = this.getPreviousBlock();
            if (t3)
              return function() {
                let t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                return rt((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).slice(0, t4.length), t4);
              }(t3.getListItemAttributes(), e2.getListItemAttributes());
          }
        }
      }
      decreaseNestingLevel() {
        const t2 = this.getBlock();
        if (t2)
          return this.setDocument(this.document.replaceBlock(t2, t2.decreaseNestingLevel()));
      }
      increaseNestingLevel() {
        const t2 = this.getBlock();
        if (t2)
          return this.setDocument(this.document.replaceBlock(t2, t2.increaseNestingLevel()));
      }
      canDecreaseBlockAttributeLevel() {
        var t2;
        return (null === (t2 = this.getBlock()) || void 0 === t2 ? void 0 : t2.getAttributeLevel()) > 0;
      }
      decreaseBlockAttributeLevel() {
        var t2;
        const e2 = null === (t2 = this.getBlock()) || void 0 === t2 ? void 0 : t2.getLastAttribute();
        if (e2)
          return this.removeCurrentAttribute(e2);
      }
      decreaseListLevel() {
        let [t2] = Array.from(this.getSelectedRange());
        const { index: e2 } = this.document.locationFromPosition(t2);
        let i2 = e2;
        const n2 = this.getBlock().getAttributeLevel();
        let r2 = this.document.getBlockAtIndex(i2 + 1);
        for (; r2 && r2.isListItem() && !(r2.getAttributeLevel() <= n2); )
          i2++, r2 = this.document.getBlockAtIndex(i2 + 1);
        t2 = this.document.positionFromLocation({ index: e2, offset: 0 });
        const o2 = this.document.positionFromLocation({ index: i2, offset: 0 });
        return this.setDocument(this.document.removeLastListAttributeAtRange([t2, o2]));
      }
      updateCurrentAttributes() {
        const t2 = this.getSelectedRange({ ignoreLock: true });
        if (t2) {
          const e2 = this.document.getCommonAttributesAtRange(t2);
          if (Array.from(dt()).forEach((t3) => {
            e2[t3] || this.canSetCurrentAttribute(t3) || (e2[t3] = false);
          }), !St(e2, this.currentAttributes))
            return this.currentAttributes = e2, this.notifyDelegateOfCurrentAttributesChange();
        }
      }
      getCurrentAttributes() {
        return g.call({}, this.currentAttributes);
      }
      getCurrentTextAttributes() {
        const t2 = {};
        for (const e2 in this.currentAttributes) {
          const i2 = this.currentAttributes[e2];
          false !== i2 && pt(e2) && (t2[e2] = i2);
        }
        return t2;
      }
      freezeSelection() {
        return this.setCurrentAttribute("frozen", true);
      }
      thawSelection() {
        return this.removeCurrentAttribute("frozen");
      }
      hasFrozenSelection() {
        return this.hasCurrentAttribute("frozen");
      }
      setSelection(t2) {
        var e2;
        const i2 = this.document.locationRangeFromRange(t2);
        return null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.compositionDidRequestChangingSelectionToLocationRange(i2);
      }
      getSelectedRange() {
        const t2 = this.getLocationRange();
        if (t2)
          return this.document.rangeFromLocationRange(t2);
      }
      setSelectedRange(t2) {
        const e2 = this.document.locationRangeFromRange(t2);
        return this.getSelectionManager().setLocationRange(e2);
      }
      getPosition() {
        const t2 = this.getLocationRange();
        if (t2)
          return this.document.positionFromLocation(t2[0]);
      }
      getLocationRange(t2) {
        return this.targetLocationRange ? this.targetLocationRange : this.getSelectionManager().getLocationRange(t2) || Lt({ index: 0, offset: 0 });
      }
      withTargetLocationRange(t2, e2) {
        let i2;
        this.targetLocationRange = t2;
        try {
          i2 = e2();
        } finally {
          this.targetLocationRange = null;
        }
        return i2;
      }
      withTargetRange(t2, e2) {
        const i2 = this.document.locationRangeFromRange(t2);
        return this.withTargetLocationRange(i2, e2);
      }
      withTargetDOMRange(t2, e2) {
        const i2 = this.createLocationRangeFromDOMRange(t2, { strict: false });
        return this.withTargetLocationRange(i2, e2);
      }
      getExpandedRangeInDirection(t2) {
        let { length: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, [i2, n2] = Array.from(this.getSelectedRange());
        return "backward" === t2 ? e2 ? i2 -= e2 : i2 = this.translateUTF16PositionFromOffset(i2, -1) : e2 ? n2 += e2 : n2 = this.translateUTF16PositionFromOffset(n2, 1), Lt([i2, n2]);
      }
      shouldManageMovingCursorInDirection(t2) {
        if (this.editingAttachment)
          return true;
        const e2 = this.getExpandedRangeInDirection(t2);
        return null != this.getAttachmentAtRange(e2);
      }
      moveCursorInDirection(t2) {
        let e2, i2;
        if (this.editingAttachment)
          i2 = this.document.getRangeOfAttachment(this.editingAttachment);
        else {
          const n2 = this.getSelectedRange();
          i2 = this.getExpandedRangeInDirection(t2), e2 = !wt(n2, i2);
        }
        if ("backward" === t2 ? this.setSelectedRange(i2[0]) : this.setSelectedRange(i2[1]), e2) {
          const t3 = this.getAttachmentAtRange(i2);
          if (t3)
            return this.editAttachment(t3);
        }
      }
      expandSelectionInDirection(t2) {
        let { length: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const i2 = this.getExpandedRangeInDirection(t2, { length: e2 });
        return this.setSelectedRange(i2);
      }
      expandSelectionForEditing() {
        if (this.hasCurrentAttribute("href"))
          return this.expandSelectionAroundCommonAttribute("href");
      }
      expandSelectionAroundCommonAttribute(t2) {
        const e2 = this.getPosition(), i2 = this.document.getRangeOfCommonAttributeAtPosition(t2, e2);
        return this.setSelectedRange(i2);
      }
      selectionContainsAttachments() {
        var t2;
        return (null === (t2 = this.getSelectedAttachments()) || void 0 === t2 ? void 0 : t2.length) > 0;
      }
      selectionIsInCursorTarget() {
        return this.editingAttachment || this.positionIsCursorTarget(this.getPosition());
      }
      positionIsCursorTarget(t2) {
        const e2 = this.document.locationFromPosition(t2);
        if (e2)
          return this.locationIsCursorTarget(e2);
      }
      positionIsBlockBreak(t2) {
        var e2;
        return null === (e2 = this.document.getPieceAtPosition(t2)) || void 0 === e2 ? void 0 : e2.isBlockBreak();
      }
      getSelectedDocument() {
        const t2 = this.getSelectedRange();
        if (t2)
          return this.document.getDocumentAtRange(t2);
      }
      getSelectedAttachments() {
        var t2;
        return null === (t2 = this.getSelectedDocument()) || void 0 === t2 ? void 0 : t2.getAttachments();
      }
      getAttachments() {
        return this.attachments.slice(0);
      }
      refreshAttachments() {
        const t2 = this.document.getAttachments(), { added: e2, removed: i2 } = function() {
          let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
          const i3 = [], n2 = [], r2 = /* @__PURE__ */ new Set();
          t3.forEach((t4) => {
            r2.add(t4);
          });
          const o2 = /* @__PURE__ */ new Set();
          return e3.forEach((t4) => {
            o2.add(t4), r2.has(t4) || i3.push(t4);
          }), t3.forEach((t4) => {
            o2.has(t4) || n2.push(t4);
          }), { added: i3, removed: n2 };
        }(this.attachments, t2);
        return this.attachments = t2, Array.from(i2).forEach((t3) => {
          var e3, i3;
          t3.delegate = null, null === (e3 = this.delegate) || void 0 === e3 || null === (i3 = e3.compositionDidRemoveAttachment) || void 0 === i3 || i3.call(e3, t3);
        }), (() => {
          const t3 = [];
          return Array.from(e2).forEach((e3) => {
            var i3, n2;
            e3.delegate = this, t3.push(null === (i3 = this.delegate) || void 0 === i3 || null === (n2 = i3.compositionDidAddAttachment) || void 0 === n2 ? void 0 : n2.call(i3, e3));
          }), t3;
        })();
      }
      attachmentDidChangeAttributes(t2) {
        var e2, i2;
        return this.revision++, null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionDidEditAttachment) || void 0 === i2 ? void 0 : i2.call(e2, t2);
      }
      attachmentDidChangePreviewURL(t2) {
        var e2, i2;
        return this.revision++, null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionDidChangeAttachmentPreviewURL) || void 0 === i2 ? void 0 : i2.call(e2, t2);
      }
      editAttachment(t2, e2) {
        var i2, n2;
        if (t2 !== this.editingAttachment)
          return this.stopEditingAttachment(), this.editingAttachment = t2, null === (i2 = this.delegate) || void 0 === i2 || null === (n2 = i2.compositionDidStartEditingAttachment) || void 0 === n2 ? void 0 : n2.call(i2, this.editingAttachment, e2);
      }
      stopEditingAttachment() {
        var t2, e2;
        this.editingAttachment && (null === (t2 = this.delegate) || void 0 === t2 || null === (e2 = t2.compositionDidStopEditingAttachment) || void 0 === e2 || e2.call(t2, this.editingAttachment), this.editingAttachment = null);
      }
      updateAttributesForAttachment(t2, e2) {
        return this.setDocument(this.document.updateAttributesForAttachment(t2, e2));
      }
      removeAttributeForAttachment(t2, e2) {
        return this.setDocument(this.document.removeAttributeForAttachment(t2, e2));
      }
      breakFormattedBlock(t2) {
        let { document: e2 } = t2;
        const { block: i2 } = t2;
        let n2 = t2.startPosition, r2 = [n2 - 1, n2];
        i2.getBlockBreakPosition() === t2.startLocation.offset ? (i2.breaksOnReturn() && "\n" === t2.nextCharacter ? n2 += 1 : e2 = e2.removeTextAtRange(r2), r2 = [n2, n2]) : "\n" === t2.nextCharacter ? "\n" === t2.previousCharacter ? r2 = [n2 - 1, n2 + 1] : (r2 = [n2, n2 + 1], n2 += 1) : t2.startLocation.offset - 1 != 0 && (n2 += 1);
        const o2 = new qe([i2.removeLastAttribute().copyWithoutText()]);
        return this.setDocument(e2.insertDocumentAtRange(o2, r2)), this.setSelection(n2);
      }
      getPreviousBlock() {
        const t2 = this.getLocationRange();
        if (t2) {
          const { index: e2 } = t2[0];
          if (e2 > 0)
            return this.document.getBlockAtIndex(e2 - 1);
        }
      }
      getBlock() {
        const t2 = this.getLocationRange();
        if (t2)
          return this.document.getBlockAtIndex(t2[0].index);
      }
      getAttachmentAtRange(t2) {
        const e2 = this.document.getDocumentAtRange(t2);
        if (e2.toString() === "".concat("￼", "\n"))
          return e2.getAttachments()[0];
      }
      notifyDelegateOfCurrentAttributesChange() {
        var t2, e2;
        return null === (t2 = this.delegate) || void 0 === t2 || null === (e2 = t2.compositionDidChangeCurrentAttributes) || void 0 === e2 ? void 0 : e2.call(t2, this.currentAttributes);
      }
      notifyDelegateOfInsertionAtRange(t2) {
        var e2, i2;
        return null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionDidPerformInsertionAtRange) || void 0 === i2 ? void 0 : i2.call(e2, t2);
      }
      translateUTF16PositionFromOffset(t2, e2) {
        const i2 = this.document.toUTF16String(), n2 = i2.offsetFromUCS2Offset(t2);
        return i2.offsetToUCS2Offset(n2 + e2);
      }
    }
    gi.proxyMethod("getSelectionManager().getPointRange"), gi.proxyMethod("getSelectionManager().setLocationRangeFromPointRange"), gi.proxyMethod("getSelectionManager().createLocationRangeFromDOMRange"), gi.proxyMethod("getSelectionManager().locationIsCursorTarget"), gi.proxyMethod("getSelectionManager().selectionIsExpanded"), gi.proxyMethod("delegate?.getSelectionManager");
    class mi extends H {
      constructor(t2) {
        super(...arguments), this.composition = t2, this.undoEntries = [], this.redoEntries = [];
      }
      recordUndoEntry(t2) {
        let { context: e2, consolidatable: i2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const n2 = this.undoEntries.slice(-1)[0];
        if (!i2 || !pi(n2, t2, e2)) {
          const i3 = this.createEntry({ description: t2, context: e2 });
          this.undoEntries.push(i3), this.redoEntries = [];
        }
      }
      undo() {
        const t2 = this.undoEntries.pop();
        if (t2) {
          const e2 = this.createEntry(t2);
          return this.redoEntries.push(e2), this.composition.loadSnapshot(t2.snapshot);
        }
      }
      redo() {
        const t2 = this.redoEntries.pop();
        if (t2) {
          const e2 = this.createEntry(t2);
          return this.undoEntries.push(e2), this.composition.loadSnapshot(t2.snapshot);
        }
      }
      canUndo() {
        return this.undoEntries.length > 0;
      }
      canRedo() {
        return this.redoEntries.length > 0;
      }
      createEntry() {
        let { description: t2, context: e2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return { description: null == t2 ? void 0 : t2.toString(), context: JSON.stringify(e2), snapshot: this.composition.getSnapshot() };
      }
    }
    const pi = (t2, e2, i2) => (null == t2 ? void 0 : t2.description) === (null == e2 ? void 0 : e2.toString()) && (null == t2 ? void 0 : t2.context) === JSON.stringify(i2), fi = "attachmentGallery";
    class bi {
      constructor(t2) {
        this.document = t2.document, this.selectedRange = t2.selectedRange;
      }
      perform() {
        return this.removeBlockAttribute(), this.applyBlockAttribute();
      }
      getSnapshot() {
        return { document: this.document, selectedRange: this.selectedRange };
      }
      removeBlockAttribute() {
        return this.findRangesOfBlocks().map((t2) => this.document = this.document.removeAttributeAtRange(fi, t2));
      }
      applyBlockAttribute() {
        let t2 = 0;
        this.findRangesOfPieces().forEach((e2) => {
          e2[1] - e2[0] > 1 && (e2[0] += t2, e2[1] += t2, "\n" !== this.document.getCharacterAtPosition(e2[1]) && (this.document = this.document.insertBlockBreakAtRange(e2[1]), e2[1] < this.selectedRange[1] && this.moveSelectedRangeForward(), e2[1]++, t2++), 0 !== e2[0] && "\n" !== this.document.getCharacterAtPosition(e2[0] - 1) && (this.document = this.document.insertBlockBreakAtRange(e2[0]), e2[0] < this.selectedRange[0] && this.moveSelectedRangeForward(), e2[0]++, t2++), this.document = this.document.applyBlockAttributeAtRange(fi, true, e2));
        });
      }
      findRangesOfBlocks() {
        return this.document.findRangesForBlockAttribute(fi);
      }
      findRangesOfPieces() {
        return this.document.findRangesForTextAttribute("presentation", { withValue: "gallery" });
      }
      moveSelectedRangeForward() {
        this.selectedRange[0] += 1, this.selectedRange[1] += 1;
      }
    }
    const vi = function(t2) {
      const e2 = new bi(t2);
      return e2.perform(), e2.getSnapshot();
    }, Ai = [vi];
    class xi {
      constructor(t2, e2, i2) {
        this.insertFiles = this.insertFiles.bind(this), this.composition = t2, this.selectionManager = e2, this.element = i2, this.undoManager = new mi(this.composition), this.filters = Ai.slice(0);
      }
      loadDocument(t2) {
        return this.loadSnapshot({ document: t2, selectedRange: [0, 0] });
      }
      loadHTML() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
        const e2 = Xe.parse(t2, { referenceElement: this.element }).getDocument();
        return this.loadDocument(e2);
      }
      loadJSON(t2) {
        let { document: e2, selectedRange: i2 } = t2;
        return e2 = qe.fromJSON(e2), this.loadSnapshot({ document: e2, selectedRange: i2 });
      }
      loadSnapshot(t2) {
        return this.undoManager = new mi(this.composition), this.composition.loadSnapshot(t2);
      }
      getDocument() {
        return this.composition.document;
      }
      getSelectedDocument() {
        return this.composition.getSelectedDocument();
      }
      getSnapshot() {
        return this.composition.getSnapshot();
      }
      toJSON() {
        return this.getSnapshot();
      }
      deleteInDirection(t2) {
        return this.composition.deleteInDirection(t2);
      }
      insertAttachment(t2) {
        return this.composition.insertAttachment(t2);
      }
      insertAttachments(t2) {
        return this.composition.insertAttachments(t2);
      }
      insertDocument(t2) {
        return this.composition.insertDocument(t2);
      }
      insertFile(t2) {
        return this.composition.insertFile(t2);
      }
      insertFiles(t2) {
        return this.composition.insertFiles(t2);
      }
      insertHTML(t2) {
        return this.composition.insertHTML(t2);
      }
      insertString(t2) {
        return this.composition.insertString(t2);
      }
      insertText(t2) {
        return this.composition.insertText(t2);
      }
      insertLineBreak() {
        return this.composition.insertLineBreak();
      }
      getSelectedRange() {
        return this.composition.getSelectedRange();
      }
      getPosition() {
        return this.composition.getPosition();
      }
      getClientRectAtPosition(t2) {
        const e2 = this.getDocument().locationRangeFromRange([t2, t2 + 1]);
        return this.selectionManager.getClientRectAtLocationRange(e2);
      }
      expandSelectionInDirection(t2) {
        return this.composition.expandSelectionInDirection(t2);
      }
      moveCursorInDirection(t2) {
        return this.composition.moveCursorInDirection(t2);
      }
      setSelectedRange(t2) {
        return this.composition.setSelectedRange(t2);
      }
      activateAttribute(t2) {
        let e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        return this.composition.setCurrentAttribute(t2, e2);
      }
      attributeIsActive(t2) {
        return this.composition.hasCurrentAttribute(t2);
      }
      canActivateAttribute(t2) {
        return this.composition.canSetCurrentAttribute(t2);
      }
      deactivateAttribute(t2) {
        return this.composition.removeCurrentAttribute(t2);
      }
      setHTMLAtributeAtPosition(t2, e2, i2) {
        this.composition.setHTMLAtributeAtPosition(t2, e2, i2);
      }
      canDecreaseNestingLevel() {
        return this.composition.canDecreaseNestingLevel();
      }
      canIncreaseNestingLevel() {
        return this.composition.canIncreaseNestingLevel();
      }
      decreaseNestingLevel() {
        if (this.canDecreaseNestingLevel())
          return this.composition.decreaseNestingLevel();
      }
      increaseNestingLevel() {
        if (this.canIncreaseNestingLevel())
          return this.composition.increaseNestingLevel();
      }
      canRedo() {
        return this.undoManager.canRedo();
      }
      canUndo() {
        return this.undoManager.canUndo();
      }
      recordUndoEntry(t2) {
        let { context: e2, consolidatable: i2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return this.undoManager.recordUndoEntry(t2, { context: e2, consolidatable: i2 });
      }
      redo() {
        if (this.canRedo())
          return this.undoManager.redo();
      }
      undo() {
        if (this.canUndo())
          return this.undoManager.undo();
      }
    }
    class yi {
      constructor(t2) {
        this.element = t2;
      }
      findLocationFromContainerAndOffset(t2, e2) {
        let { strict: i2 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : { strict: true }, n2 = 0, r2 = false;
        const o2 = { index: 0, offset: 0 }, s2 = this.findAttachmentElementParentForNode(t2);
        s2 && (t2 = s2.parentNode, e2 = C(s2));
        const a2 = R(this.element, { usingFilter: Ei });
        for (; a2.nextNode(); ) {
          const s3 = a2.currentNode;
          if (s3 === t2 && O(t2)) {
            P(s3) || (o2.offset += e2);
            break;
          }
          if (s3.parentNode === t2) {
            if (n2++ === e2)
              break;
          } else if (!y(t2, s3) && n2 > 0)
            break;
          T(s3, { strict: i2 }) ? (r2 && o2.index++, o2.offset = 0, r2 = true) : o2.offset += Ci(s3);
        }
        return o2;
      }
      findContainerAndOffsetFromLocation(t2) {
        let e2, i2;
        if (0 === t2.index && 0 === t2.offset) {
          for (e2 = this.element, i2 = 0; e2.firstChild; )
            if (e2 = e2.firstChild, w(e2)) {
              i2 = 1;
              break;
            }
          return [e2, i2];
        }
        let [n2, r2] = this.findNodeAndOffsetFromLocation(t2);
        if (n2) {
          if (O(n2))
            0 === Ci(n2) ? (e2 = n2.parentNode.parentNode, i2 = C(n2.parentNode), P(n2, { name: "right" }) && i2++) : (e2 = n2, i2 = t2.offset - r2);
          else {
            if (e2 = n2.parentNode, !T(n2.previousSibling) && !w(e2))
              for (; n2 === e2.lastChild && (n2 = e2, e2 = e2.parentNode, !w(e2)); )
                ;
            i2 = C(n2), 0 !== t2.offset && i2++;
          }
          return [e2, i2];
        }
      }
      findNodeAndOffsetFromLocation(t2) {
        let e2, i2, n2 = 0;
        for (const r2 of this.getSignificantNodesForIndex(t2.index)) {
          const o2 = Ci(r2);
          if (t2.offset <= n2 + o2)
            if (O(r2)) {
              if (e2 = r2, i2 = n2, t2.offset === i2 && P(e2))
                break;
            } else
              e2 || (e2 = r2, i2 = n2);
          if (n2 += o2, n2 > t2.offset)
            break;
        }
        return [e2, i2];
      }
      findAttachmentElementParentForNode(t2) {
        for (; t2 && t2 !== this.element; ) {
          if (I(t2))
            return t2;
          t2 = t2.parentNode;
        }
      }
      getSignificantNodesForIndex(t2) {
        const e2 = [], i2 = R(this.element, { usingFilter: ki });
        let n2 = false;
        for (; i2.nextNode(); ) {
          const o2 = i2.currentNode;
          var r2;
          if (B(o2)) {
            if (null != r2 ? r2++ : r2 = 0, r2 === t2)
              n2 = true;
            else if (n2)
              break;
          } else
            n2 && e2.push(o2);
        }
        return e2;
      }
    }
    const Ci = function(t2) {
      if (t2.nodeType === Node.TEXT_NODE) {
        if (P(t2))
          return 0;
        return t2.textContent.length;
      }
      return "br" === E(t2) || I(t2) ? 1 : 0;
    }, ki = function(t2) {
      return Ri(t2) === NodeFilter.FILTER_ACCEPT ? Ei(t2) : NodeFilter.FILTER_REJECT;
    }, Ri = function(t2) {
      return N(t2) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
    }, Ei = function(t2) {
      return I(t2.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
    };
    class Si {
      createDOMRangeFromPoint(t2) {
        let e2, { x: i2, y: n2 } = t2;
        if (document.caretPositionFromPoint) {
          const { offsetNode: t3, offset: r2 } = document.caretPositionFromPoint(i2, n2);
          return e2 = document.createRange(), e2.setStart(t3, r2), e2;
        }
        if (document.caretRangeFromPoint)
          return document.caretRangeFromPoint(i2, n2);
        if (document.body.createTextRange) {
          const t3 = Nt();
          try {
            const t4 = document.body.createTextRange();
            t4.moveToPoint(i2, n2), t4.select();
          } catch (t4) {
          }
          return e2 = Nt(), Ot(t3), e2;
        }
      }
      getClientRectsForDOMRange(t2) {
        const e2 = Array.from(t2.getClientRects());
        return [e2[0], e2[e2.length - 1]];
      }
    }
    class Li extends H {
      constructor(t2) {
        super(...arguments), this.didMouseDown = this.didMouseDown.bind(this), this.selectionDidChange = this.selectionDidChange.bind(this), this.element = t2, this.locationMapper = new yi(this.element), this.pointMapper = new Si(), this.lockCount = 0, f("mousedown", { onElement: this.element, withCallback: this.didMouseDown });
      }
      getLocationRange() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return false === t2.strict ? this.createLocationRangeFromDOMRange(Nt()) : t2.ignoreLock ? this.currentLocationRange : this.lockedLocationRange ? this.lockedLocationRange : this.currentLocationRange;
      }
      setLocationRange(t2) {
        if (this.lockedLocationRange)
          return;
        t2 = Lt(t2);
        const e2 = this.createDOMRangeFromLocationRange(t2);
        e2 && (Ot(e2), this.updateCurrentLocationRange(t2));
      }
      setLocationRangeFromPointRange(t2) {
        t2 = Lt(t2);
        const e2 = this.getLocationAtPoint(t2[0]), i2 = this.getLocationAtPoint(t2[1]);
        this.setLocationRange([e2, i2]);
      }
      getClientRectAtLocationRange(t2) {
        const e2 = this.createDOMRangeFromLocationRange(t2);
        if (e2)
          return this.getClientRectsForDOMRange(e2)[1];
      }
      locationIsCursorTarget(t2) {
        const e2 = Array.from(this.findNodeAndOffsetFromLocation(t2))[0];
        return P(e2);
      }
      lock() {
        0 == this.lockCount++ && (this.updateCurrentLocationRange(), this.lockedLocationRange = this.getLocationRange());
      }
      unlock() {
        if (0 == --this.lockCount) {
          const { lockedLocationRange: t2 } = this;
          if (this.lockedLocationRange = null, null != t2)
            return this.setLocationRange(t2);
        }
      }
      clearSelection() {
        var t2;
        return null === (t2 = It()) || void 0 === t2 ? void 0 : t2.removeAllRanges();
      }
      selectionIsCollapsed() {
        var t2;
        return true === (null === (t2 = Nt()) || void 0 === t2 ? void 0 : t2.collapsed);
      }
      selectionIsExpanded() {
        return !this.selectionIsCollapsed();
      }
      createLocationRangeFromDOMRange(t2, e2) {
        if (null == t2 || !this.domRangeWithinElement(t2))
          return;
        const i2 = this.findLocationFromContainerAndOffset(t2.startContainer, t2.startOffset, e2);
        if (!i2)
          return;
        const n2 = t2.collapsed ? void 0 : this.findLocationFromContainerAndOffset(t2.endContainer, t2.endOffset, e2);
        return Lt([i2, n2]);
      }
      didMouseDown() {
        return this.pauseTemporarily();
      }
      pauseTemporarily() {
        let t2;
        this.paused = true;
        const e2 = () => {
          if (this.paused = false, clearTimeout(i2), Array.from(t2).forEach((t3) => {
            t3.destroy();
          }), y(document, this.element))
            return this.selectionDidChange();
        }, i2 = setTimeout(e2, 200);
        t2 = ["mousemove", "keydown"].map((t3) => f(t3, { onElement: document, withCallback: e2 }));
      }
      selectionDidChange() {
        if (!this.paused && !x(this.element))
          return this.updateCurrentLocationRange();
      }
      updateCurrentLocationRange(t2) {
        var e2, i2;
        if ((null != t2 ? t2 : t2 = this.createLocationRangeFromDOMRange(Nt())) && !wt(t2, this.currentLocationRange))
          return this.currentLocationRange = t2, null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.locationRangeDidChange) || void 0 === i2 ? void 0 : i2.call(e2, this.currentLocationRange.slice(0));
      }
      createDOMRangeFromLocationRange(t2) {
        const e2 = this.findContainerAndOffsetFromLocation(t2[0]), i2 = Dt(t2) ? e2 : this.findContainerAndOffsetFromLocation(t2[1]) || e2;
        if (null != e2 && null != i2) {
          const t3 = document.createRange();
          return t3.setStart(...Array.from(e2 || [])), t3.setEnd(...Array.from(i2 || [])), t3;
        }
      }
      getLocationAtPoint(t2) {
        const e2 = this.createDOMRangeFromPoint(t2);
        var i2;
        if (e2)
          return null === (i2 = this.createLocationRangeFromDOMRange(e2)) || void 0 === i2 ? void 0 : i2[0];
      }
      domRangeWithinElement(t2) {
        return t2.collapsed ? y(this.element, t2.startContainer) : y(this.element, t2.startContainer) && y(this.element, t2.endContainer);
      }
    }
    Li.proxyMethod("locationMapper.findLocationFromContainerAndOffset"), Li.proxyMethod("locationMapper.findContainerAndOffsetFromLocation"), Li.proxyMethod("locationMapper.findNodeAndOffsetFromLocation"), Li.proxyMethod("pointMapper.createDOMRangeFromPoint"), Li.proxyMethod("pointMapper.getClientRectsForDOMRange");
    var Di = Object.freeze({ __proto__: null, Attachment: ke, AttachmentManager: hi, AttachmentPiece: Re, Block: Be, Composition: gi, Document: qe, Editor: xi, HTMLParser: Xe, HTMLSanitizer: Je, LineBreakInsertion: di, LocationMapper: yi, ManagedAttachment: ui, Piece: ye, PointMapper: Si, SelectionManager: Li, SplittableList: Se, StringPiece: Ee, Text: Te, UndoManager: mi }), wi = Object.freeze({ __proto__: null, ObjectView: ee, AttachmentView: re, BlockView: de, DocumentView: ge, PieceView: le, PreviewableAttachmentView: ae, TextView: ce });
    const { lang: Ti, css: Bi, keyNames: Fi } = V, Pi = function(t2) {
      return function() {
        const e2 = t2.apply(this, arguments);
        e2.do(), this.undos || (this.undos = []), this.undos.push(e2.undo);
      };
    };
    class Ii extends H {
      constructor(t2, e2, i2) {
        let n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
        super(...arguments), Ae(this, "makeElementMutable", Pi(() => ({ do: () => {
          this.element.dataset.trixMutable = true;
        }, undo: () => delete this.element.dataset.trixMutable }))), Ae(this, "addToolbar", Pi(() => {
          const t3 = S({ tagName: "div", className: Bi.attachmentToolbar, data: { trixMutable: true }, childNodes: S({ tagName: "div", className: "trix-button-row", childNodes: S({ tagName: "span", className: "trix-button-group trix-button-group--actions", childNodes: S({ tagName: "button", className: "trix-button trix-button--remove", textContent: Ti.remove, attributes: { title: Ti.remove }, data: { trixAction: "remove" } }) }) }) });
          return this.attachment.isPreviewable() && t3.appendChild(S({ tagName: "div", className: Bi.attachmentMetadataContainer, childNodes: S({ tagName: "span", className: Bi.attachmentMetadata, childNodes: [S({ tagName: "span", className: Bi.attachmentName, textContent: this.attachment.getFilename(), attributes: { title: this.attachment.getFilename() } }), S({ tagName: "span", className: Bi.attachmentSize, textContent: this.attachment.getFormattedFilesize() })] }) })), f("click", { onElement: t3, withCallback: this.didClickToolbar }), f("click", { onElement: t3, matchingSelector: "[data-trix-action]", withCallback: this.didClickActionButton }), b("trix-attachment-before-toolbar", { onElement: this.element, attributes: { toolbar: t3, attachment: this.attachment } }), { do: () => this.element.appendChild(t3), undo: () => k(t3) };
        })), Ae(this, "installCaptionEditor", Pi(() => {
          const t3 = S({ tagName: "textarea", className: Bi.attachmentCaptionEditor, attributes: { placeholder: Ti.captionPlaceholder }, data: { trixMutable: true } });
          t3.value = this.attachmentPiece.getCaption();
          const e3 = t3.cloneNode();
          e3.classList.add("trix-autoresize-clone"), e3.tabIndex = -1;
          const i3 = function() {
            e3.value = t3.value, t3.style.height = e3.scrollHeight + "px";
          };
          f("input", { onElement: t3, withCallback: i3 }), f("input", { onElement: t3, withCallback: this.didInputCaption }), f("keydown", { onElement: t3, withCallback: this.didKeyDownCaption }), f("change", { onElement: t3, withCallback: this.didChangeCaption }), f("blur", { onElement: t3, withCallback: this.didBlurCaption });
          const n3 = this.element.querySelector("figcaption"), r2 = n3.cloneNode();
          return { do: () => {
            if (n3.style.display = "none", r2.appendChild(t3), r2.appendChild(e3), r2.classList.add("".concat(Bi.attachmentCaption, "--editing")), n3.parentElement.insertBefore(r2, n3), i3(), this.options.editCaption)
              return Rt(() => t3.focus());
          }, undo() {
            k(r2), n3.style.display = null;
          } };
        })), this.didClickToolbar = this.didClickToolbar.bind(this), this.didClickActionButton = this.didClickActionButton.bind(this), this.didKeyDownCaption = this.didKeyDownCaption.bind(this), this.didInputCaption = this.didInputCaption.bind(this), this.didChangeCaption = this.didChangeCaption.bind(this), this.didBlurCaption = this.didBlurCaption.bind(this), this.attachmentPiece = t2, this.element = e2, this.container = i2, this.options = n2, this.attachment = this.attachmentPiece.attachment, "a" === E(this.element) && (this.element = this.element.firstChild), this.install();
      }
      install() {
        this.makeElementMutable(), this.addToolbar(), this.attachment.isPreviewable() && this.installCaptionEditor();
      }
      uninstall() {
        var t2;
        let e2 = this.undos.pop();
        for (this.savePendingCaption(); e2; )
          e2(), e2 = this.undos.pop();
        null === (t2 = this.delegate) || void 0 === t2 || t2.didUninstallAttachmentEditor(this);
      }
      savePendingCaption() {
        if (null != this.pendingCaption) {
          const r2 = this.pendingCaption;
          var t2, e2, i2, n2;
          if (this.pendingCaption = null, r2)
            null === (t2 = this.delegate) || void 0 === t2 || null === (e2 = t2.attachmentEditorDidRequestUpdatingAttributesForAttachment) || void 0 === e2 || e2.call(t2, { caption: r2 }, this.attachment);
          else
            null === (i2 = this.delegate) || void 0 === i2 || null === (n2 = i2.attachmentEditorDidRequestRemovingAttributeForAttachment) || void 0 === n2 || n2.call(i2, "caption", this.attachment);
        }
      }
      didClickToolbar(t2) {
        return t2.preventDefault(), t2.stopPropagation();
      }
      didClickActionButton(t2) {
        var e2;
        if ("remove" === t2.target.getAttribute("data-trix-action"))
          return null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.attachmentEditorDidRequestRemovalOfAttachment(this.attachment);
      }
      didKeyDownCaption(t2) {
        var e2, i2;
        if ("return" === Fi[t2.keyCode])
          return t2.preventDefault(), this.savePendingCaption(), null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.attachmentEditorDidRequestDeselectingAttachment) || void 0 === i2 ? void 0 : i2.call(e2, this.attachment);
      }
      didInputCaption(t2) {
        this.pendingCaption = t2.target.value.replace(/\s/g, " ").trim();
      }
      didChangeCaption(t2) {
        return this.savePendingCaption();
      }
      didBlurCaption(t2) {
        return this.savePendingCaption();
      }
    }
    class Ni extends H {
      constructor(t2, i2) {
        super(...arguments), this.didFocus = this.didFocus.bind(this), this.didBlur = this.didBlur.bind(this), this.didClickAttachment = this.didClickAttachment.bind(this), this.element = t2, this.composition = i2, this.documentView = new ge(this.composition.document, { element: this.element }), f("focus", { onElement: this.element, withCallback: this.didFocus }), f("blur", { onElement: this.element, withCallback: this.didBlur }), f("click", { onElement: this.element, matchingSelector: "a[contenteditable=false]", preventDefault: true }), f("mousedown", { onElement: this.element, matchingSelector: e, withCallback: this.didClickAttachment }), f("click", { onElement: this.element, matchingSelector: "a".concat(e), preventDefault: true });
      }
      didFocus(t2) {
        var e2;
        const i2 = () => {
          var t3, e3;
          if (!this.focused)
            return this.focused = true, null === (t3 = this.delegate) || void 0 === t3 || null === (e3 = t3.compositionControllerDidFocus) || void 0 === e3 ? void 0 : e3.call(t3);
        };
        return (null === (e2 = this.blurPromise) || void 0 === e2 ? void 0 : e2.then(i2)) || i2();
      }
      didBlur(t2) {
        this.blurPromise = new Promise((t3) => Rt(() => {
          var e2, i2;
          x(this.element) || (this.focused = null, null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionControllerDidBlur) || void 0 === i2 || i2.call(e2));
          return this.blurPromise = null, t3();
        }));
      }
      didClickAttachment(t2, e2) {
        var i2, n2;
        const r2 = this.findAttachmentForElement(e2), o2 = !!A(t2.target, { matchingSelector: "figcaption" });
        return null === (i2 = this.delegate) || void 0 === i2 || null === (n2 = i2.compositionControllerDidSelectAttachment) || void 0 === n2 ? void 0 : n2.call(i2, r2, { editCaption: o2 });
      }
      getSerializableElement() {
        return this.isEditingAttachment() ? this.documentView.shadowElement : this.element;
      }
      render() {
        var t2, e2, i2, n2, r2, o2;
        (this.revision !== this.composition.revision && (this.documentView.setDocument(this.composition.document), this.documentView.render(), this.revision = this.composition.revision), this.canSyncDocumentView() && !this.documentView.isSynced()) && (null === (i2 = this.delegate) || void 0 === i2 || null === (n2 = i2.compositionControllerWillSyncDocumentView) || void 0 === n2 || n2.call(i2), this.documentView.sync(), null === (r2 = this.delegate) || void 0 === r2 || null === (o2 = r2.compositionControllerDidSyncDocumentView) || void 0 === o2 || o2.call(r2));
        return null === (t2 = this.delegate) || void 0 === t2 || null === (e2 = t2.compositionControllerDidRender) || void 0 === e2 ? void 0 : e2.call(t2);
      }
      rerenderViewForObject(t2) {
        return this.invalidateViewForObject(t2), this.render();
      }
      invalidateViewForObject(t2) {
        return this.documentView.invalidateViewForObject(t2);
      }
      isViewCachingEnabled() {
        return this.documentView.isViewCachingEnabled();
      }
      enableViewCaching() {
        return this.documentView.enableViewCaching();
      }
      disableViewCaching() {
        return this.documentView.disableViewCaching();
      }
      refreshViewCache() {
        return this.documentView.garbageCollectCachedViews();
      }
      isEditingAttachment() {
        return !!this.attachmentEditor;
      }
      installAttachmentEditorForAttachment(t2, e2) {
        var i2;
        if ((null === (i2 = this.attachmentEditor) || void 0 === i2 ? void 0 : i2.attachment) === t2)
          return;
        const n2 = this.documentView.findElementForObject(t2);
        if (!n2)
          return;
        this.uninstallAttachmentEditor();
        const r2 = this.composition.document.getAttachmentPieceForAttachment(t2);
        this.attachmentEditor = new Ii(r2, n2, this.element, e2), this.attachmentEditor.delegate = this;
      }
      uninstallAttachmentEditor() {
        var t2;
        return null === (t2 = this.attachmentEditor) || void 0 === t2 ? void 0 : t2.uninstall();
      }
      didUninstallAttachmentEditor() {
        return this.attachmentEditor = null, this.render();
      }
      attachmentEditorDidRequestUpdatingAttributesForAttachment(t2, e2) {
        var i2, n2;
        return null === (i2 = this.delegate) || void 0 === i2 || null === (n2 = i2.compositionControllerWillUpdateAttachment) || void 0 === n2 || n2.call(i2, e2), this.composition.updateAttributesForAttachment(t2, e2);
      }
      attachmentEditorDidRequestRemovingAttributeForAttachment(t2, e2) {
        var i2, n2;
        return null === (i2 = this.delegate) || void 0 === i2 || null === (n2 = i2.compositionControllerWillUpdateAttachment) || void 0 === n2 || n2.call(i2, e2), this.composition.removeAttributeForAttachment(t2, e2);
      }
      attachmentEditorDidRequestRemovalOfAttachment(t2) {
        var e2, i2;
        return null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionControllerDidRequestRemovalOfAttachment) || void 0 === i2 ? void 0 : i2.call(e2, t2);
      }
      attachmentEditorDidRequestDeselectingAttachment(t2) {
        var e2, i2;
        return null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionControllerDidRequestDeselectingAttachment) || void 0 === i2 ? void 0 : i2.call(e2, t2);
      }
      canSyncDocumentView() {
        return !this.isEditingAttachment();
      }
      findAttachmentForElement(t2) {
        return this.composition.document.getAttachmentById(parseInt(t2.dataset.trixId, 10));
      }
    }
    class Oi extends H {
    }
    const Mi = "data-trix-mutable", ji = "[".concat(Mi, "]"), Wi = { attributes: true, childList: true, characterData: true, characterDataOldValue: true, subtree: true };
    class Ui extends H {
      constructor(t2) {
        super(t2), this.didMutate = this.didMutate.bind(this), this.element = t2, this.observer = new window.MutationObserver(this.didMutate), this.start();
      }
      start() {
        return this.reset(), this.observer.observe(this.element, Wi);
      }
      stop() {
        return this.observer.disconnect();
      }
      didMutate(t2) {
        var e2, i2;
        if (this.mutations.push(...Array.from(this.findSignificantMutations(t2) || [])), this.mutations.length)
          return null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.elementDidMutate) || void 0 === i2 || i2.call(e2, this.getMutationSummary()), this.reset();
      }
      reset() {
        this.mutations = [];
      }
      findSignificantMutations(t2) {
        return t2.filter((t3) => this.mutationIsSignificant(t3));
      }
      mutationIsSignificant(t2) {
        if (this.nodeIsMutable(t2.target))
          return false;
        for (const e2 of Array.from(this.nodesModifiedByMutation(t2)))
          if (this.nodeIsSignificant(e2))
            return true;
        return false;
      }
      nodeIsSignificant(t2) {
        return t2 !== this.element && !this.nodeIsMutable(t2) && !N(t2);
      }
      nodeIsMutable(t2) {
        return A(t2, { matchingSelector: ji });
      }
      nodesModifiedByMutation(t2) {
        const e2 = [];
        switch (t2.type) {
          case "attributes":
            t2.attributeName !== Mi && e2.push(t2.target);
            break;
          case "characterData":
            e2.push(t2.target.parentNode), e2.push(t2.target);
            break;
          case "childList":
            e2.push(...Array.from(t2.addedNodes || [])), e2.push(...Array.from(t2.removedNodes || []));
        }
        return e2;
      }
      getMutationSummary() {
        return this.getTextMutationSummary();
      }
      getTextMutationSummary() {
        const { additions: t2, deletions: e2 } = this.getTextChangesFromCharacterData(), i2 = this.getTextChangesFromChildList();
        Array.from(i2.additions).forEach((e3) => {
          Array.from(t2).includes(e3) || t2.push(e3);
        }), e2.push(...Array.from(i2.deletions || []));
        const n2 = {}, r2 = t2.join("");
        r2 && (n2.textAdded = r2);
        const o2 = e2.join("");
        return o2 && (n2.textDeleted = o2), n2;
      }
      getMutationsByType(t2) {
        return Array.from(this.mutations).filter((e2) => e2.type === t2);
      }
      getTextChangesFromChildList() {
        let t2, e2;
        const i2 = [], n2 = [];
        Array.from(this.getMutationsByType("childList")).forEach((t3) => {
          i2.push(...Array.from(t3.addedNodes || [])), n2.push(...Array.from(t3.removedNodes || []));
        });
        0 === i2.length && 1 === n2.length && B(n2[0]) ? (t2 = [], e2 = ["\n"]) : (t2 = qi(i2), e2 = qi(n2));
        return { additions: t2.filter((t3, i3) => t3 !== e2[i3]).map(Wt), deletions: e2.filter((e3, i3) => e3 !== t2[i3]).map(Wt) };
      }
      getTextChangesFromCharacterData() {
        let t2, e2;
        const i2 = this.getMutationsByType("characterData");
        if (i2.length) {
          const n2 = i2[0], r2 = i2[i2.length - 1], o2 = function(t3, e3) {
            let i3, n3;
            return t3 = X.box(t3), (e3 = X.box(e3)).length < t3.length ? [n3, i3] = Vt(t3, e3) : [i3, n3] = Vt(e3, t3), { added: i3, removed: n3 };
          }(Wt(n2.oldValue), Wt(r2.target.data));
          t2 = o2.added, e2 = o2.removed;
        }
        return { additions: t2 ? [t2] : [], deletions: e2 ? [e2] : [] };
      }
    }
    const qi = function() {
      let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      const e2 = [];
      for (const i2 of Array.from(t2))
        switch (i2.nodeType) {
          case Node.TEXT_NODE:
            e2.push(i2.data);
            break;
          case Node.ELEMENT_NODE:
            "br" === E(i2) ? e2.push("\n") : e2.push(...Array.from(qi(i2.childNodes) || []));
        }
      return e2;
    };
    class Vi extends te {
      constructor(t2) {
        super(...arguments), this.file = t2;
      }
      perform(t2) {
        const e2 = new FileReader();
        return e2.onerror = () => t2(false), e2.onload = () => {
          e2.onerror = null;
          try {
            e2.abort();
          } catch (t3) {
          }
          return t2(true, this.file);
        }, e2.readAsArrayBuffer(this.file);
      }
    }
    class Hi {
      constructor(t2) {
        this.element = t2;
      }
      shouldIgnore(t2) {
        return !!a.samsungAndroid && (this.previousEvent = this.event, this.event = t2, this.checkSamsungKeyboardBuggyModeStart(), this.checkSamsungKeyboardBuggyModeEnd(), this.buggyMode);
      }
      checkSamsungKeyboardBuggyModeStart() {
        this.insertingLongTextAfterUnidentifiedChar() && zi(this.element.innerText, this.event.data) && (this.buggyMode = true, this.event.preventDefault());
      }
      checkSamsungKeyboardBuggyModeEnd() {
        this.buggyMode && "insertText" !== this.event.inputType && (this.buggyMode = false);
      }
      insertingLongTextAfterUnidentifiedChar() {
        var t2;
        return this.isBeforeInputInsertText() && this.previousEventWasUnidentifiedKeydown() && (null === (t2 = this.event.data) || void 0 === t2 ? void 0 : t2.length) > 50;
      }
      isBeforeInputInsertText() {
        return "beforeinput" === this.event.type && "insertText" === this.event.inputType;
      }
      previousEventWasUnidentifiedKeydown() {
        var t2, e2;
        return "keydown" === (null === (t2 = this.previousEvent) || void 0 === t2 ? void 0 : t2.type) && "Unidentified" === (null === (e2 = this.previousEvent) || void 0 === e2 ? void 0 : e2.key);
      }
    }
    const zi = (t2, e2) => Ji(t2) === Ji(e2), _i = new RegExp("(".concat("￼", "|").concat(h, "|").concat(d, "|\\s)+"), "g"), Ji = (t2) => t2.replace(_i, " ").trim();
    class Ki extends H {
      constructor(t2) {
        super(...arguments), this.element = t2, this.mutationObserver = new Ui(this.element), this.mutationObserver.delegate = this, this.flakyKeyboardDetector = new Hi(this.element);
        for (const t3 in this.constructor.events)
          f(t3, { onElement: this.element, withCallback: this.handlerFor(t3) });
      }
      elementDidMutate(t2) {
      }
      editorWillSyncDocumentView() {
        return this.mutationObserver.stop();
      }
      editorDidSyncDocumentView() {
        return this.mutationObserver.start();
      }
      requestRender() {
        var t2, e2;
        return null === (t2 = this.delegate) || void 0 === t2 || null === (e2 = t2.inputControllerDidRequestRender) || void 0 === e2 ? void 0 : e2.call(t2);
      }
      requestReparse() {
        var t2, e2;
        return null === (t2 = this.delegate) || void 0 === t2 || null === (e2 = t2.inputControllerDidRequestReparse) || void 0 === e2 || e2.call(t2), this.requestRender();
      }
      attachFiles(t2) {
        const e2 = Array.from(t2).map((t3) => new Vi(t3));
        return Promise.all(e2).then((t3) => {
          this.handleInput(function() {
            var e3, i2;
            return null === (e3 = this.delegate) || void 0 === e3 || e3.inputControllerWillAttachFiles(), null === (i2 = this.responder) || void 0 === i2 || i2.insertFiles(t3), this.requestRender();
          });
        });
      }
      handlerFor(t2) {
        return (e2) => {
          e2.defaultPrevented || this.handleInput(() => {
            if (!x(this.element)) {
              if (this.flakyKeyboardDetector.shouldIgnore(e2))
                return;
              this.eventName = t2, this.constructor.events[t2].call(this, e2);
            }
          });
        };
      }
      handleInput(t2) {
        try {
          var e2;
          null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillHandleInput(), t2.call(this);
        } finally {
          var i2;
          null === (i2 = this.delegate) || void 0 === i2 || i2.inputControllerDidHandleInput();
        }
      }
      createLinkHTML(t2, e2) {
        const i2 = document.createElement("a");
        return i2.href = t2, i2.textContent = e2 || t2, i2.outerHTML;
      }
    }
    var Gi;
    Ae(Ki, "events", {});
    const { browser: $i, keyNames: Xi } = V;
    let Yi = 0;
    class Qi extends Ki {
      constructor() {
        super(...arguments), this.resetInputSummary();
      }
      setInputSummary() {
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        this.inputSummary.eventName = this.eventName;
        for (const e2 in t2) {
          const i2 = t2[e2];
          this.inputSummary[e2] = i2;
        }
        return this.inputSummary;
      }
      resetInputSummary() {
        this.inputSummary = {};
      }
      reset() {
        return this.resetInputSummary(), Pt.reset();
      }
      elementDidMutate(t2) {
        var e2, i2;
        return this.isComposing() ? null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.inputControllerDidAllowUnhandledInput) || void 0 === i2 ? void 0 : i2.call(e2) : this.handleInput(function() {
          return this.mutationIsSignificant(t2) && (this.mutationIsExpected(t2) ? this.requestRender() : this.requestReparse()), this.reset();
        });
      }
      mutationIsExpected(t2) {
        let { textAdded: e2, textDeleted: i2 } = t2;
        if (this.inputSummary.preferDocument)
          return true;
        const n2 = null != e2 ? e2 === this.inputSummary.textAdded : !this.inputSummary.textAdded, r2 = null != i2 ? this.inputSummary.didDelete : !this.inputSummary.didDelete, o2 = ["\n", " \n"].includes(e2) && !n2, s2 = "\n" === i2 && !r2;
        if (o2 && !s2 || s2 && !o2) {
          const t3 = this.getSelectedRange();
          if (t3) {
            var a2;
            const i3 = o2 ? e2.replace(/\n$/, "").length || -1 : (null == e2 ? void 0 : e2.length) || 1;
            if (null !== (a2 = this.responder) && void 0 !== a2 && a2.positionIsBlockBreak(t3[1] + i3))
              return true;
          }
        }
        return n2 && r2;
      }
      mutationIsSignificant(t2) {
        var e2;
        const i2 = Object.keys(t2).length > 0, n2 = "" === (null === (e2 = this.compositionInput) || void 0 === e2 ? void 0 : e2.getEndData());
        return i2 || !n2;
      }
      getCompositionInput() {
        if (this.isComposing())
          return this.compositionInput;
        this.compositionInput = new rn(this);
      }
      isComposing() {
        return this.compositionInput && !this.compositionInput.isEnded();
      }
      deleteInDirection(t2, e2) {
        var i2;
        return false !== (null === (i2 = this.responder) || void 0 === i2 ? void 0 : i2.deleteInDirection(t2)) ? this.setInputSummary({ didDelete: true }) : e2 ? (e2.preventDefault(), this.requestRender()) : void 0;
      }
      serializeSelectionToDataTransfer(t2) {
        var e2;
        if (!function(t3) {
          if (null == t3 || !t3.setData)
            return false;
          for (const e3 in yt) {
            const i3 = yt[e3];
            try {
              if (t3.setData(e3, i3), !t3.getData(e3) === i3)
                return false;
            } catch (t4) {
              return false;
            }
          }
          return true;
        }(t2))
          return;
        const i2 = null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.getSelectedDocument().toSerializableDocument();
        return t2.setData("application/x-trix-document", JSON.stringify(i2)), t2.setData("text/html", ge.render(i2).innerHTML), t2.setData("text/plain", i2.toString().replace(/\n$/, "")), true;
      }
      canAcceptDataTransfer(t2) {
        const e2 = {};
        return Array.from((null == t2 ? void 0 : t2.types) || []).forEach((t3) => {
          e2[t3] = true;
        }), e2.Files || e2["application/x-trix-document"] || e2["text/html"] || e2["text/plain"];
      }
      getPastedHTMLUsingHiddenElement(t2) {
        const e2 = this.getSelectedRange(), i2 = { position: "absolute", left: "".concat(window.pageXOffset, "px"), top: "".concat(window.pageYOffset, "px"), opacity: 0 }, n2 = S({ style: i2, tagName: "div", editable: true });
        return document.body.appendChild(n2), n2.focus(), requestAnimationFrame(() => {
          const i3 = n2.innerHTML;
          return k(n2), this.setSelectedRange(e2), t2(i3);
        });
      }
    }
    Ae(Qi, "events", { keydown(t2) {
      this.isComposing() || this.resetInputSummary(), this.inputSummary.didInput = true;
      const e2 = Xi[t2.keyCode];
      if (e2) {
        var i2;
        let n3 = this.keys;
        ["ctrl", "alt", "shift", "meta"].forEach((e3) => {
          var i3;
          t2["".concat(e3, "Key")] && ("ctrl" === e3 && (e3 = "control"), n3 = null === (i3 = n3) || void 0 === i3 ? void 0 : i3[e3]);
        }), null != (null === (i2 = n3) || void 0 === i2 ? void 0 : i2[e2]) && (this.setInputSummary({ keyName: e2 }), Pt.reset(), n3[e2].call(this, t2));
      }
      if (kt(t2)) {
        const e3 = String.fromCharCode(t2.keyCode).toLowerCase();
        if (e3) {
          var n2;
          const i3 = ["alt", "shift"].map((e4) => {
            if (t2["".concat(e4, "Key")])
              return e4;
          }).filter((t3) => t3);
          i3.push(e3), null !== (n2 = this.delegate) && void 0 !== n2 && n2.inputControllerDidReceiveKeyboardCommand(i3) && t2.preventDefault();
        }
      }
    }, keypress(t2) {
      if (null != this.inputSummary.eventName)
        return;
      if (t2.metaKey)
        return;
      if (t2.ctrlKey && !t2.altKey)
        return;
      const e2 = en(t2);
      var i2, n2;
      return e2 ? (null === (i2 = this.delegate) || void 0 === i2 || i2.inputControllerWillPerformTyping(), null === (n2 = this.responder) || void 0 === n2 || n2.insertString(e2), this.setInputSummary({ textAdded: e2, didDelete: this.selectionIsExpanded() })) : void 0;
    }, textInput(t2) {
      const { data: e2 } = t2, { textAdded: i2 } = this.inputSummary;
      if (i2 && i2 !== e2 && i2.toUpperCase() === e2) {
        var n2;
        const t3 = this.getSelectedRange();
        return this.setSelectedRange([t3[0], t3[1] + i2.length]), null === (n2 = this.responder) || void 0 === n2 || n2.insertString(e2), this.setInputSummary({ textAdded: e2 }), this.setSelectedRange(t3);
      }
    }, dragenter(t2) {
      t2.preventDefault();
    }, dragstart(t2) {
      var e2, i2;
      return this.serializeSelectionToDataTransfer(t2.dataTransfer), this.draggedRange = this.getSelectedRange(), null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.inputControllerDidStartDrag) || void 0 === i2 ? void 0 : i2.call(e2);
    }, dragover(t2) {
      if (this.draggedRange || this.canAcceptDataTransfer(t2.dataTransfer)) {
        t2.preventDefault();
        const n2 = { x: t2.clientX, y: t2.clientY };
        var e2, i2;
        if (!St(n2, this.draggingPoint))
          return this.draggingPoint = n2, null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.inputControllerDidReceiveDragOverPoint) || void 0 === i2 ? void 0 : i2.call(e2, this.draggingPoint);
      }
    }, dragend(t2) {
      var e2, i2;
      null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.inputControllerDidCancelDrag) || void 0 === i2 || i2.call(e2), this.draggedRange = null, this.draggingPoint = null;
    }, drop(t2) {
      var e2, i2;
      t2.preventDefault();
      const n2 = null === (e2 = t2.dataTransfer) || void 0 === e2 ? void 0 : e2.files, r2 = t2.dataTransfer.getData("application/x-trix-document"), o2 = { x: t2.clientX, y: t2.clientY };
      if (null === (i2 = this.responder) || void 0 === i2 || i2.setLocationRangeFromPointRange(o2), null != n2 && n2.length)
        this.attachFiles(n2);
      else if (this.draggedRange) {
        var s2, a2;
        null === (s2 = this.delegate) || void 0 === s2 || s2.inputControllerWillMoveText(), null === (a2 = this.responder) || void 0 === a2 || a2.moveTextFromRange(this.draggedRange), this.draggedRange = null, this.requestRender();
      } else if (r2) {
        var l2;
        const t3 = qe.fromJSONString(r2);
        null === (l2 = this.responder) || void 0 === l2 || l2.insertDocument(t3), this.requestRender();
      }
      this.draggedRange = null, this.draggingPoint = null;
    }, cut(t2) {
      var e2, i2;
      if (null !== (e2 = this.responder) && void 0 !== e2 && e2.selectionIsExpanded() && (this.serializeSelectionToDataTransfer(t2.clipboardData) && t2.preventDefault(), null === (i2 = this.delegate) || void 0 === i2 || i2.inputControllerWillCutText(), this.deleteInDirection("backward"), t2.defaultPrevented))
        return this.requestRender();
    }, copy(t2) {
      var e2;
      null !== (e2 = this.responder) && void 0 !== e2 && e2.selectionIsExpanded() && this.serializeSelectionToDataTransfer(t2.clipboardData) && t2.preventDefault();
    }, paste(t2) {
      const e2 = t2.clipboardData || t2.testClipboardData, i2 = { clipboard: e2 };
      if (!e2 || nn(t2))
        return void this.getPastedHTMLUsingHiddenElement((t3) => {
          var e3, n3, r3;
          return i2.type = "text/html", i2.html = t3, null === (e3 = this.delegate) || void 0 === e3 || e3.inputControllerWillPaste(i2), null === (n3 = this.responder) || void 0 === n3 || n3.insertHTML(i2.html), this.requestRender(), null === (r3 = this.delegate) || void 0 === r3 ? void 0 : r3.inputControllerDidPaste(i2);
        });
      const n2 = e2.getData("URL"), r2 = e2.getData("text/html"), o2 = e2.getData("public.url-name");
      if (n2) {
        var s2, a2, l2;
        let t3;
        i2.type = "text/html", t3 = o2 ? qt(o2).trim() : n2, i2.html = this.createLinkHTML(n2, t3), null === (s2 = this.delegate) || void 0 === s2 || s2.inputControllerWillPaste(i2), this.setInputSummary({ textAdded: t3, didDelete: this.selectionIsExpanded() }), null === (a2 = this.responder) || void 0 === a2 || a2.insertHTML(i2.html), this.requestRender(), null === (l2 = this.delegate) || void 0 === l2 || l2.inputControllerDidPaste(i2);
      } else if (Ct(e2)) {
        var c2, u2, h2;
        i2.type = "text/plain", i2.string = e2.getData("text/plain"), null === (c2 = this.delegate) || void 0 === c2 || c2.inputControllerWillPaste(i2), this.setInputSummary({ textAdded: i2.string, didDelete: this.selectionIsExpanded() }), null === (u2 = this.responder) || void 0 === u2 || u2.insertString(i2.string), this.requestRender(), null === (h2 = this.delegate) || void 0 === h2 || h2.inputControllerDidPaste(i2);
      } else if (r2) {
        var d2, g2, m2;
        i2.type = "text/html", i2.html = r2, null === (d2 = this.delegate) || void 0 === d2 || d2.inputControllerWillPaste(i2), null === (g2 = this.responder) || void 0 === g2 || g2.insertHTML(i2.html), this.requestRender(), null === (m2 = this.delegate) || void 0 === m2 || m2.inputControllerDidPaste(i2);
      } else if (Array.from(e2.types).includes("Files")) {
        var p2, f2;
        const t3 = null === (p2 = e2.items) || void 0 === p2 || null === (p2 = p2[0]) || void 0 === p2 || null === (f2 = p2.getAsFile) || void 0 === f2 ? void 0 : f2.call(p2);
        if (t3) {
          var b2, v2, A2;
          const e3 = Zi(t3);
          !t3.name && e3 && (t3.name = "pasted-file-".concat(++Yi, ".").concat(e3)), i2.type = "File", i2.file = t3, null === (b2 = this.delegate) || void 0 === b2 || b2.inputControllerWillAttachFiles(), null === (v2 = this.responder) || void 0 === v2 || v2.insertFile(i2.file), this.requestRender(), null === (A2 = this.delegate) || void 0 === A2 || A2.inputControllerDidPaste(i2);
        }
      }
      t2.preventDefault();
    }, compositionstart(t2) {
      return this.getCompositionInput().start(t2.data);
    }, compositionupdate(t2) {
      return this.getCompositionInput().update(t2.data);
    }, compositionend(t2) {
      return this.getCompositionInput().end(t2.data);
    }, beforeinput(t2) {
      this.inputSummary.didInput = true;
    }, input(t2) {
      return this.inputSummary.didInput = true, t2.stopPropagation();
    } }), Ae(Qi, "keys", { backspace(t2) {
      var e2;
      return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t2);
    }, delete(t2) {
      var e2;
      return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t2);
    }, return(t2) {
      var e2, i2;
      return this.setInputSummary({ preferDocument: true }), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i2 = this.responder) || void 0 === i2 ? void 0 : i2.insertLineBreak();
    }, tab(t2) {
      var e2, i2;
      null !== (e2 = this.responder) && void 0 !== e2 && e2.canIncreaseNestingLevel() && (null === (i2 = this.responder) || void 0 === i2 || i2.increaseNestingLevel(), this.requestRender(), t2.preventDefault());
    }, left(t2) {
      var e2;
      if (this.selectionIsInCursorTarget())
        return t2.preventDefault(), null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.moveCursorInDirection("backward");
    }, right(t2) {
      var e2;
      if (this.selectionIsInCursorTarget())
        return t2.preventDefault(), null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.moveCursorInDirection("forward");
    }, control: { d(t2) {
      var e2;
      return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t2);
    }, h(t2) {
      var e2;
      return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t2);
    }, o(t2) {
      var e2, i2;
      return t2.preventDefault(), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i2 = this.responder) || void 0 === i2 || i2.insertString("\n", { updatePosition: false }), this.requestRender();
    } }, shift: { return(t2) {
      var e2, i2;
      null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i2 = this.responder) || void 0 === i2 || i2.insertString("\n"), this.requestRender(), t2.preventDefault();
    }, tab(t2) {
      var e2, i2;
      null !== (e2 = this.responder) && void 0 !== e2 && e2.canDecreaseNestingLevel() && (null === (i2 = this.responder) || void 0 === i2 || i2.decreaseNestingLevel(), this.requestRender(), t2.preventDefault());
    }, left(t2) {
      if (this.selectionIsInCursorTarget())
        return t2.preventDefault(), this.expandSelectionInDirection("backward");
    }, right(t2) {
      if (this.selectionIsInCursorTarget())
        return t2.preventDefault(), this.expandSelectionInDirection("forward");
    } }, alt: { backspace(t2) {
      var e2;
      return this.setInputSummary({ preferDocument: false }), null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.inputControllerWillPerformTyping();
    } }, meta: { backspace(t2) {
      var e2;
      return this.setInputSummary({ preferDocument: false }), null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.inputControllerWillPerformTyping();
    } } }), Qi.proxyMethod("responder?.getSelectedRange"), Qi.proxyMethod("responder?.setSelectedRange"), Qi.proxyMethod("responder?.expandSelectionInDirection"), Qi.proxyMethod("responder?.selectionIsInCursorTarget"), Qi.proxyMethod("responder?.selectionIsExpanded");
    const Zi = (t2) => {
      var e2;
      return null === (e2 = t2.type) || void 0 === e2 || null === (e2 = e2.match(/\/(\w+)$/)) || void 0 === e2 ? void 0 : e2[1];
    }, tn = !(null === (Gi = " ".codePointAt) || void 0 === Gi || !Gi.call(" ", 0)), en = function(t2) {
      if (t2.key && tn && t2.key.codePointAt(0) === t2.keyCode)
        return t2.key;
      {
        let e2;
        if (null === t2.which ? e2 = t2.keyCode : 0 !== t2.which && 0 !== t2.charCode && (e2 = t2.charCode), null != e2 && "escape" !== Xi[e2])
          return X.fromCodepoints([e2]).toString();
      }
    }, nn = function(t2) {
      const e2 = t2.clipboardData;
      if (e2) {
        if (e2.types.includes("text/html")) {
          for (const t3 of e2.types) {
            const i2 = /^CorePasteboardFlavorType/.test(t3), n2 = /^dyn\./.test(t3) && e2.getData(t3);
            if (i2 || n2)
              return true;
          }
          return false;
        }
        {
          const t3 = e2.types.includes("com.apple.webarchive"), i2 = e2.types.includes("com.apple.flat-rtfd");
          return t3 || i2;
        }
      }
    };
    class rn extends H {
      constructor(t2) {
        super(...arguments), this.inputController = t2, this.responder = this.inputController.responder, this.delegate = this.inputController.delegate, this.inputSummary = this.inputController.inputSummary, this.data = {};
      }
      start(t2) {
        if (this.data.start = t2, this.isSignificant()) {
          var e2, i2;
          if ("keypress" === this.inputSummary.eventName && this.inputSummary.textAdded)
            null === (i2 = this.responder) || void 0 === i2 || i2.deleteInDirection("left");
          this.selectionIsExpanded() || (this.insertPlaceholder(), this.requestRender()), this.range = null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.getSelectedRange();
        }
      }
      update(t2) {
        if (this.data.update = t2, this.isSignificant()) {
          const t3 = this.selectPlaceholder();
          t3 && (this.forgetPlaceholder(), this.range = t3);
        }
      }
      end(t2) {
        return this.data.end = t2, this.isSignificant() ? (this.forgetPlaceholder(), this.canApplyToDocument() ? (this.setInputSummary({ preferDocument: true, didInput: false }), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i2 = this.responder) || void 0 === i2 || i2.setSelectedRange(this.range), null === (n2 = this.responder) || void 0 === n2 || n2.insertString(this.data.end), null === (r2 = this.responder) || void 0 === r2 ? void 0 : r2.setSelectedRange(this.range[0] + this.data.end.length)) : null != this.data.start || null != this.data.update ? (this.requestReparse(), this.inputController.reset()) : void 0) : this.inputController.reset();
        var e2, i2, n2, r2;
      }
      getEndData() {
        return this.data.end;
      }
      isEnded() {
        return null != this.getEndData();
      }
      isSignificant() {
        return !$i.composesExistingText || this.inputSummary.didInput;
      }
      canApplyToDocument() {
        var t2, e2;
        return 0 === (null === (t2 = this.data.start) || void 0 === t2 ? void 0 : t2.length) && (null === (e2 = this.data.end) || void 0 === e2 ? void 0 : e2.length) > 0 && this.range;
      }
    }
    rn.proxyMethod("inputController.setInputSummary"), rn.proxyMethod("inputController.requestRender"), rn.proxyMethod("inputController.requestReparse"), rn.proxyMethod("responder?.selectionIsExpanded"), rn.proxyMethod("responder?.insertPlaceholder"), rn.proxyMethod("responder?.selectPlaceholder"), rn.proxyMethod("responder?.forgetPlaceholder");
    class on extends Ki {
      constructor() {
        super(...arguments), this.render = this.render.bind(this);
      }
      elementDidMutate() {
        return this.scheduledRender ? this.composing ? null === (t2 = this.delegate) || void 0 === t2 || null === (e2 = t2.inputControllerDidAllowUnhandledInput) || void 0 === e2 ? void 0 : e2.call(t2) : void 0 : this.reparse();
        var t2, e2;
      }
      scheduleRender() {
        return this.scheduledRender ? this.scheduledRender : this.scheduledRender = requestAnimationFrame(this.render);
      }
      render() {
        var t2, e2;
        (cancelAnimationFrame(this.scheduledRender), this.scheduledRender = null, this.composing) || (null === (e2 = this.delegate) || void 0 === e2 || e2.render());
        null === (t2 = this.afterRender) || void 0 === t2 || t2.call(this), this.afterRender = null;
      }
      reparse() {
        var t2;
        return null === (t2 = this.delegate) || void 0 === t2 ? void 0 : t2.reparse();
      }
      insertString() {
        var t2;
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", i2 = arguments.length > 1 ? arguments[1] : void 0;
        return null === (t2 = this.delegate) || void 0 === t2 || t2.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
          var t3;
          return null === (t3 = this.responder) || void 0 === t3 ? void 0 : t3.insertString(e2, i2);
        });
      }
      toggleAttributeIfSupported(t2) {
        var e2;
        if (dt().includes(t2))
          return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformFormatting(t2), this.withTargetDOMRange(function() {
            var e3;
            return null === (e3 = this.responder) || void 0 === e3 ? void 0 : e3.toggleCurrentAttribute(t2);
          });
      }
      activateAttributeIfSupported(t2, e2) {
        var i2;
        if (dt().includes(t2))
          return null === (i2 = this.delegate) || void 0 === i2 || i2.inputControllerWillPerformFormatting(t2), this.withTargetDOMRange(function() {
            var i3;
            return null === (i3 = this.responder) || void 0 === i3 ? void 0 : i3.setCurrentAttribute(t2, e2);
          });
      }
      deleteInDirection(t2) {
        let { recordUndoEntry: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { recordUndoEntry: true };
        var i2;
        e2 && (null === (i2 = this.delegate) || void 0 === i2 || i2.inputControllerWillPerformTyping());
        const n2 = () => {
          var e3;
          return null === (e3 = this.responder) || void 0 === e3 ? void 0 : e3.deleteInDirection(t2);
        }, r2 = this.getTargetDOMRange({ minLength: this.composing ? 1 : 2 });
        return r2 ? this.withTargetDOMRange(r2, n2) : n2();
      }
      withTargetDOMRange(t2, e2) {
        var i2;
        return "function" == typeof t2 && (e2 = t2, t2 = this.getTargetDOMRange()), t2 ? null === (i2 = this.responder) || void 0 === i2 ? void 0 : i2.withTargetDOMRange(t2, e2.bind(this)) : (Pt.reset(), e2.call(this));
      }
      getTargetDOMRange() {
        var t2, e2;
        let { minLength: i2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { minLength: 0 };
        const n2 = null === (t2 = (e2 = this.event).getTargetRanges) || void 0 === t2 ? void 0 : t2.call(e2);
        if (n2 && n2.length) {
          const t3 = sn(n2[0]);
          if (0 === i2 || t3.toString().length >= i2)
            return t3;
        }
      }
      withEvent(t2, e2) {
        let i2;
        this.event = t2;
        try {
          i2 = e2.call(this);
        } finally {
          this.event = null;
        }
        return i2;
      }
    }
    Ae(on, "events", { keydown(t2) {
      if (kt(t2)) {
        var e2;
        const i2 = hn(t2);
        null !== (e2 = this.delegate) && void 0 !== e2 && e2.inputControllerDidReceiveKeyboardCommand(i2) && t2.preventDefault();
      } else {
        let e3 = t2.key;
        t2.altKey && (e3 += "+Alt"), t2.shiftKey && (e3 += "+Shift");
        const i2 = this.constructor.keys[e3];
        if (i2)
          return this.withEvent(t2, i2);
      }
    }, paste(t2) {
      var e2;
      let i2;
      const n2 = null === (e2 = t2.clipboardData) || void 0 === e2 ? void 0 : e2.getData("URL");
      return cn(t2) ? (t2.preventDefault(), this.attachFiles(t2.clipboardData.files)) : un(t2) ? (t2.preventDefault(), i2 = { type: "text/plain", string: t2.clipboardData.getData("text/plain") }, null === (r2 = this.delegate) || void 0 === r2 || r2.inputControllerWillPaste(i2), null === (o2 = this.responder) || void 0 === o2 || o2.insertString(i2.string), this.render(), null === (s2 = this.delegate) || void 0 === s2 ? void 0 : s2.inputControllerDidPaste(i2)) : n2 ? (t2.preventDefault(), i2 = { type: "text/html", html: this.createLinkHTML(n2) }, null === (a2 = this.delegate) || void 0 === a2 || a2.inputControllerWillPaste(i2), null === (l2 = this.responder) || void 0 === l2 || l2.insertHTML(i2.html), this.render(), null === (c2 = this.delegate) || void 0 === c2 ? void 0 : c2.inputControllerDidPaste(i2)) : void 0;
      var r2, o2, s2, a2, l2, c2;
    }, beforeinput(t2) {
      const e2 = this.constructor.inputTypes[t2.inputType];
      e2 && (this.withEvent(t2, e2), this.scheduleRender());
    }, input(t2) {
      Pt.reset();
    }, dragstart(t2) {
      var e2, i2;
      null !== (e2 = this.responder) && void 0 !== e2 && e2.selectionContainsAttachments() && (t2.dataTransfer.setData("application/x-trix-dragging", true), this.dragging = { range: null === (i2 = this.responder) || void 0 === i2 ? void 0 : i2.getSelectedRange(), point: dn(t2) });
    }, dragenter(t2) {
      an(t2) && t2.preventDefault();
    }, dragover(t2) {
      if (this.dragging) {
        t2.preventDefault();
        const i2 = dn(t2);
        var e2;
        if (!St(i2, this.dragging.point))
          return this.dragging.point = i2, null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.setLocationRangeFromPointRange(i2);
      } else
        an(t2) && t2.preventDefault();
    }, drop(t2) {
      var e2, i2;
      if (this.dragging)
        return t2.preventDefault(), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillMoveText(), null === (i2 = this.responder) || void 0 === i2 || i2.moveTextFromRange(this.dragging.range), this.dragging = null, this.scheduleRender();
      if (an(t2)) {
        var n2;
        t2.preventDefault();
        const e3 = dn(t2);
        return null === (n2 = this.responder) || void 0 === n2 || n2.setLocationRangeFromPointRange(e3), this.attachFiles(t2.dataTransfer.files);
      }
    }, dragend() {
      var t2;
      this.dragging && (null === (t2 = this.responder) || void 0 === t2 || t2.setSelectedRange(this.dragging.range), this.dragging = null);
    }, compositionend(t2) {
      this.composing && (this.composing = false, a.recentAndroid || this.scheduleRender());
    } }), Ae(on, "keys", { ArrowLeft() {
      var t2, e2;
      if (null !== (t2 = this.responder) && void 0 !== t2 && t2.shouldManageMovingCursorInDirection("backward"))
        return this.event.preventDefault(), null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.moveCursorInDirection("backward");
    }, ArrowRight() {
      var t2, e2;
      if (null !== (t2 = this.responder) && void 0 !== t2 && t2.shouldManageMovingCursorInDirection("forward"))
        return this.event.preventDefault(), null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.moveCursorInDirection("forward");
    }, Backspace() {
      var t2, e2, i2;
      if (null !== (t2 = this.responder) && void 0 !== t2 && t2.shouldManageDeletingInDirection("backward"))
        return this.event.preventDefault(), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i2 = this.responder) || void 0 === i2 || i2.deleteInDirection("backward"), this.render();
    }, Tab() {
      var t2, e2;
      if (null !== (t2 = this.responder) && void 0 !== t2 && t2.canIncreaseNestingLevel())
        return this.event.preventDefault(), null === (e2 = this.responder) || void 0 === e2 || e2.increaseNestingLevel(), this.render();
    }, "Tab+Shift"() {
      var t2, e2;
      if (null !== (t2 = this.responder) && void 0 !== t2 && t2.canDecreaseNestingLevel())
        return this.event.preventDefault(), null === (e2 = this.responder) || void 0 === e2 || e2.decreaseNestingLevel(), this.render();
    } }), Ae(on, "inputTypes", { deleteByComposition() {
      return this.deleteInDirection("backward", { recordUndoEntry: false });
    }, deleteByCut() {
      return this.deleteInDirection("backward");
    }, deleteByDrag() {
      return this.event.preventDefault(), this.withTargetDOMRange(function() {
        var t2;
        this.deleteByDragRange = null === (t2 = this.responder) || void 0 === t2 ? void 0 : t2.getSelectedRange();
      });
    }, deleteCompositionText() {
      return this.deleteInDirection("backward", { recordUndoEntry: false });
    }, deleteContent() {
      return this.deleteInDirection("backward");
    }, deleteContentBackward() {
      return this.deleteInDirection("backward");
    }, deleteContentForward() {
      return this.deleteInDirection("forward");
    }, deleteEntireSoftLine() {
      return this.deleteInDirection("forward");
    }, deleteHardLineBackward() {
      return this.deleteInDirection("backward");
    }, deleteHardLineForward() {
      return this.deleteInDirection("forward");
    }, deleteSoftLineBackward() {
      return this.deleteInDirection("backward");
    }, deleteSoftLineForward() {
      return this.deleteInDirection("forward");
    }, deleteWordBackward() {
      return this.deleteInDirection("backward");
    }, deleteWordForward() {
      return this.deleteInDirection("forward");
    }, formatBackColor() {
      return this.activateAttributeIfSupported("backgroundColor", this.event.data);
    }, formatBold() {
      return this.toggleAttributeIfSupported("bold");
    }, formatFontColor() {
      return this.activateAttributeIfSupported("color", this.event.data);
    }, formatFontName() {
      return this.activateAttributeIfSupported("font", this.event.data);
    }, formatIndent() {
      var t2;
      if (null !== (t2 = this.responder) && void 0 !== t2 && t2.canIncreaseNestingLevel())
        return this.withTargetDOMRange(function() {
          var t3;
          return null === (t3 = this.responder) || void 0 === t3 ? void 0 : t3.increaseNestingLevel();
        });
    }, formatItalic() {
      return this.toggleAttributeIfSupported("italic");
    }, formatJustifyCenter() {
      return this.toggleAttributeIfSupported("justifyCenter");
    }, formatJustifyFull() {
      return this.toggleAttributeIfSupported("justifyFull");
    }, formatJustifyLeft() {
      return this.toggleAttributeIfSupported("justifyLeft");
    }, formatJustifyRight() {
      return this.toggleAttributeIfSupported("justifyRight");
    }, formatOutdent() {
      var t2;
      if (null !== (t2 = this.responder) && void 0 !== t2 && t2.canDecreaseNestingLevel())
        return this.withTargetDOMRange(function() {
          var t3;
          return null === (t3 = this.responder) || void 0 === t3 ? void 0 : t3.decreaseNestingLevel();
        });
    }, formatRemove() {
      this.withTargetDOMRange(function() {
        for (const i2 in null === (t2 = this.responder) || void 0 === t2 ? void 0 : t2.getCurrentAttributes()) {
          var t2, e2;
          null === (e2 = this.responder) || void 0 === e2 || e2.removeCurrentAttribute(i2);
        }
      });
    }, formatSetBlockTextDirection() {
      return this.activateAttributeIfSupported("blockDir", this.event.data);
    }, formatSetInlineTextDirection() {
      return this.activateAttributeIfSupported("textDir", this.event.data);
    }, formatStrikeThrough() {
      return this.toggleAttributeIfSupported("strike");
    }, formatSubscript() {
      return this.toggleAttributeIfSupported("sub");
    }, formatSuperscript() {
      return this.toggleAttributeIfSupported("sup");
    }, formatUnderline() {
      return this.toggleAttributeIfSupported("underline");
    }, historyRedo() {
      var t2;
      return null === (t2 = this.delegate) || void 0 === t2 ? void 0 : t2.inputControllerWillPerformRedo();
    }, historyUndo() {
      var t2;
      return null === (t2 = this.delegate) || void 0 === t2 ? void 0 : t2.inputControllerWillPerformUndo();
    }, insertCompositionText() {
      return this.composing = true, this.insertString(this.event.data);
    }, insertFromComposition() {
      return this.composing = false, this.insertString(this.event.data);
    }, insertFromDrop() {
      const t2 = this.deleteByDragRange;
      var e2;
      if (t2)
        return this.deleteByDragRange = null, null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillMoveText(), this.withTargetDOMRange(function() {
          var e3;
          return null === (e3 = this.responder) || void 0 === e3 ? void 0 : e3.moveTextFromRange(t2);
        });
    }, insertFromPaste() {
      const { dataTransfer: t2 } = this.event, e2 = { dataTransfer: t2 }, i2 = t2.getData("URL"), n2 = t2.getData("text/html");
      if (i2) {
        var r2;
        let n3;
        this.event.preventDefault(), e2.type = "text/html";
        const o3 = t2.getData("public.url-name");
        n3 = o3 ? qt(o3).trim() : i2, e2.html = this.createLinkHTML(i2, n3), null === (r2 = this.delegate) || void 0 === r2 || r2.inputControllerWillPaste(e2), this.withTargetDOMRange(function() {
          var t3;
          return null === (t3 = this.responder) || void 0 === t3 ? void 0 : t3.insertHTML(e2.html);
        }), this.afterRender = () => {
          var t3;
          return null === (t3 = this.delegate) || void 0 === t3 ? void 0 : t3.inputControllerDidPaste(e2);
        };
      } else if (Ct(t2)) {
        var o2;
        e2.type = "text/plain", e2.string = t2.getData("text/plain"), null === (o2 = this.delegate) || void 0 === o2 || o2.inputControllerWillPaste(e2), this.withTargetDOMRange(function() {
          var t3;
          return null === (t3 = this.responder) || void 0 === t3 ? void 0 : t3.insertString(e2.string);
        }), this.afterRender = () => {
          var t3;
          return null === (t3 = this.delegate) || void 0 === t3 ? void 0 : t3.inputControllerDidPaste(e2);
        };
      } else if (ln(this.event)) {
        var s2;
        e2.type = "File", e2.file = t2.files[0], null === (s2 = this.delegate) || void 0 === s2 || s2.inputControllerWillPaste(e2), this.withTargetDOMRange(function() {
          var t3;
          return null === (t3 = this.responder) || void 0 === t3 ? void 0 : t3.insertFile(e2.file);
        }), this.afterRender = () => {
          var t3;
          return null === (t3 = this.delegate) || void 0 === t3 ? void 0 : t3.inputControllerDidPaste(e2);
        };
      } else if (n2) {
        var a2;
        this.event.preventDefault(), e2.type = "text/html", e2.html = n2, null === (a2 = this.delegate) || void 0 === a2 || a2.inputControllerWillPaste(e2), this.withTargetDOMRange(function() {
          var t3;
          return null === (t3 = this.responder) || void 0 === t3 ? void 0 : t3.insertHTML(e2.html);
        }), this.afterRender = () => {
          var t3;
          return null === (t3 = this.delegate) || void 0 === t3 ? void 0 : t3.inputControllerDidPaste(e2);
        };
      }
    }, insertFromYank() {
      return this.insertString(this.event.data);
    }, insertLineBreak() {
      return this.insertString("\n");
    }, insertLink() {
      return this.activateAttributeIfSupported("href", this.event.data);
    }, insertOrderedList() {
      return this.toggleAttributeIfSupported("number");
    }, insertParagraph() {
      var t2;
      return null === (t2 = this.delegate) || void 0 === t2 || t2.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
        var t3;
        return null === (t3 = this.responder) || void 0 === t3 ? void 0 : t3.insertLineBreak();
      });
    }, insertReplacementText() {
      const t2 = this.event.dataTransfer.getData("text/plain"), e2 = this.event.getTargetRanges()[0];
      this.withTargetDOMRange(e2, () => {
        this.insertString(t2, { updatePosition: false });
      });
    }, insertText() {
      var t2;
      return this.insertString(this.event.data || (null === (t2 = this.event.dataTransfer) || void 0 === t2 ? void 0 : t2.getData("text/plain")));
    }, insertTranspose() {
      return this.insertString(this.event.data);
    }, insertUnorderedList() {
      return this.toggleAttributeIfSupported("bullet");
    } });
    const sn = function(t2) {
      const e2 = document.createRange();
      return e2.setStart(t2.startContainer, t2.startOffset), e2.setEnd(t2.endContainer, t2.endOffset), e2;
    }, an = (t2) => {
      var e2;
      return Array.from((null === (e2 = t2.dataTransfer) || void 0 === e2 ? void 0 : e2.types) || []).includes("Files");
    }, ln = (t2) => {
      var e2;
      return (null === (e2 = t2.dataTransfer.files) || void 0 === e2 ? void 0 : e2[0]) && !cn(t2) && !((t3) => {
        let { dataTransfer: e3 } = t3;
        return e3.types.includes("Files") && e3.types.includes("text/html") && e3.getData("text/html").includes("urn:schemas-microsoft-com:office:office");
      })(t2);
    }, cn = function(t2) {
      const e2 = t2.clipboardData;
      if (e2) {
        return Array.from(e2.types).filter((t3) => t3.match(/file/i)).length === e2.types.length && e2.files.length >= 1;
      }
    }, un = function(t2) {
      const e2 = t2.clipboardData;
      if (e2)
        return e2.types.includes("text/plain") && 1 === e2.types.length;
    }, hn = function(t2) {
      const e2 = [];
      return t2.altKey && e2.push("alt"), t2.shiftKey && e2.push("shift"), e2.push(t2.key), e2;
    }, dn = (t2) => ({ x: t2.clientX, y: t2.clientY }), gn = "[data-trix-attribute]", mn = "[data-trix-action]", pn = "".concat(gn, ", ").concat(mn), fn = "[data-trix-dialog]", bn = "".concat(fn, "[data-trix-active]"), vn = "".concat(fn, " [data-trix-method]"), An = "".concat(fn, " [data-trix-input]"), xn = (t2, e2) => (e2 || (e2 = Cn(t2)), t2.querySelector("[data-trix-input][name='".concat(e2, "']"))), yn = (t2) => t2.getAttribute("data-trix-action"), Cn = (t2) => t2.getAttribute("data-trix-attribute") || t2.getAttribute("data-trix-dialog-attribute");
    class kn extends H {
      constructor(t2) {
        super(t2), this.didClickActionButton = this.didClickActionButton.bind(this), this.didClickAttributeButton = this.didClickAttributeButton.bind(this), this.didClickDialogButton = this.didClickDialogButton.bind(this), this.didKeyDownDialogInput = this.didKeyDownDialogInput.bind(this), this.element = t2, this.attributes = {}, this.actions = {}, this.resetDialogInputs(), f("mousedown", { onElement: this.element, matchingSelector: mn, withCallback: this.didClickActionButton }), f("mousedown", { onElement: this.element, matchingSelector: gn, withCallback: this.didClickAttributeButton }), f("click", { onElement: this.element, matchingSelector: pn, preventDefault: true }), f("click", { onElement: this.element, matchingSelector: vn, withCallback: this.didClickDialogButton }), f("keydown", { onElement: this.element, matchingSelector: An, withCallback: this.didKeyDownDialogInput });
      }
      didClickActionButton(t2, e2) {
        var i2;
        null === (i2 = this.delegate) || void 0 === i2 || i2.toolbarDidClickButton(), t2.preventDefault();
        const n2 = yn(e2);
        return this.getDialog(n2) ? this.toggleDialog(n2) : null === (r2 = this.delegate) || void 0 === r2 ? void 0 : r2.toolbarDidInvokeAction(n2, e2);
        var r2;
      }
      didClickAttributeButton(t2, e2) {
        var i2;
        null === (i2 = this.delegate) || void 0 === i2 || i2.toolbarDidClickButton(), t2.preventDefault();
        const n2 = Cn(e2);
        var r2;
        this.getDialog(n2) ? this.toggleDialog(n2) : null === (r2 = this.delegate) || void 0 === r2 || r2.toolbarDidToggleAttribute(n2);
        return this.refreshAttributeButtons();
      }
      didClickDialogButton(t2, e2) {
        const i2 = A(e2, { matchingSelector: fn });
        return this[e2.getAttribute("data-trix-method")].call(this, i2);
      }
      didKeyDownDialogInput(t2, e2) {
        if (13 === t2.keyCode) {
          t2.preventDefault();
          const i2 = e2.getAttribute("name"), n2 = this.getDialog(i2);
          this.setAttribute(n2);
        }
        if (27 === t2.keyCode)
          return t2.preventDefault(), this.hideDialog();
      }
      updateActions(t2) {
        return this.actions = t2, this.refreshActionButtons();
      }
      refreshActionButtons() {
        return this.eachActionButton((t2, e2) => {
          t2.disabled = false === this.actions[e2];
        });
      }
      eachActionButton(t2) {
        return Array.from(this.element.querySelectorAll(mn)).map((e2) => t2(e2, yn(e2)));
      }
      updateAttributes(t2) {
        return this.attributes = t2, this.refreshAttributeButtons();
      }
      refreshAttributeButtons() {
        return this.eachAttributeButton((t2, e2) => (t2.disabled = false === this.attributes[e2], this.attributes[e2] || this.dialogIsVisible(e2) ? (t2.setAttribute("data-trix-active", ""), t2.classList.add("trix-active")) : (t2.removeAttribute("data-trix-active"), t2.classList.remove("trix-active"))));
      }
      eachAttributeButton(t2) {
        return Array.from(this.element.querySelectorAll(gn)).map((e2) => t2(e2, Cn(e2)));
      }
      applyKeyboardCommand(t2) {
        const e2 = JSON.stringify(t2.sort());
        for (const t3 of Array.from(this.element.querySelectorAll("[data-trix-key]"))) {
          const i2 = t3.getAttribute("data-trix-key").split("+");
          if (JSON.stringify(i2.sort()) === e2)
            return b("mousedown", { onElement: t3 }), true;
        }
        return false;
      }
      dialogIsVisible(t2) {
        const e2 = this.getDialog(t2);
        if (e2)
          return e2.hasAttribute("data-trix-active");
      }
      toggleDialog(t2) {
        return this.dialogIsVisible(t2) ? this.hideDialog() : this.showDialog(t2);
      }
      showDialog(t2) {
        var e2, i2;
        this.hideDialog(), null === (e2 = this.delegate) || void 0 === e2 || e2.toolbarWillShowDialog();
        const n2 = this.getDialog(t2);
        n2.setAttribute("data-trix-active", ""), n2.classList.add("trix-active"), Array.from(n2.querySelectorAll("input[disabled]")).forEach((t3) => {
          t3.removeAttribute("disabled");
        });
        const r2 = Cn(n2);
        if (r2) {
          const e3 = xn(n2, t2);
          e3 && (e3.value = this.attributes[r2] || "", e3.select());
        }
        return null === (i2 = this.delegate) || void 0 === i2 ? void 0 : i2.toolbarDidShowDialog(t2);
      }
      setAttribute(t2) {
        const e2 = Cn(t2), i2 = xn(t2, e2);
        return i2.willValidate && !i2.checkValidity() ? (i2.setAttribute("data-trix-validate", ""), i2.classList.add("trix-validate"), i2.focus()) : (null === (n2 = this.delegate) || void 0 === n2 || n2.toolbarDidUpdateAttribute(e2, i2.value), this.hideDialog());
        var n2;
      }
      removeAttribute(t2) {
        var e2;
        const i2 = Cn(t2);
        return null === (e2 = this.delegate) || void 0 === e2 || e2.toolbarDidRemoveAttribute(i2), this.hideDialog();
      }
      hideDialog() {
        const t2 = this.element.querySelector(bn);
        var e2;
        if (t2)
          return t2.removeAttribute("data-trix-active"), t2.classList.remove("trix-active"), this.resetDialogInputs(), null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.toolbarDidHideDialog(((t3) => t3.getAttribute("data-trix-dialog"))(t2));
      }
      resetDialogInputs() {
        Array.from(this.element.querySelectorAll(An)).forEach((t2) => {
          t2.setAttribute("disabled", "disabled"), t2.removeAttribute("data-trix-validate"), t2.classList.remove("trix-validate");
        });
      }
      getDialog(t2) {
        return this.element.querySelector("[data-trix-dialog=".concat(t2, "]"));
      }
    }
    class Rn extends Oi {
      constructor(t2) {
        let { editorElement: e2, document: i2, html: n2 } = t2;
        super(...arguments), this.editorElement = e2, this.selectionManager = new Li(this.editorElement), this.selectionManager.delegate = this, this.composition = new gi(), this.composition.delegate = this, this.attachmentManager = new hi(this.composition.getAttachments()), this.attachmentManager.delegate = this, this.inputController = 2 === M.getLevel() ? new on(this.editorElement) : new Qi(this.editorElement), this.inputController.delegate = this, this.inputController.responder = this.composition, this.compositionController = new Ni(this.editorElement, this.composition), this.compositionController.delegate = this, this.toolbarController = new kn(this.editorElement.toolbarElement), this.toolbarController.delegate = this, this.editor = new xi(this.composition, this.selectionManager, this.editorElement), i2 ? this.editor.loadDocument(i2) : this.editor.loadHTML(n2);
      }
      registerSelectionManager() {
        return Pt.registerSelectionManager(this.selectionManager);
      }
      unregisterSelectionManager() {
        return Pt.unregisterSelectionManager(this.selectionManager);
      }
      render() {
        return this.compositionController.render();
      }
      reparse() {
        return this.composition.replaceHTML(this.editorElement.innerHTML);
      }
      compositionDidChangeDocument(t2) {
        if (this.notifyEditorElement("document-change"), !this.handlingInput)
          return this.render();
      }
      compositionDidChangeCurrentAttributes(t2) {
        return this.currentAttributes = t2, this.toolbarController.updateAttributes(this.currentAttributes), this.updateCurrentActions(), this.notifyEditorElement("attributes-change", { attributes: this.currentAttributes });
      }
      compositionDidPerformInsertionAtRange(t2) {
        this.pasting && (this.pastedRange = t2);
      }
      compositionShouldAcceptFile(t2) {
        return this.notifyEditorElement("file-accept", { file: t2 });
      }
      compositionDidAddAttachment(t2) {
        const e2 = this.attachmentManager.manageAttachment(t2);
        return this.notifyEditorElement("attachment-add", { attachment: e2 });
      }
      compositionDidEditAttachment(t2) {
        this.compositionController.rerenderViewForObject(t2);
        const e2 = this.attachmentManager.manageAttachment(t2);
        return this.notifyEditorElement("attachment-edit", { attachment: e2 }), this.notifyEditorElement("change");
      }
      compositionDidChangeAttachmentPreviewURL(t2) {
        return this.compositionController.invalidateViewForObject(t2), this.notifyEditorElement("change");
      }
      compositionDidRemoveAttachment(t2) {
        const e2 = this.attachmentManager.unmanageAttachment(t2);
        return this.notifyEditorElement("attachment-remove", { attachment: e2 });
      }
      compositionDidStartEditingAttachment(t2, e2) {
        return this.attachmentLocationRange = this.composition.document.getLocationRangeOfAttachment(t2), this.compositionController.installAttachmentEditorForAttachment(t2, e2), this.selectionManager.setLocationRange(this.attachmentLocationRange);
      }
      compositionDidStopEditingAttachment(t2) {
        this.compositionController.uninstallAttachmentEditor(), this.attachmentLocationRange = null;
      }
      compositionDidRequestChangingSelectionToLocationRange(t2) {
        if (!this.loadingSnapshot || this.isFocused())
          return this.requestedLocationRange = t2, this.compositionRevisionWhenLocationRangeRequested = this.composition.revision, this.handlingInput ? void 0 : this.render();
      }
      compositionWillLoadSnapshot() {
        this.loadingSnapshot = true;
      }
      compositionDidLoadSnapshot() {
        this.compositionController.refreshViewCache(), this.render(), this.loadingSnapshot = false;
      }
      getSelectionManager() {
        return this.selectionManager;
      }
      attachmentManagerDidRequestRemovalOfAttachment(t2) {
        return this.removeAttachment(t2);
      }
      compositionControllerWillSyncDocumentView() {
        return this.inputController.editorWillSyncDocumentView(), this.selectionManager.lock(), this.selectionManager.clearSelection();
      }
      compositionControllerDidSyncDocumentView() {
        return this.inputController.editorDidSyncDocumentView(), this.selectionManager.unlock(), this.updateCurrentActions(), this.notifyEditorElement("sync");
      }
      compositionControllerDidRender() {
        this.requestedLocationRange && (this.compositionRevisionWhenLocationRangeRequested === this.composition.revision && this.selectionManager.setLocationRange(this.requestedLocationRange), this.requestedLocationRange = null, this.compositionRevisionWhenLocationRangeRequested = null), this.renderedCompositionRevision !== this.composition.revision && (this.runEditorFilters(), this.composition.updateCurrentAttributes(), this.notifyEditorElement("render")), this.renderedCompositionRevision = this.composition.revision;
      }
      compositionControllerDidFocus() {
        return this.isFocusedInvisibly() && this.setLocationRange({ index: 0, offset: 0 }), this.toolbarController.hideDialog(), this.notifyEditorElement("focus");
      }
      compositionControllerDidBlur() {
        return this.notifyEditorElement("blur");
      }
      compositionControllerDidSelectAttachment(t2, e2) {
        return this.toolbarController.hideDialog(), this.composition.editAttachment(t2, e2);
      }
      compositionControllerDidRequestDeselectingAttachment(t2) {
        const e2 = this.attachmentLocationRange || this.composition.document.getLocationRangeOfAttachment(t2);
        return this.selectionManager.setLocationRange(e2[1]);
      }
      compositionControllerWillUpdateAttachment(t2) {
        return this.editor.recordUndoEntry("Edit Attachment", { context: t2.id, consolidatable: true });
      }
      compositionControllerDidRequestRemovalOfAttachment(t2) {
        return this.removeAttachment(t2);
      }
      inputControllerWillHandleInput() {
        this.handlingInput = true, this.requestedRender = false;
      }
      inputControllerDidRequestRender() {
        this.requestedRender = true;
      }
      inputControllerDidHandleInput() {
        if (this.handlingInput = false, this.requestedRender)
          return this.requestedRender = false, this.render();
      }
      inputControllerDidAllowUnhandledInput() {
        return this.notifyEditorElement("change");
      }
      inputControllerDidRequestReparse() {
        return this.reparse();
      }
      inputControllerWillPerformTyping() {
        return this.recordTypingUndoEntry();
      }
      inputControllerWillPerformFormatting(t2) {
        return this.recordFormattingUndoEntry(t2);
      }
      inputControllerWillCutText() {
        return this.editor.recordUndoEntry("Cut");
      }
      inputControllerWillPaste(t2) {
        return this.editor.recordUndoEntry("Paste"), this.pasting = true, this.notifyEditorElement("before-paste", { paste: t2 });
      }
      inputControllerDidPaste(t2) {
        return t2.range = this.pastedRange, this.pastedRange = null, this.pasting = null, this.notifyEditorElement("paste", { paste: t2 });
      }
      inputControllerWillMoveText() {
        return this.editor.recordUndoEntry("Move");
      }
      inputControllerWillAttachFiles() {
        return this.editor.recordUndoEntry("Drop Files");
      }
      inputControllerWillPerformUndo() {
        return this.editor.undo();
      }
      inputControllerWillPerformRedo() {
        return this.editor.redo();
      }
      inputControllerDidReceiveKeyboardCommand(t2) {
        return this.toolbarController.applyKeyboardCommand(t2);
      }
      inputControllerDidStartDrag() {
        this.locationRangeBeforeDrag = this.selectionManager.getLocationRange();
      }
      inputControllerDidReceiveDragOverPoint(t2) {
        return this.selectionManager.setLocationRangeFromPointRange(t2);
      }
      inputControllerDidCancelDrag() {
        this.selectionManager.setLocationRange(this.locationRangeBeforeDrag), this.locationRangeBeforeDrag = null;
      }
      locationRangeDidChange(t2) {
        return this.composition.updateCurrentAttributes(), this.updateCurrentActions(), this.attachmentLocationRange && !wt(this.attachmentLocationRange, t2) && this.composition.stopEditingAttachment(), this.notifyEditorElement("selection-change");
      }
      toolbarDidClickButton() {
        if (!this.getLocationRange())
          return this.setLocationRange({ index: 0, offset: 0 });
      }
      toolbarDidInvokeAction(t2, e2) {
        return this.invokeAction(t2, e2);
      }
      toolbarDidToggleAttribute(t2) {
        if (this.recordFormattingUndoEntry(t2), this.composition.toggleCurrentAttribute(t2), this.render(), !this.selectionFrozen)
          return this.editorElement.focus();
      }
      toolbarDidUpdateAttribute(t2, e2) {
        if (this.recordFormattingUndoEntry(t2), this.composition.setCurrentAttribute(t2, e2), this.render(), !this.selectionFrozen)
          return this.editorElement.focus();
      }
      toolbarDidRemoveAttribute(t2) {
        if (this.recordFormattingUndoEntry(t2), this.composition.removeCurrentAttribute(t2), this.render(), !this.selectionFrozen)
          return this.editorElement.focus();
      }
      toolbarWillShowDialog(t2) {
        return this.composition.expandSelectionForEditing(), this.freezeSelection();
      }
      toolbarDidShowDialog(t2) {
        return this.notifyEditorElement("toolbar-dialog-show", { dialogName: t2 });
      }
      toolbarDidHideDialog(t2) {
        return this.thawSelection(), this.editorElement.focus(), this.notifyEditorElement("toolbar-dialog-hide", { dialogName: t2 });
      }
      freezeSelection() {
        if (!this.selectionFrozen)
          return this.selectionManager.lock(), this.composition.freezeSelection(), this.selectionFrozen = true, this.render();
      }
      thawSelection() {
        if (this.selectionFrozen)
          return this.composition.thawSelection(), this.selectionManager.unlock(), this.selectionFrozen = false, this.render();
      }
      canInvokeAction(t2) {
        return !!this.actionIsExternal(t2) || !(null === (e2 = this.actions[t2]) || void 0 === e2 || null === (e2 = e2.test) || void 0 === e2 || !e2.call(this));
        var e2;
      }
      invokeAction(t2, e2) {
        return this.actionIsExternal(t2) ? this.notifyEditorElement("action-invoke", { actionName: t2, invokingElement: e2 }) : null === (i2 = this.actions[t2]) || void 0 === i2 || null === (i2 = i2.perform) || void 0 === i2 ? void 0 : i2.call(this);
        var i2;
      }
      actionIsExternal(t2) {
        return /^x-./.test(t2);
      }
      getCurrentActions() {
        const t2 = {};
        for (const e2 in this.actions)
          t2[e2] = this.canInvokeAction(e2);
        return t2;
      }
      updateCurrentActions() {
        const t2 = this.getCurrentActions();
        if (!St(t2, this.currentActions))
          return this.currentActions = t2, this.toolbarController.updateActions(this.currentActions), this.notifyEditorElement("actions-change", { actions: this.currentActions });
      }
      runEditorFilters() {
        let t2 = this.composition.getSnapshot();
        if (Array.from(this.editor.filters).forEach((e3) => {
          const { document: i3, selectedRange: n2 } = t2;
          t2 = e3.call(this.editor, t2) || {}, t2.document || (t2.document = i3), t2.selectedRange || (t2.selectedRange = n2);
        }), e2 = t2, i2 = this.composition.getSnapshot(), !wt(e2.selectedRange, i2.selectedRange) || !e2.document.isEqualTo(i2.document))
          return this.composition.loadSnapshot(t2);
        var e2, i2;
      }
      updateInputElement() {
        const t2 = function(t3, e2) {
          const i2 = li[e2];
          if (i2)
            return i2(t3);
          throw new Error("unknown content type: ".concat(e2));
        }(this.compositionController.getSerializableElement(), "text/html");
        return this.editorElement.setInputElementValue(t2);
      }
      notifyEditorElement(t2, e2) {
        switch (t2) {
          case "document-change":
            this.documentChangedSinceLastRender = true;
            break;
          case "render":
            this.documentChangedSinceLastRender && (this.documentChangedSinceLastRender = false, this.notifyEditorElement("change"));
            break;
          case "change":
          case "attachment-add":
          case "attachment-edit":
          case "attachment-remove":
            this.updateInputElement();
        }
        return this.editorElement.notify(t2, e2);
      }
      removeAttachment(t2) {
        return this.editor.recordUndoEntry("Delete Attachment"), this.composition.removeAttachment(t2), this.render();
      }
      recordFormattingUndoEntry(t2) {
        const e2 = gt(t2), i2 = this.selectionManager.getLocationRange();
        if (e2 || !Dt(i2))
          return this.editor.recordUndoEntry("Formatting", { context: this.getUndoContext(), consolidatable: true });
      }
      recordTypingUndoEntry() {
        return this.editor.recordUndoEntry("Typing", { context: this.getUndoContext(this.currentAttributes), consolidatable: true });
      }
      getUndoContext() {
        for (var t2 = arguments.length, e2 = new Array(t2), i2 = 0; i2 < t2; i2++)
          e2[i2] = arguments[i2];
        return [this.getLocationContext(), this.getTimeContext(), ...Array.from(e2)];
      }
      getLocationContext() {
        const t2 = this.selectionManager.getLocationRange();
        return Dt(t2) ? t2[0].index : t2;
      }
      getTimeContext() {
        return q.interval > 0 ? Math.floor((/* @__PURE__ */ new Date()).getTime() / q.interval) : 0;
      }
      isFocused() {
        var t2;
        return this.editorElement === (null === (t2 = this.editorElement.ownerDocument) || void 0 === t2 ? void 0 : t2.activeElement);
      }
      isFocusedInvisibly() {
        return this.isFocused() && !this.getLocationRange();
      }
      get actions() {
        return this.constructor.actions;
      }
    }
    Ae(Rn, "actions", { undo: { test() {
      return this.editor.canUndo();
    }, perform() {
      return this.editor.undo();
    } }, redo: { test() {
      return this.editor.canRedo();
    }, perform() {
      return this.editor.redo();
    } }, link: { test() {
      return this.editor.canActivateAttribute("href");
    } }, increaseNestingLevel: { test() {
      return this.editor.canIncreaseNestingLevel();
    }, perform() {
      return this.editor.increaseNestingLevel() && this.render();
    } }, decreaseNestingLevel: { test() {
      return this.editor.canDecreaseNestingLevel();
    }, perform() {
      return this.editor.decreaseNestingLevel() && this.render();
    } }, attachFiles: { test: () => true, perform() {
      return M.pickFiles(this.editor.insertFiles);
    } } }), Rn.proxyMethod("getSelectionManager().setLocationRange"), Rn.proxyMethod("getSelectionManager().getLocationRange");
    var En = Object.freeze({ __proto__: null, AttachmentEditorController: Ii, CompositionController: Ni, Controller: Oi, EditorController: Rn, InputController: Ki, Level0InputController: Qi, Level2InputController: on, ToolbarController: kn }), Sn = Object.freeze({ __proto__: null, MutationObserver: Ui, SelectionChangeObserver: Ft }), Ln = Object.freeze({ __proto__: null, FileVerificationOperation: Vi, ImagePreloadOperation: Ce });
    bt("trix-toolbar", "%t {\n  display: block;\n}\n\n%t {\n  white-space: nowrap;\n}\n\n%t [data-trix-dialog] {\n  display: none;\n}\n\n%t [data-trix-dialog][data-trix-active] {\n  display: block;\n}\n\n%t [data-trix-dialog] [data-trix-validate]:invalid {\n  background-color: #ffdddd;\n}");
    class Dn extends HTMLElement {
      connectedCallback() {
        "" === this.innerHTML && (this.innerHTML = U.getDefaultHTML());
      }
    }
    let wn = 0;
    const Tn = function(t2) {
      if (!t2.hasAttribute("contenteditable"))
        return t2.setAttribute("contenteditable", ""), function(t3) {
          let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          return e2.times = 1, f(t3, e2);
        }("focus", { onElement: t2, withCallback: () => Bn(t2) });
    }, Bn = function(t2) {
      return Fn(t2), Pn();
    }, Fn = function(t2) {
      var e2, i2;
      if (null !== (e2 = (i2 = document).queryCommandSupported) && void 0 !== e2 && e2.call(i2, "enableObjectResizing"))
        return document.execCommand("enableObjectResizing", false, false), f("mscontrolselect", { onElement: t2, preventDefault: true });
    }, Pn = function(t2) {
      var e2, i2;
      if (null !== (e2 = (i2 = document).queryCommandSupported) && void 0 !== e2 && e2.call(i2, "DefaultParagraphSeparator")) {
        const { tagName: t3 } = n.default;
        if (["div", "p"].includes(t3))
          return document.execCommand("DefaultParagraphSeparator", false, t3);
      }
    }, In = a.forcesObjectResizing ? { display: "inline", width: "auto" } : { display: "inline-block", width: "1px" };
    bt("trix-editor", "%t {\n    display: block;\n}\n\n%t:empty:not(:focus)::before {\n    content: attr(placeholder);\n    color: graytext;\n    cursor: text;\n    pointer-events: none;\n    white-space: pre-line;\n}\n\n%t a[contenteditable=false] {\n    cursor: text;\n}\n\n%t img {\n    max-width: 100%;\n    height: auto;\n}\n\n%t ".concat(e, " figcaption textarea {\n    resize: none;\n}\n\n%t ").concat(e, " figcaption textarea.trix-autoresize-clone {\n    position: absolute;\n    left: -9999px;\n    max-height: 0px;\n}\n\n%t ").concat(e, " figcaption[data-trix-placeholder]:empty::before {\n    content: attr(data-trix-placeholder);\n    color: graytext;\n}\n\n%t [data-trix-cursor-target] {\n    display: ").concat(In.display, " !important;\n    width: ").concat(In.width, " !important;\n    padding: 0 !important;\n    margin: 0 !important;\n    border: none !important;\n}\n\n%t [data-trix-cursor-target=left] {\n    vertical-align: top !important;\n    margin-left: -1px !important;\n}\n\n%t [data-trix-cursor-target=right] {\n    vertical-align: bottom !important;\n    margin-right: -1px !important;\n}"));
    class Nn extends HTMLElement {
      get trixId() {
        return this.hasAttribute("trix-id") ? this.getAttribute("trix-id") : (this.setAttribute("trix-id", ++wn), this.trixId);
      }
      get labels() {
        const t2 = [];
        this.id && this.ownerDocument && t2.push(...Array.from(this.ownerDocument.querySelectorAll("label[for='".concat(this.id, "']")) || []));
        const e2 = A(this, { matchingSelector: "label" });
        return e2 && [this, null].includes(e2.control) && t2.push(e2), t2;
      }
      get toolbarElement() {
        var t2;
        if (this.hasAttribute("toolbar"))
          return null === (t2 = this.ownerDocument) || void 0 === t2 ? void 0 : t2.getElementById(this.getAttribute("toolbar"));
        if (this.parentNode) {
          const t3 = "trix-toolbar-".concat(this.trixId);
          this.setAttribute("toolbar", t3);
          const e2 = S("trix-toolbar", { id: t3 });
          return this.parentNode.insertBefore(e2, this), e2;
        }
      }
      get form() {
        var t2;
        return null === (t2 = this.inputElement) || void 0 === t2 ? void 0 : t2.form;
      }
      get inputElement() {
        var t2;
        if (this.hasAttribute("input"))
          return null === (t2 = this.ownerDocument) || void 0 === t2 ? void 0 : t2.getElementById(this.getAttribute("input"));
        if (this.parentNode) {
          const t3 = "trix-input-".concat(this.trixId);
          this.setAttribute("input", t3);
          const e2 = S("input", { type: "hidden", id: t3 });
          return this.parentNode.insertBefore(e2, this.nextElementSibling), e2;
        }
      }
      get editor() {
        var t2;
        return null === (t2 = this.editorController) || void 0 === t2 ? void 0 : t2.editor;
      }
      get name() {
        var t2;
        return null === (t2 = this.inputElement) || void 0 === t2 ? void 0 : t2.name;
      }
      get value() {
        var t2;
        return null === (t2 = this.inputElement) || void 0 === t2 ? void 0 : t2.value;
      }
      set value(t2) {
        var e2;
        this.defaultValue = t2, null === (e2 = this.editor) || void 0 === e2 || e2.loadHTML(this.defaultValue);
      }
      notify(t2, e2) {
        if (this.editorController)
          return b("trix-".concat(t2), { onElement: this, attributes: e2 });
      }
      setInputElementValue(t2) {
        this.inputElement && (this.inputElement.value = t2);
      }
      connectedCallback() {
        this.hasAttribute("data-trix-internal") || (Tn(this), function(t2) {
          if (!t2.hasAttribute("role"))
            t2.setAttribute("role", "textbox");
        }(this), function(t2) {
          if (t2.hasAttribute("aria-label") || t2.hasAttribute("aria-labelledby"))
            return;
          const e2 = function() {
            const e3 = Array.from(t2.labels).map((e4) => {
              if (!e4.contains(t2))
                return e4.textContent;
            }).filter((t3) => t3), i2 = e3.join(" ");
            return i2 ? t2.setAttribute("aria-label", i2) : t2.removeAttribute("aria-label");
          };
          e2(), f("focus", { onElement: t2, withCallback: e2 });
        }(this), this.editorController || (b("trix-before-initialize", { onElement: this }), this.editorController = new Rn({ editorElement: this, html: this.defaultValue = this.value }), requestAnimationFrame(() => b("trix-initialize", { onElement: this }))), this.editorController.registerSelectionManager(), this.registerResetListener(), this.registerClickListener(), function(t2) {
          if (!document.querySelector(":focus") && t2.hasAttribute("autofocus") && document.querySelector("[autofocus]") === t2)
            t2.focus();
        }(this));
      }
      disconnectedCallback() {
        var t2;
        return null === (t2 = this.editorController) || void 0 === t2 || t2.unregisterSelectionManager(), this.unregisterResetListener(), this.unregisterClickListener();
      }
      registerResetListener() {
        return this.resetListener = this.resetBubbled.bind(this), window.addEventListener("reset", this.resetListener, false);
      }
      unregisterResetListener() {
        return window.removeEventListener("reset", this.resetListener, false);
      }
      registerClickListener() {
        return this.clickListener = this.clickBubbled.bind(this), window.addEventListener("click", this.clickListener, false);
      }
      unregisterClickListener() {
        return window.removeEventListener("click", this.clickListener, false);
      }
      resetBubbled(t2) {
        if (!t2.defaultPrevented && t2.target === this.form)
          return this.reset();
      }
      clickBubbled(t2) {
        if (t2.defaultPrevented)
          return;
        if (this.contains(t2.target))
          return;
        const e2 = A(t2.target, { matchingSelector: "label" });
        return e2 && Array.from(this.labels).includes(e2) ? this.focus() : void 0;
      }
      reset() {
        this.value = this.defaultValue;
      }
    }
    const On = { VERSION: t, config: V, core: ci, models: Di, views: wi, controllers: En, observers: Sn, operations: Ln, elements: Object.freeze({ __proto__: null, TrixEditorElement: Nn, TrixToolbarElement: Dn }), filters: Object.freeze({ __proto__: null, Filter: bi, attachmentGalleryFilter: vi }) };
    Object.assign(On, Di), window.Trix = On, setTimeout(function() {
      customElements.get("trix-toolbar") || customElements.define("trix-toolbar", Dn), customElements.get("trix-editor") || customElements.define("trix-editor", Nn);
    }, 0);
    var script$1 = {
      name: "EditorWrapper",
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: ""
          }
        };
      }
    };
    const _hoisted_1 = ["id", "value"];
    function render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_trix_editor = resolveComponent("trix-editor");
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(_ctx.classes.container)
        },
        [
          createBaseVNode("input", {
            id: `editor-input-${_ctx.id}`,
            value: _ctx.value,
            type: "hidden"
          }, null, 8, _hoisted_1),
          createVNode(_component_trix_editor, mergeProps(_ctx.options, {
            onTrixChange: _ctx.handleChange,
            onTrixBlur: _ctx.handleBlur,
            onTrixFileAccept: _ctx.handleFileAccept,
            onTrixAttachmentAdd: _ctx.handleAttachmentAdd,
            ref: "trix$"
          }), null, 16, ["onTrixChange", "onTrixBlur", "onTrixFileAccept", "onTrixAttachmentAdd"])
        ],
        2
        /* CLASS */
      );
    }
    script$1.render = render;
    script$1.__file = "themes/blank/templates/wrappers/EditorWrapper.vue";
    var script = {
      name: "EditorWrapper",
      render: script$1.render,
      data() {
        return {
          merge: true,
          defaultClasses: {
            container: "",
            container_hideBold: "vf-editor-hide-bold",
            container_hideItalic: "vf-editor-hide-italic",
            container_hideStrike: "vf-editor-hide-strike",
            container_hideLink: "vf-editor-hide-link",
            container_hideHeading: "vf-editor-hide-heading",
            container_hideQuote: "vf-editor-hide-quote",
            container_hideCode: "vf-editor-hide-code",
            container_hideBulletList: "vf-editor-hide-bullet-list",
            container_hideNumberList: "vf-editor-hide-number-list",
            container_hideDecreaseNesting: "vf-editor-hide-decrease-nesting",
            container_hideIncreaseNesting: "vf-editor-hide-increase-nesting",
            container_hideAttach: "vf-editor-hide-attach",
            container_hideUndo: "vf-editor-hide-undo",
            container_hideRedo: "vf-editor-hide-redo",
            $container: (classes2, { hideTools }) => [
              classes2.container
            ].concat(hideTools.map((t2) => classes2[`container_hide${t2.split("-").map((s2) => s2.charAt(0).toUpperCase() + s2.slice(1)).join("")}`]))
          }
        };
      }
    };
    var css_248z = `@charset "UTF-8";

trix-toolbar {
  padding: 0.5rem 0.375rem;
  border-radius: 0.25rem;
  flex-wrap: wrap;
}

trix-toolbar .trix-button-row {
  display: block;
  margin-bottom: -0.25rem;
  flex-wrap: nowrap;
  justify-content: space-between;
  overflow-x: auto;
}

trix-toolbar .trix-button-group {
  display: inline;
}

trix-toolbar .trix-button-group-spacer {
  display: hidden;
  flex-grow: 1;
}

trix-toolbar .trix-button {
  position: relative;
  margin-bottom: 0.25rem;
  color: var(--vf-bg-icon);
  padding-left: 0.5rem;
  padding-right: 0.5rem;
  outline: none;
  border-radius: 0.25rem;
  white-space: nowrap;
  float: left;
  border: 0;
  background: none;
}

trix-toolbar .trix-button.trix-active {
  background-color: var(--vf-bg-selected);
  filter: brightness(0.9);
}

trix-toolbar .trix-button:not(.trix-active):hover {
  background-color: var(--vf-bg-selected);
}

.is-disabled trix-toolbar .trix-button:not(.trix-active):hover {
  background: transparent;
  cursor: default;
}

trix-toolbar .trix-button:not(:disabled) {
  cursor: pointer;
}

.is-disabled trix-toolbar .trix-button {
  cursor: default;
  pointer-events: none;
}

trix-toolbar .trix-button--icon {
  width: 2.5rem;
  height: 1.5rem;
  font-size: 0.75rem;
  line-height: 1rem;
  text-indent: -9999px;
}

trix-toolbar .trix-button--icon::before {
  position: absolute;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  display: inline-block;
  content: "";
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-position: center center;
  -webkit-mask-position: center center;
  mask-size: contain;
  -webkit-mask-size: contain;
  background-color: var(--vf-bg-icon);
  top: 0.125rem;
  bottom: 0.125rem;
  margin-top: 0.125rem;
  margin-bottom: 0.125rem;
}

trix-toolbar .trix-button--icon.trix-active::before {
  opacity: 1;
}

trix-toolbar .trix-button--icon:disabled::before {
  opacity: 0.4;
}

trix-toolbar .trix-button--icon-attach::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M67.508 468.467c-58.005-58.013-58.016-151.92 0-209.943l225.011-225.04c44.643-44.645 117.279-44.645 161.92 0 44.743 44.749 44.753 117.186 0 161.944l-189.465 189.49c-31.41 31.413-82.518 31.412-113.926.001-31.479-31.482-31.49-82.453 0-113.944L311.51 110.491c4.687-4.687 12.286-4.687 16.972 0l16.967 16.971c4.685 4.686 4.685 12.283 0 16.969L184.983 304.917c-12.724 12.724-12.73 33.328 0 46.058 12.696 12.697 33.356 12.699 46.054-.001l189.465-189.489c25.987-25.989 25.994-68.06.001-94.056-25.931-25.934-68.119-25.932-94.049 0l-225.01 225.039c-39.249 39.252-39.258 102.795-.001 142.057 39.285 39.29 102.885 39.287 142.162-.028A739446.174 739446.174 0 0 1 439.497 238.49c4.686-4.687 12.282-4.684 16.969.004l16.967 16.971c4.685 4.686 4.689 12.279.004 16.965a755654.128 755654.128 0 0 0-195.881 195.996c-58.034 58.092-152.004 58.093-210.048.041z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M67.508 468.467c-58.005-58.013-58.016-151.92 0-209.943l225.011-225.04c44.643-44.645 117.279-44.645 161.92 0 44.743 44.749 44.753 117.186 0 161.944l-189.465 189.49c-31.41 31.413-82.518 31.412-113.926.001-31.479-31.482-31.49-82.453 0-113.944L311.51 110.491c4.687-4.687 12.286-4.687 16.972 0l16.967 16.971c4.685 4.686 4.685 12.283 0 16.969L184.983 304.917c-12.724 12.724-12.73 33.328 0 46.058 12.696 12.697 33.356 12.699 46.054-.001l189.465-189.489c25.987-25.989 25.994-68.06.001-94.056-25.931-25.934-68.119-25.932-94.049 0l-225.01 225.039c-39.249 39.252-39.258 102.795-.001 142.057 39.285 39.29 102.885 39.287 142.162-.028A739446.174 739446.174 0 0 1 439.497 238.49c4.686-4.687 12.282-4.684 16.969.004l16.967 16.971c4.685 4.686 4.689 12.279.004 16.965a755654.128 755654.128 0 0 0-195.881 195.996c-58.034 58.092-152.004 58.093-210.048.041z'%3e%3c/path%3e%3c/svg%3e");
}

trix-toolbar .trix-button--icon-bold::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 384 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M333.49 238a122 122 0 0 0 27-65.21C367.87 96.49 308 32 233.42 32H34a16 16 0 0 0-16 16v48a16 16 0 0 0 16 16h31.87v288H34a16 16 0 0 0-16 16v48a16 16 0 0 0 16 16h209.32c70.8 0 134.14-51.75 141-122.4 4.74-48.45-16.39-92.06-50.83-119.6zM145.66 112h87.76a48 48 0 0 1 0 96h-87.76zm87.76 288h-87.76V288h87.76a56 56 0 0 1 0 112z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 384 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M333.49 238a122 122 0 0 0 27-65.21C367.87 96.49 308 32 233.42 32H34a16 16 0 0 0-16 16v48a16 16 0 0 0 16 16h31.87v288H34a16 16 0 0 0-16 16v48a16 16 0 0 0 16 16h209.32c70.8 0 134.14-51.75 141-122.4 4.74-48.45-16.39-92.06-50.83-119.6zM145.66 112h87.76a48 48 0 0 1 0 96h-87.76zm87.76 288h-87.76V288h87.76a56 56 0 0 1 0 112z'%3e%3c/path%3e%3c/svg%3e");
}

trix-toolbar .trix-button--icon-italic::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M320 48v32a16 16 0 0 1-16 16h-62.76l-80 320H208a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16H16a16 16 0 0 1-16-16v-32a16 16 0 0 1 16-16h62.76l80-320H112a16 16 0 0 1-16-16V48a16 16 0 0 1 16-16h192a16 16 0 0 1 16 16z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M320 48v32a16 16 0 0 1-16 16h-62.76l-80 320H208a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16H16a16 16 0 0 1-16-16v-32a16 16 0 0 1 16-16h62.76l80-320H112a16 16 0 0 1-16-16V48a16 16 0 0 1 16-16h192a16 16 0 0 1 16 16z'%3e%3c/path%3e%3c/svg%3e");
}

trix-toolbar .trix-button--icon-link::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M314.222 197.78c51.091 51.091 54.377 132.287 9.75 187.16-6.242 7.73-2.784 3.865-84.94 86.02-54.696 54.696-143.266 54.745-197.99 0-54.711-54.69-54.734-143.255 0-197.99 32.773-32.773 51.835-51.899 63.409-63.457 7.463-7.452 20.331-2.354 20.486 8.192a173.31 173.31 0 0 0 4.746 37.828c.966 4.029-.272 8.269-3.202 11.198L80.632 312.57c-32.755 32.775-32.887 85.892 0 118.8 32.775 32.755 85.892 32.887 118.8 0l75.19-75.2c32.718-32.725 32.777-86.013 0-118.79a83.722 83.722 0 0 0-22.814-16.229c-4.623-2.233-7.182-7.25-6.561-12.346 1.356-11.122 6.296-21.885 14.815-30.405l4.375-4.375c3.625-3.626 9.177-4.594 13.76-2.294 12.999 6.524 25.187 15.211 36.025 26.049zM470.958 41.04c-54.724-54.745-143.294-54.696-197.99 0-82.156 82.156-78.698 78.29-84.94 86.02-44.627 54.873-41.341 136.069 9.75 187.16 10.838 10.838 23.026 19.525 36.025 26.049 4.582 2.3 10.134 1.331 13.76-2.294l4.375-4.375c8.52-8.519 13.459-19.283 14.815-30.405.621-5.096-1.938-10.113-6.561-12.346a83.706 83.706 0 0 1-22.814-16.229c-32.777-32.777-32.718-86.065 0-118.79l75.19-75.2c32.908-32.887 86.025-32.755 118.8 0 32.887 32.908 32.755 86.025 0 118.8l-45.848 45.84c-2.93 2.929-4.168 7.169-3.202 11.198a173.31 173.31 0 0 1 4.746 37.828c.155 10.546 13.023 15.644 20.486 8.192 11.574-11.558 30.636-30.684 63.409-63.457 54.733-54.735 54.71-143.3-.001-197.991z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M314.222 197.78c51.091 51.091 54.377 132.287 9.75 187.16-6.242 7.73-2.784 3.865-84.94 86.02-54.696 54.696-143.266 54.745-197.99 0-54.711-54.69-54.734-143.255 0-197.99 32.773-32.773 51.835-51.899 63.409-63.457 7.463-7.452 20.331-2.354 20.486 8.192a173.31 173.31 0 0 0 4.746 37.828c.966 4.029-.272 8.269-3.202 11.198L80.632 312.57c-32.755 32.775-32.887 85.892 0 118.8 32.775 32.755 85.892 32.887 118.8 0l75.19-75.2c32.718-32.725 32.777-86.013 0-118.79a83.722 83.722 0 0 0-22.814-16.229c-4.623-2.233-7.182-7.25-6.561-12.346 1.356-11.122 6.296-21.885 14.815-30.405l4.375-4.375c3.625-3.626 9.177-4.594 13.76-2.294 12.999 6.524 25.187 15.211 36.025 26.049zM470.958 41.04c-54.724-54.745-143.294-54.696-197.99 0-82.156 82.156-78.698 78.29-84.94 86.02-44.627 54.873-41.341 136.069 9.75 187.16 10.838 10.838 23.026 19.525 36.025 26.049 4.582 2.3 10.134 1.331 13.76-2.294l4.375-4.375c8.52-8.519 13.459-19.283 14.815-30.405.621-5.096-1.938-10.113-6.561-12.346a83.706 83.706 0 0 1-22.814-16.229c-32.777-32.777-32.718-86.065 0-118.79l75.19-75.2c32.908-32.887 86.025-32.755 118.8 0 32.887 32.908 32.755 86.025 0 118.8l-45.848 45.84c-2.93 2.929-4.168 7.169-3.202 11.198a173.31 173.31 0 0 1 4.746 37.828c.155 10.546 13.023 15.644 20.486 8.192 11.574-11.558 30.636-30.684 63.409-63.457 54.733-54.735 54.71-143.3-.001-197.991z'%3e%3c/path%3e%3c/svg%3e");
}

trix-toolbar .trix-button--icon-strike::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M496 224H293.9l-87.17-26.83A43.55 43.55 0 0 1 219.55 112h66.79A49.89 49.89 0 0 1 331 139.58a16 16 0 0 0 21.46 7.15l42.94-21.47a16 16 0 0 0 7.16-21.46l-.53-1A128 128 0 0 0 287.51 32h-68a123.68 123.68 0 0 0-123 135.64c2 20.89 10.1 39.83 21.78 56.36H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h480a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm-180.24 96A43 43 0 0 1 336 356.45 43.59 43.59 0 0 1 292.45 400h-66.79A49.89 49.89 0 0 1 181 372.42a16 16 0 0 0-21.46-7.15l-42.94 21.47a16 16 0 0 0-7.16 21.46l.53 1A128 128 0 0 0 224.49 480h68a123.68 123.68 0 0 0 123-135.64 114.25 114.25 0 0 0-5.34-24.36z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M496 224H293.9l-87.17-26.83A43.55 43.55 0 0 1 219.55 112h66.79A49.89 49.89 0 0 1 331 139.58a16 16 0 0 0 21.46 7.15l42.94-21.47a16 16 0 0 0 7.16-21.46l-.53-1A128 128 0 0 0 287.51 32h-68a123.68 123.68 0 0 0-123 135.64c2 20.89 10.1 39.83 21.78 56.36H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h480a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm-180.24 96A43 43 0 0 1 336 356.45 43.59 43.59 0 0 1 292.45 400h-66.79A49.89 49.89 0 0 1 181 372.42a16 16 0 0 0-21.46-7.15l-42.94 21.47a16 16 0 0 0-7.16 21.46l.53 1A128 128 0 0 0 224.49 480h68a123.68 123.68 0 0 0 123-135.64 114.25 114.25 0 0 0-5.34-24.36z'%3e%3c/path%3e%3c/svg%3e");
}

trix-toolbar .trix-button--icon-quote::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M464 32H336c-26.5 0-48 21.5-48 48v128c0 26.5 21.5 48 48 48h80v64c0 35.3-28.7 64-64 64h-8c-13.3 0-24 10.7-24 24v48c0 13.3 10.7 24 24 24h8c88.4 0 160-71.6 160-160V80c0-26.5-21.5-48-48-48zm-288 0H48C21.5 32 0 53.5 0 80v128c0 26.5 21.5 48 48 48h80v64c0 35.3-28.7 64-64 64h-8c-13.3 0-24 10.7-24 24v48c0 13.3 10.7 24 24 24h8c88.4 0 160-71.6 160-160V80c0-26.5-21.5-48-48-48z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M464 32H336c-26.5 0-48 21.5-48 48v128c0 26.5 21.5 48 48 48h80v64c0 35.3-28.7 64-64 64h-8c-13.3 0-24 10.7-24 24v48c0 13.3 10.7 24 24 24h8c88.4 0 160-71.6 160-160V80c0-26.5-21.5-48-48-48zm-288 0H48C21.5 32 0 53.5 0 80v128c0 26.5 21.5 48 48 48h80v64c0 35.3-28.7 64-64 64h-8c-13.3 0-24 10.7-24 24v48c0 13.3 10.7 24 24 24h8c88.4 0 160-71.6 160-160V80c0-26.5-21.5-48-48-48z'%3e%3c/path%3e%3c/svg%3e");
  top: 0.25rem;
  bottom: 0.25rem;
  margin-top: 1px;
  margin-bottom: 1px;
}

trix-toolbar .trix-button--icon-heading-1::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M448 96v320h32a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16H320a16 16 0 0 1-16-16v-32a16 16 0 0 1 16-16h32V288H160v128h32a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16H32a16 16 0 0 1-16-16v-32a16 16 0 0 1 16-16h32V96H32a16 16 0 0 1-16-16V48a16 16 0 0 1 16-16h160a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16h-32v128h192V96h-32a16 16 0 0 1-16-16V48a16 16 0 0 1 16-16h160a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M448 96v320h32a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16H320a16 16 0 0 1-16-16v-32a16 16 0 0 1 16-16h32V288H160v128h32a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16H32a16 16 0 0 1-16-16v-32a16 16 0 0 1 16-16h32V96H32a16 16 0 0 1-16-16V48a16 16 0 0 1 16-16h160a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16h-32v128h192V96h-32a16 16 0 0 1-16-16V48a16 16 0 0 1 16-16h160a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16z'%3e%3c/path%3e%3c/svg%3e");
}

trix-toolbar .trix-button--icon-code::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 640 304' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M165.9%2c291.3 L209.4%2c244.9 C214%2c240 213.7%2c232.2 208.6%2c227.7 L118%2c148 L208.6%2c68.3 C213.7%2c63.8 214.1%2c56 209.4%2c51.1 L165.9%2c4.7 C161.4%2c-0.1 153.8%2c-0.4 148.9%2c4.2 L4.8%2c139.2 C-0.3%2c143.9 -0.3%2c152 4.8%2c156.7 L148.9%2c291.8 C153.8%2c296.4 161.4%2c296.2 165.9%2c291.3 Z M493.1%2c291.9 L637.2%2c156.8 C642.3%2c152.1 642.3%2c144 637.2%2c139.3 L493.1%2c4.1 C488.3%2c-0.4 480.7%2c-0.2 476.1%2c4.6 L432.6%2c51 C428%2c55.9 428.3%2c63.7 433.4%2c68.2 L524%2c148 L433.4%2c227.7 C428.3%2c232.2 427.9%2c240 432.6%2c244.9 L476.1%2c291.3 C480.6%2c296.2 488.2%2c296.4 493.1%2c291.9 Z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 640 304' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M165.9%2c291.3 L209.4%2c244.9 C214%2c240 213.7%2c232.2 208.6%2c227.7 L118%2c148 L208.6%2c68.3 C213.7%2c63.8 214.1%2c56 209.4%2c51.1 L165.9%2c4.7 C161.4%2c-0.1 153.8%2c-0.4 148.9%2c4.2 L4.8%2c139.2 C-0.3%2c143.9 -0.3%2c152 4.8%2c156.7 L148.9%2c291.8 C153.8%2c296.4 161.4%2c296.2 165.9%2c291.3 Z M493.1%2c291.9 L637.2%2c156.8 C642.3%2c152.1 642.3%2c144 637.2%2c139.3 L493.1%2c4.1 C488.3%2c-0.4 480.7%2c-0.2 476.1%2c4.6 L432.6%2c51 C428%2c55.9 428.3%2c63.7 433.4%2c68.2 L524%2c148 L433.4%2c227.7 C428.3%2c232.2 427.9%2c240 432.6%2c244.9 L476.1%2c291.3 C480.6%2c296.2 488.2%2c296.4 493.1%2c291.9 Z'%3e%3c/path%3e%3c/svg%3e");
  top: 0.375rem;
  bottom: 0.375rem;
  margin-top: 1px;
  margin-bottom: 1px;
}

trix-toolbar .trix-button--icon-bullet-list::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M48 48a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm0 160a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm0 160a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm448 16H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M48 48a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm0 160a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm0 160a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm448 16H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z'%3e%3c/path%3e%3c/svg%3e");
  margin-top: 1px;
  margin-bottom: 1px;
}

trix-toolbar .trix-button--icon-number-list::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M61.77 401l17.5-20.15a19.92 19.92 0 0 0 5.07-14.19v-3.31C84.34 356 80.5 352 73 352H16a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h22.83a157.41 157.41 0 0 0-11 12.31l-5.61 7c-4 5.07-5.25 10.13-2.8 14.88l1.05 1.93c3 5.76 6.29 7.88 12.25 7.88h4.73c10.33 0 15.94 2.44 15.94 9.09 0 4.72-4.2 8.22-14.36 8.22a41.54 41.54 0 0 1-15.47-3.12c-6.49-3.88-11.74-3.5-15.6 3.12l-5.59 9.31c-3.72 6.13-3.19 11.72 2.63 15.94 7.71 4.69 20.38 9.44 37 9.44 34.16 0 48.5-22.75 48.5-44.12-.03-14.38-9.12-29.76-28.73-34.88zM496 224H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zM16 160h64a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8H64V40a8 8 0 0 0-8-8H32a8 8 0 0 0-7.14 4.42l-8 16A8 8 0 0 0 24 64h8v64H16a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8zm-3.91 160H80a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8H41.32c3.29-10.29 48.34-18.68 48.34-56.44 0-29.06-25-39.56-44.47-39.56-21.36 0-33.8 10-40.46 18.75-4.37 5.59-3 10.84 2.8 15.37l8.58 6.88c5.61 4.56 11 2.47 16.12-2.44a13.44 13.44 0 0 1 9.46-3.84c3.33 0 9.28 1.56 9.28 8.75C51 248.19 0 257.31 0 304.59v4C0 316 5.08 320 12.09 320z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M61.77 401l17.5-20.15a19.92 19.92 0 0 0 5.07-14.19v-3.31C84.34 356 80.5 352 73 352H16a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h22.83a157.41 157.41 0 0 0-11 12.31l-5.61 7c-4 5.07-5.25 10.13-2.8 14.88l1.05 1.93c3 5.76 6.29 7.88 12.25 7.88h4.73c10.33 0 15.94 2.44 15.94 9.09 0 4.72-4.2 8.22-14.36 8.22a41.54 41.54 0 0 1-15.47-3.12c-6.49-3.88-11.74-3.5-15.6 3.12l-5.59 9.31c-3.72 6.13-3.19 11.72 2.63 15.94 7.71 4.69 20.38 9.44 37 9.44 34.16 0 48.5-22.75 48.5-44.12-.03-14.38-9.12-29.76-28.73-34.88zM496 224H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zM16 160h64a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8H64V40a8 8 0 0 0-8-8H32a8 8 0 0 0-7.14 4.42l-8 16A8 8 0 0 0 24 64h8v64H16a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8zm-3.91 160H80a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8H41.32c3.29-10.29 48.34-18.68 48.34-56.44 0-29.06-25-39.56-44.47-39.56-21.36 0-33.8 10-40.46 18.75-4.37 5.59-3 10.84 2.8 15.37l8.58 6.88c5.61 4.56 11 2.47 16.12-2.44a13.44 13.44 0 0 1 9.46-3.84c3.33 0 9.28 1.56 9.28 8.75C51 248.19 0 257.31 0 304.59v4C0 316 5.08 320 12.09 320z'%3e%3c/path%3e%3c/svg%3e");
  margin-top: 1px;
  margin-bottom: 1px;
}

trix-toolbar .trix-button--icon-undo::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z'%3e%3c/path%3e%3c/svg%3e");
  top: 0.25rem;
  bottom: 0.25rem;
}

trix-toolbar .trix-button--icon-redo::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 512 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z'%3e%3c/path%3e%3c/svg%3e");
  top: 0.25rem;
  bottom: 0.25rem;
}

trix-toolbar .trix-button--icon-decrease-nesting-level::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 448 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M100.682584%2c116.695158 L4.68258422%2c212.695158 C-1.56086141%2c218.942698 -1.56086141%2c229.067619 4.68258422%2c235.315158 L100.682584%2c331.315158 C110.722584%2c341.335158 127.992584%2c334.215158 127.992584%2c319.995158 L127.992584%2c127.995158 C127.992584%2c113.685158 110.662584%2c106.695158 100.682584%2c116.695158 Z M432%2c384 L16%2c384 C7.163444%2c384 1.082166e-15%2c391.163444 0%2c400 L0%2c432 C1.082166e-15%2c440.836556 7.163444%2c448 16%2c448 L432%2c448 C440.836556%2c448 448%2c440.836556 448%2c432 L448%2c400 C448%2c391.163444 440.836556%2c384 432%2c384 Z M204.83%2c256 C201.426459%2c255.997344 198.161555%2c257.348219 195.754887%2c259.754887 C193.348219%2c262.161555 191.997344%2c265.426459 192%2c268.83 L192%2c307.17 C191.997344%2c310.573541 193.348219%2c313.838445 195.754887%2c316.245113 C198.161555%2c318.651781 201.426459%2c320.002656 204.83%2c320 L435.17%2c320 C438.573541%2c320.002656 441.838445%2c318.651781 444.245113%2c316.245113 C446.651781%2c313.838445 448.002656%2c310.573541 448%2c307.17 L448%2c268.83 C448.002656%2c265.426459 446.651781%2c262.161555 444.245113%2c259.754887 C441.838445%2c257.348219 438.573541%2c255.997344 435.17%2c256 L204.83%2c256 Z M435.17%2c128 L204.83%2c128 C201.426459%2c127.997344 198.161555%2c129.348219 195.754887%2c131.754887 C193.348219%2c134.161555 191.997344%2c137.426459 192%2c140.83 L192%2c179.17 C191.997344%2c182.573541 193.348219%2c185.838445 195.754887%2c188.245113 C198.161555%2c190.651781 201.426459%2c192.002656 204.83%2c192 L435.17%2c192 C438.573541%2c192.002656 441.838445%2c190.651781 444.245113%2c188.245113 C446.651781%2c185.838445 448.002656%2c182.573541 448%2c179.17 L448%2c140.83 C448.002656%2c137.426459 446.651781%2c134.161555 444.245113%2c131.754887 C441.838445%2c129.348219 438.573541%2c127.997344 435.17%2c128 Z M432%2c0 L16%2c0 C7.163444%2c0 1.082166e-15%2c7.163444 0%2c16 L0%2c48 C1.082166e-15%2c56.836556 7.163444%2c64 16%2c64 L432%2c64 C440.836556%2c64 448%2c56.836556 448%2c48 L448%2c16 C448%2c7.163444 440.836556%2c0 432%2c0 Z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 448 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M100.682584%2c116.695158 L4.68258422%2c212.695158 C-1.56086141%2c218.942698 -1.56086141%2c229.067619 4.68258422%2c235.315158 L100.682584%2c331.315158 C110.722584%2c341.335158 127.992584%2c334.215158 127.992584%2c319.995158 L127.992584%2c127.995158 C127.992584%2c113.685158 110.662584%2c106.695158 100.682584%2c116.695158 Z M432%2c384 L16%2c384 C7.163444%2c384 1.082166e-15%2c391.163444 0%2c400 L0%2c432 C1.082166e-15%2c440.836556 7.163444%2c448 16%2c448 L432%2c448 C440.836556%2c448 448%2c440.836556 448%2c432 L448%2c400 C448%2c391.163444 440.836556%2c384 432%2c384 Z M204.83%2c256 C201.426459%2c255.997344 198.161555%2c257.348219 195.754887%2c259.754887 C193.348219%2c262.161555 191.997344%2c265.426459 192%2c268.83 L192%2c307.17 C191.997344%2c310.573541 193.348219%2c313.838445 195.754887%2c316.245113 C198.161555%2c318.651781 201.426459%2c320.002656 204.83%2c320 L435.17%2c320 C438.573541%2c320.002656 441.838445%2c318.651781 444.245113%2c316.245113 C446.651781%2c313.838445 448.002656%2c310.573541 448%2c307.17 L448%2c268.83 C448.002656%2c265.426459 446.651781%2c262.161555 444.245113%2c259.754887 C441.838445%2c257.348219 438.573541%2c255.997344 435.17%2c256 L204.83%2c256 Z M435.17%2c128 L204.83%2c128 C201.426459%2c127.997344 198.161555%2c129.348219 195.754887%2c131.754887 C193.348219%2c134.161555 191.997344%2c137.426459 192%2c140.83 L192%2c179.17 C191.997344%2c182.573541 193.348219%2c185.838445 195.754887%2c188.245113 C198.161555%2c190.651781 201.426459%2c192.002656 204.83%2c192 L435.17%2c192 C438.573541%2c192.002656 441.838445%2c190.651781 444.245113%2c188.245113 C446.651781%2c185.838445 448.002656%2c182.573541 448%2c179.17 L448%2c140.83 C448.002656%2c137.426459 446.651781%2c134.161555 444.245113%2c131.754887 C441.838445%2c129.348219 438.573541%2c127.997344 435.17%2c128 Z M432%2c0 L16%2c0 C7.163444%2c0 1.082166e-15%2c7.163444 0%2c16 L0%2c48 C1.082166e-15%2c56.836556 7.163444%2c64 16%2c64 L432%2c64 C440.836556%2c64 448%2c56.836556 448%2c48 L448%2c16 C448%2c7.163444 440.836556%2c0 432%2c0 Z'%3e%3c/path%3e%3c/svg%3e");
  margin-bottom: 0;
}

trix-toolbar .trix-button--icon-increase-nesting-level::before {
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 448 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M27.31 363.3l96-96a16 16 0 0 0 0-22.62l-96-96C17.27 138.66 0 145.78 0 160v192c0 14.31 17.33 21.3 27.31 11.3zM432 416H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm3.17-128H204.83A12.82 12.82 0 0 0 192 300.83v38.34A12.82 12.82 0 0 0 204.83 352h230.34A12.82 12.82 0 0 0 448 339.17v-38.34A12.82 12.82 0 0 0 435.17 288zm0-128H204.83A12.82 12.82 0 0 0 192 172.83v38.34A12.82 12.82 0 0 0 204.83 224h230.34A12.82 12.82 0 0 0 448 211.17v-38.34A12.82 12.82 0 0 0 435.17 160zM432 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 448 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M27.31 363.3l96-96a16 16 0 0 0 0-22.62l-96-96C17.27 138.66 0 145.78 0 160v192c0 14.31 17.33 21.3 27.31 11.3zM432 416H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm3.17-128H204.83A12.82 12.82 0 0 0 192 300.83v38.34A12.82 12.82 0 0 0 204.83 352h230.34A12.82 12.82 0 0 0 448 339.17v-38.34A12.82 12.82 0 0 0 435.17 288zm0-128H204.83A12.82 12.82 0 0 0 192 172.83v38.34A12.82 12.82 0 0 0 204.83 224h230.34A12.82 12.82 0 0 0 448 211.17v-38.34A12.82 12.82 0 0 0 435.17 160zM432 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z'%3e%3c/path%3e%3c/svg%3e");
  margin-top: 1px;
  margin-bottom: 1px;
}

trix-toolbar .trix-dialogs {
  position: relative;
}

trix-toolbar .trix-dialog {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  font-size: 0.75rem;
  line-height: 1rem;
  padding: 1rem 0.625rem;
  background-color: var(--vf-bg-input);
  box-shadow: 0 0px 15px 0px rgba(0, 0, 0, 0.3);
  margin-top: 0.375rem;
  border-radius: 0.25rem;
  z-index: 2;
}

trix-toolbar .trix-input--dialog {
  padding: 0.375rem 0.75rem;
  border: 1px solid var(--vf-border-color-input);
  border-radius: 0.25rem;
  margin-right: 0.5rem;
  font-size: 0.75rem;
  line-height: 1rem;
  background: var(--vf-bg-input);
  color: var(--vf-color-input);
}

trix-toolbar .trix-input--dialog:focus {
  outline: var(--vf-ring-width) solid var(--vf-ring-color) !important;
}

trix-toolbar .trix-input--dialog.validate:invalid {
  border-color: var(--vf-color-danger);
}

trix-toolbar .trix-button--dialog {
  padding: 0.5rem;
  border-left-width: 1px;
  border-color: var(--vf-border-color-input);
  background-color: transparent;
  border-radius: 0;
}

trix-toolbar .trix-button--dialog:not(.trix-active):hover {
  background-color: transparent;
}

trix-toolbar .trix-button--dialog:first-of-type {
  border: 0;
}

trix-toolbar .trix-dialog--link {
  max-width: 36rem;
}

trix-toolbar .trix-dialog__link-fields {
  display: flex;
  align-items: center;
  width: 100%;
}

trix-toolbar .trix-dialog__link-fields .trix-input {
  flex: 1 1 0%;
}

trix-toolbar .trix-dialog__link-fields .trix-button-group {
  flex-grow: 0;
  flex-shrink: 0;
}

trix-editor {
  padding-left: var(--vf-px-input);
  padding-right: var(--vf-px-input);
  padding-bottom: var(--vf-py-input);
  border-radius: var(--vf-radius-large);
  outline: none;
  min-height: 6rem;
}

trix-editor:empty:not(:focus)::before {
  color: var(--vf-color-placeholder);
}

trix-editor [data-trix-mutable]:not(.attachment__caption-editor) {
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
}

trix-editor [data-trix-mutable]::-moz-selection,
trix-editor [data-trix-cursor-target]::-moz-selection,
trix-editor [data-trix-mutable] ::-moz-selection {
  background-image: none;
}

trix-editor [data-trix-mutable]::-moz-selection, trix-editor [data-trix-cursor-target]::-moz-selection, trix-editor [data-trix-mutable] ::-moz-selection {
  background-image: none;
}

trix-editor [data-trix-mutable]::selection,
trix-editor [data-trix-cursor-target]::selection,
trix-editor [data-trix-mutable] ::selection {
  background-image: none;
}

trix-editor [data-trix-mutable].attachment__caption-editor:focus::-moz-selection {
  background: highlight;
}

trix-editor [data-trix-mutable].attachment__caption-editor:focus::selection {
  background: highlight;
}

trix-editor [data-trix-mutable].attachment.attachment--file {
  background-color: var(--vf-bg-selected);
}

trix-editor [data-trix-mutable].attachment img {
  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
}

trix-editor .attachment {
  position: relative;
}

trix-editor .attachment:hover {
  cursor: default;
}

trix-editor .attachment--preview .attachment__caption:hover {
  cursor: text;
}

trix-editor .attachment__progress {
  position: absolute;
  z-index: 1;
  height: 1.25rem;
  top: 50%;
  left: 0;
  transform: translateY(-0.625rem);
  width: 100%;
  padding-left: 1rem;
  padding-right: 1rem;
  opacity: 0.2;
  transition-property: opacity;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

trix-editor .attachment__progress[value="100"] {
  opacity: 0;
}

trix-editor .attachment__caption-editor {
  display: inline-block;
  padding: 0;
  margin: 0;
  font-size: 0.875rem;
  line-height: 1.25rem;
  text-align: center;
  vertical-align: top;
  width: 100%;
  border-width: 0;
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  outline: 0;
  background: var(--vf-bg-input);
  color: var(--vf-color-input);
  font-family: inherit;
}

trix-editor .attachment__toolbar {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 1;
  transform: translateY(-50%);
  text-align: center;
  width: 100%;
}

trix-editor .trix-button-group {
  display: inline-flex;
}

trix-editor .trix-button {
  position: relative;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 0.75rem;
  padding-right: 0.75rem;
  margin: 0;
  background-color: transparent;
  color: var(--vf-bg-icon);
  font-size: 0.875rem;
  line-height: 1.25rem;
  white-space: nowrap;
  border-radius: 0;
  border-width: 0;
  outline: 0;
}

trix-editor .trix-button:not(:disabled) {
  cursor: pointer;
}

trix-editor .trix-button--remove {
  display: inline-block;
  overflow-x: hidden;
  padding: 0;
  background-color: var(--vf-bg-input);
  line-height: 1.75rem;
  border-color: var(--vf-color-selected);
  border-radius: 9999px;
  border-width: 1px;
  border-style: solid;
  outline: 0;
  text-indent: -9999px;
  width: 24px;
  height: 24px;
}

trix-editor .trix-button--remove:hover {
  background-color: var(--vf-bg-selected);
}

trix-editor .trix-button--remove::before {
  content: "";
  display: inline-block;
  position: absolute;
  top: 0.125rem;
  right: 0.125rem;
  bottom: 0.125rem;
  left: 0.125rem;
  background-color: var(--vf-color-input);
  opacity: 0.7;
  background-position: center;
  background-repeat: no-repeat;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-position: center center;
  -webkit-mask-position: center center;
  mask-size: contain;
  -webkit-mask-size: contain;
  mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M193.94 256L296.5 153.44l21.15-21.15c3.12-3.12 3.12-8.19 0-11.31l-22.63-22.63c-3.12-3.12-8.19-3.12-11.31 0L160 222.06 36.29 98.34c-3.12-3.12-8.19-3.12-11.31 0L2.34 120.97c-3.12 3.12-3.12 8.19 0 11.31L126.06 256 2.34 379.71c-3.12 3.12-3.12 8.19 0 11.31l22.63 22.63c3.12 3.12 8.19 3.12 11.31 0L160 289.94 262.56 392.5l21.15 21.15c3.12 3.12 8.19 3.12 11.31 0l22.63-22.63c3.12-3.12 3.12-8.19 0-11.31L193.94 256z'%3e%3c/path%3e%3c/svg%3e");
  -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='0 0 320 512' fill='currentColor' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M193.94 256L296.5 153.44l21.15-21.15c3.12-3.12 3.12-8.19 0-11.31l-22.63-22.63c-3.12-3.12-8.19-3.12-11.31 0L160 222.06 36.29 98.34c-3.12-3.12-8.19-3.12-11.31 0L2.34 120.97c-3.12 3.12-3.12 8.19 0 11.31L126.06 256 2.34 379.71c-3.12 3.12-3.12 8.19 0 11.31l22.63 22.63c3.12 3.12 8.19 3.12 11.31 0L160 289.94 262.56 392.5l21.15 21.15c3.12 3.12 8.19 3.12 11.31 0l22.63-22.63c3.12-3.12 3.12-8.19 0-11.31L193.94 256z'%3e%3c/path%3e%3c/svg%3e");
}

trix-editor .attachment__metadata-container {
  position: relative;
}

trix-editor .attachment__metadata {
  position: absolute;
  top: 1rem;
  left: 50%;
  padding-top: 0.125rem;
  padding-bottom: 0.125rem;
  padding-left: 0.5rem;
  padding-right: 0.5rem;
  background-color: #000000;
  opacity: 0.7;
  transform: translateX(-50%);
  color: #ffffff;
  font-size: 0.875rem;
  line-height: 1.25rem;
  border-radius: 0.25rem;
}

trix-editor .attachment__metadata .attachment__name {
  display: inline-block;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
  white-space: nowrap;
  max-width: 100%;
}

trix-editor .attachment__metadata .attachment__size {
  margin-left: 0.25rem;
  white-space: nowrap;
}

.trix-content h1,
trix-editor h1 {
  font-size: 1.875rem;
  line-height: 2.25rem;
  font-weight: 700;
  line-height: 1.25;
}

.trix-content a,
trix-editor a {
  color: var(--vf-primary);
}

.trix-content ul,
trix-editor ul {
  padding-left: 2.5rem;
  list-style-type: disc;
}

.trix-content [dir=rtl] ul,
trix-editor [dir=rtl] ul {
  padding-right: 2.5rem;
  list-style-type: disc;
}

.trix-content ol,
trix-editor ol {
  padding-left: 2.5rem;
  list-style-type: decimal;
}

.trix-content [dir=rtl] ol,
trix-editor [dir=rtl] ol {
  padding-right: 2.5rem;
  list-style-type: decimal;
}

.trix-content blockquote,
trix-editor blockquote {
  padding-left: 0.625rem;
  border-left-width: 4px;
  border-color: var(--vf-gray-300);
  border-left-style: solid;
  margin: 0;
}

.trix-content [dir=rtl] blockquote,
.trix-content blockquote[dir=rtl],
trix-editor [dir=rtl] blockquote,
trix-editor blockquote[dir=rtl] {
  padding-left: 0.625rem;
  border-left-width: 4px;
  border-color: var(--vf-gray-300);
}

.trix-content pre,
trix-editor pre {
  display: inline-block;
  overscroll-behavior-x: auto;
  padding: 0.5rem;
  background-color: var(--vf-gray-50);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 0.875rem;
  line-height: 1.25rem;
  vertical-align: top;
  white-space: pre;
  width: 100%;
}

.trix-content img,
trix-editor img {
  max-width: 100%;
  height: auto;
}

.trix-content .attachment__caption,
trix-editor .attachment__caption {
  font-size: 0.875rem;
  line-height: 1.25rem;
  text-align: center;
}

.trix-content .attachment__caption .attachment__name + .attachment__size::before,
trix-editor .attachment__caption .attachment__name + .attachment__size::before {
  content: " · ";
}

.trix-content * {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

.trix-content .attachment {
  display: inline-block;
  position: relative;
  max-width: 100%;
}

.trix-content .attachment a {
  text-decoration: none;
}

.trix-content .attachment--preview {
  text-align: center;
  width: 100%;
}

.trix-content .attachment--preview .attachment__caption {
  color: var(--vf-gray-500);
  font-size: 0.875rem;
  line-height: 1.25rem;
}

.trix-content .attachment--file {
  padding-top: 0.375rem;
  padding-bottom: 0.375rem;
  padding-left: 1rem;
  padding-right: 1rem;
  margin: 0.125rem;
  margin-top: 0;
  color: var(--vf-gray-700);
  line-height: 1;
  border-radius: 0.25rem;
  border-width: 1px;
  border-color: var(--vf-gray-300);
}

.trix-content .attachment-gallery {
  display: flex;
  position: relative;
  display: flex;
  flex-wrap: wrap;
}

.trix-content .attachment-gallery .attachment {
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 0.5rem;
  padding-right: 0.5rem;
  flex-grow: 1;
  flex-shrink: 0;
  width: 33.333333%;
}

.trix-content .attachment-gallery.attachment-gallery--2 .attachment, .trix-content .attachment-gallery.attachment-gallery--4 .attachment {
  width: 50%;
}

.trix-content .attachment__progress {
  display: none;
}

.vf-editor-sm trix-editor {
  padding-left: var(--vf-px-input-sm);
  padding-right: var(--vf-px-input-sm);
  padding-bottom: var(--vf-py-input-sm);
  border-radius: var(--vf-radius-large-sm);
  min-height: 5rem;
}

.vf-editor-sm .trix-content h1,
.vf-editor-sm trix-editor h1 {
  font-size: 1.625rem;
  font-weight: 700;
  line-height: 1.25;
}

.vf-editor-sm trix-toolbar {
  padding: var(--vf-py-input-sm) var(--vf-py-input-sm);
}

.vf-editor-sm trix-toolbar .trix-button--icon {
  width: 2.25rem;
}

.vf-editor-lg trix-editor {
  padding-left: var(--vf-px-input-lg);
  padding-right: var(--vf-px-input-lg);
  padding-bottom: var(--vf-py-input-lg);
  border-radius: var(--vf-radius-large-lg);
}

.vf-editor-disabled trix-toolbar {
  pointer-events: none;
}

.vf-editor-hide-bold .trix-button--icon-bold {
  display: none;
}

.vf-editor-hide-italic .trix-button--icon-italic {
  display: none;
}

.vf-editor-hide-strike .trix-button--icon-strike {
  display: none;
}

.vf-editor-hide-link .trix-button--icon-link {
  display: none;
}

.vf-editor-hide-heading .trix-button--icon-heading-1 {
  display: none;
}

.vf-editor-hide-quote .trix-button--icon-quote {
  display: none;
}

.vf-editor-hide-code .trix-button--icon-code {
  display: none;
}

.vf-editor-hide-bullet-list .trix-button--icon-bullet-list {
  display: none;
}

.vf-editor-hide-number-list .trix-button--icon-number-list {
  display: none;
}

.vf-editor-hide-decrease-nesting .trix-button--icon-decrease-nesting-level {
  display: none;
}

.vf-editor-hide-increase-nesting .trix-button--icon-increase-nesting-level {
  display: none;
}

.vf-editor-hide-attach .trix-button--icon-attach {
  display: none;
}

.vf-editor-hide-undo .trix-button--icon-undo {
  display: none;
}

.vf-editor-hide-redo .trix-button--icon-redo {
  display: none;
}

.dark .trix-content blockquote,
.dark trix-editor blockquote {
  border-color: var(--vf-dark-700);
}

.dark .trix-content pre,
.dark trix-editor pre {
  background-color: var(--vf-dark-900);
}`;
    styleInject(css_248z);
    script.__file = "themes/vueform/templates/wrappers/EditorWrapper.vue";
    function columns(breakpoint, size2) {
      switch (breakpoint) {
        case "default":
          return "vf-col-".concat(size2);
        default:
          return "vf-col-".concat(breakpoint, "-").concat(size2);
      }
    }
    var classes = {};
    var index = {
      templates: {
        Vueform: script$27,
        FormErrors: script$25,
        FormMessages: script$23,
        FormLanguages: script$21,
        FormLanguage: script$1$,
        FormTabs: script$1Z,
        FormTab: script$1X,
        FormSteps: script$1V,
        FormStepsControls: script$1T,
        FormStepsControl: script$1R,
        FormStep: script$1P,
        FormElements: script$1N,
        ElementLayout: script$1L,
        ElementLayoutInline: script$1J,
        ElementLoader: script$1H,
        ElementLabelFloating: script$1F,
        ElementLabel: script$1D,
        ElementInfo: script$1B,
        ElementDescription: script$1z,
        ElementError: script$1x,
        ElementMessage: script$1v,
        ElementText: script$1t,
        ElementAddon: script$1r,
        ElementAddonOptions: script$1p,
        ButtonElement: script$1n,
        CaptchaElement: script$1l,
        CheckboxElement: script$1j,
        CheckboxgroupElement: script$1h,
        CheckboxgroupElement_tabs: script$1g,
        CheckboxgroupElement_blocks: script$1f,
        DateElement: script$1d,
        DatesElement: script$1b,
        FileElement: script$19,
        GroupElement: script$17,
        HiddenElement: script$15,
        ListElement: script$13,
        LocationElement: script$11,
        MultifileElement: script$$,
        MultiselectElement: script$Y,
        ObjectElement: script$W,
        PhoneElement: script$U,
        RadioElement: script$S,
        RadiogroupElement: script$Q,
        RadiogroupElement_tabs: script$P,
        RadiogroupElement_blocks: script$O,
        SelectElement: script$M,
        SignatureElement: script$K,
        SliderElement: script$H,
        StaticElement: script$F,
        TagsElement: script$D,
        TextareaElement: script$B,
        TextElement: script$z,
        ToggleElement: script$w,
        EditorElement: script$u,
        TTextareaElement: script$s,
        TTextElement: script$q,
        TEditorElement: script$o,
        CheckboxgroupCheckbox: script$m,
        CheckboxgroupCheckbox_tabs: script$k,
        CheckboxgroupCheckbox_blocks: script$i,
        DragAndDrop: script$g,
        FilePreview: script$e,
        FilePreview_image: script$c,
        FilePreview_gallery: script$a,
        RadiogroupRadio: script$8,
        RadiogroupRadio_tabs: script$6,
        RadiogroupRadio_blocks: script$4,
        DatepickerWrapper: script$2,
        EditorWrapper: script
      },
      classes,
      columns
    };
    axios$1.defaults.headers.post = {
      // 'Content-Type': 'application/json'
      // ADD Authorization bearer token here
    };
    const vueformConfig = {
      theme: index,
      locales: { en: en$1 },
      locale: "en"
    };
    const CreateListing_vue_vue_type_style_index_0_lang = "";
    const _sfc_main$1 = {
      mixins: [VueformComponent],
      props: {
        productId: {
          type: String,
          required: false,
          default: ""
        },
        siteId: {
          type: String,
          required: false,
          default: ""
        },
        url: {
          type: String,
          required: false,
          default: ""
        },
        t: {
          type: String,
          required: false,
          default: ""
        }
      },
      setup(props, context) {
        console.log("CreateListing.vue setup is called");
        const form = base$1b(props, context);
        const vueform2 = ref({
          size: "md",
          displayErrors: false,
          steps: {
            page0: {
              label: "Details",
              elements: [
                "h2",
                "divider",
                "accommodation_type",
                "advert_elsewhere",
                "import",
                "accommodation_name",
                "divider_1"
              ],
              buttons: {
                previous: false
              }
            },
            page1: {
              label: "Location",
              elements: [
                "h2_1",
                "divider_2",
                "location",
                "divider_3"
              ]
            },
            page2: {
              label: "Rooms",
              elements: [
                "h2_2",
                "divider_4",
                "guests_count",
                "bathroom_count",
                "size",
                "h2_3",
                "divider_5",
                "rooms",
                "divider_6"
              ]
            },
            page3: {
              label: "Equipment & facilities",
              elements: [
                "h2_4",
                "divider_7",
                "equipment",
                "divider_8"
              ]
            },
            page4: {
              label: "Breakfast",
              elements: [
                "h2_5",
                "divider_9",
                "serve_breakfast",
                "breakfast_in_price",
                "breakfast_price",
                "breakfast_types",
                "divider_10"
              ]
            },
            page5: {
              label: "Parking",
              elements: [
                "h2_6",
                "divider_11",
                "parking",
                "parking_price",
                "parking_interval",
                "parking_reservation",
                "parking_location",
                "parking_location_offsite_description",
                "parking_type",
                "divider_12"
              ]
            },
            page6: {
              label: "Languages",
              elements: [
                "h2_7",
                "divider_13",
                "languages",
                "divider_14"
              ]
            },
            page7: {
              label: "House rules",
              elements: [
                "h2_8",
                "divider_15",
                "rules",
                "check_in_from",
                "check_in_until",
                "p_1",
                "check_out_from",
                "check_out_until",
                "divider_16"
              ]
            },
            page8: {
              label: "Host profile",
              elements: [
                "h2_9",
                "divider_17",
                "profile",
                "property",
                "host_name",
                "about_host",
                "about_neighbourhood",
                "divider_18"
              ]
            },
            page9: {
              label: "Gallery",
              elements: [
                "h2_10",
                "divider_19",
                "gallery",
                "divider_20"
              ]
            },
            page10: {
              label: "Payment",
              elements: [
                "h2_11",
                "divider_21",
                "can_charge_card",
                "price_per_night",
                "divider_22"
              ]
            },
            page11: {
              label: "Rate plans",
              elements: [
                "h2_12",
                "divider_23",
                "h3",
                "p_copy5",
                "free_days_before_cancellation",
                "accidental_booking_protection",
                "standard_plan_divider",
                "h4",
                "p",
                "group_discount",
                "container",
                "divider_29",
                "h3_1",
                "p_copy",
                "p_copy2",
                "nonrefundable_rate_plan",
                "non_refundable_plan_discount",
                "divider_30",
                "h3_2",
                "p_copy3",
                "p_copy4",
                "weekly_rate_plan",
                "weekly_rate",
                "divider_24"
              ]
            },
            page12: {
              label: "Availability",
              elements: [
                "h2_13",
                "divider_25",
                "available_from",
                "available_from_date",
                "divider_26"
              ]
            },
            page13: {
              label: "Complete",
              elements: [
                "h2_14",
                "divider_27",
                "terms_1",
                "terms_2",
                "divider_28"
              ]
            }
          },
          addClass: "vf-create-listing",
          schema: {
            h2: {
              type: "static",
              content: "Details",
              tag: "h2",
              top: "1"
            },
            divider: {
              type: "static",
              tag: "hr"
            },
            accommodation_type: {
              type: "radiogroup",
              view: "tabs",
              items: [
                "Apartment",
                "Private",
                "Hotel",
                "Other"
              ],
              rules: [
                "required"
              ],
              fieldName: "Accommodation type",
              default: "Apartment",
              label: "Select accommodation type"
            },
            advert_elsewhere: {
              type: "checkboxgroup",
              fieldName: "Posted elsewhere",
              items: [
                "Airbnb",
                "Tripadvisor",
                "Vrbo",
                "Other"
              ],
              label: "Have you posted it elsewhere?"
            },
            import: {
              type: "group",
              schema: {
                external_url: {
                  type: "text",
                  inputType: "url",
                  rules: [
                    "required",
                    "max:255",
                    "url"
                  ],
                  placeholder: "eg. http(s)://domain.com",
                  floating: false,
                  label: "Import your data from Airbnb or Vrbo",
                  columns: {
                    container: 9,
                    label: 12,
                    wrapper: 12
                  },
                  description: "Ex.: https://airbnb.com/rooms/xxxxxxxxxx or\nhttps://vrbo.com/xxxxxx"
                },
                import_button: {
                  type: "button",
                  buttonLabel: "Import",
                  columns: {
                    container: 3,
                    label: 12,
                    wrapper: 12
                  },
                  buttonType: "anchor",
                  label: "&nbsp;",
                  after: "&nbsp;",
                  full: true,
                  align: "center"
                }
              },
              conditions: [
                [
                  "advert_elsewhere",
                  "in",
                  [
                    "Airbnb",
                    "Vrbo"
                  ]
                ]
              ]
            },
            accommodation_name: {
              type: "text",
              description: "This name will be shown in the results.",
              rules: [
                "required",
                "max:255"
              ],
              fieldName: "Name",
              label: "Name of accommodation",
              default: "Ferienwohnung auf der Hinteregg"
            },
            divider_1: {
              type: "static",
              tag: "hr",
              top: "1",
              bottom: "1"
            },
            h2_1: {
              type: "static",
              content: "Location of accommodation",
              tag: "h2",
              top: "1"
            },
            divider_2: {
              type: "static",
              tag: "hr"
            },
            location: {
              type: "object",
              schema: {
                p: {
                  type: "static",
                  tag: "p",
                  content: "Please make sure your address is correct, we will send a letter to make sure of authenticity - <b>later this is hard to modify</b>"
                },
                country: {
                  type: "select",
                  search: true,
                  native: false,
                  inputType: "search",
                  autocomplete: "off",
                  items: "/json/countries.json",
                  rules: [
                    "required"
                  ],
                  label: "Country",
                  default: "CH"
                },
                state: {
                  type: "select",
                  search: true,
                  native: false,
                  inputType: "search",
                  autocomplete: "off",
                  items: "/json/states.json",
                  rules: [
                    "required"
                  ],
                  label: "State",
                  conditions: [
                    [
                      "location.country",
                      "in",
                      [
                        "US"
                      ]
                    ]
                  ]
                },
                street: {
                  type: "text",
                  label: "Street name",
                  rules: [
                    "required",
                    "max:255"
                  ],
                  columns: {
                    container: 8,
                    label: 12,
                    wrapper: 12
                  },
                  default: "Alte Steige"
                },
                house_number: {
                  type: "text",
                  label: "House number",
                  rules: [
                    "required",
                    "max:255"
                  ],
                  columns: {
                    container: 4,
                    label: 12,
                    wrapper: 12
                  },
                  default: "15"
                },
                floor: {
                  type: "text",
                  label: "Floor or door number (optional)",
                  rules: [
                    "nullable",
                    "max:255"
                  ]
                },
                zip: {
                  type: "text",
                  rules: [
                    "required",
                    "max:255"
                  ],
                  columns: {
                    container: 4,
                    label: 12,
                    wrapper: 12
                  },
                  label: "Zip code",
                  default: "87629"
                },
                city: {
                  type: "text",
                  rules: [
                    "required",
                    "max:255"
                  ],
                  columns: {
                    container: 8,
                    label: 12,
                    wrapper: 12
                  },
                  label: "City",
                  default: "Füssen"
                }
              }
            },
            divider_3: {
              type: "static",
              tag: "hr",
              top: "1",
              bottom: "1"
            },
            h2_2: {
              type: "static",
              tag: "h2",
              content: "Rooms",
              top: "1"
            },
            divider_4: {
              type: "static",
              tag: "hr"
            },
            guests_count: {
              type: "text",
              inputType: "number",
              rules: [
                "required",
                "integer"
              ],
              autocomplete: "off",
              label: "How many guests can stay?",
              columns: {
                wrapper: 2
              },
              default: "4"
            },
            bathroom_count: {
              type: "text",
              inputType: "number",
              rules: [
                "required",
                "numeric"
              ],
              autocomplete: "off",
              label: "How many bathrooms?",
              columns: {
                wrapper: 2
              },
              default: "2"
            },
            size: {
              type: "text",
              inputType: "number",
              rules: [
                "nullable",
                "numeric"
              ],
              autocomplete: "off",
              label: "How big is this apartment? (optional)",
              columns: {
                wrapper: 2
              },
              addons: {
                after: "m<sup>2</sup>"
              },
              default: "75"
            },
            h2_3: {
              type: "static",
              tag: "h2",
              content: "Room editor",
              top: "2"
            },
            divider_5: {
              type: "static",
              tag: "hr"
            },
            rooms: {
              type: "list",
              element: {
                type: "object",
                schema: {
                  h4: {
                    type: "static",
                    tag: "h4",
                    content: "Room"
                  },
                  room_type: {
                    type: "select",
                    search: true,
                    native: false,
                    label: "Room type",
                    inputType: "search",
                    autocomplete: "off",
                    items: [
                      "Bedroom",
                      "Living room",
                      "Other"
                    ],
                    rules: [
                      "required"
                    ],
                    default: "Bedroom"
                  },
                  html: {
                    type: "static",
                    columns: {
                      container: 1
                    }
                  },
                  container: {
                    type: "group",
                    schema: {
                      h4: {
                        type: "static",
                        tag: "h4",
                        content: "Beds"
                      },
                      container: {
                        type: "group",
                        schema: {
                          html: {
                            type: "static",
                            content: "Bed type",
                            columns: {
                              container: 10
                            }
                          },
                          html_copy: {
                            type: "static",
                            content: "Count",
                            columns: {
                              container: 2
                            }
                          }
                        },
                        conditions: [
                          [
                            "rooms.*.container.beds",
                            "not_empty"
                          ]
                        ]
                      },
                      beds: {
                        type: "list",
                        element: {
                          type: "object",
                          schema: {
                            bed_type: {
                              type: "select",
                              search: true,
                              native: false,
                              inputType: "search",
                              autocomplete: "off",
                              columns: {
                                container: 10
                              },
                              items: [
                                "Single bed (90 cm - 130 cm)",
                                "Big single bed (131 cm - 150 cm)",
                                "Double bed (151 cm - 180 cm)",
                                "Big double bed (181 cm - 210 cm)",
                                "Bunk-bed (variable size)",
                                "Sofa-bed (variable size)",
                                "Futon (variable size)"
                              ],
                              default: "Single bed (90 cm - 130 cm)"
                            },
                            bed_count: {
                              type: "text",
                              inputType: "number",
                              rules: [
                                "required",
                                "integer"
                              ],
                              autocomplete: "off",
                              columns: {
                                container: 2
                              },
                              default: "1"
                            }
                          }
                        },
                        addText: "+ Add bed"
                      }
                    },
                    columns: {
                      container: 11
                    }
                  },
                  divider: {
                    type: "static",
                    tag: "hr"
                  }
                }
              },
              addText: "+ Add room"
            },
            divider_6: {
              type: "static",
              tag: "hr",
              bottom: "1"
            },
            h2_4: {
              type: "static",
              tag: "h2",
              content: "Equipment &amp; facilities",
              top: "1"
            },
            divider_7: {
              type: "static",
              tag: "hr"
            },
            equipment: {
              type: "object",
              schema: {
                general: {
                  type: "checkboxgroup",
                  label: "General",
                  items: [
                    "AC",
                    "Heating",
                    "Free Wifi",
                    "Electric car charger"
                  ],
                  columns: {
                    container: 6,
                    label: 12,
                    wrapper: 12
                  }
                },
                kitchen: {
                  type: "checkboxgroup",
                  label: "Kitchen and cleaning",
                  columns: {
                    container: 6,
                    label: 12,
                    wrapper: 12
                  },
                  items: [
                    "Electric kettle",
                    "Tea/coffee maker",
                    "Towels",
                    "Washing machine",
                    "Dishwasher"
                  ]
                },
                entertainment: {
                  type: "checkboxgroup",
                  label: "Entertainment",
                  columns: {
                    container: 6,
                    label: 12,
                    wrapper: 12
                  },
                  items: [
                    "Flat screen tv",
                    "Bar",
                    "Hot tub",
                    "Sauna",
                    "Swimming pool"
                  ]
                },
                outside: {
                  type: "checkboxgroup",
                  label: "Outside",
                  columns: {
                    container: 6,
                    label: 12,
                    wrapper: 12
                  },
                  items: [
                    "BBQ",
                    "Balcony",
                    "Garden",
                    "Beach"
                  ]
                }
              }
            },
            divider_8: {
              type: "static",
              tag: "hr",
              top: "1",
              bottom: "1"
            },
            h2_5: {
              type: "static",
              tag: "h2",
              content: "Breakfast details",
              top: "1"
            },
            divider_9: {
              type: "static",
              tag: "hr"
            },
            serve_breakfast: {
              type: "radiogroup",
              view: "tabs",
              items: [
                "Yes",
                "No"
              ],
              default: "No",
              rules: [
                "required"
              ],
              label: "Do you serve breakfast?",
              fieldName: "Breakfast"
            },
            breakfast_in_price: {
              type: "radiogroup",
              view: "tabs",
              items: [
                "Yes",
                "No"
              ],
              default: "Yes",
              rules: [
                "required"
              ],
              label: "Is it included in the price?",
              conditions: [
                [
                  "serve_breakfast",
                  "in",
                  [
                    "Yes"
                  ]
                ]
              ]
            },
            breakfast_price: {
              type: "text",
              inputType: "number",
              rules: [
                "required",
                "numeric"
              ],
              autocomplete: "off",
              label: "Breakfast cost per person, per day",
              addons: {
                before: "$"
              },
              description: "Including taxes and fees.",
              conditions: [
                [
                  "breakfast_in_price",
                  "in",
                  [
                    "No"
                  ]
                ],
                [
                  "serve_breakfast",
                  "in",
                  [
                    "Yes"
                  ]
                ]
              ]
            },
            breakfast_types: {
              type: "tags",
              closeOnSelect: false,
              label: "What types of breakfasts do you offer?",
              items: [
                "Á la carte",
                "American",
                "Asian",
                "Breakfast togo",
                "Buffet",
                "Continental",
                "Full English/Irish",
                "Gluten-free",
                "Halal",
                "Italian",
                "Kosher",
                "Vegan",
                "Vegetarian"
              ],
              rules: [
                "required"
              ],
              search: true,
              inputType: "search",
              autocomplete: "off",
              conditions: [
                [
                  "serve_breakfast",
                  "in",
                  [
                    "Yes"
                  ]
                ]
              ],
              description: "Select all that applies."
            },
            divider_10: {
              type: "static",
              tag: "hr",
              top: "1",
              bottom: "1"
            },
            h2_6: {
              type: "static",
              tag: "h2",
              content: "Parking",
              top: "1"
            },
            divider_11: {
              type: "static",
              tag: "hr"
            },
            parking: {
              type: "radiogroup",
              view: "tabs",
              label: "Is parking available to the guests?",
              items: [
                "Yes, free",
                "Yes, paid",
                "No"
              ],
              default: "No",
              rules: [
                "required"
              ]
            },
            parking_price: {
              type: "text",
              inputType: "number",
              rules: [
                "required",
                "numeric"
              ],
              autocomplete: "off",
              label: "Cost of parking",
              addons: {
                before: "$"
              },
              columns: {
                container: 6,
                label: 12,
                wrapper: 12
              },
              conditions: [
                [
                  "parking",
                  "in",
                  [
                    "Yes, paid"
                  ]
                ]
              ]
            },
            parking_interval: {
              type: "select",
              search: true,
              native: false,
              inputType: "search",
              autocomplete: "off",
              columns: {
                container: 6,
                label: 12,
                wrapper: 12
              },
              label: "&nbsp;",
              rules: [
                "required"
              ],
              canDeselect: false,
              items: [
                "Per hour",
                "Per day",
                "Per stay"
              ],
              default: "Per day",
              conditions: [
                [
                  "parking",
                  "in",
                  [
                    "Yes, paid"
                  ]
                ]
              ]
            },
            parking_reservation: {
              type: "radiogroup",
              view: "tabs",
              label: "Do guests need to reserve a parking spot?",
              items: [
                "Yes",
                "No"
              ],
              rules: [
                "required"
              ],
              conditions: [
                [
                  "parking",
                  "not_in",
                  [
                    "No"
                  ]
                ]
              ]
            },
            parking_location: {
              type: "radiogroup",
              view: "tabs",
              label: "Where is the parking located?",
              rules: [
                "required"
              ],
              items: [
                "On site",
                "Off site"
              ],
              conditions: [
                [
                  "parking",
                  "not_in",
                  [
                    "No"
                  ]
                ]
              ]
            },
            parking_location_offsite_description: {
              type: "textarea",
              label: "Offsite parking location/description",
              conditions: [
                [
                  "parking_location",
                  "in",
                  [
                    "Off site"
                  ]
                ]
              ],
              rules: [
                "required",
                "min:3"
              ],
              rows: 2
            },
            parking_type: {
              type: "radiogroup",
              view: "tabs",
              label: "What type of parking is it?",
              items: [
                "Private",
                "Public"
              ],
              rules: [
                "required"
              ],
              conditions: [
                [
                  "parking",
                  "not_in",
                  [
                    "No"
                  ]
                ]
              ]
            },
            divider_12: {
              type: "static",
              tag: "hr",
              top: "1",
              bottom: "1"
            },
            h2_7: {
              type: "static",
              tag: "h2",
              content: "Spoken language",
              top: "1"
            },
            divider_13: {
              type: "static",
              tag: "hr"
            },
            languages: {
              type: "tags",
              closeOnSelect: false,
              search: true,
              label: "Select all that applies.",
              inputType: "search",
              autocomplete: "off",
              items: "/json/languages.json",
              rules: [
                "required"
              ],
              default: [
                "English"
              ]
            },
            divider_14: {
              type: "static",
              tag: "hr",
              top: "1",
              bottom: "1"
            },
            h2_8: {
              type: "static",
              tag: "h2",
              content: "House rules",
              top: "1"
            },
            divider_15: {
              type: "static",
              tag: "hr"
            },
            rules: {
              type: "checkboxgroup",
              items: [
                "Smoking allowed",
                "Pets allowed",
                "Children allowed",
                "Parties/events allowed"
              ]
            },
            check_in_from: {
              type: "date",
              label: "Check-in",
              time: true,
              date: false,
              columns: {
                container: 4,
                label: 12,
                wrapper: 12
              },
              rules: [
                "required"
              ],
              placeholder: "From",
              default: "15:00"
            },
            check_in_until: {
              type: "date",
              time: true,
              date: false,
              columns: {
                container: 4,
                label: 12,
                wrapper: 12
              },
              rules: [
                "required"
              ],
              placeholder: "Until",
              label: "&nbsp;",
              default: "23:00"
            },
            p_1: {
              type: "static",
              tag: "p",
              columns: {
                container: 4
              }
            },
            check_out_from: {
              type: "date",
              label: "Check-out",
              time: true,
              date: false,
              columns: {
                container: 4,
                label: 12,
                wrapper: 12
              },
              rules: [
                "required"
              ],
              placeholder: "From",
              default: "06:00"
            },
            check_out_until: {
              type: "date",
              time: true,
              date: false,
              columns: {
                container: 4,
                label: 12,
                wrapper: 12
              },
              rules: [
                "required"
              ],
              placeholder: "Until",
              label: "&nbsp;",
              default: "10:00"
            },
            divider_16: {
              type: "static",
              tag: "hr",
              bottom: "1",
              top: "1"
            },
            h2_9: {
              type: "static",
              tag: "h2",
              content: "Host profile",
              top: "1"
            },
            divider_17: {
              type: "static",
              tag: "hr"
            },
            profile: {
              type: "checkboxgroup",
              items: [
                "The property",
                "The host",
                "The neighbourhood"
              ],
              default: [
                "The property"
              ]
            },
            property: {
              type: "textarea",
              label: "About the property",
              placeholder: "What makes your place unique? What can guests expect?",
              conditions: [
                [
                  "profile",
                  "in",
                  [
                    "The property"
                  ]
                ]
              ],
              rules: [
                "required"
              ]
            },
            host_name: {
              type: "text",
              label: "Host name",
              rules: [
                "required",
                "max:255"
              ],
              conditions: [
                [
                  "profile",
                  "in",
                  [
                    "The host"
                  ]
                ]
              ]
            },
            about_host: {
              type: "textarea",
              label: "About the host",
              placeholder: "What are your interests? What do you like about hosting?",
              rules: [
                "required",
                "max:1023"
              ],
              conditions: [
                [
                  "profile",
                  "in",
                  [
                    "The host"
                  ]
                ]
              ]
            },
            about_neighbourhood: {
              type: "textarea",
              label: "About the neighbourhood",
              placeholder: "What’s the area like? Are there any attractions nearby?",
              rules: [
                "required",
                "max:1023"
              ],
              conditions: [
                [
                  "profile",
                  "in",
                  [
                    "The neighbourhood"
                  ]
                ]
              ]
            },
            divider_18: {
              type: "static",
              tag: "hr",
              bottom: "1",
              top: "1"
            },
            h2_10: {
              type: "static",
              tag: "h2",
              content: "What does your place look like?",
              top: "1"
            },
            divider_19: {
              type: "static",
              tag: "hr"
            },
            gallery: {
              type: "multifile",
              view: "gallery",
              accept: "image/*,image/jpeg,image/png,image/gif,image/svg+xml",
              drop: true,
              description: "First uploaded photo will be shown in search results\nMax size is 2MB/file, accepted formats are: JPG, PNG, GIF, SVG. You’re 29% more likely to get bookings if you upload at least 5 photos.",
              file: {
                rules: [
                  "mimetypes:image/jpeg,image/png,image/gif,image/svg+xml",
                  "max:2048"
                ]
              },
              before: "Add at least one photo now. You can always add more later.",
              fieldName: "gallery"
            },
            divider_20: {
              type: "static",
              tag: "hr",
              top: "1",
              bottom: "1"
            },
            h2_11: {
              type: "static",
              tag: "h2",
              content: "Guest payment options",
              top: "1"
            },
            divider_21: {
              type: "static",
              tag: "hr"
            },
            can_charge_card: {
              type: "radiogroup",
              view: "tabs",
              label: "Can you charge credit cards at your property?",
              items: [
                "Yes",
                "No"
              ],
              default: "Yes",
              rules: [
                "required"
              ]
            },
            price_per_night: {
              type: "text",
              inputType: "number",
              rules: [
                "required",
                "numeric"
              ],
              autocomplete: "off",
              label: "How much do you want to charge per night?",
              addons: {
                before: "$"
              },
              description: "Including taxes, commission, and fees",
              columns: {
                wrapper: 3
              },
              default: "120"
            },
            divider_22: {
              type: "static",
              tag: "hr",
              bottom: "1",
              top: "1"
            },
            h2_12: {
              type: "static",
              tag: "h2",
              content: "Rate plans",
              top: "1"
            },
            divider_23: {
              type: "static",
              tag: "hr"
            },
            h3: {
              type: "static",
              tag: "h3",
              content: "Standard rate plan",
              top: "1"
            },
            p_copy5: {
              type: "static",
              tag: "p",
              content: "How many days before arrival can guests cancel their booking for free?"
            },
            free_days_before_cancellation: {
              type: "text",
              inputType: "number",
              rules: [
                "required",
                "min:1",
                "max:30",
                "integer"
              ],
              autocomplete: "off",
              addons: {
                after: "days"
              },
              default: "2",
              description: "Guests love flexibility – free cancellation rates are generally the most booked rates. Get your first booking sooner by allowing guests to cancel up to one day before check-in.",
              fieldName: "cancellation days",
              columns: {
                wrapper: 2
              }
            },
            accidental_booking_protection: {
              type: "toggle",
              text: "Accidental booking protection",
              description: "To avoid having to deal with accidental bookings, we automatically waive cancellation fees for guests who cancel within 24 hours of booking.",
              default: true,
              labels: {
                on: "On",
                off: "Off"
              }
            },
            standard_plan_divider: {
              type: "static",
              tag: "hr"
            },
            h4: {
              type: "static",
              tag: "h4",
              content: "Discount"
            },
            p: {
              type: "static",
              tag: "p",
              content: "Offering lower rates for groups of less than 3 makes your property more attractive to potential guests."
            },
            group_discount: {
              type: "toggle",
              text: "Price per group size",
              labels: {
                on: "On",
                off: "Off"
              }
            },
            container: {
              type: "group",
              schema: {
                guest_discount_1: {
                  type: "text",
                  placeholder: "Discount",
                  columns: {
                    container: 4
                  },
                  addons: {
                    after: "%"
                  },
                  label: "1 guest",
                  rules: [
                    "integer"
                  ],
                  default: "20",
                  inputType: "number"
                },
                guest_discount_2: {
                  type: "text",
                  placeholder: "Discount",
                  columns: {
                    container: 4
                  },
                  addons: {
                    after: "%"
                  },
                  label: "2 guests",
                  rules: [
                    "integer"
                  ],
                  default: "10",
                  inputType: "number"
                },
                guest_discount_3: {
                  type: "text",
                  placeholder: "Discount",
                  columns: {
                    container: 4
                  },
                  addons: {
                    after: "%"
                  },
                  label: "3+ guests",
                  rules: [
                    "integer"
                  ],
                  default: "0",
                  inputType: "number"
                }
              },
              conditions: [
                [
                  "group_discount",
                  "==",
                  true
                ]
              ],
              description: "The recommended discounts are based on data from properties like yours. These can be updated at any time."
            },
            divider_29: {
              type: "static",
              tag: "hr"
            },
            h3_1: {
              type: "static",
              tag: "h3",
              content: "Non-refundable rate plan",
              top: "1"
            },
            p_copy: {
              type: "static",
              tag: "p",
              content: "In addition to the standard rate plan you created for your property, you can add a non-refundable rate plan. "
            },
            p_copy2: {
              type: "static",
              tag: "p",
              content: "With this, you set a discounted price but your revenue for these bookings is guaranteed because guests won&#92;&#38;#39;t receive a refund if they cancel or no-show."
            },
            nonrefundable_rate_plan: {
              type: "toggle",
              text: "Set up non-refundable rate plan",
              labels: {
                on: "On",
                off: "Off"
              }
            },
            non_refundable_plan_discount: {
              type: "text",
              inputType: "number",
              autocomplete: "off",
              label: "Discount for guests that book with this rate plan:",
              addons: {
                after: "%"
              },
              description: "Guests who select non-refundable rates are usually looking for competitive prices. A discount of at least 10% will attract more guests by improving your visibility.",
              default: "10",
              columns: {
                wrapper: 2
              },
              conditions: [
                [
                  "nonrefundable_rate_plan",
                  "==",
                  true
                ]
              ]
            },
            divider_30: {
              type: "static",
              tag: "hr"
            },
            h3_2: {
              type: "static",
              tag: "h3",
              content: "Weekly rate plan",
              top: "1"
            },
            p_copy3: {
              type: "static",
              tag: "p",
              content: "In addition to the standard rate plan you created for your property, you can add a weekly rate plan."
            },
            p_copy4: {
              type: "static",
              tag: "p",
              content: "For this, you set a discounted price and use the same cancellation policy as the standard rate plan. Guests who stay for at least a week are interested in discounts since they’ll be spending more on their overall booking."
            },
            weekly_rate_plan: {
              type: "toggle",
              text: "Set up weekly rate",
              labels: {
                on: "On",
                off: "Off"
              }
            },
            weekly_rate: {
              type: "text",
              inputType: "number",
              rules: [
                "required",
                "integer"
              ],
              autocomplete: "off",
              label: "How much cheaper than the standard rate?",
              addons: {
                after: "%"
              },
              columns: {
                wrapper: 2
              },
              default: "15",
              conditions: [
                [
                  "weekly_rate_plan",
                  "==",
                  true
                ]
              ]
            },
            divider_24: {
              type: "static",
              tag: "hr",
              bottom: "1",
              top: "1"
            },
            h2_13: {
              type: "static",
              tag: "h2",
              content: "Availability",
              top: "1"
            },
            divider_25: {
              type: "static",
              tag: "hr"
            },
            available_from: {
              type: "radiogroup",
              view: "tabs",
              label: "What&#92;&#38;#39;s the first date when guests can check in?",
              items: [
                "As soon as possible",
                "On a specific date"
              ],
              default: "As soon as possible"
            },
            available_from_date: {
              type: "date",
              rules: [
                "required"
              ],
              conditions: [
                [
                  "available_from",
                  "in",
                  [
                    "On a specific date"
                  ]
                ]
              ],
              placeholder: "Choose a date",
              floating: false,
              displayFormat: "Do MMM, YYYY"
            },
            divider_26: {
              type: "static",
              tag: "hr",
              bottom: "1",
              top: "1"
            },
            h2_14: {
              type: "static",
              tag: "h2",
              content: "Complete",
              top: "1"
            },
            divider_27: {
              type: "static",
              tag: "hr"
            },
            terms_1: {
              type: "checkbox",
              text: "I certify that this is a legitimate accommodation business with all necessary licenses and permits, which can be shown upon first request. Mydomain.com B.V. reserves the right to verify and investigate any details provided in this registration.",
              fieldName: "Registration rights",
              rules: [
                "accepted"
              ]
            },
            terms_2: {
              type: "checkbox",
              text: "I have read, accepted, and agreed to the Terms and Conditions and Privacy Policy.",
              fieldName: "Terms",
              rules: [
                "accepted"
              ]
            },
            divider_28: {
              type: "static",
              tag: "hr",
              bottom: "1",
              top: "1"
            }
          }
        });
        const { url: url2, t: t2 } = toRefs(props);
        onMounted(async () => {
          console.log("onMounted is triggered in CreateListing.vue");
          console.log(`Product ID: ${props.productId}, Site ID: ${props.siteId}`);
          alert("CreateListing.vue is mounted!");
          const data = (await axios$1.get("/sampleData/sampleData.json")).data;
          form.load(data.data);
          vueform2.value.endpoint = url2;
          axios$1.defaults.headers.post = {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${t2.value}`
          };
        });
        return {
          ...form,
          vueform: vueform2
        };
      }
    };
    const _sfc_main = {
      __name: "MyForm",
      setup(__props) {
        return (_ctx, _cache) => {
          return openBlock(), createBlock(_sfc_main$1);
        };
      }
    };
    Z$1({
      rootComponent: _sfc_main,
      elementName: "my-form",
      plugins: {
        install(Vue) {
          Vue.use(vueform, vueformConfig);
        }
      },
      cssFrameworkStyles: styles,
      VueDefineCustomElement: defineCustomElement,
      h: h$1,
      createApp,
      getCurrentInstance,
      disableStyleRemoval: true,
      disableShadowDOM: true,
      props: {
        // Define the props that the custom element will accept
        productId: String,
        siteId: String,
        // Submit url
        url: String,
        // Submit authorization token
        t: String
      }
    });
  }
});
export default require_index_001();
